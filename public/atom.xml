<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Bezhuang&#39;s Blog</title>
  
  
  <link href="http://blog.zhuangzhihao.top/atom.xml" rel="self"/>
  
  <link href="http://blog.zhuangzhihao.top/"/>
  <updated>2022-01-04T16:00:00.000Z</updated>
  <id>http://blog.zhuangzhihao.top/</id>
  
  <author>
    <name>Bezhuang</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>双色球系统</title>
    <link href="http://blog.zhuangzhihao.top/%E5%8F%8C%E8%89%B2%E7%90%83/"/>
    <id>http://blog.zhuangzhihao.top/%E5%8F%8C%E8%89%B2%E7%90%83/</id>
    <published>2021-12-31T16:00:00.000Z</published>
    <updated>2022-01-04T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>双色球是最常见的一种彩票。双色球投注区分为红球号码区和蓝球号码区，红球号码范围为01～33，蓝球号码范围为01～16。双色球每期从33个红球中开出6个号码，从16个蓝球中开出1个号码作为中奖号码，双色球玩法即是竞猜开奖号码的6个红球号码和1个蓝球号码，顺序不限。以下为双色球的业务分析和代码实现笔记。</p></blockquote><a id="more"></a><h3 id="随机一组中奖号码"><a href="#随机一组中奖号码" class="headerlink" title="随机一组中奖号码"></a>随机一组中奖号码</h3><ul><li>中奖号码由6个红球和1个蓝球组成</li><li>定义方法用于返回一组中奖号码（7个数据），返回的形式是一个整型数组</li><li>随机的6个中奖的红球号码不能重复<ul><li>每次随机一个红球号码后去数组中判断是否存在</li><li>如果存在则需要重新随机一个数字直到不重复为止</li></ul></li></ul><h3 id="用户输入一组双色球号码"><a href="#用户输入一组双色球号码" class="headerlink" title="用户输入一组双色球号码"></a>用户输入一组双色球号码</h3><ul><li>定义一个方法录入用户输入的6个红球和1个蓝球号码</li><li>该方法最终需要返回一个数组，数组中就是用户录入的号码（7位）</li></ul><h3 id="中奖情况判断"><a href="#中奖情况判断" class="headerlink" title="中奖情况判断"></a>中奖情况判断</h3><ul><li>定义一个方法接收中奖号码的数组，用户选号的数组</li><li>根据命中红球数和篮球数判断最终的中奖情况并输出详情和中奖金额</li><li>统计红球的命中数量<ul><li>遍历用户的每个选号，然后遍历中奖号码的数组</li><li>看当前选号是否在中奖号码中存在，存在则命中数量加1</li></ul></li></ul><h3 id="Java-版代码实现"><a href="#Java-版代码实现" class="headerlink" title="Java 版代码实现"></a>Java 版代码实现</h3><pre><code class="java">public class DoubleChromosphere &#123;    public static void main(String[] args) &#123;        // 随机6个红球号码（1-33，不能重复），随机一个蓝球号码（1-16），用数组装起来作为中奖号码        int[] luckNumbers = createLuckNumber();        // printArray(luckNumbers);        // 录入用户选中的号码        int[] userNumbers = userInputNumbers();        // 判断中奖情况        judge(luckNumbers, userNumbers);    &#125;    public static void judge(int[] luckNumbers, int[] userNumbers )&#123;        // 判断是否中奖              // 定义2个变量分别存储红球命中的个数，以及蓝球命中的个数        int redHitNumbers = 0;        int blueHitNumbers = 0;        // 判断红球命中了几个，开始统计        for (int i = 0; i &lt; userNumbers.length - 1; i++) &#123;            for (int j = 0; j &lt; luckNumbers.length - 1; j++) &#123;                // 每次找到了相等了，意味着当前号码命中了                if(userNumbers[i] == luckNumbers[j])&#123;                    redHitNumbers ++ ;                    break;                &#125;            &#125;        &#125;        // 蓝球号码是否命中        blueHitNumbers = luckNumbers[6] == userNumbers[6] ? 1 : 0;        System.out.println(&quot;中奖号码是：&quot;  );        printArray(luckNumbers);        System.out.println(&quot;您投注号码是：&quot;  );        printArray(userNumbers);        System.out.println(&quot;您命中了几个红球：&quot; + redHitNumbers);        System.out.println(&quot;您是否命中蓝球：&quot; + ( blueHitNumbers == 1 ? &quot;是&quot;: &quot;否&quot; ) );        // 判断中奖情况        if(blueHitNumbers == 1 &amp;&amp; redHitNumbers &lt; 3)&#123;            System.out.println(&quot;恭喜您，中了5元小奖！&quot;);        &#125;else if(blueHitNumbers == 1 &amp;&amp; redHitNumbers == 3                || blueHitNumbers == 0 &amp;&amp; redHitNumbers == 4)&#123;            System.out.println(&quot;恭喜您，中了10元小奖！&quot;);        &#125;else if(blueHitNumbers == 1 &amp;&amp; redHitNumbers == 4                || blueHitNumbers == 0 &amp;&amp; redHitNumbers == 5)&#123;            System.out.println(&quot;恭喜您，中了200元！&quot;);        &#125;else if(blueHitNumbers == 1 &amp;&amp; redHitNumbers == 5)&#123;            System.out.println(&quot;恭喜您，中了3000元大奖！&quot;);        &#125;else if(blueHitNumbers == 0 &amp;&amp; redHitNumbers == 6)&#123;            System.out.println(&quot;恭喜您，中了500万超级大奖！&quot;);        &#125;else if(blueHitNumbers == 1 &amp;&amp; redHitNumbers == 6)&#123;            System.out.println(&quot;恭喜您，中了1000万巨奖！可以开始享受人生，诗和远方！！&quot;);        &#125;else &#123;            System.out.println(&quot;感谢您为福利事业做出的突出贡献！！&quot;);        &#125;    &#125;    public static int[] userInputNumbers()&#123;        // 动态初始化一个数组，长度为7        int[] numbers = new int[7];        Scanner sc = new Scanner(System.in);        for (int i = 0; i &lt; numbers.length - 1; i++) &#123;            System.out.println(&quot;请您输入第&quot;+(i + 1)+&quot;个红球号码（1-33、不重复）：&quot;);            int data = sc.nextInt();            numbers[i] = data;        &#125;        // 录入一个蓝球号码        System.out.println(&quot;请您输入一个蓝球号码（1-16）：&quot;);        int data = sc.nextInt();        numbers[numbers.length - 1] = data;        return numbers;    &#125;    public static void printArray(int[] arr)&#123;        for (int i = 0; i &lt; arr.length; i++) &#123;            System.out.print(arr[i] + &quot; &quot;);        &#125;        System.out.println();    &#125;    public static int[] createLuckNumber()&#123;        // 定义一个动态初始化的数组，存储7个数字        int[] numbers = new int[7];          // 遍历数组，为每个位置生成对应的号码。(注意：遍历前6个位置，生成6个不重复的红球号码，范围是1-33)        Random r = new Random();        for (int i = 0; i &lt; numbers.length - 1; i++) &#123;            // 为当前位置找出一个不重复的1-33之间的数字            while (true) &#123;                int data = r.nextInt(33) + 1;                 // 注意：必须判断当前随机的这个号码之前是否出现过，出现过要重新随机一个，直到不重复为止，才可以存入数组中去                // 定义一个flag变量，默认认为data是没有重复的                boolean flag = true;                for (int j = 0; j &lt; i; j++) &#123;                    if(numbers[j] == data) &#123;                        // data当前这个数据之前出现过，不能用                        flag = false;                        break;                    &#125;                &#125;                if(flag) &#123;                    // data这个数据之前没有出现过，可以使用了                    numbers[i] = data;                    break;                &#125;            &#125;        &#125;        // 为第7个位置生成一个1-16的号码作为蓝球号码        numbers[numbers.length - 1] = r.nextInt(16) + 1;        return numbers;    &#125;&#125;</code></pre>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;双色球是最常见的一种彩票。双色球投注区分为红球号码区和蓝球号码区，红球号码范围为01～33，蓝球号码范围为01～16。双色球每期从33个红球中开出6个号码，从16个蓝球中开出1个号码作为中奖号码，双色球玩法即是竞猜开奖号码的6个红球号码和1个蓝球号码，顺序不限。以下为双色球的业务分析和代码实现笔记。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="编程与开发" scheme="http://blog.zhuangzhihao.top/categories/%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="Java" scheme="http://blog.zhuangzhihao.top/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Accenture Coding Virtual Experience Program</title>
    <link href="http://blog.zhuangzhihao.top/Accenture-Coding-Virtual-Experience/"/>
    <id>http://blog.zhuangzhihao.top/Accenture-Coding-Virtual-Experience/</id>
    <published>2021-12-31T16:00:00.000Z</published>
    <updated>2022-01-16T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>The Accenture Know-the-Code Virtual Experience Program covers the fundamentals of software development, including object-oriented programming, code refactoring, and agile delivery. It empowers me to explore what a career in software development could look like at Accenture while practicing my coding skills. The following are the notes I took during this virtual experience.</p></blockquote><a id="more"></a><div class="row">    <embed src="/pdf/Accenture-Coding-Virtual-Experience.pdf" width="100%" height="550" type="application/pdf"></div><h3 id="Task-1-Object-Oriented-Programming"><a href="#Task-1-Object-Oriented-Programming" class="headerlink" title="Task 1: Object Oriented Programming"></a>Task 1: Object Oriented Programming</h3><h4 id="Background-Information"><a href="#Background-Information" class="headerlink" title="Background Information"></a>Background Information</h4><ul><li>Recently, a company has brought on Accenture to help with the development of its e-commerce website written in Java using the Spring Boot framework. The first task they need help with is searching for products</li><li>One of the UX designers at Accenture has already implemented the new search capability in the UI</li><li>My responsibility is to implement the search capability in our backend Java app</li></ul><h4 id="Requirements"><a href="#Requirements" class="headerlink" title="Requirements"></a>Requirements</h4><ul><li>Expose an HTTP GET request on the path <code>/api/products/search</code></li><li>The request should take a single parameter named “<code>query</code>” which will be the text that was entered in the search bar</li><li>The request will return a Collection of <code>ProductItem</code> which are the matching products for the search</li></ul><h4 id="Implement-a-new-controller-to-handle-searching"><a href="#Implement-a-new-controller-to-handle-searching" class="headerlink" title="Implement a new controller to handle searching"></a>Implement a new controller to handle searching</h4><ol><li>Download and unzip the mock-company-webapp codebase</li><li>Open the application in IDEA with Gradle support</li><li>Follow the README.md instructions for setting up the development environment</li><li>Implement the “<code>search</code>” method of the class <code>SearchController</code>, the relevant code is outlined with a TODO comment</li><li>The controller should use the “<code>productItemRepository</code>” to interface with the product database</li><li>Review the tests and implement the controller to the spec</li></ol><h4 id="Practical-skills-gained"><a href="#Practical-skills-gained" class="headerlink" title="Practical skills gained"></a>Practical skills gained</h4><ul><li>Object Oriented Programming</li><li>Java</li><li>Spring</li></ul><h3 id="Task-2-Code-Refactoring"><a href="#Task-2-Code-Refactoring" class="headerlink" title="Task 2: Code Refactoring"></a>Task 2: Code Refactoring</h3><h4 id="Background-Information-1"><a href="#Background-Information-1" class="headerlink" title="Background Information"></a>Background Information</h4><ul><li>Now we’ve identified some code in the <code>ReportController</code> class that seems to be doing similar product searching</li><li>I need to refactor the <code>SearchController</code> logic into a new <code>SearchService</code> class that can be used in the <code>SearchController</code> as well as in the <code>ReportController</code></li></ul><h4 id="Requirements-1"><a href="#Requirements-1" class="headerlink" title="Requirements"></a>Requirements</h4><ul><li>Logic moved from <code>SearchController</code> to <code>SearchService</code></li><li><code>SearchController</code> and <code>ReportController</code> both updated to use the <code>SearchService</code></li><li>All unit tests pass</li></ul><h4 id="Refactor-controllers-to-a-shared-service"><a href="#Refactor-controllers-to-a-shared-service" class="headerlink" title="Refactor controllers to a shared service"></a>Refactor controllers to a shared service</h4><ol><li>Follow the README.md instructions for setting up the development environment</li><li>Create the new <code>SearchService</code> class in the “<code>services</code>” package. All of the search logic from the <code>SearchController</code> should be moved into a function in this class for reusability. The relevant code is outlined with a TODO comment</li><li>Using <code>@Autowired</code>, inject the <code>SearchService</code> into the <code>SearchController</code> and <code>ReportController</code></li><li>Refactor both controller classes to use the service by rewriting their functions to use the new service</li><li>Ensure unit tests all pass</li></ol><h4 id="Practical-skills-gained-1"><a href="#Practical-skills-gained-1" class="headerlink" title="Practical skills gained"></a>Practical skills gained</h4><ul><li>Java</li><li>Spring</li></ul><h3 id="Task-3-Continuous-Integration"><a href="#Task-3-Continuous-Integration" class="headerlink" title="Task 3: Continuous Integration"></a>Task 3: Continuous Integration</h3><h4 id="Background-Information-2"><a href="#Background-Information-2" class="headerlink" title="Background Information"></a>Background Information</h4><ul><li>Continuous Integration is the practice of automating the integration of code changes from multiple contributors into a single software project</li><li>It’s a primary DevOps best practice, allowing developers to frequently merge code changes into a central repository where building and test runs can occur</li><li>Use the most popular Continuous Integration tool, Jenkins</li><li>Creating a <code>Jenkinsfile</code> that will build and test the application on all branches of the repository</li></ul><h4 id="Requirements-2"><a href="#Requirements-2" class="headerlink" title="Requirements"></a>Requirements</h4><ul><li>GitHub account created, Git CLI setup, mock-company-webapp repository forked and cloned</li><li><code>Jenkinsfile</code> defined with stages setting it up to run on commit to any branch in the repository</li><li>Continuous Integration server runs <code>build/test</code> and succeeds</li><li>Change made to code that breaks test</li><li>Continuous Integration server runs <code>build/test</code> and fails</li></ul><h4 id="Simulating-Jenkins-using-the-Jenkinsfile-Runner-Action-in-a-GitHub-Workflow"><a href="#Simulating-Jenkins-using-the-Jenkinsfile-Runner-Action-in-a-GitHub-Workflow" class="headerlink" title="Simulating Jenkins using the Jenkinsfile Runner Action in a GitHub Workflow"></a>Simulating Jenkins using the <code>Jenkinsfile</code> Runner Action in a GitHub Workflow</h4><ol><li>Create an account with GitHub and fork the mock-company-webapp repository</li><li>Setup the Git CLI on workstation and “<code>clone</code>” the repository you forked to workstation</li><li>Install the Pipelines application from the GitHub marketplace to use Jenkins directly</li><li>use the Simulated Jenkins for GitHub link to add a <code>.github/workflows/workflow.yml</code> to the repository.</li><li>Add the following stages to the <code>Jenkinsfile</code>, the relevant code is outlined with a TODO comment.<ul><li>Build: <code>./gradlew assemble</code></li><li>Test: <code>./gradlew test</code></li></ul></li><li>Continue to tweak the <code>Jenkinsfile</code> until the build is successful</li><li>Change the <code>SearchService</code> to always return <code>Collections.emptyList()</code> in order to break the tests.</li><li>Commit the change and validate the Continuous Integration build fails which proves that we’ve properly set up Continuous Integration guard rails, that will catch failing tests each time a commit is made by a developer</li></ol><h4 id="Practical-skills-gained-2"><a href="#Practical-skills-gained-2" class="headerlink" title="Practical skills gained"></a>Practical skills gained</h4><ul><li>Continuous Integration</li><li>Jenkins</li><li>DevOps</li></ul><h3 id="Task-4-Agile-Planning"><a href="#Task-4-Agile-Planning" class="headerlink" title="Task 4: Agile Planning"></a>Task 4: Agile Planning</h3><h4 id="Background-Information-3"><a href="#Background-Information-3" class="headerlink" title="Background Information"></a>Background Information</h4><ul><li>In an Agile planning session, developers are given a set of large software features that they then must break up into smaller units of work, called stories, that can be completed within a one to three week period, called a sprint</li><li>A story is an informal, general explanation of a software feature written from the perspective of the end user or customer and is made up of the following components:<ul><li>Who the feature is for</li><li>What they need</li><li>Why they need it</li><li>What shows it’s done</li></ul></li></ul><h4 id="Requirements-3"><a href="#Requirements-3" class="headerlink" title="Requirements"></a>Requirements</h4><ul><li>Stories are written in the following format: As a <code>&lt;who the feature is for&gt;</code>, I need to be able to <code>&lt;what they need&gt;</code> so I can <code>&lt;why they need it&gt;</code></li><li>The “<code>what shows it’s done</code>”, called acceptance criteria, must be provided with the story as well</li><li>Stories are then pointed or sized which means to assign some kind of value indicating the difficulty of implementing the story</li><li>Use a T-Shirt size strategy assigning a value of small/medium/large to each story</li><li>It’s very important that stories are broken down as small as they can be so try and keep them either small or medium</li><li>This allows for better concurrency throughout the sprint and easier completion within a single sprint</li></ul><h4 id="planning-a-sprint-to-implement-the-checkout-feature-of-the-site"><a href="#planning-a-sprint-to-implement-the-checkout-feature-of-the-site" class="headerlink" title="planning a sprint to implement the checkout feature of the site"></a>planning a sprint to implement the checkout feature of the site</h4><ul><li>Create a document that defines around 10 to 20 stories around the checkout feature</li><li>Pull in a subset of these stories based on our capacity to work on in the next sprint</li><li>Make sure the stories are broken up as small as possible, and the acceptance criteria is testable</li></ul><h4 id="Practical-skills-gained-3"><a href="#Practical-skills-gained-3" class="headerlink" title="Practical skills gained"></a>Practical skills gained</h4><ul><li>Agile Methodology</li><li>Software Development Lifecycle (SDLC)</li></ul>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;The Accenture Know-the-Code Virtual Experience Program covers the fundamentals of software development, including object-oriented programming, code refactoring, and agile delivery. It empowers me to explore what a career in software development could look like at Accenture while practicing my coding skills. The following are the notes I took during this virtual experience.&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="程序人生" scheme="http://blog.zhuangzhihao.top/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/"/>
    
    
    <category term="Forage" scheme="http://blog.zhuangzhihao.top/tags/Forage/"/>
    
  </entry>
  
  <entry>
    <title>从2020的视角看线性代数</title>
    <link href="http://blog.zhuangzhihao.top/%E4%BB%8E2020%E7%9A%84%E8%A7%86%E8%A7%92%E7%9C%8B%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/"/>
    <id>http://blog.zhuangzhihao.top/%E4%BB%8E2020%E7%9A%84%E8%A7%86%E8%A7%92%E7%9C%8B%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/</id>
    <published>2021-12-17T16:00:00.000Z</published>
    <updated>2021-12-24T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>2020 年 MIT 数学教授 Gilbert Strang 录制了一个关于线性代数的学习和教学的一个新的、启发性的课程，从矩阵 A 的列空间和组合这些列的乘法 Ax 开始，包括了线性代数的概览、正交向量、特征值和特征向量、以及奇异值和奇异向量等方面的内容。以下为所记课堂笔记，笔记以中文形式记录，方便理解，可供参考。</p></blockquote><a id="more"></a><h3 id="矩阵的列空间"><a href="#矩阵的列空间" class="headerlink" title="矩阵的列空间"></a>矩阵的列空间</h3><h4 id="常用矩阵"><a href="#常用矩阵" class="headerlink" title="常用矩阵"></a>常用矩阵</h4><ul><li><p>$A_{0}=\begin{bmatrix}<br>1 &amp; 3 &amp; 2 \<br>4 &amp; 12 &amp; 8 \<br>2 &amp; 6 &amp; 4<br>\end{bmatrix}$</p><ul><li>$A_{0}$ 所有的行向量在同一个方向并且所有的列向量在同一个方向</li></ul></li><li><p>$A_{1}=\begin{bmatrix}<br>1 &amp; 4 &amp; 2 \<br>4 &amp; 1 &amp; 3 \<br>5 &amp; 5 &amp; 5<br>\end{bmatrix}$</p><ul><li>$A_{1}$ 第一行加第二行等于第三行</li></ul></li><li><p>对称矩阵</p><ul><li><p>$S_{2}=\begin{bmatrix}<br>2 &amp; -1 \<br>-1 &amp; 2<br>\end{bmatrix}$</p></li><li><p>$S_{3}=\begin{bmatrix}<br>1 &amp; -1 &amp; 0 \<br>-1 &amp; 2 &amp; -1 \<br>0 &amp; -1 &amp; 1<br>\end{bmatrix}$</p></li><li><p>$S_{4}=\begin{bmatrix}<br>2 &amp; -1 &amp; 0 \<br>-1 &amp; 2 &amp; -1 \<br>0 &amp; -1 &amp; 2<br>\end{bmatrix}$</p></li></ul></li><li><p>正交矩阵</p><ul><li>$Q_{5}=\begin{bmatrix}<br>\cos \theta  &amp; -\sin \theta  \<br>sin\theta  &amp; \cos \theta<br>\end{bmatrix}$</li></ul></li><li><p>$A_{6}=\begin{bmatrix}<br>3 &amp; 0 \<br>4 &amp; 5<br>\end{bmatrix}$</p></li></ul><h4 id="A-的列空间（列的所有线性组合）"><a href="#A-的列空间（列的所有线性组合）" class="headerlink" title="A 的列空间（列的所有线性组合）"></a>A 的列空间（列的所有线性组合）</h4><ul><li><p>将矩阵乘以向量</p><ul><li><p>$Ax=\begin{bmatrix} 1 &amp; 4 &amp; 5 \ 3 &amp; 2 &amp; 5 \ 2 &amp; 1 &amp; 3 \end{bmatrix}\begin{bmatrix} x_{1} \ x_{2} \ x_{3} \end{bmatrix}=\begin{bmatrix} 1 \ 3 \ 2 \end{bmatrix}x_{1}+\begin{bmatrix} x \ 2 \ 1 \end{bmatrix}x_{2}+\begin{bmatrix} 5 \ 5 \ 3 \end{bmatrix}x_{3}$</p></li><li><p>$Ax$ 为一种特殊的列的线性组合</p></li><li><p>$A$ 的列空间 = $C(A)$ = 所有 $Ax$ 向量 = 各列的所有线性组合</p></li><li><p>$C(A)$ 是一个平面</p></li></ul></li></ul><h4 id="列空间的基"><a href="#列空间的基" class="headerlink" title="列空间的基"></a>列空间的基</h4><ul><li><p>$A=CR=\begin{bmatrix}<br>1 &amp; 4 \<br>3 &amp; 2 \<br>2 &amp; 1<br>\end{bmatrix}\begin{bmatrix}<br>1 &amp; 0 &amp; 1 \<br>0 &amp; 1 &amp; 1<br>\end{bmatrix}$</p><ul><li><p>行秩 = 列秩 = r = 2</p></li><li><p>C 是平面的两个独立列向量，而 R 则表示了 A 是如何通过 C 中的两个向量重组 A 的</p></li><li><p>R 的 r 行是行空间的一组基</p></li></ul></li><li><p>$A = CR$ 表明 A 的行秩等于列秩 </p><ul><li>C 的 r 列相互线性独立（由定义可知）</li><li>A 的每一列都是（C 的）这 r 列的线性组合（因为 A = CR）</li><li>R 的 r 行相互线性独立（这 r 列包含了 r × r 的矩阵 I ）</li><li>A 的每一行都是（C 的）这 r 行的线性组合（因为 A = CR）</li></ul></li><li><p>核心内容 </p><ul><li>C 的 r 列组成了 A 的列空间的基：维度 r </li><li>R 的 r 列组成了 A 的行空间的基：维度 r</li></ul></li><li><p>基包含两个向量 </p><ul><li>A 的秩等于 r = 2 </li><li>$n − r = 3 − 2 = 1$</li></ul></li><li><p>计数定理 </p><ul><li>$Ax = 0$ 有一组解 $x = (1, 1, −1)$ 有 $n − r$ 组独立解可使 $Ax = 0$ 成立</li></ul></li></ul><h4 id="秩为-1-的矩阵-A"><a href="#秩为-1-的矩阵-A" class="headerlink" title="秩为 1 的矩阵 A"></a>秩为 1 的矩阵 A</h4><ul><li>如果 A 的任意一列均为第一列的若干倍，那么 A 的每一行均为某行的若干倍</li><li>用 A = CR 来证明<ul><li>C 当中的一列 $v$ ⇒ R 当中的一行 $w$</li><li>$A=\left[ v\right] ^{\left[ w\right] }$ ⇒ 每一行都是 $w$ 的倍数</li></ul></li></ul><h4 id="A-CR-的优良性质"><a href="#A-CR-的优良性质" class="headerlink" title="A = CR 的优良性质"></a>A = CR 的优良性质</h4><ul><li>C 的列直接来源于 A：体现了此公式的内涵</li><li>R 变成了A 的行化简阶梯形</li><li>“行秩 = 列秩”这一结论变得显然：C = 列的基，R = 行的基</li></ul><h4 id="A-CR-不好的性质"><a href="#A-CR-不好的性质" class="headerlink" title="A = CR 不好的性质"></a>A = CR 不好的性质</h4><ul><li>C 和 R 可能是病态矩阵</li><li>如果 A 是可逆的，则有 C = A 和 R = I ⇒ A = AI，原地打转</li></ul><h3 id="线性代数概览"><a href="#线性代数概览" class="headerlink" title="线性代数概览"></a>线性代数概览</h3><h4 id="线性方程组"><a href="#线性方程组" class="headerlink" title="线性方程组"></a>线性方程组</h4><ul><li>若 $Ax = 0$ 则有 $\begin{bmatrix} 1 \ \vdots \ m \end{bmatrix}\left[ x\right]=\begin{bmatrix} 0 \ \vdots \ 0 \end{bmatrix}$，x 与 A 的各列均正交<ul><li>每个处于 A 的零空间当中的 x 都与 A 的行空间正交 </li><li>每个处于 $A^T$ 的零空间当中的 y 都与 A 的列空间正交</li></ul></li><li>$N\left( A\right) \bot C\left( A^{T}\right) $ 与 $N\left( A^{T}\right) \bot C\left( A\right) $<ul><li>两对正交子空间，其中一对子空间的维度之和等于 n，另一对等于 m</li></ul></li></ul><h4 id="宏观视角下的线性代数"><a href="#宏观视角下的线性代数" class="headerlink" title="宏观视角下的线性代数"></a>宏观视角下的线性代数</h4><ul><li><img src="https://cdn.jsdelivr.net/gh/Bezhuang/Imgbed/blogimg/%E4%BB%8E2020%E7%9C%8B%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B001.png" style="zoom:67%;"></li><li>一对子空间处于 $R_{n}$ 之中，另一对处于$R_{m}$ 当中</li><li>从行空间变换为列空间——由此可知 A 是可逆的</li></ul><h4 id="列与行相乘（六组因式）"><a href="#列与行相乘（六组因式）" class="headerlink" title="列与行相乘（六组因式）"></a>列与行相乘（六组因式）</h4><ul><li>A = BC = 秩为 1 的矩阵之和（列乘以行：外积）</li><li>对矩阵相乘的全新理解（高层次），每次拿一列乘以一行是低层次的<ul><li><img src="https://cdn.jsdelivr.net/gh/Bezhuang/Imgbed/blogimg/%E4%BB%8E2020%E7%9C%8B%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B002.png" style="zoom:67%;"></li></ul></li><li>$A=\begin{bmatrix} 2 &amp; 3 \ 4 &amp; 7 \end{bmatrix}=\begin{bmatrix} 1 &amp; 0 \ 2 &amp; 1 \end{bmatrix}\begin{bmatrix} 2 &amp; 3 \ 0 &amp; 1 \end{bmatrix}=LU$ （将矩阵拆分成上下两个三角矩阵）<ul><li>$2x+3y=7$ ， $4x+7y=15$  ⇒ $x=2,y=1$</li><li>若两行发生交换，则 $PA = LU$ （P 指的是排列矩阵）</li></ul></li></ul><h4 id="用消元来解Ax-b（因式-A-LU）"><a href="#用消元来解Ax-b（因式-A-LU）" class="headerlink" title="用消元来解Ax = b（因式 A = LU）"></a>用消元来解Ax = b（因式 A = LU）</h4><ul><li>下三角矩阵 L 乘以上三角矩阵 U</li><li><img src="https://cdn.jsdelivr.net/gh/Bezhuang/Imgbed/blogimg/%E4%BB%8E2020%E7%9C%8B%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B003.png" style="zoom:67%;"></li></ul><h3 id="正交向量"><a href="#正交向量" class="headerlink" title="正交向量"></a>正交向量</h3><h4 id="正交向量-–-矩阵-–-子空间"><a href="#正交向量-–-矩阵-–-子空间" class="headerlink" title="正交向量 – 矩阵 – 子空间"></a>正交向量 – 矩阵 – 子空间</h4><ul><li>$X^{T}y=0,y^{T}x=0,\left( x+y\right) ^{T}\left( x+y\right)=x^{T}<em>{x}+y^{T}</em>{y}$ （直角三角形）</li><li><img src="https://cdn.jsdelivr.net/gh/Bezhuang/Imgbed/blogimg/%E4%BB%8E2020%E7%9C%8B%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B004.png" style="zoom:67%;"></li><li>$Q=\dfrac{1}{3}\begin{bmatrix} -1 &amp; 2 \ 2 &amp; -1 \ 2 &amp; 2 \end{bmatrix}$ ，$Q^{T}Q=I,QQ^{T}\neq I$ ，$QQ^TQQ^T = QQ^T$</li></ul><h4 id="正交矩阵"><a href="#正交矩阵" class="headerlink" title="正交矩阵"></a>正交矩阵</h4><h3 id="特征值和特征向量"><a href="#特征值和特征向量" class="headerlink" title="特征值和特征向量"></a>特征值和特征向量</h3><h3 id="奇异值和奇异向量"><a href="#奇异值和奇异向量" class="headerlink" title="奇异值和奇异向量"></a>奇异值和奇异向量</h3>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;2020 年 MIT 数学教授 Gilbert Strang 录制了一个关于线性代数的学习和教学的一个新的、启发性的课程，从矩阵 A 的列空间和组合这些列的乘法 Ax 开始，包括了线性代数的概览、正交向量、特征值和特征向量、以及奇异值和奇异向量等方面的内容。以下为所记课堂笔记，笔记以中文形式记录，方便理解，可供参考。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="数学" scheme="http://blog.zhuangzhihao.top/categories/%E6%95%B0%E5%AD%A6/"/>
    
    
    <category term="OpenCourseWare" scheme="http://blog.zhuangzhihao.top/tags/OpenCourseWare/"/>
    
  </entry>
  
  <entry>
    <title>微分学重点</title>
    <link href="http://blog.zhuangzhihao.top/%E5%BE%AE%E5%88%86%E5%AD%A6%E9%87%8D%E7%82%B9/"/>
    <id>http://blog.zhuangzhihao.top/%E5%BE%AE%E5%88%86%E5%AD%A6%E9%87%8D%E7%82%B9/</id>
    <published>2021-12-04T16:00:00.000Z</published>
    <updated>2021-12-10T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>微分学重点的十二章关于导数的课程深入挖掘了微积分的子领域，“微分”。 与微积分重点的课程一样，MIT 数学教授 Gilbert Strang 解释了每个主题如何应用于现实生活中，是对微积分重点的补充，以下为所记课堂笔记，笔记以中文形式记录，方便理解，可供参考。</p></blockquote><a id="more"></a><h3 id="极限和连续"><a href="#极限和连续" class="headerlink" title="极限和连续"></a>极限和连续</h3><ul><li><p> 极限定义：当 $n\rightarrow \infty$ 时，$a_{n}\rightarrow A$</p></li><li><p>洛必达法则：假设 $f(x)$ 和 $g(x)$ 都收敛于 0</p><ul><li> $\dfrac{f\left( x\right) }{g\left( x\right) }=\dfrac{\dfrac{\Delta f}{\Delta x}}{\dfrac{\Delta g}{\Delta x}}\rightarrow \dfrac{s}{t}$</li></ul></li><li><p> 可导必然连续，连续不一定可导</p></li><li><p> 连续定义：对任取 $\varepsilon$，都能找到 $\delta$，满足如果 $\left| x-a\right| &lt;\delta$，则 $\left| f\left( x\right) -f\left( a\right) \right| &lt;\varepsilon$</p></li></ul><h3 id="sinx-和-cosx-的导数"><a href="#sinx-和-cosx-的导数" class="headerlink" title="$sinx$ 和 $cosx$ 的导数"></a>$sinx$ 和 $cosx$ 的导数</h3><ul><li><p>用 $sin$ 和 $cos$ 表示勾股定理</p><ul><li><p>$a^2+b^2=c^2$ $\rightarrow$ $\dfrac{a^{2}}{c^{2}}+\dfrac{b^{2}}{c^{2}}=1$ </p></li><li><p>$\left( \cos \theta \right) ^{2}+\left( \sin \theta \right) ^{2}=1$</p></li></ul></li><li><p>$\dfrac{d}{dx}\sin x=\dfrac{\Delta \left( \sin x\right) }{\Delta x}=\dfrac{\sin \left( x+\Delta x\right) -\sin x}{\Delta x}$</p><ul><li><p>因为 $\sin \left( x+\Delta x\right) =\sin x\cos \Delta x+\cos x\sin \Delta x$</p></li><li><p>所以原式 = $\dfrac{sinx\left( \cos \Delta x-1\right) }{\Delta x}+\dfrac{\cos x\sin \Delta x}{\Delta x}$</p></li><li><p>又因为 $\dfrac{\cos \left( \Delta x-1\right) }{\Delta x}\rightarrow 0$ 且 $\dfrac{\sin \Delta x}{\Delta x}\rightarrow 1$</p></li><li><p>所以 $\dfrac{d}{dx}\sin x=\cos x$</p></li></ul></li><li><p>$\dfrac{d}{dx}\cos x=\dfrac{\Delta \left( \cos x\right) }{\Delta x}=\dfrac{\cos \left( x+\Delta x\right) -\cos x}{\Delta x}$</p><ul><li><p>因为 $\cos \left( x+\Delta x\right) =\cos x\cos \Delta x-\sin x\sin \Delta x$</p></li><li><p>所以原式 = $\dfrac{cos\left( \cos \Delta x-1\right) }{\Delta x}-\dfrac{\sin x\sin \Delta x}{\Delta x}$</p></li><li><p>所以 $\dfrac{d}{dx}\cos x=-\sin x$</p></li></ul></li><li><p>$sinx$ 和 $cosx$ 的导数</p><ul><li><p>$\dfrac{d}{dx}\sin x=\cos x$</p></li><li><p>$\dfrac{d}{dx}\cos x=-\sin x$</p></li></ul></li></ul><h3 id="乘法法则和除法法则"><a href="#乘法法则和除法法则" class="headerlink" title="乘法法则和除法法则"></a>乘法法则和除法法则</h3><ul><li><p>$p(x)=f(x)g(x)$</p><ul><li><p>$\dfrac{\Delta p}{\Delta x}=\dfrac{f\Delta g}{\Delta x}+\dfrac{g\Delta f}{\Delta x}+\dfrac{\Delta f{\Delta }g}{\Delta x}$</p></li><li><p>乘法法则：$\dfrac{dp}{dx}=f\left( x\right) \dfrac{dg}{dx}+g\left( x\right) \dfrac{df}{dx}$</p></li><li><p>$\dfrac{d}{dx}x^{n}=nx^{n-1}$</p></li><li><p>$y=x^2sinx$：$\dfrac{dy}{dx}=x^{2}\cos x+2xsinx$</p></li></ul></li><li><p>$q(x)=\dfrac{f(x)}{g(x)}$</p><ul><li><p>$f(x)=g(x)q(x)$</p></li><li><p>$\dfrac{df}{dx}=g\left( x\right) \dfrac{dq}{dx}+q\left( x\right) \dfrac{dg}{dx}=g\left( x\right) \dfrac{dq}{dx}+\dfrac{f\left( x\right) }{g\left( x\right) }\dfrac{dg}{dx}$</p></li><li><p>$g\left( x\right) \dfrac{df}{dx}-f\left( x\right) \dfrac{dg}{dx}=g(x)^{2}\dfrac{dq}{dx}$</p></li><li><p>除法法则：$\dfrac{dq}{dx}=\dfrac{g\left( x\right) \dfrac{df}{dx}-f\left( x\right) \dfrac{dg}{dx}}{g\left( x\right) ^{2}}$</p></li></ul></li></ul><h3 id="链式法则"><a href="#链式法则" class="headerlink" title="链式法则"></a>链式法则</h3><ul><li><p>函数链（复合函数）：$y=g(x)$，$z=f(y)$</p><ul><li>求导：$\dfrac{dz}{dx}=\dfrac{dz}{dy}\dfrac{dy}{dx}$</li></ul></li><li><p>$sin(3x)$ 的导数：$3cos(3x)$</p></li><li><p>$\dfrac{1}{\sqrt{1-x^{2}}}$ 的导数：$\left( -\dfrac{1}{2}\left( 1-x^{2}\right) ^{-3}\right) -2x=x\left( 1-x^{2}\right) ^{-\dfrac{3}{2}}$</p></li><li><p>$e^{-\dfrac{x^{2}}{2}}$ 的导数：$-x\cdot e^{-\dfrac{x^{2}}{2}}$</p><ul><li>二阶导数：$\left( -x\right) \left( -xe^{-\dfrac{x^{2}}{2}}\right) +\left( e^{-\dfrac{x^{2}}{2}}\right) \left( -1\right)=(x^2-1)\cdot e^{-\dfrac{x^{2}}{2}}$</li></ul></li></ul><h3 id="反函数-f-1-left-y-right-与对数函数-x-lny"><a href="#反函数-f-1-left-y-right-与对数函数-x-lny" class="headerlink" title="反函数 $f^{-1}\left( y\right)$ 与对数函数 $x=lny$"></a>反函数 $f^{-1}\left( y\right)$ 与对数函数 $x=lny$</h3><ul><li><p>$y=f(x)$ 的反函数：$x=f^{-1}(y)$，原函数和反函数关于 $y=x$ 对称</p></li><li><p>$y=e^{x}$ 的反函数：$x=lny$</p></li><li><p>对数函数的性质</p><ul><li><p>$\ln(xy) =\ln x+\ln y$</p></li><li><p>$ln(y^n)=nlny$</p></li></ul></li><li><p>$\dfrac{d}{dy}\left( \ln y\right) =\dfrac{1}{y}$</p></li></ul><h3 id="对数函数-lny-和反三角函数-sin-1-y-的导数"><a href="#对数函数-lny-和反三角函数-sin-1-y-的导数" class="headerlink" title="对数函数 $lny$ 和反三角函数 $sin^{-1}(y)$ 的导数"></a>对数函数 $lny$ 和反三角函数 $sin^{-1}(y)$ 的导数</h3><ul><li><p>令 $y=e^x$</p><ul><li><p>$\ln \left( e^{x}\right) =x$ 两边求导 $\dfrac{d}{dy}\left( \ln y\right) e^{x}=1$</p></li><li><p>$\dfrac{d}{dy}\left( \ln y\right) =\dfrac{1}{e^{x}}=\dfrac{1}{y}$</p></li></ul></li><li><p>$x=\sin ^{-1}y=\arcsin y$</p><ul><li><p>$y=\sin \left( \sin ^{-1}y\right)$ 两边求导 $1=\cos \left( \sin ^{-1}y\right) \dfrac{d\sin ^{-1}y}{dy}$</p></li><li><p>$1=\sqrt{1-y^{2}}\dfrac{d}{dy}\sin ^{-1}y$</p></li><li><p>$\dfrac{d}{dy}\sin ^{-1}y=\dfrac{1}{\sqrt{1-y^{2}}}$</p></li></ul></li><li><p>同理：$\dfrac{d}{dy}\cos ^{-1}y=\dfrac{-1}{\sqrt{1-y^{2}}}$，$\dfrac{d}{dy}\tan ^{-1}\left( y\right) =\dfrac{1}{1+y^{2}}$</p></li></ul><h3 id="增长率和对数图"><a href="#增长率和对数图" class="headerlink" title="增长率和对数图"></a>增长率和对数图</h3><ul><li><p>线性增长：$cx,x^{2},x^{3},\ldots$</p></li><li><p>指数增长：$2^{x},e^{x},10^{x},\ldots$</p></li><li><p>阶乘：$2^{x},e^{x},10^{x},\ldots$</p></li><li><p>对数图</p><ul><li><img src="https://cdn.jsdelivr.net/gh/Bezhuang/Imgbed/blogimg/微积分重点04.png" style="zoom: 50%;"></li></ul></li><li><p>线性拟合</p><ul><li><p>$y=Ax^{n}\rightarrow \log y=\log A+n\log x$</p></li><li><p>$y=B\cdot 10^{cx}\rightarrow \log y=\log B+cx$</p></li></ul></li></ul><h3 id="线性近似和牛顿法"><a href="#线性近似和牛顿法" class="headerlink" title="线性近似和牛顿法"></a>线性近似和牛顿法</h3><ul><li><p>取 $x=a$，已知 $\dfrac{df}{dx}=f’\left( a\right) =\lim _{x\rightarrow a}\dfrac{f\left( x\right) -f\left( a\right) }{x-a}$，求 $f(x)$</p></li><li><p>线性近似：函数在 a 点一阶泰勒展开</p><ul><li><p>$f’\left( a\right) \approx \dfrac{f\left( x\right) -f\left( a\right) }{x-a}$</p></li><li><p>$f\left( x\right) \approx f\left( a\right) +\left( x-a\right) f’\left( a\right)$</p></li></ul></li><li><p>牛顿法</p><ul><li><p>令 $F(x)=0$</p></li><li><p>$x-a\approx \dfrac{-F\left( a\right) }{F’\left( a\right) }$</p></li></ul></li><li><p>近似法求 $\sqrt{9.06}$</p><ul><li><p>$f\left( x\right) =\sqrt{x}=x^{\dfrac{1}{2}}$</p></li><li><p>$f’\left( x\right) =\dfrac{1}{2}x^{-\dfrac{1}{2}}=\dfrac{1}{\sqrt[2] {x}}$</p></li><li><p>取 $a=9$，$f(a)=\sqrt9=3$，$f’(a)=\dfrac{1}{6}$</p></li><li><p>$\sqrt{9.06}\approx 3+\left( 9.06-9\right) \dfrac{1}{6}=3.01$</p></li></ul></li><li><p>近似法求 $e^{0.01}$</p><ul><li><p>$f\left( x\right) =e^{x}$（$x=0.01$）</p></li><li><p>取 $a=0$，$f(a)=e^0=1$，$f’(a)=e^0=1$</p></li><li><p>$e^{x}=e^{0=01}=1+\left( 0.d-0\right) \cdot 1=1.01=1+x$</p></li></ul></li><li><p>牛顿法求 $\sqrt{9.06}$</p><ul><li><p>$F\left( x\right) =x^{2}-9.06=0$</p></li><li><p>取 $a=3$，$F(a)=9-9.06=-0.06$，$F’(a)=2a=6$</p></li><li><p>$x-3\approx \dfrac{0.06}{6}=0.01$</p></li></ul></li></ul><h3 id="幂级数和欧拉公式"><a href="#幂级数和欧拉公式" class="headerlink" title="幂级数和欧拉公式"></a>幂级数和欧拉公式</h3><ul><li><p>泰勒级数：$f\left( x\right) =f\left( 0\right) +f’\left( 0\right) \dfrac{x}{1}+f’’\left( 0\right) \dfrac{x^{2}}{2}+\ldots +f^{\left( n\right) }\left( 0\right) \dfrac{x^{n}}{n!}$</p><ul><li>$x^n$ 的 n 阶导：$n!$</li></ul></li><li><p>使用泰勒级数展开的幂级数</p><ul><li><p>$e^{x}=1+x+\dfrac{1}{2}x^{2}+\dfrac{1}{6}x^{3}+\ldots +\dfrac{1}{n!}x^{n}$</p></li><li><p>$\sin x=x-\dfrac{x^{3}}{3!}+\dfrac{x^{5}}{5!}\ldots$ 奇级数</p></li><li><p>$\cos x=1-\dfrac{x^{2}}{2!}+\dfrac{x^{4}}{4!}\ldots$ 偶级数</p></li></ul></li><li><p>欧拉公式：将 $e^x$ 级数中的 $x$ 考虑为虚数 $i$</p><ul><li><p>$e^{ix}=1+ix+\dfrac{1}{2!}\left( ix\right) ^{2}+\dfrac{1}{3!}\left( ix\right) ^{3}+\ldots$</p></li><li><p>实数、虚数分离：$e^{ix}=\left( 1-\dfrac{1}{2!}x^{2}+\ldots \right) +i\left( x-\dfrac{1}{3!}x^{3}+\ldots \right)$</p></li><li><p>因此：$e^{ix}=\cos x+i\sin x$</p></li><li><p>同理：$e^{-ix}=\cos x-i\sin x$</p></li></ul></li><li><p>几何级数：$\dfrac{1}{1-x}=1+x+x^{2}+x^{3}+\ldots ( \left| x\right| &lt; 1)$</p></li><li><p>将几何级数逐项积分：$-ln \left( 1-x\right) =x+\dfrac{x^{2}}{2}+\dfrac{x^{3}}{3}+\dfrac{x^{4}}{4}+\ldots ( \left| x\right| &lt; 1)$</p></li></ul><h3 id="关于运动的微分方程"><a href="#关于运动的微分方程" class="headerlink" title="关于运动的微分方程"></a>关于运动的微分方程</h3><ul><li><p>微分方程就是函数的导数和函数本身之间存在的关系</p></li><li><p>常系数二阶线性微分方程：$m\dfrac{d^{2}y}{dt^{2}}+2r\dfrac{dy}{dt}+ky=0$</p><ul><li><p>$m=0$ 时，$\dfrac{dy}{dt}=ay\rightarrow y=ce^{at}$</p></li><li><p>$r=0$ 时，$\dfrac{d^{2}y}{dt^{2}}=-\omega ^{2}y$ （$\omega ^{2}= \dfrac{k}{m}$）$\rightarrow y=C\cos \omega t+D\sin \omega t$</p></li><li><img src="https://cdn.jsdelivr.net/gh/Bezhuang/Imgbed/blogimg/%E5%BE%AE%E7%A7%AF%E5%88%86%E9%87%8D%E7%82%B905.png" style="zoom: 50%;"></li></ul></li><li><p>令 $y=e^{\lambda t}$ 满足方程 $m\lambda ^{2}e^{\lambda t}+2r\lambda e^{\lambda t}+ke^{\lambda t}=0$</p><ul><li><p>$m\lambda ^{2}+2r\lambda +k=0$</p></li><li><p>$\lambda =\dfrac{-r\pm \sqrt{r^{2}-km}}{m}$</p></li><li><p>$y=Ce^{\lambda _{1}t}+De^{\lambda _{2}t}$</p></li><li><p>若 $\lambda _{1}=\lambda _{2}$，$y=Ce^{\lambda t}+Dte^{\lambda t}$</p></li></ul></li><li><p>当 $m=1,r=3,k=10$ 时，$1y’’+6y’+10y=0$</p><ul><li><p>$\lambda ^{2}+6\lambda +10=0$</p></li><li><p>$\lambda =-3\pm i$</p></li><li><p>$y\left( t\right) =Ce^{\left( -3+i\right) t}+De^{\left( -3-i\right) t}$</p></li><li><p>由欧拉公式：$y\left( t\right) =Ae^{-3t}\cos t+Be^{-3t}\sin t$</p></li></ul></li></ul><h3 id="关于增长的微分方程"><a href="#关于增长的微分方程" class="headerlink" title="关于增长的微分方程"></a>关于增长的微分方程</h3><ul><li><p>微分方程 $\dfrac{dy}{dt}=cy$，对于任意 A 有解 $y\left( t\right) =Ae^{ct}$</p><ul><li>$y\left( t\right) =y\left( 0\right) e^{ct}$</li></ul></li><li><p>增加初始常数：$\dfrac{dy}{dt}=cy+s$</p><ul><li><p>$\dfrac{d}{dt}\left( y+\dfrac{s}{c}\right) =c\left( y+\dfrac{s}{c}\right)$</p></li><li><p>$y\left( t\right) =-\dfrac{s}{c}+\left( y\left( 0\right) +\dfrac{s}{c}\right) e^{ct}$</p></li></ul></li><li><p>人口增长方程：$\dfrac{dP}{dt}=cP-sP^{2}$，$c$ 为增长率而 $s$ 为竞争因素</p><ul><li><img src="https://cdn.jsdelivr.net/gh/Bezhuang/Imgbed/blogimg/%E5%BE%AE%E7%A7%AF%E5%88%86%E9%87%8D%E7%82%B906.png" style="zoom: 50%;"></li><li><p>令 $y=\dfrac{1}{P}$，$\dfrac{dy}{dt}=-\dfrac{\dfrac{dP}{dt}}{P^{2}}=\dfrac{\left( cP+sP^{2}\right) }{P^{2}}=s-cP=s-cy$</p></li><li><p>$y\left( t\right) =\dfrac{s}{c}+Ae^{-ct}=\dfrac{s}{c}+\left( y\left( 0\right) -\dfrac{s}{c}\right) e^{-ct}$</p></li><li><p>$\dfrac{1}{p\left( t\right) }-\dfrac{s}{c}=\left( \dfrac{1}{p(0)}-\dfrac{s}{c}\right) e^{-ct}$</p></li></ul></li><li><p>人口增长方程二阶导数：$\dfrac{d^{2}P}{dt^{2}}=\dfrac{d}{dt}\left( cP-sP^{2}\right) =\left( c-2sP\right) \dfrac{dP}{dt}$</p><ul><li>$p=\dfrac{c}{2s}$ 时，$\dfrac{d^{2}P}{dt^{2}}=0$（拐点，增长率开始放缓）</li></ul></li></ul><h3 id="微分学总结"><a href="#微分学总结" class="headerlink" title="微分学总结"></a>微分学总结</h3><h4 id="六函数"><a href="#六函数" class="headerlink" title="六函数"></a>六函数</h4><table><thead><tr><th align="center">积分</th><th align="center"></th><th align="center">导数</th></tr></thead><tbody><tr><td align="center">$\dfrac{x^{n+1}}{\left( n+1\right) },n\neq -1$</td><td align="center">$x^n$</td><td align="center">$nx^{n-1}$</td></tr><tr><td align="center">$-cosx$</td><td align="center">$sinx$</td><td align="center">$cosx$</td></tr><tr><td align="center">$sinx$</td><td align="center">$cosx$</td><td align="center">$-sinx$</td></tr><tr><td align="center">$\dfrac{e^{cx}}{c}$</td><td align="center">$e^{cx}$</td><td align="center">$ce^{cx}$</td></tr><tr><td align="center">$x\ln x-x$</td><td align="center">$lnx$</td><td align="center">$\dfrac{1}{x}$</td></tr><tr><td align="center">斜坡函数</td><td align="center">分段函数</td><td align="center">$\delta$ 函数</td></tr></tbody></table><h4 id="六法则"><a href="#六法则" class="headerlink" title="六法则"></a>六法则</h4><ul><li><p>加法法则：和的导数等于导数的和</p><ul><li>$af\left( x\right) +bg\left( x\right) \rightarrow a\dfrac{df}{dx}+b\dfrac{dg}{dx}$</li></ul></li><li><p>乘法法则：上乘下导加下乘上导</p><ul><li>$f\left( x\right) g\left( x\right) \rightarrow f\left( x\right) \dfrac{dg}{dx}+g\left( x\right) \dfrac{df}{dx}$</li></ul></li><li><p>除法法则：下平方分之下乘上导减上乘下导</p><ul><li>$\dfrac{f\left( x\right) }{g\left( x\right) }\rightarrow  \dfrac{g\left( x\right) \dfrac{df}{dx}-f\left( x\right) \dfrac{dg}{dx}}{g\left( x\right) ^{2}}$</li></ul></li><li><p>链式法则</p><ul><li>$f\left( g\left( x\right) \right) \rightarrow \dfrac{df}{dy}\dfrac{dy}{dx}$</li></ul></li><li><p>反函数的导数等于原函数的导数分之一</p><ul><li>$x=f^{-1}\left( y\right) \rightarrow \dfrac{dx}{dy}=\dfrac{1}{\dfrac{dy}{dx}}$</li></ul></li><li><p>洛必达法则：$\dfrac{0}{0}$ 或 $\dfrac{\infty }{\infty }$</p><ul><li>$\dfrac{f\left( x\right) }{g\left( x\right) }\rightarrow \dfrac{\dfrac{dt}{dx}}{\dfrac{dg}{dx}}$</li></ul></li></ul><h4 id="六定理"><a href="#六定理" class="headerlink" title="六定理"></a>六定理</h4><ul><li><p>微积分基本定理</p><ul><li><p>如果函数 $f(x)=\int _{a}^{x}s\left( t\right) dt$，那么函数的导数为 $\dfrac{df}{dx}=s\left( x\right) $</p></li><li><p>如果函数的导数为 $\dfrac{df}{dx}=s\left( x\right) $，那么导数的积分（原函数）为 $\int _{a}^{b}s\left( x\right) dx=f\left( b\right) -f\left( a\right) $</p></li></ul></li><li><p>介值定理（全值定理）</p><ul><li><p>对于 $a\leq x\leq b$ 区间上的连续函数</p></li><li><p>一定能取到最大值 $M$ 和最小值 $m$，使得 $[M,m]$ 中的任意值都存在函数上的点与之对应</p></li><li><p>连续函数的一个区间内的函数值肯定介于最大值 $M$ 和最小值 $m$之间</p></li></ul></li><li><p>中值定理</p><ul><li>如果函数 $f(x)$ 在闭区间 $[a,b]$ 上连续，在开区间 $(a,b)$ 内可导，那么在 $(a,b)$ 内至少有一点 $\varepsilon $，使 $f\left( b\right) -f\left( a\right) =f\left( \varepsilon \right) \left( b-a\right) $ 成立</li></ul></li><li><p>泰勒级数</p><ul><li><p>$f\left( x\right) =f\left( a\right) +f’\left( a\right) \left( x-a\right) +\dfrac{1}{2}f’’\left( a\right) \left( x-a\right) ^{2}+\ldots =\sum ^{\infty }_{n=0}\dfrac{1}{n!}f^{\left( n\right) }\left( a\right) \left( x-a\right) ^{n}$</p></li><li><p>若级数截断于 $\left( x-a\right) ^{n}$ 项，余项为：$\dfrac{1}{\left( n+1\right) !}f^{\left( n+1\right) }\left( c\right) \left( x-a\right) ^{\left( n+1\right) }$</p></li><li><p>当 $a=0$ 时，$f\left( x\right)=\sum ^{\infty }_{n=0}\dfrac{1}{n!}f^{\left( n\right) }\left( 0\right) \left( x\right) ^{n}$</p></li></ul></li><li><p>二项式定理</p><ul><li><p>帕斯卡三角：<img src="https://cdn.jsdelivr.net/gh/Bezhuang/Imgbed/blogimg/%E5%BE%AE%E7%A7%AF%E5%88%86%E9%87%8D%E7%82%B907.png" style="zoom:80%;"></p></li><li><p>$(1+x)^p=1+px+\dfrac{P\left( p-1\right) }{\left( 2\right) \left( 1\right) }x^{2}+\dfrac{p\left( p-1\right) \left( p-2\right) }{\left( 3\right) \left( 2\right) \left( 1\right) }x^{3}+\ldots $</p></li></ul></li></ul>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;微分学重点的十二章关于导数的课程深入挖掘了微积分的子领域，“微分”。 与微积分重点的课程一样，MIT 数学教授 Gilbert Strang 解释了每个主题如何应用于现实生活中，是对微积分重点的补充，以下为所记课堂笔记，笔记以中文形式记录，方便理解，可供参考。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="数学" scheme="http://blog.zhuangzhihao.top/categories/%E6%95%B0%E5%AD%A6/"/>
    
    
    <category term="OpenCourseWare" scheme="http://blog.zhuangzhihao.top/tags/OpenCourseWare/"/>
    
  </entry>
  
  <entry>
    <title>微积分重点</title>
    <link href="http://blog.zhuangzhihao.top/%E5%BE%AE%E7%A7%AF%E5%88%86%E9%87%8D%E7%82%B9/"/>
    <id>http://blog.zhuangzhihao.top/%E5%BE%AE%E7%A7%AF%E5%88%86%E9%87%8D%E7%82%B9/</id>
    <published>2021-11-20T16:00:00.000Z</published>
    <updated>2021-12-04T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>微积分重点（Highlights of Calculus）是 MIT 数学教授 Gilbert Strang 对于微积分中的精华和重点出的一个生动、简短的课程，帮助我们重新审视微积分，课程主要涉及单变量微积分的总览，以下为所记课堂笔记，笔记以中文形式记录，方便理解，可供参考。</p></blockquote><a id="more"></a><h3 id="微积分总览"><a href="#微积分总览" class="headerlink" title="微积分总览"></a>微积分总览</h3><ul><li><p>微积分是函数（1）和函数（2）之间的桥梁</p><ul><li><p>距离 $f\left( t\right)$ 、速度 $\dfrac{df}{dt}$</p></li><li><p>高度 $y\left( x\right)$ 、斜率 $\dfrac{dy}{dx}$</p></li></ul></li><li><p>匀速情况下，$速度=\dfrac{距离}{时间}$，即 $斜率=\dfrac{垂直}{水平}$，即 $s=\dfrac{f}{t}$</p><ul><li>若要求中间一段时间或距离的速度，$s=\dfrac{\Delta f}{\Delta t}$</li></ul></li><li><p>匀变速情况下，函数图像均为曲线</p><ul><li><p>微分学就是已知 $距离-时间$ 函数求 $速度-时间$ 函数</p></li><li><p>积分学就是已知 $速度-时间$ 函数求 $距离-时间$ 函数</p></li><li><p> $速度-时间$ 函数 $s=at$ 下面积 $\dfrac{1}{2}t\left( at\right)$ 就是 $距离-时间$ 函数 $\dfrac{1}{2}at^{2}$</p></li><li><p>速度 $s=\dfrac{df}{dt}$ 就是 $f=\int s\left( t\right) dt$ 的导数</p></li></ul></li></ul><h3 id="导数总览"><a href="#导数总览" class="headerlink" title="导数总览"></a>导数总览</h3><ul><li><p>已知距离 $f\left( t\right)$  如何求速度 $\dfrac{df}{dt}$，即已知高度 $y\left( x\right)$  如何求斜率 $\dfrac{dy}{dx}$</p></li><li><p>三个重要函数的斜率</p><ul><li><p>幂函数 $y=x^{n}$ ：$\dfrac{dy}{dx}=nx^{n-1}$</p></li><li><p>三角函数 $y=\sin x$ ：$\dfrac{dy}{dx}=\cos x$</p></li><li><p>指数函数 $y=e^{x}$ ：$\dfrac{dy}{dx}=e^{x}$</p></li></ul></li><li><p>$y=x^2$ 斜率的含义</p><ul><li><p>$平均斜率\dfrac{\left( \Delta x\right) ^{2}}{\Delta x}$，即 $\dfrac{\Delta y}{\Delta x}$ $\rightarrow$ $瞬时斜率\dfrac{dy}{dx}$</p></li><li><p>$\dfrac{\Delta y}{\Delta x}=\dfrac{\left( x+\Delta x\right) ^{2}}{\Delta x}\dfrac{-x^{2}}{}=\dfrac{2xax+\left( \Delta x\right) ^{2}}{\Delta x}=2x+\Delta x$</p></li><li><p>求导：$\dfrac{dy}{dx}=\lim\dfrac{\Delta y}{\Delta x}=2x$</p></li></ul></li><li><p>任意 $x$ 处，$y=\sin x 的斜率\rightarrow \dfrac{dy}{dx}=\cos x$</p></li></ul><h3 id="极值及二阶导数"><a href="#极值及二阶导数" class="headerlink" title="极值及二阶导数"></a>极值及二阶导数</h3><ul><li><p>二阶导数：导数的导数</p><ul><li>一阶导数用于确认极值点，二阶导数表明曲线弯曲方向</li></ul></li><li><p>二阶导数的例子：加速度</p><ul><li><p>距离 $f\left( t\right)$ 、速度 $\dfrac{df}{dt}$、加速度 $\dfrac{d^{2}f}{dt^{2}}$</p></li><li><p>高度 $y=x^2$ 、斜率 $\dfrac{dy}{dx}=2x$、弯曲性 $\dfrac{d^{2}f}{dt^{2}}=2$</p></li><li><p>$sinx$ 的二阶导数为 $-sinx$</p></li></ul></li><li><p>凸函数和凹函数：$f’’ &gt;0$ 为凸，表示向上弯曲，相对的凹为 $f’’ &lt;0$</p></li><li><p>拐点：二阶导数为 0 的点，表示弯曲方向改变</p></li><li><p>对于函数 $y=x^{3}-x^{2}$ $\rightarrow$ $y’=3x^{2}-2x$，$y’’=6x-2$</p><ul><li><p>求极值点：令 $y’=3x^{2}-2x=0$，$x= 0或x=\dfrac{2}{3}$</p></li><li><p>$x=0$ 处，二阶导数为负，取局部最大值（极大值）</p></li><li><p>$x=\dfrac{2}{3}$ 处，二阶导数为正，取局部最小值（极小值）</p></li></ul></li><li><p>应用：上班的最短时间</p><ul><li><p>设高速总长 $b$，家垂直上高速距离为 $a$，没走的高速距离为 $x$</p></li><li><img src="https://cdn.jsdelivr.net/gh/Bezhuang/Imgbed/blogimg/%E5%BE%AE%E7%A7%AF%E5%88%86%E9%87%8D%E7%82%B901.png" style="zoom: 33%;"></li><li><p>$时间t=\dfrac{b-x}{60}+\dfrac{\sqrt{a^{2}+x^{2}}}{30}$</p></li><li><p>取时间方程的导数，然后令导数为 0 来求最小值</p></li><li><p>$f’=-\dfrac{1}{60}+\dfrac{1}{30}\cdot \dfrac{1}{2}\cdot \dfrac{2x}{\sqrt{a^{2}+x^{2}}}=0$ $\rightarrow$ $x=\dfrac{a}{\sqrt{3}}$</p></li></ul></li><li><p>最值的一般求法：比较所有驻点（$f’=0$）处及边界点函数值，得到最大或最小值即函数最值</p></li><li><p>$f’’$ 的符号可通过 $f’$ 的单调性求出：$x&gt;0$ 时，$f’(x)&gt;f’(0)$ ，斜率变化率为正，$f’’&gt;0$</p></li></ul><h3 id="指数函数-e-x"><a href="#指数函数-e-x" class="headerlink" title="指数函数 $e^x$"></a>指数函数 $e^x$</h3><ul><li><p>最简单的微分方程：$y=\dfrac{dy}{dx}$</p></li><li><p>指数函数：通过微积分构造的函数</p><ul><li><p>重要性质一：指数函数的导数就是其自身</p></li><li><p>函数初始点：$y=e^{0}=1$</p></li><li><p>$\dfrac{x^{n}}{n!}$ 斜率的导数为 $\dfrac{x^{n-1}}{\left( n-1\right) !}$</p></li><li><p>指数级数：$e^{x}=1+x+\dfrac{x^{2}}{2!}+\dfrac{x^{3}}{3!}+\ldots +\dfrac{x^{n}}{n!}+\ldots$</p></li><li><p>重要性质二：$e^{x}\cdot e^{X}=e^{x+X}$</p></li><li><p>$e$ 等于 $x=1$ 时指数级数的值：$e=1+1+\dfrac{1}{2}+\dfrac{1}{6}+\ldots \dfrac{1}{n!}+\ldots\approx 2.71828\ldots$</p></li></ul></li><li><p>指数函数的图像</p><ul><li><p>由重要性质二可得：$e^{-x}=\dfrac{1}{e^{x}}$</p></li><li><img src="https://cdn.jsdelivr.net/gh/Bezhuang/Imgbed/blogimg/%E5%BE%AE%E7%A7%AF%E5%88%86%E9%87%8D%E7%82%B902.png" style="zoom:50%;"></li></ul></li><li><p>应用：计算存款复利</p><ul><li><p>假设利率为 100%，1 美元存一年得到 2 美元或更多</p></li><li><p>将一年分为 n 份付利息，得到 $\left( 1+\dfrac{1}{n}\right) ^{n}$，$n\rightarrow \infty$ 时最终趋近于 $e$</p></li><li><p>解常微分方程：$\dfrac{dy}{dx}=cy$ $\rightarrow$ $y\left( x\right) =e^{cx}$</p></li></ul></li></ul><h3 id="积分总览"><a href="#积分总览" class="headerlink" title="积分总览"></a>积分总览</h3><ul><li><p>函数二 $\dfrac{dy}{dx}=nx^{n-1}$ 是函数一 $y=x^{n}$ 的导数</p></li><li><p>函数一 $y=\dfrac{x^{n+1}}{n+1}$ 是函数二 $\dfrac{dy}{dx}=x^{n}$ 的积分</p></li><li><p>求原函数：$y\left( x\right) =\int s\left( x\right) dx$</p></li><li><p>求积分方法A：反过来看什么函数的导数能得到要积分的函数</p></li><li><p>例：通过代数方法求函数一</p><ul><li><img src="https://cdn.jsdelivr.net/gh/Bezhuang/Imgbed/blogimg/%E5%BE%AE%E7%A7%AF%E5%88%86%E9%87%8D%E7%82%B903.png" style="zoom:67%;"></li><li><p>相加求和：$\sum \Delta y=y_{终}-y_{始}$</p></li></ul></li><li><p>例：通过微积分方法求函数一</p><ul><li><p>同时乘除 $\Delta x$：$\sum \left( \dfrac{\Delta y}{\Delta x}\right) \Delta x=y_{终}-y_{始}$</p></li><li><p>在 $\Delta x\rightarrow 0$ 的极限情况下，求和转化为积分：$\int \dfrac{dy}{dx}dx$</p></li></ul></li><li><p>求积分方法B：$积分=函数一=函数二图像下的面积$</p><ul><li>斜率为 $s=2-2x$，对应的高度 $y=2x-x^2$</li></ul></li></ul>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;微积分重点（Highlights of Calculus）是 MIT 数学教授 Gilbert Strang 对于微积分中的精华和重点出的一个生动、简短的课程，帮助我们重新审视微积分，课程主要涉及单变量微积分的总览，以下为所记课堂笔记，笔记以中文形式记录，方便理解，可供参考。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="数学" scheme="http://blog.zhuangzhihao.top/categories/%E6%95%B0%E5%AD%A6/"/>
    
    
    <category term="OpenCourseWare" scheme="http://blog.zhuangzhihao.top/tags/OpenCourseWare/"/>
    
  </entry>
  
  <entry>
    <title>Machine Learning with Python</title>
    <link href="http://blog.zhuangzhihao.top/Machine-Learning-with-Python/"/>
    <id>http://blog.zhuangzhihao.top/Machine-Learning-with-Python/</id>
    <published>2021-11-09T16:00:00.000Z</published>
    <updated>2021-12-14T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>This course provided by IBM dives into the basics of machine learning using an approachable, and well-known programming language, Python. In this course, I’ve learned about the purpose of Machine Learning and where it applies to the real world and had a general overview of Machine Learning topics such as supervised vs unsupervised learning, model evaluation, and Machine Learning algorithms. The following are the notes I took during this course.</p></blockquote><a id="more"></a><div class="row">    <embed src="/pdf/ml-with-py.pdf" width="100%" height="550" type="application/pdf"></div><h3 id="Introduction-to-Machine-Learning"><a href="#Introduction-to-Machine-Learning" class="headerlink" title="Introduction to Machine Learning"></a>Introduction to Machine Learning</h3><h4 id="What-is-machine-learning"><a href="#What-is-machine-learning" class="headerlink" title="What is machine learning"></a>What is machine learning</h4><ul><li>Machine learning is the subfield of computer science that gives “computers the ability to learn without being explicitly programmed.”</li><li>Major machine learning techniques<ul><li>Regression/Estimation: Predicting continuous values</li><li>Classification: Predicting the item class/category of a case</li><li>Clustering: Finding the structure of data, summarization</li><li>Associations: Associating frequent co-occurring items/events</li><li>Anomaly detection: Discovering abnormal and unusual cases</li><li>Sequence mining: Predicting next events, click-stream (Markov Model, HMM)</li><li>Dimension Reduction: Reducing the size of data (PCA)</li><li>Recommendation systems: Recommending items</li></ul></li><li>Difference between artificial intelligence, machine learning and deep learning<ul><li>AI components: Computer Vision, Language Processing, Creativity, etc</li><li>Machine learning: Classification, Clustering, Neural Network, etc</li><li>Revolution in ML: Deep learning</li></ul></li></ul><h4 id="Python-libraries-for-machine-learning"><a href="#Python-libraries-for-machine-learning" class="headerlink" title="Python libraries for machine learning"></a>Python libraries for machine learning</h4><ul><li>NumPy, SciPy, Matplotlib, pandas, Scikit Learn</li><li>Scikit Learn: Classification, Regression and Clustering algorithms, Works with NumPy and SciPy, Easy to implement<pre><code class="python">from sklearn import preprocessingx = preprocessing.StandardScaler().fit(X).transform(X)</code></pre></li></ul><p>from sklearn.model_selection import train_test_split<br>X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.33)</p><p>from sklearn import svm<br>clf = svm.SVC(gamma=0.001, C=100.)<br>clf.fit(X_train, y_train)<br>clf.predict(X_test)</p><p>from sklearn.metrics import confusion_matrix<br>print(confusion_matrix(y_test, yhat, labels=[1,0]))</p><p>import pickle<br>s = pickle.dump(clf)</p><p>```</p><h4 id="Supervised-vs-Unsupervised-learning"><a href="#Supervised-vs-Unsupervised-learning" class="headerlink" title="Supervised vs Unsupervised learning"></a>Supervised vs Unsupervised learning</h4><ul><li>Supervised learning: Teach the model with labeled data, then with that knowledge, it can predict unknown or future instances</li><li>Types of supervised learning: Classification and Regression<ul><li>Classification is the process of predicting discrete class labels or categories (Classifies labeled data)</li><li>Regression is the process of predicting continuous values (Predicts trends using previous labeled data)</li></ul></li><li>Unsupervised learning: The model works on its own to discover information</li><li>Unsupervised learning techniques: Dimension reduction, Density estimation, Market basket analysis, Clustering</li><li>Clustering is grouping of data points or objects that are somehow similar by Discovering structure, Summarization and Anomaly detection (Finds patterns and groupings from unlabeled data)</li><li>Supervised Learning has more evaluation methods than unsupervised learning, whereas unsupervised learning is a less controlled environment</li></ul><h3 id="Linear-Regression"><a href="#Linear-Regression" class="headerlink" title="Linear Regression"></a>Linear Regression</h3><h4 id="Regression"><a href="#Regression" class="headerlink" title="Regression"></a>Regression</h4><ul><li>Regression is the process of predicting a continuous value</li><li>Two types of regression model: Simple Regression and Multiple Regression</li><li>Applications of regression: Sales forecasting, Satisfaction analysis, Price estimation, Employment income, etc.</li><li>Regression algorithms<ul><li>Ordinal regression</li><li>Poisson regression</li><li>Fast forest quantile regression</li><li>Linear, Polynomial, Lasso, Stepwise, Ridge regression</li><li>Bayesian linear regression</li><li>Neural network regression</li><li>Decision forest regression</li><li>Boosted decision tree regression</li><li>KNN (K-nearest neighbors)</li></ul></li></ul><h4 id="Simple-Linear-Regression"><a href="#Simple-Linear-Regression" class="headerlink" title="Simple Linear Regression"></a>Simple Linear Regression</h4>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;This course provided by IBM dives into the basics of machine learning using an approachable, and well-known programming language, Python. In this course, I’ve learned about the purpose of Machine Learning and where it applies to the real world and had a general overview of Machine Learning topics such as supervised vs unsupervised learning, model evaluation, and Machine Learning algorithms. The following are the notes I took during this course.&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="人工智能与大数据" scheme="http://blog.zhuangzhihao.top/categories/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E4%B8%8E%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
    
    <category term="Coursera" scheme="http://blog.zhuangzhihao.top/tags/Coursera/"/>
    
    <category term="Python" scheme="http://blog.zhuangzhihao.top/tags/Python/"/>
    
    <category term="Machine Learning" scheme="http://blog.zhuangzhihao.top/tags/Machine-Learning/"/>
    
  </entry>
  
  <entry>
    <title>白话机器学习算法</title>
    <link href="http://blog.zhuangzhihao.top/%E7%99%BD%E8%AF%9D%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95/"/>
    <id>http://blog.zhuangzhihao.top/%E7%99%BD%E8%AF%9D%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95/</id>
    <published>2021-10-30T16:00:00.000Z</published>
    <updated>2021-11-23T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>机器学习算法是数据科学的力量之源，它和数据一起产生极其宝贵的知识并且帮助我们以新的方式利用已有信息。<a href="https://book.douban.com/subject/30442187/">白话机器学习算法</a>一书用通俗易懂的语言以及大量有趣的示例和插图讲解10多种前沿的机器学习算法。内容涵盖k均值聚类、主成分分析、关联规则、社会网络分析等无监督学习算法，以及回归分析、k最近邻、支持向量机、决策树、随机森林、神经网络等监督学习算法，并概述强化学习算法的思想。以下为阅读过程中所作的读书笔记，可供参考。</p></blockquote><a id="more"></a><h3 id="为何需要数据科学"><a href="#为何需要数据科学" class="headerlink" title="为何需要数据科学"></a>为何需要数据科学</h3><ul><li>借助现代计算机和高级算法，我们能够做到以下几点：<ol><li>从大型数据集中发现隐藏的趋势</li><li> 充分利用发现的趋势做预测</li><li>计算每种结果出现的概率</li><li>快速获取准确结果</li></ol></li></ul><h3 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h3><h4 id="准备数据"><a href="#准备数据" class="headerlink" title="准备数据"></a>准备数据</h4><ul><li>数据格式：数据点、数据集</li><li>变量（variable）：用于描述数据点，又叫属性、特征或维度<ul><li>二值变量（binary variable）：最简单的变量类型，只有2个可选值</li><li>分类变量（categorical variable）：用来表示有2个以上选择的情况</li><li>整型变量（integer variable）：用来表示整数</li><li>连续变量（continuous variable）：用来表示小数</li></ul></li><li>变量选择是一个试错的过程，需要根据反馈结果不断更换变量，选取那些最有希望的变量，以待进一步分析</li><li>特征工程（feature engineering）是将原始数据转化成更好的表达问题本质的特征的过程，使得将这些特征运用到预测模型中能提高对不可见数据的模型预测精度</li><li>解决数据缺失：近似、计算、移除</li></ul><h4 id="选择算法"><a href="#选择算法" class="headerlink" title="选择算法"></a>选择算法</h4><ul><li>无监督学习（unsupervised learning）：依靠算法从数据中找出隐藏的模式<ul><li>k 均值聚类、主成分分析、关联规则、社会网络分析</li><li>通过间接手段，可以对无监督学习模型输出的结果进行验证</li></ul></li><li>监督学习（supervised learning）：基于数据中已有的模式做预测<ul><li>回归分析、k 最近邻、支持向量机、决策树、随机森林（random forest）、神经网络</li></ul></li><li>强化学习（reinforcement learning）：使用数据中的模式做预测，并根据越来越多的反馈结果不断改进</li><li>除了要了解算法使用的任务类型外，还要了解各种算法对不同数据类型的分析能力，以及结果的本质</li></ul><h4 id="参数调优（parameter-tuning）"><a href="#参数调优（parameter-tuning）" class="headerlink" title="参数调优（parameter tuning）"></a>参数调优（parameter tuning）</h4><ul><li>不同的算法有不同的调节参数，即便是同一个算法，如果参数调的不一样，所产生的结果也各不相同</li><li>过拟合模型：过度敏感，把数据中的随机波动当成持久模式，对当前数据有着很高的预测准确度，但是对未知数据的预测准确度较差（泛化能力不强）</li><li>欠拟合模型（underfitting）：过于愚钝，很可能会忽视数据中的重要趋势，这会导致模型对当前数据和未知数据的预测准确度下降</li><li>理想拟合：算法能在识别主要趋势和忽视微小变化之间找到平衡，使最终得到的模型非常适合做预测</li><li>对于大多数模型而言，过拟合（overfitting）是常见问题，所以增加预测模型的复杂度能最大限度的减少预测误差，但容易出现预测边界过度复杂</li><li>通过正则化（regularization）引入惩罚参数，通过人为增大预测误差，对模型复杂度的增加进行惩罚，从而使算法同时考虑复杂度和准确度使模型保持简单，有助于提高模型的泛化能力</li></ul><h4 id="评价模型"><a href="#评价模型" class="headerlink" title="评价模型"></a>评价模型</h4><ul><li>使用一些评价指标来比较模型的预测准确度：预测准确率、混淆矩阵和均方根误差（root mean squared error）</li><li>分类指标（classification）<ul><li>预测准确率：正确预测所占的比率，无法通过预测准确率得知预测误差是如何产生的</li><li>混淆矩阵（confusion matrix）：在预测准确率的基础上添加假正类型和假负类型，辨别预测误差数</li></ul></li><li>回归指标<ul><li>由于回归预测使用连续值，因此误差一般被量化成预测值和实际值之差，惩罚随误差大小而不同</li><li>均方根误差：将每个误差都取平方，放大大误差，这使得均方根误差对异常值极其敏感，对这些值的惩罚力度也更大，避免较大的误差</li></ul></li><li>验证：评估模型对新数据的预测准确度，避免过拟合模型在面对当前数据表现良好而面对新数据时可能表现糟糕的情况</li><li>在评估模型时并不一定非要使用新数据，而是可以把当前的数据集划分成训练集（training dataset）和测试集（test dataset）<ul><li>训练集用来生成和调整预测模型，测试集用来充当新数据并评估模型的预测准确度</li><li>最好的模型针对测试集所做的预测一定是最准确的</li><li>为了使验证（validation）过程行之有效，需要不带偏差的把数据点随机分派到数据集和测试集中</li></ul></li><li>交叉验证（cross-validation）：使用同一个数据集进行训练和测试，避免因为原始数据集很小而无法留出足够的数据形成测试集的情况<ul><li>把数据集划分成若干组用来对模型进行反复测试</li><li>在单次迭代中除了某一组外其他各组都被用来训练预测模型，然后留下来的那组被用来测试模型</li><li>这个过程重复进行直到每一个组都测试过模型，并且只测试过一次</li></ul></li></ul><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><ul><li>数据科学研究的 4 个主要步骤：<ol><li>准备待分析的数据</li><li>根据研究需求挑选合适的算法，为数据建立模型</li><li>对算法的参数进行调优，优化模型</li><li>根据准确度评价模型</li></ol></li></ul><h3 id="k-均值聚类（k-means-clustering）"><a href="#k-均值聚类（k-means-clustering）" class="headerlink" title="k 均值聚类（k-means clustering）"></a>k 均值聚类（k-means clustering）</h3><h4 id="定义群组"><a href="#定义群组" class="headerlink" title="定义群组"></a>定义群组</h4><ul><li>群组数量要足够大，以便提取有意义的模式用作商业决策参考，还要足够小，能够确保各个群组之间有明显的区别</li><li>使用陡坡图（scree plot）确定合适的群组数量<ul><li>陡坡图可以展现群组内散度随群组数量增加而降低的过程</li><li>陡坡图曲线的拐弯处表示最佳群组数量，此处的群组内散度较为合理</li></ul></li><li>通过检查群组成员与群组中心点的距离判断该群组的有效性（群组最好由密集的数据点组成）<ol><li>猜测每个群组的中心点，因为暂时不能确定通过猜测得到的中心点是否正确，所以称它们为伪中心点</li><li>把每个数据点分配给最近的伪中心点</li><li>根据群组成员的分布调整为中心点的位置</li><li>重复步骤 2 和步骤 3 直至群组成员不再发生变化</li></ol></li><li>聚类也可以在更多的维度上进行，虽然多维度分析很难进行可视化，但是可以借助程序计算数据点和群组中心点在多维度情形下的距离</li></ul><h4 id="局限性"><a href="#局限性" class="headerlink" title="局限性"></a>局限性</h4><ul><li>每个数据点只能属于一个群组：恰好位于两个群组中间的数据点无法确定应属于哪个群组</li><li>群组被假定是正圆形的：若群组的实际形状是椭圆形，那么位于椭圆两端的数据点可能被划入邻近的其他群组</li><li>群组被假定是离散的：k 均值聚类既不允许群组重叠，也不允许它们相互嵌套</li><li>弥补局限性的方法：先用 k 均值聚类方法大致了解数据结构，再综合运用其他更高级的方法进行深入分析</li></ul><h4 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h4><ul><li>k 均值聚类用于把相似的数据点划入同一个群组，群组数量 k 必须事先指定</li><li>给数据点分组时，首先把各个数据点分配到距离最近的群组中，然后调整群组中心点的位置，重复这2个步骤直到群组中的成员不再发生变化</li><li>k 均值聚类最适用于正圆形、非重叠的群组</li></ul><h3 id="主成分分析（principal-component-analysis）"><a href="#主成分分析（principal-component-analysis）" class="headerlink" title="主成分分析（principal component analysis）"></a>主成分分析（principal component analysis）</h3><h4 id="主成分"><a href="#主成分" class="headerlink" title="主成分"></a>主成分</h4><ul><li>主成分分析用于找出最能区分数据点的变量，这种变量被称为主成分，数据点会沿着主成分的维度最大限度地分散开</li><li>主成分可以用已有的一个或多个变量表示</li><li>标准化（standardization）类似于使用百分位数表示每个变量，以此将所有变量统一到一个标准尺度上</li><li>采用主成分分析之后，可以不再通过试错法组合变量，而是通过精确计算各个变量的权重来获得最优变量组合</li></ul><h4 id="确定主成分数量"><a href="#确定主成分数量" class="headerlink" title="确定主成分数量"></a>确定主成分数量</h4><ul><li>由于主成分来源于原始变量，因此用来区分数据点的可用信息会受到原始变量个数的制约</li><li>为了让结果更简单、更通用，应该只选择前几个主成分进行可视化和后续分析<ul><li>将主成分按照其对数据点的区分效果进行排列</li><li>随着主成分个数增多，区分数据点的效果会变差</li><li>陡坡图曲线的拐弯处往往体现了最佳主成分数量</li></ul></li><li>对当前的数据样本进行解释时，使用的主成分越少，泛化能力就越强</li></ul><h4 id="局限性-1"><a href="#局限性-1" class="headerlink" title="局限性"></a>局限性</h4><ul><li>散度最大化：主成分分析有个重要假设，即数据点最分散的维度是最有用的</li><li>解释成分：主成分分析必须对其产生的成分进行解释，但有时可能很难解释变量按某种方式进行组合的原因</li><li>正交成分：主成分分析算法成分之间存在正交关系，然而真实信息维度之间可能不存在正交关系</li><li>弥补局限性的方法：独立成分分析（不需要假设正交关系，在确定成分时还无需考虑数据的散度）</li></ul><h4 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h4><ul><li>主成分分析是一种降维技巧，它使得我们可以使用较小的变量来描述数据，这些变量即为主成分</li><li>每个主成分都是原始变量的某种加权组合，最好的主成分可以用来改进数据分析和可视化</li><li>当信息最丰富的几个维度拥有最大的数据散度，并且彼此正交时，主成分分析能有最佳效果</li></ul><h3 id="关联规则（association-rule）"><a href="#关联规则（association-rule）" class="headerlink" title="关联规则（association rule）"></a>关联规则（association rule）</h3><h4 id="支持度、置信度和提升度"><a href="#支持度、置信度和提升度" class="headerlink" title="支持度、置信度和提升度"></a>支持度、置信度和提升度</h4><ul><li>识别关联规则的常用指标有3个：支持度、置信度和提升度</li><li>支持度：某个项集出现的频率，可以人为设定一个支持度阈值，当某个项集的支持度高于这个阈值时，就把它称为频繁项集</li><li>置信度：当 X 项出现时 Y 项同时出现的频率，记为 {X-&gt;Y} ，但它可能会错估某个关联规则的重要性</li><li>提升度：X 项和 Y 项一同出现的频率，同时考虑这两项各自出现的频率</li><li>{X-&gt;Y} 的提升度 = {X-&gt;Y} 的置信度 / {Y} 的支持度</li></ul><h4 id="先验原则（apriori-principal）"><a href="#先验原则（apriori-principal）" class="headerlink" title="先验原则（apriori principal）"></a>先验原则（apriori principal）</h4><ul><li>先验原则是指如果某个项集出现的不频繁那么包含它的任何更大的项集必定也出现的不频繁</li><li>寻找具有高支持度的项集<ol><li>列出只包含一个元素的项集</li><li>计算每个项集的支持度，保留那些满足最小支持度阈值条件的项集，淘汰不满足的项集</li><li>项候选项集中增加一个元素，并利用在步骤2中保留下来的项集产生所有可能的组合</li><li>重复步骤2和步骤3，为越来越大的项集确定支持度，直到没有待检查的新项集</li></ol></li><li>寻找具有高置信度或高提升度的关联规则<ul><li>因为置信度和提升度都是基于支持度计算出来的，因此一旦识别出具有高支持度的项集，寻找关联规则就不会那么费劲了</li></ul></li></ul><h4 id="局限性-2"><a href="#局限性-2" class="headerlink" title="局限性"></a>局限性</h4><ul><li>计算成本高：当库存量很大或者支持度阈值很低时，候选项集仍然会很多</li><li>假关联：当元素的数量很大时，偶尔会出现假关联，为了确保所发现的关联规则具有普遍性，应该对他们进行验证</li><li>弥补局限性的方法：使用高级数据结构对候选项集进行更高效的分类，从而减少比较的次数</li></ul><h4 id="小结-3"><a href="#小结-3" class="headerlink" title="小结"></a>小结</h4><ul><li>关联规则用于揭示某一元素出现的频率以及它与其他元素的关系</li><li>识别关联规则的常用指标有3个<ol><li>{X} 的支持度表示 X 项出现的频率</li><li>{X-&gt;Y} 的置信度表示当 X 项出现时，Y 项同时出现的频率</li><li>{X-&gt;Y} 的提升度表示 X 项和 Y 项一同出现的频率，并且考虑每项各自出现的频率</li><li>利用先验原则可以淘汰一大部分非频繁项集，从而大大地加快搜索频繁相机的速度</li></ol></li></ul><h3 id="社会网络分析"><a href="#社会网络分析" class="headerlink" title="社会网络分析"></a>社会网络分析</h3><h4 id="Louvain-方法（Louvain-method）"><a href="#Louvain-方法（Louvain-method）" class="headerlink" title="Louvain 方法（Louvain method）"></a>Louvain 方法（Louvain method）</h4><ul><li>通过对节点分组可以找出网络中存在的群组，研究这些群组有助于理解网络各部分的区别和联系</li><li>Louvain 方法用来在网络中找出群组，它会尝试使用不同的聚类配置来做如下两种事：<ol><li>同一群组中各个节点间的边数和强度最大化</li><li>把属于不同群组的节点间的边数和强度最小化</li></ol></li><li>模块度用于表示上述两件事的完成程度，模块度越高，群组越理想</li><li>为了获得理想的聚类配置，Louvain 方法会不断迭代<ol><li>把每个节点看作一个群组，即一开始群组数和节点数相同</li><li>把一个节点重新分配给对提高模块度有最大帮助的群组，如果无法进一步提高，模块度节点保持不动，针对每个节点重复这个过程直到不能再分配</li><li>把步骤2中发现的每个群组作为一个节点构建出一个粗粒度网络，并且把以前的群间边合并成连接新结点且带权重的边</li><li>重复步骤2和步骤3直到无法再重新分配和合并</li></ol></li><li>Louvain 方法先发现小群组，然后在适当的情况下合并它们，帮助我们找出更重要的群组，但它有一定的局限性<ul><li>重要但较小的群组可能会被合并：需要检查在中间迭代阶段被发现的群组，如果有必要就把它们保留下来</li><li>有多种可能的聚类配置：若网络中包含重叠或嵌套的群组，需要依据其他信息源对群组予以验证</li></ul></li></ul><h4 id="PageRank-算法（PageRank-algorithm）"><a href="#PageRank-算法（PageRank-algorithm）" class="headerlink" title="PageRank 算法（PageRank algorithm）"></a>PageRank 算法（PageRank algorithm）</h4><ul><li>虽然群组可以反映出相互作用高度集中的区域，但是这些相互作用可能受占主导地位的节点支配，群组则围绕着这些主导节点形成，为了找出占主导地位的节点，需要对节点进行排序</li><li>PageRank 算法是谷歌公司最初用来为网页排名的算法之一，以 Larry Page 的姓氏命名</li><li>在PageRank 算法中，决定一个网页排名的因素有如下3个：<ol><li>链接数量：被其他网页链接的次数越多，该网页的访问者可能就越多</li><li>链接强度：这些链接被访问的次数越多，该网页的流量就越大</li><li>链接来源：如果被其他有较高排名的网页链接，那么该网页的排名也会升高</li></ol></li><li>尽管 PageRank 算法易于使用，但它有偏向于旧节点的局限性：如果一个新网页包含非常棒的内容但一开始访问者人数很少，那么它的排名就比较低</li><li>可以定期更新 PageRank 值，让新网页随着自身知名度的提高获得提高排名的机会</li></ul><h4 id="小结-4"><a href="#小结-4" class="headerlink" title="小结"></a>小结</h4><ul><li>社会网络分析可用于绘制和分析多个实体之间的关系</li><li>Louvain 方法用于在一个网络中找出群组，具体做法是将群组内部的相互作用最大化，同时把群组之间的相互作用最小化，当群组大小相同且相互分离时，该方法的效果最佳</li><li>PageRank 算法根据链接的数量强度以及来源对网络中的节点进行排序，这个算法有助于找出网络中占主导地位的节点，但对链接数不太多的新节点并不友好</li></ul><h3 id="回归分析（regression-analysis）"><a href="#回归分析（regression-analysis）" class="headerlink" title="回归分析（regression analysis）"></a>回归分析（regression analysis）</h3><h4 id="趋势线"><a href="#趋势线" class="headerlink" title="趋势线"></a>趋势线</h4><ul><li>趋势线是做预测时常用的工具，他们很容易生成，也很容易理解</li><li>一般的趋势往往只涉及单个预测变量，这个变量用来产生预测结果，不过通过添加更多预测变量可以改善预测结果</li><li>回归分析不但可以通过考虑更多预测变量改善预测结果，还可以比较各个预测变量的强弱</li></ul><h4 id="梯度下降法（gradient-decent）"><a href="#梯度下降法（gradient-decent）" class="headerlink" title="梯度下降法（gradient decent）"></a>梯度下降法（gradient decent）</h4><ul><li>在回归分析中预测变量的权重是主要参数，通过解方程可以求得最优权重</li><li>梯度下降法先初步猜测合适的权重组合，再通过一个迭代过程，把这些权重应用于每个数据点做预测，然后调整权重以减少整体预测误差</li><li>这个过程类似于一步步走到山底下，每走一步梯度下降法都要判断从哪个方向下是最陡峭的，然后朝着那个方向重新校准权重，最终到达最低点，这个点的预测误差最小（经过优化的回归趋势线与梯度上的最低点相对应）</li><li>除了回归之外，梯度下降法也能用来优化其他模型中的参数，比如支持向量机和神经网络</li><li>梯度下降法的结果可能会受到初始参数值（下山起点）的影响，若起点下方恰好有一个小凹坑，那么梯度下降法可能会将其误认为是最优点</li><li>为了降低陷入这种凹坑的风险，可以使用随机梯度下降法，每次迭代并不是采用所有的数据点，而是只从其中选取一个来调整参数，引入多变性，有助于算法逃离凹坑</li></ul><h4 id="回归系数"><a href="#回归系数" class="headerlink" title="回归系数"></a>回归系数</h4><ul><li>在为回归预测变量求得最佳权重之后，需要对它们进行解释</li><li>回归系数：回归预测变量权重，它表示某个预测变量相比于其他预测变量的影响大小</li><li>预测变量的度量单位不同也会影响对回归系数的解释，因此应该在做回归分析之前先对预测变量的度量单位进行标准化，经过标准化之后预测变量的系数被称为标准化回归系数</li></ul><h4 id="相关系数（correlation-coefficient）"><a href="#相关系数（correlation-coefficient）" class="headerlink" title="相关系数（correlation coefficient）"></a>相关系数（correlation coefficient）</h4><ul><li>相关系数：当只存在一个预测变量时，该预测变量的标准化回归系数</li><li>关联方向：相关系数为正表示预测变量和结果变化的方向一致，为负则表示两者变化方向相反</li><li>关联强度：r 值越接近于 -1 或 1，预测变量的作用就越大，若值为 0 则表示预测变量和结果之间不存在关系</li><li>因为相关系数表示单个预测变量的绝对强度，所以相比于回归系数，相关系数在对预测变量进行排序时更可靠</li></ul><h4 id="局限性-3"><a href="#局限性-3" class="headerlink" title="局限性"></a>局限性</h4><ul><li>对异常值敏感：回归分析平等地对待所有的数据点，只要存在几个有异常值的数据点，就会给趋势线造成很大的影响，因此在做进一步分析之前，可以先使用散点图找出异常值</li><li>多重共线性问题（multicollinearity）：如果回归模型包含高度相关的预测变量，就会造成相关预测变量权重失真，因此可以使用更高级的技术，如套索回归或岭回归</li><li>弯曲的趋势：需要对预测变量的值进行转换，或使用支持向量机等其他算法</li><li>并不说明存在因果关系</li></ul><h4 id="小结-5"><a href="#小结-5" class="headerlink" title="小结"></a>小结</h4><ul><li>回归分析用于寻找最佳拟合线（best-fit line），使得尽可能多的数据点位于这条线上或附近</li><li>趋势线由带权重的组合预测变量得到，这些权重被称为回归系数，表示某个预测变量相对于其他预测变量的影响强度</li><li>以下情况下，回归分析的效果最好：<ol><li>预测变量之间的关系不强</li><li>无异常值</li><li>趋势可以用直线表示</li></ol></li></ul><h3 id="k-最近邻算法（k-Nearest-Neighbors）和异常检测"><a href="#k-最近邻算法（k-Nearest-Neighbors）和异常检测" class="headerlink" title="k 最近邻算法（k-Nearest Neighbors）和异常检测"></a>k 最近邻算法（k-Nearest Neighbors）和异常检测</h3><h4 id="k-最近邻算法"><a href="#k-最近邻算法" class="headerlink" title="k 最近邻算法"></a>k 最近邻算法</h4><ul><li>k 最近邻算法根据周围数据点的类型对某个数据点进行分类（物以类聚，人以群分）</li><li>在 k 最近邻算法中，参数 k 表示周围数据点的个数，选择 k 值的过程叫做参数调优，它对预测的准确度起着至关重要的作用</li><li>使用不同的 k 值进行拟合：<ul><li>如果 k 值太小，数据点只与最近的邻居匹配，并且随机造成所产生的误差也会被放大</li><li>如果 k 值太大，数据点会尝试与更远的邻居匹配，其中隐含的模式会被忽略</li><li>只有当 k 值恰到好处时，数据点才会参考合适数量的邻居，使得误差相互抵消，有利于揭示数据中隐藏的趋势</li></ul></li><li>为实现理想拟合并把误差降到最低，可以使用交叉验证法对参数 k 进行调优</li><li>对于二分类问题，可以把 k 设置成一个奇数，以避免出现平局的情况</li><li>除了用来为数据点分类，k 最近邻算法还可以通过合计周围数据点的值来预测连续值</li><li>通过使用加权平均值，能够进一步改善预测结果，离数据点越近的邻居，其值越能反映该数据点的真实值，因此赋给它的权重应该更大</li></ul><h4 id="异常检测"><a href="#异常检测" class="headerlink" title="异常检测"></a>异常检测</h4><ul><li>k 最近邻算法不仅可以用来预测数据点的类别和取值，还可以用来识别异常，比如检测欺诈行为</li><li>在异常检测的过程中还可能会有新发现，比如发现之前被忽略的预测变量</li><li>事实上任何能够产生预测模型的算法都可以用来检测异常，比如在回归分析中，如果某个数据点明显偏离最佳拟合线，那么就会被识别为异常点</li><li>异常数据点既可能因缺失预测变量所致，也可能因预测模型缺少足够的训练数据所致</li><li>一旦找到异常数据点，就要将它们从数据集中移除，然后再训练预测模型，减少数据中包含的噪声，进而提高模型的准确度</li></ul><h4 id="局限性-4"><a href="#局限性-4" class="headerlink" title="局限性"></a>局限性</h4><ul><li>类别不平衡：可以使用加权投票法来取代少数服从多数原则，确保较近数据点类别的权重比较远的更大</li><li>预测变量过多：在多个维度上识别和处理近邻会导致你计算量大增，需要降维（dimension reduction）</li></ul><h4 id="小结-6"><a href="#小结-6" class="headerlink" title="小结"></a>小结</h4><ul><li>k 最近邻算法根据周围数据点的类型对某个数据点进行分类</li><li>k 表示用作参考的数据点的个数，可以使用交叉验证法来确定</li><li>当预测变量数目不多，并且类别大小差别不大时，k 最近邻算法才能产生非常好的效果</li><li>不准确的分类可能会被标记为潜在异常</li></ul><h3 id="支持向量机（support-vector-machine）"><a href="#支持向量机（support-vector-machine）" class="headerlink" title="支持向量机（support vector machine）"></a>支持向量机（support vector machine）</h3><h4 id="勾画最佳分界线"><a href="#勾画最佳分界线" class="headerlink" title="勾画最佳分界线"></a>勾画最佳分界线</h4><ul><li>支持向量机的主要目标是得到一条能用于分组的最佳分界线，需要注意的是，能用于分组的分界线可能有很多条</li><li>为了找出最佳分界线，首先需要从一组中找出距离另一组最近的外围数据点，然后在两组的外围数据点之间画出最佳分界线，由于这些外围数据点在寻找最佳分界线的过程中起了支持作用，因此叫做支持向量</li><li>支持向量机的一个优点是计算速度很快，仅依靠外围数据点就能找到决策边界</li><li>这种对数据点子集的依赖也有缺点，这是因为决策边界对支持向量的位置比较敏感，选取不同的数据点作为训练数据，相应支持向量的位置也不同</li><li>支持向量机算法有一个关键特征——缓冲带<ul><li>缓冲带允许一定数量的训练数据点位于错误的一边，由此得到一条更软的分界线</li><li>缓冲带对异常值有更强的耐扰性，因此对新数据有更强的泛化能力</li><li>缓冲带通过调整惩罚参数得到，这个参数决定了对分类误差的宽容度，惩罚参数越大，宽容度就越大，缓冲带也就越宽</li><li>为了让模型对当前数据和新数据有较高的预测准确度，可以使用交叉验证法求得最佳惩罚参数</li></ul></li><li>支持向量机的另一个强项是找到决策边界的凸弧，它在发现错综复杂的凸弧时有着更出众的计算效率<ul><li>支持向量机的秘诀是核技巧（kernel trick）</li><li>支持向量机不会直接在在数据平面上绘制有凸弧的分界线，而是会首先把数据映射到高维空间，然后在高维空间中将数据点用直线分开，这些直线容易计算，并且当映射回低维空间时，也很容易转化成曲线</li></ul></li><li>支持向量机具备在高维空间操纵数据的能力，使得它在分析有多个变量的数据集时大受欢迎</li><li>支持向量机的常见应用场景包括遗传信息破译以及文本情感分析</li></ul><h4 id="局限性-5"><a href="#局限性-5" class="headerlink" title="局限性"></a>局限性</h4><ul><li>小数据集：由于支持向量机依靠支持向量确定决策边界，因此样本量少，用来对分界线进行准确定位的数据也少</li><li>多组数据：支持向量机每次只能对两组进行分类，如果存在2个以上的组，则需要对每一组都应用支持向量机（多类支持向量机）</li><li>两组之间存在大量重叠：靠近边界的数据点可能更容易发生分类错误，而且支持向量机没有给出每个数据点遭遇错误分类的概率，但可以通过数据点到决策边界的距离来估计其被正确分类的可能性</li></ul><h4 id="小结-7"><a href="#小结-7" class="headerlink" title="小结"></a>小结</h4><ul><li>支持向量机用来把数据点分为两组，其方法是在两组的外围数据点（支持向量）的中间画一条分界线</li><li>支持向量机对异常值有较好的容忍度，它通过一个缓冲带允许少量数据点位于错误的一边，此外他还通过核技巧高效地求得带凸弧的决策边界</li><li>当需要把大样本中的数据点分为两组时，支持向量机能够发挥最佳作用</li></ul><h3 id="决策树（decision-tree）"><a href="#决策树（decision-tree）" class="headerlink" title="决策树（decision tree）"></a>决策树（decision tree）</h3><h4 id="生成决策树"><a href="#生成决策树" class="headerlink" title="生成决策树"></a>生成决策树</h4><ul><li>递归拆分（recursive partitioning）<ol><li>确定一个二元选择题，它能够把数据点拆分成两组，并最大限度地提高每组数据点的同质性</li><li>针对每个叶结点重复步骤1，直到满足终止条件</li></ol></li><li>终止条件可能有多个，可以使用交叉验证法进行选取<ul><li>每个叶节点的数据全属于同一类或有相同的值</li><li>叶节点包含的数据点少于5个</li><li>进一步分支会超出阈值并且不能提高同质性</li></ul></li><li>由于递归拆分只用最佳二元选择题来生成决策树，因此不显著的变量并不会影响结果</li><li>而且二元选择题往往围绕着最重要的值划分数据点，所以决策树对异常值有较强的耐扰性</li><li>决策树易于可视化，使我们更容易评估预测变量及其相互作用</li></ul><h4 id="局限性-6"><a href="#局限性-6" class="headerlink" title="局限性"></a>局限性</h4><ul><li>不稳定：决策树是通过把数据点分组生成的，数据中的细微变化可能影响拆分结果，并导致生成的决策树截然不同</li><li>容易产生过拟合：决策树每次拆分数据点时都力求找到最佳拆分方式</li><li>不准确：一开始就是用最佳二元选择题拆分数据点并不能保证结果最准确</li><li>弥补局限性的方法：每次拆分时可以不采用最佳拆分方式，而是尽量让决策树多样化，然后综合不同的决策树产生的预测结果，让最终预测结果具有更好的稳定性和准确性</li></ul><h4 id="决策树的多样化方法"><a href="#决策树的多样化方法" class="headerlink" title="决策树的多样化方法"></a>决策树的多样化方法</h4><ul><li>随机森林：随机选择不同的二元选择题，生成多棵决策树，然后综合这些决策树的预测结果</li><li>梯度提升（gradient boosting）：有策略地选择二元选择题，以逐步提高决策树的预测准确度，然后将所有的预测结果的加权平均数作为最终结果</li></ul><p>虽然随机森林的和梯度提升能够产生更准确的预测结果，但是它们往往比较复杂并且很难进行可视化（黑盒）</p><h4 id="小结-8"><a href="#小结-8" class="headerlink" title="小结"></a>小结</h4><ul><li>决策树通过询问一系列二元选择题来做预测</li><li>若想生成决策树，就要不断拆分数据样本以获得同质组，直到满足终止条件，这个过程被称为递归拆分</li><li>虽然决策树易于使用和理解，但是容易造成过拟合问题，导致出现不一致的结果，为了尽量避免出现这种情况，可以采用随机森林等替代方法</li></ul><h3 id="随机森林"><a href="#随机森林" class="headerlink" title="随机森林"></a>随机森林</h3><h4 id="集成模型"><a href="#集成模型" class="headerlink" title="集成模型"></a>集成模型</h4><ul><li>集成方法（ensembling）：通过组合有不同优缺点的模型来提高预测准确度的方法</li><li>集成模型：通过组合许多模型的预测结果得到的预测模型，在组合模型时，既可以遵循少数服从多数的原则，也可以取平均值</li><li>随机森林是决策树的集成模型</li><li>相比于子模型，集成模型的预测准确度更高，这是因为准确的预测模型会彼此强化，错误的则会彼此抵消<ul><li>为了达到这种效果，集成模型的子模型一定不能犯同类错误，换言之，子模型必须是不相关的</li></ul></li><li>自助聚集法：用来生成不相关的决策树的系统化方法</li></ul><h4 id="自助聚集法（bootstrap-aggregating）"><a href="#自助聚集法（bootstrap-aggregating）" class="headerlink" title="自助聚集法（bootstrap aggregating）"></a>自助聚集法（bootstrap aggregating）</h4><ul><li>自助聚集法用来生成数千棵决策树，这些树彼此有明显的不同</li><li>为使决策树之间的关联度最小化，每棵树都由训练数据集的一个随机子集产生，并且使用的是预测变量的一个随机子集，这让生成的决策树各不相同，但仍然保留了一定的预测能力</li><li>通过限制每次拆分时所用的预测变量，能够生成各不相同的决策树，从而避免发生过拟合问题</li><li>为进一步降低发生过拟合问题的可能性，可以增加随机森林中决策树的数量，使模型更通用、更准确</li></ul><h4 id="局限性-7"><a href="#局限性-7" class="headerlink" title="局限性"></a>局限性</h4><ul><li>随机森林由随机生成的决策树组成，并不存在明确的预测规则，这种不可解释性可能会带来一些伦理问题</li><li>因此随机森林适用于那些预测准确度比可解释性更重要的场合</li></ul><h4 id="小结-9"><a href="#小结-9" class="headerlink" title="小结"></a>小结</h4><ul><li>随机森林的预测结果往往比单棵决策树更准确，这是因为它充分利用了两种技术：自助聚集法和集成方法</li><li>自助聚集法通过随机限制数据拆分过程所用的变量来生成一系列不相关的决策树</li><li>集成方法则把决策树的预测结果组合在一起</li><li>虽然随机森林的预测结果不具有可解释性，但仍然可以根据对预测结果的贡献度大小对各个预测变量进行排序</li></ul><h3 id="神经网络（neural-network）"><a href="#神经网络（neural-network）" class="headerlink" title="神经网络（neural network）"></a>神经网络（neural network）</h3><h4 id="神经网络的诞生"><a href="#神经网络的诞生" class="headerlink" title="神经网络的诞生"></a>神经网络的诞生</h4><ul><li>数据存储和共享技术取得进步：为训练神经网络提供了海量数据，有助于改善神经网络的性能</li><li>计算能力越来越强大：GPU的运行速度最快能达到CPU的150倍，能为在大数据集上训练神经网络提供强大的支持</li><li>算法获得改进</li></ul><h4 id="神经网络的构成"><a href="#神经网络的构成" class="headerlink" title="神经网络的构成"></a>神经网络的构成</h4><ul><li>输入层：该层处理输入图像的每个像素<ul><li>为提高预测准确度，可以使用卷积层</li><li>卷积层并不处理单个像素，而是识别像素组合的特征，这种分析只关注特征是否出现而不关注出现的位置</li><li>所以即使某些关键特征偏离了中心，神经网络仍然能够正确识别，这种特性叫做平移不变性（translational invariance）</li></ul></li><li>隐藏层：在像素进入神经网络之后，通过层层转换不断提高和那些标签已知的图像的相似度<ul><li>标签已知是指神经网络以前见过这些图像</li><li>虽然转换得越多，预测准确度就会越高，但是处理时间就会明显增加，一般来说几个隐藏层就足够了</li><li>每层的神经元数量要和图像的像素数成比例</li></ul></li><li>输出层：该层产生最终预测结果，在这一层中神经元可以只有一个，也可以和结果一样多</li><li>损失层：该层通常位于最后，并提供有关输入是否识别正确的反馈，如果不正确则给出误差量<ul><li>在训练神经网络的过程中，损失层至关重要，若预测准确，来自于损失层的反馈会强化产生该预测结果的激活路径</li><li>若预测错误，则错误会沿着路径逆向返回，这条路径上的神经元的激活条件就会被重新调整，以减少错误，这个过程称为反向传播（back propagation）</li></ul></li><li>通过不断重复这个训练过程，神经网络会学习输入信号和正确输出标签之间的联系，并且把这些联系作为激活规则（activation rule）编入每个神经元，因此为了提高神经网络的预测准确度，需要调整管理激活规则的部件</li></ul><h4 id="激活规则"><a href="#激活规则" class="headerlink" title="激活规则"></a>激活规则</h4><ul><li>为了产生预测结果，需要沿着一条路径依次激活神经元，每个神经元的激活过程都由其激活规则所控制，激活规则指定了输入信号的来源和强度，在神经网络的训练过程中激活规则会不断调整</li><li>良好的激活规则有助于产生准确的预测结果，其关键在于确定合适的权重和阈值</li><li>另外神经网络的其他参数也需要调整，比如隐藏层的数量、每层的神经元数量等。可以使用梯度下降法优化这些参数</li></ul><h4 id="局限性-8"><a href="#局限性-8" class="headerlink" title="局限性"></a>局限性</h4><ul><li>需要大样本：神经网络的复杂性使之能够识别带有复杂特征的输入，但前提是我们能为他提供大量训练数据，如果训练集太小就会出现过拟合问题</li><li>降低过拟合风险：<ul><li>二次取样（subsampling）：为了降低神经元对噪声的敏感度，需要对神经网络的输入进行平滑化处理，即针对信号样本取平均值</li><li>畸变：当缺少训练数据时，可以通过向每幅图像引入畸变，来产生更多数据，每幅畸变图像都可以作为新的输入，以此扩大训练数据的规模，畸变应该能够反映原数据集的特征（弹性变形）</li><li>丢弃（dropout）：为解决小的神经元集群之间彼此产生过度依赖，可以在训练期间随机丢弃一半的神经元，这些遭丢弃的神经元将处于未激活的状态，剩下的神经元则正常工作，下一次训练丢弃一组不同的神经元，迫使不同的神经元协同工作，从而揭示训练样本所包含的更多特征</li></ul></li><li>计算成本高：训练一个由几千个神经元组成的神经网络可能需要很长时间，一个简单的解决方法是升级硬件</li><li>另一个解决方法是调整算法，用稍低一些的预测准确度换取更快的处理速度<ul><li>随机梯度下降法：为了更新某一个参数，经典的梯度下降法在一次迭代中使用所有的训练样本，当数据集很大时这样做会耗时，随机梯度下降法是在每次迭代中只用一个训练样本来更新参数，虽然使用这个方法得到的最终参数可能不是最优的，但是准确度不会太低</li><li>小批次梯度下降法：虽然使用随机梯度下降法能够提升速度，但最终参数可能不准确，算法也可能无法收敛，导致某个参数上下波动，小批次梯度下降法是每次迭代使用训练样本的一个子集</li><li>全连接层：随着加入的神经元越来越多，路径的数量呈指数增长，为避免查看所有可能的组合，可以使初始层（处理更小、更低级的特征）的神经元部分连接，只有最后几层（处理更大、更高级的特征）才对相邻层的神经元进行全连接</li></ul></li><li>不可解释：神经网络由多层组成，每层都有几百个神经元，这些神经元有不同的激活规则控制，这使得我们很难准确地找到产生正确预测结果的输入信号组合<ul><li>但和回归分析不同，回归分析能明确地识别重要的预测变量，并比较它们的强度，神经网络的特性使之难以证明其使用得当，在涉及伦理问题时尤其如此</li></ul></li><li>尽管存在上述局限性，但是神经网络本身拥有的强大能力，使之得以应用于虚拟助手、自动驾驶等前沿领域，随着算法不断改进以及计算能力不断提升，神经网络将在物联网时代发挥关键作用</li></ul><h4 id="小结-10"><a href="#小结-10" class="headerlink" title="小结"></a>小结</h4><ul><li>神经网络由多个神经元组成，训练期间，第1层的神经元首先被输入数据激活，然后将激活状态传播到后续各层的神经元，最终在输出层产生预测结果</li><li>一个神经元是否被激活取决于输入信号的来源和强度，这由其激活规则指定，激活规则会根据预测结果的反馈不断调整，这个过程被称为反向传播</li><li>在大数据集和先进的计算硬件可用的情况下，神经网络的表现最好，然而预测结果在大部分的时候都是无法解释的</li></ul><h3 id="A-B-测试（A-B-testing）和多臂老虎机（multi-arm-bandit-problem）"><a href="#A-B-测试（A-B-testing）和多臂老虎机（multi-arm-bandit-problem）" class="headerlink" title="A/B 测试（A/B testing）和多臂老虎机（multi-arm bandit problem）"></a>A/B 测试（A/B testing）和多臂老虎机（multi-arm bandit problem）</h3><h4 id="A-B-测试的局限性"><a href="#A-B-测试的局限性" class="headerlink" title="A/B 测试的局限性"></a>A/B 测试的局限性</h4><ul><li>测试结果具有偶然性：为提高测试结果的可信度可以增加受测人数，但是会导致另一个问题</li><li>潜在的收入损失：如果把受测顾客增加一倍，那么看到糟糕广告的人数也会增加一倍，这有流失的顾客的风险</li><li>这两个问题体现了 A/B 测试中的两个权衡因素：探索和利用</li></ul><h4 id="epsilon-递减策略（epsilon-decreasing-strategy）"><a href="#epsilon-递减策略（epsilon-decreasing-strategy）" class="headerlink" title="epsilon 递减策略（epsilon-decreasing strategy）"></a>epsilon 递减策略（epsilon-decreasing strategy）</h4><ul><li>epsilon 指的是探索时间与总时间的比例，随着对效果较好的广告越来越有信心，我们使 epsilon 值递减，这个方法属于强化学习的范畴</li><li>A/B 测试由探索和利用前后两个阶段组成，而在 epsilon 递减策略中，探索阶段和利用阶段是分散的，并且一开始时探索得多一些，越接近尾声，探索得越少</li></ul><h4 id="多臂老虎机"><a href="#多臂老虎机" class="headerlink" title="多臂老虎机"></a>多臂老虎机</h4><ul><li>假设有两台老虎机 A 和 B 可供选择，玩2000个回合，每个回合要么赢1美元，要么没有收益，老虎机 A 的返还率为50%，老虎机 B 的则为40%，但我们事先并不知道这些信息，问要怎么玩才能多赢钱？<ul><li>全探索：如果随机选择老虎机，平均会赢900美元</li><li>A/B 测试：用前200个回合探索哪台老虎机的返还率更高，然后在剩下的1800个回合中选择这台老虎机，平均会赢976美元，但由于两台老虎机的返还率接近，由此存在误判的可能性（误判概率8%）</li><li>为降低误判的风险，可以把A/B 测试的探索范围扩大到500个回合，这样做可以把误判概率降到1%，但是平均中奖金额也会减少到963美元</li><li>epsilon 递减策略：如果采用 epsilon 递减策略边探索边利用，平均会赢984美元，并且误判概率为4%，通过增加探索比例（增加 epsilon 值）能够降低误判概率，但仍会减少平均中奖金额</li><li>全利用：如果一开始就掌握内部消息并选择返还率最高的老虎机 A，平均会赢1000美元，但这个假设不现实</li></ul></li><li>由此看到，在不掌握内部消息的情况下，采用 epsilon 递减策略的收益最高，而且由于存在收敛性这一数学特征，由此 epsilon 递减策略能确保在回合数足够多的情况下找出返还率最高的老虎机</li><li>胜者为先：范加尔在曼联采用了一个非常规策略来决定罚点球的球员，第一个被指定罚点球的球员会负责到底，除非他没有打进球，接下来新换的球员继续负责罚点球，如果没有罚进就再换一名球员，依此类推<ul><li>频繁地换老虎机，会导致探索过多而利用过少，只比随机选择老虎机稍好一些，而且胜者为先策略只根据上一次的结果来评估老虎机，这忽略了老虎机之前的表现</li></ul></li></ul><h4 id="epsilon-递减策略的局限性"><a href="#epsilon-递减策略的局限性" class="headerlink" title="epsilon 递减策略的局限性"></a>epsilon 递减策略的局限性</h4><ul><li>采用 epsilon 递减策略的关键在于控制好 epsilon 值，如果 epsilon 值递减的过慢，就会失去利用老虎机的机会，而如果递减得过快，就可能会选错老虎机</li><li>epsilon 值的最佳递减速度主要取决于两台老虎机返还率的相似程度，采用汤普森取样方法，可以计算 epsilon 值</li><li>epsilon 递减策略还依赖于如下假设：<ul><li>返还率恒定不变</li><li>返还率与上一次游戏无关</li><li>玩游戏和观察返还率之间的延迟极小</li></ul></li></ul><h4 id="小结-11"><a href="#小结-11" class="headerlink" title="小结"></a>小结</h4><ul><li>多臂老虎机问题的实质是如何以最佳方式分配资源</li><li>一种策略是先探索可用选项，然后把所有剩余资源分配给表现最佳的选项，这个策略叫做 A/B 测试</li><li>另一个策略是给表现最佳的选项，逐渐分配更多的资源，这个策略叫做 epsilon 递减策略</li><li>虽然 epsilon 递减策略在大多数情况下能够提供比 A/B 测试更高的回报，但是确定资源分配的最佳更新速度并非易事</li></ul><h3 id="更多评价指标"><a href="#更多评价指标" class="headerlink" title="更多评价指标"></a>更多评价指标</h3><h4 id="分类指标"><a href="#分类指标" class="headerlink" title="分类指标"></a>分类指标</h4><ul><li>接受者操作特征曲线下面积（曲线下面积）：这个指标允许我们在最大化正例率和最小化假正例率之间做权衡<ul><li>正例率：被模型正确预测为正类别的样本所占的比例</li><li>正例率 = 正例数 / ( 正例数 + 假负例数 )</li><li>假正例率：被模型错误预测为正类别的样本所占的比例</li><li>假正例率 = 假正例数 / ( 假正例数 + 负例数 )</li><li>在极端情况下，可以把所有样本全部预测为正类别，以此实现正例率最大化（正例率为1），虽然这样做可以避免出现假负例但会明显增加假正例</li><li>接受者操作特征曲线（ROC 曲线）体现了最大化正例率和最小化假正例率之间的权衡</li><li>模型性能通过 ROC 曲线下方的面积来衡量，所以该指标被称为曲线下面积，模型的准确度越高，曲线越靠近左上角</li><li>完美的预测模型会产生一条曲线下面积为1的曲线（曲线下面积等于整个图形的面积）</li></ul></li><li>对数损失指标利用置信度来校正其对预测误差的惩罚，具体来说，模型对错误预测的置信度越高，惩罚就越重<ul><li>由于对数损失指标根据对预测结果的置信度来调整惩罚程度，因此它通常用于错误预测极其有害的情况</li></ul></li></ul><h4 id="回归指标"><a href="#回归指标" class="headerlink" title="回归指标"></a>回归指标</h4><ul><li>平均绝对误差：平等的惩罚所有预测误差，具体做法是对所有数据点的预测值和实际值之差取平均值</li><li>除了考虑误差大小之外，还可以通过均方根对数误差把误差方向纳入考虑范围</li></ul>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;机器学习算法是数据科学的力量之源，它和数据一起产生极其宝贵的知识并且帮助我们以新的方式利用已有信息。&lt;a href=&quot;https://book.douban.com/subject/30442187/&quot;&gt;白话机器学习算法&lt;/a&gt;一书用通俗易懂的语言以及大量有趣的示例和插图讲解10多种前沿的机器学习算法。内容涵盖k均值聚类、主成分分析、关联规则、社会网络分析等无监督学习算法，以及回归分析、k最近邻、支持向量机、决策树、随机森林、神经网络等监督学习算法，并概述强化学习算法的思想。以下为阅读过程中所作的读书笔记，可供参考。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="读书笔记" scheme="http://blog.zhuangzhihao.top/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Machine Learning" scheme="http://blog.zhuangzhihao.top/tags/Machine-Learning/"/>
    
  </entry>
  
  <entry>
    <title>计算机组成原理（下）</title>
    <link href="http://blog.zhuangzhihao.top/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E4%B8%8B/"/>
    <id>http://blog.zhuangzhihao.top/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E4%B8%8B/</id>
    <published>2021-10-11T16:00:00.000Z</published>
    <updated>2021-11-26T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>计算机组成原理是计算机专业本科教学中的重要课程，它可以帮助我们系统地理解计算机硬件系统的组织结构和工作原理、掌握计算机硬件系统的基本分析与设计方法以及建立计算机系统的整体概念，为进一步学习计算机设计实践课程、培养系统开发、调试以及设计创新能力奠定良好的基础。计组是考研的最重最难点，在408计算机学科专业基础综合考试中占有45分。我选择的课程是哈工大的<a href="https://www.icourse163.org/course/hit-309001">国家精品课</a>，配合天勤高分笔记，以下为所记课堂笔记下半部分，包含CPU、总线和I/O系统的知识点，可供参考。上半部分笔记请访问<a href="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E4%B8%8A">计算机组成原理（上）</a></p></blockquote><a id="more"></a><h3 id="计算机系统概论"><a href="#计算机系统概论" class="headerlink" title="计算机系统概论"></a>计算机系统概论</h3><h4 id="计算机的发展历程"><a href="#计算机的发展历程" class="headerlink" title="计算机的发展历程"></a>计算机的发展历程</h4><ul><li>电子管时代 -&gt; 晶体管时代 -&gt; 中小规模集成电路时代 -&gt; 超大规模集成电路时代 -&gt; 智能计算机 -&gt; 生物计算机/量子计算机</li><li>冯·诺依曼计算机（SISD）<ol><li>由运算器、存储器、控制器、输入设备和输出设备组成</li><li>指令和数据用二进制表示，以同等地位存于存储器，可按地址寻访</li><li>指令由操作码和地址码组成</li><li>存储程序，且以运算器为中心</li></ol></li></ul><h4 id="计算机的基本组成"><a href="#计算机的基本组成" class="headerlink" title="计算机的基本组成"></a>计算机的基本组成</h4><ul><li>计算机系统由硬件和软件组成，软件分为系统软件和应用软件</li><li>软硬件在逻辑上是等效的</li><li>计算机硬件主要由存储器、运算器、控制器、输入设备和输出设备组成<ul><li>运算器 ALU + 控制器 CU = CPU</li><li>主存 + 辅存 = 存储器</li><li>CPU + 主存储器 = 主机</li><li>现代计算机为以存储器为中心，指令和数据都是保存在存储器中的</li></ul></li><li>存储器的基本组成：存储体 -&gt; 存储单元 -&gt; 存储元<ul><li>存储单元：存放一串二进制代码，每个存储单元赋予一个地址号</li><li>存储字：存储单元中二进制代码的组合</li><li>存储字长：存储字的位数</li><li>地址寄存器 MAR：存放访存地址，N 位长的 MAR 可映射到 $2^N$ 个地址</li><li>数据寄存器 MDR：暂存从主存中读写的信息，MDR 长度等于存储字长</li><li>按字节寻址和数据线无关，只和地址线有关</li><li>按字寻址，数据线个数等于存储字长位数</li><li>字地址是连续存储单元地址中的最小值</li></ul></li><li>运算器的核心是算术逻辑单元 ALU<table><thead><tr><th></th><th>ACC 累加器</th><th>MQ 乘商寄存器</th><th>X 操作数寄存器</th></tr></thead><tbody><tr><td>加法</td><td>被加数、和</td><td></td><td>加数</td></tr><tr><td>减法</td><td>被减数、差</td><td></td><td>减数</td></tr><tr><td>乘法</td><td>乘积高位</td><td>乘数、乘积地位</td><td>被乘数</td></tr><tr><td>除法</td><td>被除数、余数</td><td>商</td><td>除数</td></tr></tbody></table></li><li>控制器的功能：解释指令、保证指令的按序执行<ul><li>取指令 -&gt; 分析指令 -&gt; 执行指令</li><li>程序计数器 PC：存放当前欲执行指令的地址，具有计数功能（PC）+1 -&gt; PC</li><li>指令寄存器 IR：存放当前欲执行的指令，IR 的内容来自主存的 MDR</li><li>控制单元 CU</li></ul></li><li>主机完成一条指令的过程：<ul><li>输入程序 -&gt; 程序首地址 -&gt; PC -&gt; 启动程序运行</li><li>取指令：PC -&gt; MAR -&gt; M -&gt; MDR -&gt;IR</li><li>分析指令：OP（IR）-&gt; CU</li><li>执行指令：Ad（IR）-&gt; MAR -&gt; M -&gt; MDR -&gt; ACC</li></ul></li><li>计算机系统的层次结构：高级语言 -&gt; 汇编语言 -&gt; 操作系统 -&gt; 机器语言 -&gt; 微指令系统</li></ul><h4 id="计算机硬件的主要技术指标"><a href="#计算机硬件的主要技术指标" class="headerlink" title="计算机硬件的主要技术指标"></a>计算机硬件的主要技术指标</h4><ul><li>机器字长：CPU一次能处理数据的位数，与CPU中的寄存器位数有关</li><li>运算速度：主频、核数及每个核支持的线程数<ul><li>吉普森法：$T_{M}=\sum ^{n}<em>{i=1}f</em>{i}t_{i}$</li><li>CPI：执行一条指令所需时钟周期数</li><li>MIPS：每秒执行百万条指令</li><li>FLOPS：每秒浮点运算次数</li><li>在指令数和时钟周期一定的前提下，CPI越大，执行时间越长</li></ul></li><li>存储容量：存放二进制信息的总位数<ul><li>主存容量：存储单元个数 × 存储字长，字节数</li><li>辅存容量：字节数</li></ul></li></ul><h3 id="数据的表示和运算"><a href="#数据的表示和运算" class="headerlink" title="数据的表示和运算"></a>数据的表示和运算</h3><h4 id="数制与编码"><a href="#数制与编码" class="headerlink" title="数制与编码"></a>数制与编码</h4><ul><li>十进制换二进制：整数除二取余，由下而上；小数乘二取整，由上而下 </li><li>二进制基本符号少，易于用稳态电路实现，编码、计数、逻辑运算规则简单</li><li>八进制 Q，十六进制 H</li><li>真值换机器数：0正1负</li><li>有权BCD码（8421）：逢1001进位，4位一数，C正D负放队尾，偶数位数高位补零</li><li>余3码：8421码的基础上加十进制3（0011）</li><li>ASCII：”0”：48；”A”：65；”a”：97</li><li>国标码 = (区位码)H + 2020H</li><li>汉字内码 = (国标码)H + 8080H</li><li>奇偶校验码：添加一位校验码后使整个码字里1的个数为奇数/偶数</li><li>循环冗余校验码 CRC：检错编码</li><li>海明码：纠错编码</li></ul><h4 id="定点数"><a href="#定点数" class="headerlink" title="定点数"></a>定点数</h4><p>- </p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;计算机组成原理是计算机专业本科教学中的重要课程，它可以帮助我们系统地理解计算机硬件系统的组织结构和工作原理、掌握计算机硬件系统的基本分析与设计方法以及建立计算机系统的整体概念，为进一步学习计算机设计实践课程、培养系统开发、调试以及设计创新能力奠定良好的基础。计组是考研的最重最难点，在408计算机学科专业基础综合考试中占有45分。我选择的课程是哈工大的&lt;a href=&quot;https://www.icourse163.org/course/hit-309001&quot;&gt;国家精品课&lt;/a&gt;，配合天勤高分笔记，以下为所记课堂笔记下半部分，包含CPU、总线和I/O系统的知识点，可供参考。上半部分笔记请访问&lt;a href=&quot;/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E4%B8%8A&quot;&gt;计算机组成原理（上）&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="计算机专业" scheme="http://blog.zhuangzhihao.top/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%93%E4%B8%9A/"/>
    
    
    <category term="Computer Organization" scheme="http://blog.zhuangzhihao.top/tags/Computer-Organization/"/>
    
  </entry>
  
  <entry>
    <title>开发团队调度软件实战</title>
    <link href="http://blog.zhuangzhihao.top/%E5%BC%80%E5%8F%91%E5%9B%A2%E9%98%9F%E8%B0%83%E5%BA%A6%E8%BD%AF%E4%BB%B6/"/>
    <id>http://blog.zhuangzhihao.top/%E5%BC%80%E5%8F%91%E5%9B%A2%E9%98%9F%E8%B0%83%E5%BA%A6%E8%BD%AF%E4%BB%B6/</id>
    <published>2021-10-08T16:00:00.000Z</published>
    <updated>2021-11-10T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>在学习完 <a href="/Java%E5%9F%BA%E7%A1%80">Java 基础编程</a>的全部知识点后，为了更加熟悉 Java 面向对象的高级特性，进一步掌握编程技巧和调试技巧，实现模拟一个基于文本界面的开发团队调度软件，并以文档的形式记录软件设计结构、实现方法和一些疑难之处，主要涉及类的继承性和多态性、对象的值传递和接口、static 和 final 修饰符、特殊类的使用（包装类、抽象类、内部类）、异常处理等知识点。</p></blockquote><a id="more"></a><h3 id="软件需求"><a href="#软件需求" class="headerlink" title="软件需求"></a>软件需求</h3><ul><li>软件启动时，根据给定的数据创建公司部分成员列表（数组）</li><li>根据菜单提示，基于现有的公司成员，组建一个开发团队以开发一个新的项目</li><li>组建过程包括将成员插入到团队中，或从团队中删除某成员，还可以列出团队中现有成员的列表</li><li>开发团队成员包括架构师、设计师和程序员</li></ul><h4 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h4><ul><li>软件采用单级菜单方式工作，当软件运行时，主界面显示公司成员的列表</li><li>当选择“添加团队成员”菜单时，将执行从列表中添加指定（通过 ID）成员到开发团队的功能</li><li>如果添加操作因某种原因失败，将显示失败信息（失败原因视具体原因而不同）</li><li>当选择“删除团队成员”菜单时，将执行从开发团队中删除指定（通过 TeamID）成员的功能</li><li>当选择“团队列表”菜单时，将列出开发团队中的现有成员</li></ul><h3 id="软件设计结构"><a href="#软件设计结构" class="headerlink" title="软件设计结构"></a>软件设计结构</h3><ul><li>软件由 view、service、domain 三个模块组成<ul><li><code>com.atguigu.team.view</code> 模块为主控模块，负责菜单的显示和处理用户操作</li><li><code>com.atguigu.team.service</code> 模块为实体对象（Employee 及其子类如程序员等）的管理模块，<code>NameListService</code> 和 <code>TeamService</code> 类分别用各自的数组来管理公司员工和开发团队成员对象</li><li>domain 模块为 Employee 及其子类等 JavaBean 类所在的包</li></ul></li><li><code>com.atguigu.team.domain</code> 模块中包含了所有实体类<ul><li>其中 Programmer 及其子类，均会领用 Equipment</li></ul></li></ul><h3 id="创建项目基本组件"><a href="#创建项目基本组件" class="headerlink" title="创建项目基本组件"></a>创建项目基本组件</h3><ol><li>创建 <code>TeamSchedule</code> 项目，按照设计要求创建所有包，将项目提供的几个类复制到相应的包中<ul><li>view 包中：TSUtility.java</li><li>service包中：Data.java</li></ul></li><li>   按照设计要求，在 com.atguigu.team.domain 包中，创建 Equipment 接口及其各实现子类代码</li><li>   按照设计要求，在 com.atguigu.team.domain 包中，创建 Employee 类及其各子类代码</li><li>   检验代码的正确性</li></ol><h4 id="键盘访问的实现"><a href="#键盘访问的实现" class="headerlink" title="键盘访问的实现"></a>键盘访问的实现</h4><ul><li>项目 view 包中提供了 TSUtility.java 类，提供了以下静态方法，可用来方便地实现键盘访问<ul><li>public static char readMenuSelection()：该方法读取键盘，如果用户键入’1’-’4’中的任意字符，则方法返回。返回值为用户键入字符</li><li>public static void readReturn()：该方法提示并等待，直到用户按回车键后返回</li><li>public static int readInt()：该方法从键盘读取一个长度不超过2位的整数，并将其作为方法的返回值</li><li>public static char readConfirmSelection()：从键盘读取‘Y’或’N’，并将其作为方法的返回值</li></ul></li></ul><h4 id="Equipment-接口及其实现子类的设计"><a href="#Equipment-接口及其实现子类的设计" class="headerlink" title="Equipment 接口及其实现子类的设计"></a>Equipment 接口及其实现子类的设计</h4><ul><li>根据需要提供各属性的 get/set 方法以及重载构造器</li><li>实现类实现接口的方法，返回各自属性的信息</li></ul><h4 id="Employee-类及其子类的设计"><a href="#Employee-类及其子类的设计" class="headerlink" title="Employee 类及其子类的设计"></a>Employee 类及其子类的设计</h4><ul><li>memberId 用来记录成员加入开发团队后在团队中的 ID</li><li>Status 是项目 service 包下自定义的类，声明三个对象属性，分别表示成员的状态<ol><li>FREE-空闲</li><li>BUSY-已加入开发团队</li><li>VOCATION-正在休假</li></ol></li><li>equipment 表示该成员领用的设备</li><li>bonus 表示奖金</li><li>stock 表示公司奖励的股票数量</li><li>可根据需要为类提供各属性的 get/set 方法以及重载构造器</li></ul><h4 id="Status-类"><a href="#Status-类" class="headerlink" title="Status 类"></a>Status 类</h4><ul><li><p>Status 枚举类位于 com.atguigu.team.service 包中，封装员工的状态</p><pre><code class="java">package com.atguigu.team.service;public class Status &#123;    private final String NAME;  private Status(String name) &#123;      this.NAME = name;  &#125;  public static final Status FREE = new Status(&quot;FREE&quot;);  public static final Status VOCATION = new Status(&quot;VOCATION&quot;);   public static final Status BUSY = new Status(&quot;BUSY&quot;);  public String getNAME() &#123;      return NAME;  &#125;  @Override  public String toString() &#123;      return NAME;  &#125;&#125;</code></pre></li></ul><h3 id="实现-service-包中的类"><a href="#实现-service-包中的类" class="headerlink" title="实现 service 包中的类"></a>实现 service 包中的类</h3><ol><li>   按照设计要求编写 NameListService 类</li><li>   在 NameListService 类中临时添加一个 main 方法中，作为单元测试方法</li><li>在方法中创建 NameListService 对象，然后分别用模拟数据调用该对象的各个方法，以测试是否正确<ul><li>测试应细化到包含了所有非正常的情况，以确保方法完全正确</li></ul></li><li>   重复以上3步，完成 TeamService 类的开发</li></ol><h4 id="NameListService-类的设计"><a href="#NameListService-类的设计" class="headerlink" title="NameListService 类的设计"></a>NameListService 类的设计</h4><ul><li>负责将 Data 中的数据封装到 Employee[] 数组中，同时提供相关操作 Employee[] 的方法</li><li>employees 用来保存公司所有员工对象</li><li>NameListService() 构造器<ul><li>根据项目提供的 Data 类构建相应大小的 employees 数组</li><li>再根据 Data 类中的数据构建不同的对象，包括 Employee、Programmer、Designer 和 Architect 对象，以及相关联的 Equipment 子类的对象</li><li>将对象存于数组中</li><li>Data类位于 com.atguigu.team.service 包中</li></ul></li><li>getAllEmployees()：获取当前所有员工<ul><li>返回：包含所有员工对象的数组</li></ul></li><li>getEmployee(id : int)：获取指定ID的员工对象<ul><li>参数：指定员工的 ID</li><li>返回：指定员工对象</li><li>异常：找不到指定的员工</li></ul></li><li>在 service 子包下提供自定义异常类：TeamException</li><li>另外，可根据需要自行添加其他方法或重载构造器</li></ul><h4 id="TeamService-类的设计"><a href="#TeamService-类的设计" class="headerlink" title="TeamService 类的设计"></a>TeamService 类的设计</h4><ul><li>关于开发团队成员的管理：添加、删除等</li><li>counter 为静态变量，用来为开发团队新增成员自动生成团队中的唯一 ID，即 memberId（应使用增1的方式）</li><li>MAX_MEMBER：表示开发团队最大成员数</li><li>team数组：用来保存当前团队中的各成员对象</li><li>total：记录团队成员的实际人数</li><li>getTeam() ：返回当前团队的所有对象<ul><li>返回：包含所有成员对象的数组，数组大小与成员人数一致</li></ul></li><li>addMember(e: Employee)：向团队中添加成员<ul><li>参数：待添加成员的对象</li><li>异常：添加失败，TeamException 中包含了失败原因</li></ul></li><li>removeMember(memberId: int)：从团队中删除成员<ul><li>参数：待删除成员的 memberId</li><li>异常：找不到指定 memberId 的员工，删除失败</li></ul></li><li>另外，可根据需要自行添加其他方法或重载构造器</li></ul><h3 id="实现-view-包中类"><a href="#实现-view-包中类" class="headerlink" title="实现 view 包中类"></a>实现 view 包中类</h3><ol><li>   按照设计要求编写 TeamView 类，逐一实现各个方法，并编译</li><li>   执行 main 方法中，测试软件全部功能</li></ol><h4 id="TeamView-类的设计"><a href="#TeamView-类的设计" class="headerlink" title="TeamView 类的设计"></a>TeamView 类的设计</h4><ul><li>listSvc 和 teamSvc 属性：供类中的方法使用</li><li>enterMainMenu()：主界面显示及控制方法</li><li>以下方法仅供 enterMainMenu() 调用：<ul><li>listAllEmployees()：以表格形式列出公司所有成员</li><li>getTeam()：显示团队成员列表操作</li><li>addMember()：实现添加成员操作</li><li>deleteMember()：实现删除成员操作</li></ul></li></ul>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;在学习完 &lt;a href=&quot;/Java%E5%9F%BA%E7%A1%80&quot;&gt;Java 基础编程&lt;/a&gt;的全部知识点后，为了更加熟悉 Java 面向对象的高级特性，进一步掌握编程技巧和调试技巧，实现模拟一个基于文本界面的开发团队调度软件，并以文档的形式记录软件设计结构、实现方法和一些疑难之处，主要涉及类的继承性和多态性、对象的值传递和接口、static 和 final 修饰符、特殊类的使用（包装类、抽象类、内部类）、异常处理等知识点。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="开源项目" scheme="http://blog.zhuangzhihao.top/categories/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/"/>
    
    
    <category term="Java" scheme="http://blog.zhuangzhihao.top/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>操作系统实战（上）</title>
    <link href="http://blog.zhuangzhihao.top/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E6%88%98/"/>
    <id>http://blog.zhuangzhihao.top/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E6%88%98/</id>
    <published>2021-09-30T16:00:00.000Z</published>
    <updated>2021-09-30T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="a0ca48ec6fb8d558c804ee3d7dd79789351285adfd65951e5eabc47d6e163bbc">b37d745af087d2d9e578b95e0003d73e377d41fda17ca438dfaf10c27a76f56d6ab9646df156900f40d29bb0cd704be3d65fbe15454f5466d1245a41dbe4e35619d827bc290fa83b407ed5df72f385918378e68d704f95abd0325f710232fa6ae30794a1b5cbd00457cb516017d56b61e82999e197176a6dea9bc3eb33b35a4987f9765c4e9adc8c967218be3e522b6e73b516e023ca7959e7432d01bb4845c3ec70d30b763cade7e8e8dcde23a037e6f1867d025c00b59a4872572720384b2cb9e0008e97cad84800840075cbee98e004cc119d3bb76c461d2d39d134963d0e169dd2739b2e5d3a3a872efd5f1cb6031fa821fe73e01c3506d596979f271dc177ebb440ea2834ddc9fd6a0589bb180386c467397a4e7a389662fd8e1b17a5e36dbd5ea608551d001a1b8374447af8206982153540ce96a4066112e49b9d7248b40f7345ed95d07ec83ce0ef74406fd04b5f3b3d3c84ee6978c4bf15a843c2ddcbfb9e9649c5b6cf3f8fec8ee2de55b64ed823fb41d453337c43c925243966800bc5be90e777d4bfffb86a4cf5bc730b5ee299aa63a2afb04fea34ef346c5b9ee4eef5edf6ff9291592f872893f2c5789ee609d37f1ed3c8f3eb32c37cb8ba144e3e8bbb2dc93979e98141ec75c88f19ac33ee042f8b2ce7124b23d89d0ce590e4f6a0c7ea1dd92e44be7b26981836bcf71efc0c1e8a5d4a639e826c72d0fd6c5a470be5457cf82852dd9b1cd821f15d05f819250360e256e8563be25416dbcb9023f22059c4a1fd34be8ab9fd124c071ef625c490edc398de74510a5fae7800993300489b9fd6f3ab733c415c9eabd95f87190481aee138e8119ca2f6f7b233907c9cc6503172ba42e3b2ca4b8c2363ce899739e2ea5eecfe4b652082d3c11074f361912b8f2e4698bcffd9ba8d9981830117da5458679eadbc5209c8130df6e046b6a1d06baef3f94f7bb4884b103fcaa31fde43073c43960d0797e83a4a8129e988bffd0180e4aa5a3d31cb8aa4045b3befd2aa8c07d18a34247b04e494e472f2485b17f1993a3eb7e8b746093f32f2c4d2009c7e9bfe1c2d274f4fff78041b5483542bbd3190ca09f9fd4976c5b11a86c1c3afab76dba5896f2609f3b3396a9f673a41f56c183b0de8f99e66c47b0e778fc8b64cba59660b833b5cc9a3c2edb87a62ca80b59f6c9e3b66f82d45a00007589bdb51d6ed717718e61448f153207a54172d293982f1ad60d2b3d3d2d0ce881f66a33766a9f09fa646928a9aaf4ebd0b8656c60cb3e55fd5dac7f907ad59af8cfd5e3550b742ee74aff6331d16821ef8ee766fa5be6ed00977b38b2bdc06a53a486cff8577d9134f60530e0ce86b52c032f2a2fae4a1862f0700a1f2eb2aad69937d1dcf0be9eeb0752c4fcda27f8ae4d4821231d698a3811b0512aeca4a1493a9a267f5b59b55351f836e7d5d88683537e8cbbda415e504b7def1c806f3ea45c99599adaf4637f5e619a9011337e30f05865d100bb0f5c72b1e5c4897163cf2e458a97a8b76767d9cb75740fdce94004731e45b64f8541494e7b38174d6207884e2436a129cbde5a47582a7524fde50cade10b658012d1ed4dcfd68d4216d3cdd608f2001b4836dbc185ca94ab8f8baaefcec6be0b46c44271d904cc683eee0c7978e72395a97b573d3858cb5faae2657a2371ee010c44525b832f102f212552ec398c922756fe229f528861ef97380262914b28f74e6fa5a2b7db37126dbd168da2005b0cb68c777eeab4193ea78a408fd8e5d69478cb39008cf2a154efff41e4e67cc0eba66315976c94ea1be21f53c1861b96800db8afe168dd09cc1f7a12df642ebf372f2fbeb9b4ccc4b49619316265b057ff65cc46a8b6952069d457434bbfda5b25ce8cfc1d352c9ab2f0bd0799b8ed7bd529389bb41ade544ddb7953157e7662bac170bf1d55051e984ab441fa12bcf93af93a960689111afb31fa9315ab351244e57173216edb4509d58e156dc135e45e02b8be498f1d13099bd8a615838fdf21f8dbd5f83dfe230a72892637ab78c804dfb3c82d80a78ecfff2e75a25c15f543dc612f9f3ddaaa9db9898d55d0d7a404b9d7f05e8bc7a330a1943c9483533e537a6fd9b75f9a2e1252b5430bb163332b4305ecc81b5a5c2addc8707f33ab4169ecc112d046e95475288dbfb0b42f5af3bf47dc255edabd1d38dea9473efcf497d85e4b33c5864187be95c684500ff8a8415023fe6859344d58da8c827a91daa1677de1d89a7959779c2ea54605c339a72dd2a751dca4c82046a6ecec6683599019391522e074f585ab26899c34a9dd9bd28fe6b744aec5abd6818e18da69a6e410d0ae9b64cee92bc09bb70b5cb98cc13ae2585e843c054e004eb061394e35e952b9cb1b7125c254a819512a92659b16eecf5943c17dd6d60de1a5dfe93178a2801a8b4ce043ac542545979e8951f535767e3a02f0235367729efca6ab79928619074e3d3f1076991480ba49122275f6e5d1cba8282f4fd7efc7a411a336837c77e755dde7b66142610db2406c56a802ddf3f9c59793a699168e720fa2c96298551697f3a6b06b9023ded770ac049549fd56137099456f7473e69ffffe01f9b1a9ad04db9622265cea490da2cc37a7585dc9b6a44d2debe7a755a787bce0b9e9aaca50be01ad060a2f6878dfd60f15a577dd9c5037e40ab611a4066c460e3bf5cfa901cc2d108c346cd5f0a3a97ae28513627831d9fd70ff4606c90d10deceba9639298c441c86c65ab71426402141447044f08e577f038c6bd65a907aec80450c2d6f7a74134e742a3a7b6a8b30221fb7a3adca9078933ddfeccede7ae33459995c958cc3dc536781fc2d76da7ee29d155362510825a2a88f43b3c9e197c2b4a997d465c98db1b04ece35a6a6c8e88232e9167bc88e4cb8cb50e544b75b3cdea3a3582c33014d05537d3ecc851d29f7e151edfe566c90886eac01e3f21321394391c43fee3c44b096e3a25b340cdbb0f4950f23e7a53ede26b4315dc7d48c2275b774e923faab2bc39f3c64a3837c5b5ac257740523d202d8abb1bcc16cc21ea8dfc7ab86c7afb0cb6f6a2d3fb4b019e495341eb98797b57d94ea3612f2e4cfec7c76288e6e879d3b55dcf722357d968d5286ed087f7c4597674d4dca2049eb3f98b218a07b5885beceb019fe1aec457c1b7542f64a66d81be1e82586c71cd05a2b5c066dd8a8a4d80f1f48fb91f5b175e0860dc90778a1f73447bca863c8ac2e93684631c261c5a433a89ea7afb45b790e7cfd4d93ca67d68e4494aa6ad6b0471e73e23ba80b41e8312507bf1b6485b36c3252b4777628dadcaafe642d0055a9e34f8997278dc5409aae2ccfc394170234f0e0f004498a57ed94cd586379c9675ae2eba2e1def184da21b1e162207c79554e081d5c9b228a0a89551026c756d8e2c57d2ebf77593d5942a72be80f04cff2d1a28fc1eec474f224121624f641d696aa19741905a1fcc1425f4846eac9aceb572447eb852f87b093f3f720e9f57892fad7b21b9226c7b1c2cff166d293fa833cca363260aa28f2e194c6f3e30ccec9966ed6ba0ce5cccc40d99dd0767dcddff998a1350aef2418abcb845678a6b79c7f5405b94be342d6ed8cc15f26beccf931337aca4f28d870c3440b155dd9e91268b7199b180310a07cddfde6e5c3bb9f2ade6c4db3d769297a393f08ca23f42ea36daf686ec241c8101726c3bfce43db36a2b14422a553bfad766a6e97e516dee6d4bb56ad29d398032423be105fc6e0aaba63c466b949d78561c49ee84706e36a6abbdb535f885e4a9f6bbc9b50630cb197dacd5883d4283930b55a60f1d6480624c108016e6cb9c75d54d73b12d0c8b48792c1ae31f05a6de21a4006b63a10d2d10df162854461c6a4f7d853a0d52b74806988adedefcd4cf3124b74e0efa2bce77dbf96ae65c0d9dd4f024d4c71623ae72fc47613a03fd09dc2da6d0d827a60ce2570ea707e0e1ae7aabffcf7161418d4fee9c7b4f06076ae0f2b99a3ed8cdacece538605b8bdcb1b5faf3b271c3eaf7533f66d53ad83906be1c29892da8229b96c1f6f095fe1a24c6f0e6ceaf443482e00ccd1542957faad89d57e581eeed80cdd4acb2fc06eeec11bc2b147d58813e95993bd4fbd4113bf186f4b49ba7b2ba652970fac0a852b9692491c408c7066c3554b9acf9d526a81300ea79d3fae1b4e6511a888df5b78c3473a1a5b4c1182650171485db8416ae3f67537e32ad2dc4f63d42672b27068bc9c8eea61f289dc949beed02cdcdc1853d7098b980094d80a967546a43b0b6b78e6299c4e8ac39acfa7ff6c293e843cd6783228b825988cb688ad3a5757ce964a980a1a7bd4c6239f60f0bfc868fd483c869755f4bccc85aba7f1caba4c73f30fa2bf517bcb4528479de41bda1e5fc85e8b88a0edbe9214c37e4355c865be6260f031245cd38c4967abbdaf0e008657047f9d36eedb38b2a012e86346efe807faa32a9c70da9948074b4614ead16cc1758c1e56399bf07b03a8f3ffda1bce2fbebee02fe0320f46a8a31bc9b883b34969bbb85e54096ec7371ad515f20c5b7596d36c9d0fc03f0f31644d27acfbebedca44d4add3fe8bffd0bcaafbdd036f54209fb0d9827a040993ae53d4c1e3a2c6cf00e45a6557ba06e794dca1bdc0bf771a4b42df81b016de63bc23e46147cf100f4c4f8b1bd4f214d2355c130a547a8b9ce21729bbc93785535789e2029e9e099f66fb12b9574249847e18fd9ea6830fdc2ca0da6fe51bb21f61220c7cd90d00985ba76ebcf11fe4751b2e52d975870f5620aea19ac0274fb245a9a4cd2a2ec24ad75bf1b67dc9b0213fc7e6796f02cd8507d64ff64317d17bc19c548df65beea1bbc4c15555330d5822761efccdc3cf0e916a38a663a17ae46f95a050f9ea8838a5392317c8f989a8baca64c9574c6a2ba9dd7e4092a56e70cc172bde2c54c1192b4a75a3ac56071b632fdc9d6da81d3532b73ebe63680b0ae2308e98e250b20b081d1f57403a19b53fe023d5f0eb22cbdcdddc8e703b9a78f70cb5a817ecc27cd083564ab9eccad105e761a8128e7442e8bede4d6dadb789ec94467a8af1c2f12b6b37cd054c7a715543cae5a8d54164051843ed47a6b69091e2ccbd9eb154c2200eb3067954624709e3bda3a3cfe51476e3066d11877dff957c6dd1b274e657e1e0636b52a2c76169adee9a07ba7214924e57fe7babf3a1e9ca2aa1c2623c5280bb77e2e1b1b4cf9375ad67ba9459eac0664bf72fa0ebd3b3be699b110b08c07f8d2eea4a2491f922441850663924ab8f223724ab469db20bf6cc95db59c7603e71dac0ebfea3a79f4a213c27d031044e81e56f71168a9dc9414f4828b7bfd07550f7958c5b35f193e1096553a0179ceba89b97a4aa5eca076807e68c9a8904af98c20f3465073a13d4b558b3af01fa63e972218ee7fd323dda368b017de2e03c8b5b4355e73ff7aa3431387268a3197fa89e3adc6d1bb5fc7c54b4a487f5cff42945594f73bce0ac8745b07c9e15fdfb3359d2e10945069cb088252a1e9009ef43b2e0ebd982f0c3694c60c2d199b778cfefd1e28d86633f976bc8cfb4f02754951b2b056403f3db75a7ad826e5697fef305fa208e693e986fe8f2fd9ecef00c402a7f90874698441024951f2891139555c465e159bd3151e9d7505cf137d9c0c5cd27b508cf61fef1084765fef8efc3b188e553dd2ab1b745b73623378b231b48eef20aa4eeefff3747fcb9e0712b9e03168de51b52e8be2a7ee126c64fe62e9bbf7df64bd1037d0fc0c340465481d12d8527f60d27a168dd2cb95a77fdb109ee5cb4488cf29fa4a11af9a7865ce48425282cb584cbe211a9b6281e0f38c12cccf2f35598bd133c026a31d0935c7214b28c7a2a6633f70801bbcefa1b7a4eddbf424733141685fa340dbd9fc21ae590172f869795b303040a61230b8e68e11343cb3696fe0fa03356b67b380c6f8e4049c4121a78ffb19cce5adaa79bbf34cce7237037921cf5b3d0fcd472aea33b0b7a3aba1e5c40c8627698d80212106b7cb8b1f80e796c67d8d2ab02ca891bf6cb2692b69cb9a65a16eee365c3bd923de8b238ea0cf59a7d73b8f3876ba488db630642d53231a8cff7dc726e5a1a5a85547c9d5a50c5cb4e8c06c943b7264551297e0a6b82fe8f2df278b1d44ed2b3b811f4d38c853ed6ddd1a6c6c683e02447cc62f6b206422c182a04004b2e2eae7e869eba3fe1aadddc801b267f6625a0eed28d7c7e0280b2b3e13ad0f0fef76bad1d39f7a65b7a3eecf3d0684d603ee4112499e8e73d29d71ce5477af39d6318d58dfff3c2967e39554ba98577edf520183475282fe319ff6cc118dd76264ef6c334b14d9c9b102195e3ba197430c051ece5fac6dc5f00626bfd78881b60c7c30ef62f8627c54b8b812f2bf06aa1f0de09141250df30b9685211fcf1c8a59fc661d6085501a3af6028a9faf8be9a17712e3d3445131a556c162821913db98da90508900f36adf276ba7f402a485c386efd286b0481c91e42281d1ece09dc6c327d716ccec49e8aa48ea0e5b0d07dff3f705f187477a57de92da8e7070c4528576633092796fd25c6dd66352039033595ba0650d9af993ccb41b9c9f02b5215199846c352a8c813c31511c1349d70ec08427dca234e3e105ea4fe3d40b4fc97d9c048960bca90a3722b897855fcd14e359c9977bd6ca5f89064a88134bd32f6cbbd6eb86759a47a415dc37b048e6f747f3d2775f0f494cb55d66d92e446e592c84133a1c66485cc422579640e8c8f4dc2c88b8e200d560448afc9b61caf8421be6645dfda28fca69b758370bf18174df3d34b60875d0c5f587e2266429234d4f7a38a1fb7adbafdd6cecd408b8bee302eaee53bb45ace3420a6fcdb18b3477d03bad9cf4ba4efd6016a78947af1cb65c7000a467378d362ac57ef8f33ebfc6451f0581e66dbc74d17ce17a53a736ce5b35511e35b2cd0d511323c29043e35a37462e0c3c6e869bc915b307005669eddc6d442652013cf9a24f44b4aab9f4c06312538e3af2ed88447ed59075d393ef926ed681002a79be8c089a2674fd8c79caa1d9b8dd3e5d19601d69e4b04f5aa1e937ea36d749449ed59bf765f981f6fc4a9d712a4f71497a07501597d74e9a95af35a28f6ae337085830952952316339c2c7ce5dddd1039b873d1ebbf0537ceeee2eb752c6575375b6885a031168de3c7ee370b59bf9eae003bdb2324df365bf106b93ea2970e08af09f1e70c7701a3deb7131d78468d27cb80f2d7ea35c0b08f3cf95f688efca2fd06d5e0c86f22077ba9024dc521242da7c18ee88946a4b7a1feef41eefcf9f47be41e4ecc0ec6c326da5ce078619dc01e45999ce95aeaf35136fc50905b6534893bec74e27bb4749b4264b1cc4e027ffea859358f6d072d332bf0582e7e22a7bdeab148dcef8aede71277fd1fc37b51ba86c45bfd991f0b555b4da6d5f87ac221da5c3e1a2b77b40a17ff1257c79e3f280085de9877ad1d2579f58692b98a3dd21b2e7f4a192dd2872f5db967845d290b23eab177cfa64b5ce20ba094a8c46829e24e60ff452ef9fe5c0a190ea9486de1296fddefc028dac6b4a561fe074814f4a4ebb7b3d52c975a5bc3ae4419e07bd392400301de4c17f0cc24937198da75818dbbcddedb26e8507f3faa6de2801280061fe640491be77c36b1999145728603f435595284b34bfb92c852712fe7fa9feb605b944cbeb8f019bdd1b34c0b5fdac4f5815faae353e10fb4105380e7f837e497f69fb7342d26ba81f05d1d8e01348ce4adea5a4795c4a7a3eaecabf57259def1ea758e4ea9517b39efc0d01c709dd42e2bc6d15f06a3655d26a2416089c5cfed20b56908b86db2fe25b1d38f5ac87933131b844bce566315a187e81b8b7ec2a9de5ddd4513e729ad5b6d9289285b9e7f31194048fc31e1903ae2d8592e65f0308b5050444336be0d39faab04ea99ce8395736c3b90f05c82a883746e7ef15a9fab370effb0ca5246f5b944903f7f4d69cc23b3323e497f97c61bd383e02d67e3a9b99b53d5538d5adb09c65ba49f4483e1d9c4f75b459685fd607d4242320914b35824036ccaf3c02df15966a3be2d1ead23188ad141e88ca17487bed5a3f2d5c4de44097843cb72ad416bee00274a2b9a3493e2ffdbdee9e480d68cac42b80f5731045c39064fe958af9f5297cff25357f57a87735c6708938e5dc8e9a47b2e43a94c00f2fc899470a961a45818698dffa498aa4ace9bdc13cf0d0350876a42a26a79079ea821bac2de3081cdebd687abee64fd30578fc502a161c7e61c7abf937040b7fb33016cb45c685702b287a268a17e06c6fa6291e2f6850bb8de747aba9730d01358af3a9c9679cc8dc6a83a7e1384830c945fb3872d06c9b5ddbbef15de8d096b19ee1ea298d0616ecc0ca96a51724b7b173b1b6cf8ff81c0dc1f30e19f969405842a32f7e6b9a6bcf9b1734cad9738dc2f9e6609a308497ae9ec0dbf36599cf99c5f01d3b16ec87642c2fef1216a93c73f647111415a3da390d7c28519ddb0ee39748b0bf09ec5a89cec1bd7acbf9854ceacae1068e1c21ff05cab9c55a664f9ffe3f1e45bbe2bffcfb692697ce8a752c6f1fb975f35314cd56a8b1142fe39c682e5a433749e0048ae2a757e9143bb43bc468e105c7a55254accb4263b341e0dbc2530627118400d2107974e9a3973e948fe74d5d1e5a1dfd8a3ca372f76dcbab28af0dfb231690a7633dac9caa5a63b9bcba47efb78235ffcb3374604a60d679c83ecedfa55e4c83a677044c60ce48e2f743e76fbcf218aec41934dbab24c9a6e312c11645cfd3c42244c15272869cbd036d56a1b0502d88a34c5796d0d9b3c04ee50e86ad1f6c201072b367ec2fe49b86e85d90e92a702de388e9142fb209f0cdd5607a38562542dea8b35c6d8ca1d885e7d7eff9d46d1cdedf314033905e5fb4b7f7e5098a0ad73b2cb83f3f215642ca1fbd28166145a8b64ccd7308aea44cf755985301d43270bba6a0c91c4364158c113d48ebaed030ce1f5be20dda6e5df54629ccc5934968a09aee20ee53833570665d35c970740368c4785f13753857a05605c087ebb7fd291ac1aa17628e600e4cd5929dde3db6f076b418b0c81b788a953ba8ecef9375e4104baba219027c879647215020bdc42a35b51266616873956b2c83457cdb929c2487ea3430203e9a25214425626c97a52da5a738a6e97281755a2e6500db8c1729129f4e82d3aead1ce704c97efe9edcec4c0b75cadeb2cabc136a73bd4d25d52a01ca80e3ec25b23fc93adcf9c07e9cc4ff97d97463008db857f5fb0c7d157e82cfeb7e5861ce50d844c437eb8901e12f9e427f25546be19c4e759fd32a62125bf9baefc30ffbbc2f9a79797add08b2e90522a50d05c421d3354a0b1024a291d2620e92f2273554b563c6409f488bf00a29f542d09d1f0a190c9b074436ac6a3c5e38b2268e6ffda4582ef4ec315b962d205e7652c35f73f149db7246fde7723c070c2d7ea56237605bc8f7582e858904c8bc03a01965a1972d3a040418cd6380c97285ddb35d3b3694f68f4ad4dace843f81291ec1e3a5402e37ef680e25c0ad25955852c624c4c00e8c51deea280527b981904cdb91a73361e6920c1b87c2b0dc2d8203b056dc5c32ee0bb4b6dcf465eb71cff83e4d9b3418b91f51503643d76c7aa7f0aafbd415be61d4b403c8b37b6e52f03c363f1728bf26a4d734864893b4d31b35bc7696b91a1b09f64d6454ffd36be15f7a69ee2f3a8c3588ecdfadf4c5e888ea94275e2eb668ba3a981a07293ea5ce13ae0c61867f2793929000337ddb92305e4b194551abe151e6f9223c5559227095db4a4222cdfb7f171d54441d342945fe39eeabf423c22e636659ce80b7ce51d14f4e5d2ae60130372a21b640a15e2fe2d67fa009da2635e6654fab357a7547bcde31119cb38b5cb13acd06fc1f1b854ffeffba438b099c10a74a6cca788eff5ca188fb69bcfde10cb3f9fe243e9ee8930d1fb969e875a91390e9a17f4c3be198bd69dfa5454e420ac57a5b421e5474e23538770effdb7992288f21461d19e85284c7e97ea09514374a74e6a9760788c7af523894434a49c5e49af1a54ee1629486652986d6fe21f0c58184e1a51a695cb29f1322b8d4bd5c75f7514851c903f4df6510c8c41fae2cf643144a6d41eb80d8615bada2cab1f924ab7552dc3bae5e3cabbe3b9725769957d0c87d19cb9ef0d6d22fd7dc14b7f5883e1b4a4a4645f463ab1a57291f0c752ef79ab9d96c8920e79ae071e22307947a74de38c1f9ce3b53db5fab46a3edeb2fbd85c2946df495d79d58e12e35d213c4b5def73b405322824a6991dc0d0b4b8a99adf6b345f65f767db78e94edcff8d1160294a0287f73cccd9c692968bfb84932e4423e53a7837426aaf86051f83b9bc953b4d4dfadb77f0d40314100bac3d835bc06aee0a79ce52a84e36c30ec70eebc81824495e11b65c9c0fde9026c93085f898d8cdad217084b62b67e80352e563ef73aeedd8601216f6a603622e3fa97bb4e41445b126dc28a52885eec9c83e32e2ebb446db7d6873085da9d1abedd52b230124ed5780abf8acad1665f20a8eb43c85de93de051f3fddda447212d7b364bbe22ded83a6069cd75e7b3fb5c94b65ef8c2679cec492e0b7f81d2553f9b457b4dc9d30040500a95d2266c09776fcd5d7fea84962015edae1e80586bafadbb744a534f9a52d1641a06fd35cb9477c4fba3064adbceb7ab66814553908a554178c88cd6f6e7db4174db2118fa13388b88c5535f6fbfe773d1ce7f50ac12cb5e5df23c82c8b5be33616305ae12f6b2c625585b6efc7c7b0a65bc9d4c6d757d8ecf43c3c52c21b09c2b56c3311f4b07435aa53d8120e09ca3e9a9a36c58d34e2a08057d6734e63d12efef6ea44e1c304a3b7b43bee00a4b14f2cab82fb0fc246af3b44ceba91e2952e13a8a8a1278cd10ef104007392a20e949814ff7b0027c8841f4328c4d7ed6e2efb6b6b37e1b81b67d14c5115f01a1fbc3d4c3ee2627e62a23921f95e885e04511a99aa604b7759c51a608d591e9dbed33a70abf8d4af7a451d79cd83771821e902b54cadd5d520c5236a9f77abe266feb4cdde2177d445885bd1c68a45ed64db0816d93cc1d514d67e2595c8f52c600499e67ed93fd241cc9caa712fe8f066429e04f176a597dbc7d29cb3a6ff0d496f4604d20e8e8b9851c2719ff0b00a363fc81d4c9c44db9d3a4c34d505bee1600285024e63cc054b81c5a2ffd1d87603527e675a924e3a8ac4bfe154122b54c86fa00b38d66877111efa0541906de9b40fcb02b2da8b7feaaa05a0699870dc3ef7998d92d97cae62bb9f1b1c8d368ec3420e9919c16df30714ebcb77516a88d0a221fdbc69d2521ad8775621115736ac93eeb4abeab1f46df0ebbc97161c208cc080f9faa02c6812fbce9fb4f320c213508db41c828a27d5d721fd76f5b89ee79ffee15409fad9f6e21ce17ba80fd1d6fd0c83188a12edf631565633d977d98df2c7383c61562af72e85ce5538f555394d3fb6c63788abc3dd967ef29ddcd7725cea19e611ba1a1d150a7b2d30b9906e3199482896f4e9edceedaf7b00f76abe08e807d6bbae2f2d2431b0b4a5d31ac47ad08bfe83377d41a851b17e6e4b23f9ac408587e610c643c947bd8893f2ca52685066bddf8767e1f7e681f534ca5308430a4e8cd8f18cee3db667650cda0f0f750e66ab34a75d3f1615d99254ca1304104a74d86a804c3241c2302dfc0911c9d709d8512f7d92dd90d673ba46aca744e16662c9de69ea433a016e7e04e7ea8b8c6957e9e73d6dd0dd7544d93b993e3d855d0af96266c5647e4affd6f290d3cf37b1301da561f3b7da4332bb11521b8eea24e0d7daf40aa3d097dbedec0df166746ba1d368634806957203f4b6acd781dc6a1a4bb15b4138340843ce0e605e71c4717b3e5eec7fa0f2351423d90432db0259601403a323c4b53221e81ec7d51c8aaa6d1db4ab2465cb629b2881cb4e9afdca43f77671b6dada43734c66d98f67f4b522862fd4e9d9e70c34ff55b71c14943529c7d1866bb124b82a58fedec0c42e8eca1bc0a4b2a545657ee39e39114d44a262fe12d69d854e9b2f57a3dfdddff646535f5dbb17544c4c5bf37a918ff79b87b794d49cfc7381941e0a2c74ca246c53c172f1136a597a471281e4922f2fd61eebde248cb2cb043fc311cfcc8fa4e41b12d882278182a2524edd396893d2a82967d5bbf7d537e2a11e4d88a7300d537e36b7cdc6392b3a92f55d65d13693ae0a436bb80bacec63238650d21f04ba2468364f7a32dfca696442ca9c7e089bd4d4350153d555f9d73e562b6006530da3d7f97fb89a80769186219f8596f9b8398302634f6b2eebc99d011d99ec78bf83e1f215dd804d4b8b7799675a97b56ea52d67efad19be8c171bbfac16012b0dae2c98654905c904850f29153912172f9e1963a6c695d106b17a447909bddbd4da85eb7ac39e24e27a3427431a66d2055a157255510965eb92cf05da198f7af93a06752f219a09134bad24d188e905af9e0597c8d6555727b71c682df42ee9fd4d1bdeebc37575e456ad572b61c81e9fa87409b45b5259f12b3cbb7e184dcaed1e19d028dbcf07af9a26253537491f4f3817697cadc4a438fb15e358061344f5f40135d0bed6ca59b0b067bfd479e0660fda903a4606824ac10260160cf908b661877847da86f9c6c167c7b61432a1ab471c6ed80a5ccbc4d0a6e685914aefca0f3312d8fa08727b2c50af32721a6b46dc23048a171a67fa917af8946c7b07f42ecddfbe1c39dda19b9216b34a7abdc7435251e8e60375847908787cbfed58eafdccad62bb3debfec3a7866d42fb74dae46b092dc735c710a57e42fc299c3d88e9d29c1433b68a94814dd5d8e0735d6ba5e4e568840ec31f08f8fdebf81c8e8a30a8afa242d4b8b2c10b80f661bdbe882d935d6caf66e2e399ccddc35e0e22635850a48ee90a520c8936058d11966cec04d20741f648deadd95d6e2e4d7cdc0f2f082d16083038848e6d46a122a4df8374b0a2840f5d3feeefe588c057e671b5c7b9d86b568b087e017c843bbb12aa89f42f0e7e1c2fe7d66a0bd6aa4fe85257831ab0e39f784eb0400dea3d6aa96dfdeb435a90d94112887d98d0bd1fa6c12e06da47f99d2656b41d92b684c230a98d40847b0d3d0c080402c81636d6463df08a49b4c528785c8515ffeee6d78f1ab73d578eabe330e7cd6129dc2ab5366d4387f32b802b2742339269d5398ed981870b08f8fdc2e078b4efb7713fd25740ccd282adda8cf08de92f5cbae8d70e1870e560f5609f5b0617f343e9d51dcb7fe871ac279f9afbff6404e7b7adc37c94d3ed01a2dd1afd3415c5c8490e676789f1572f95480fe86479a0d59ff94f8719c89f49ea9c13d119e8c7185c8b1d87490b2383801a56ea4b6084a5e13b9f45ba152580ca78e9bd7010abfea4193ca6b03985bc2d2d5c472bda0913915daaea391d4b9884730a7ce51f25fff60a719f269bba21fb5cff4eb141f9f7f0b03c7098efd5b5a56dae47a43ea7e8f1efa11093749303862fa0f7ee4fba573c63cd29870273ace39c8effad263830063d5b8d99efbb1e61c515dc164f36ca4b9136cfed1e1e45ef178e2ce637f2649933e75d27f20354e1a301e1757b7241b9e3d093474094e322fbbe076a29401d71fc672c9727136d611638f46d42f6e474f9f9feb80d490cdd84ac3bc2c872dbaafd173ecc12630f44e1671fc079c91615535a423be7ff6adc367f037a3f5cb20dbae8ab3a483d8e923cc533d36f7ee0c3197956ba6660d039254ff2f53c9fb6282c6413ae7771436b56992886957b25ca84673785bad32cdb99fa672096946e077c02e4ca9034aa06eb9a7dba1d335a36f73f003b4f072961c14ef858a1cf45ffc88e4484410f6cd8311c07317ed07b0cfe3752fce33ad197c99f6fa845081139ccfbca400af05404d635adca89549e41f2a90c2f51f656485ad65ac8a547e3ea980ed4ff5e7715891a6f2b1dee469afc3cc4d8e8d0d5542bf776a4a741e297d0d42c41ee39fc03e47f2dd865b4872a9ff9bf53ea442c77ac0d393d893fdeb122736a11963b0655cea97660200579333d612ec04ca423dfeff9219fc824720f7da1e1b75bbb0a5778e2c52eb5d7f86c0d22f860974ab4fe4ca2d59c5a9286d1cc5da9ada5e30135c7776dc817dc8112d4c8b80a0bd01d2baffb1059415fd971c5e470df8e32d72285b0b3bfd3b0cfb5e7866684c01b29a1502220efdfebbb2c17585cf30eb4588db843435dbd274c631374a5b13fadbef3aa7b6a4869b7e353eba32487368620cad095113693f8327992944cbd00d509e8486f20fa956e1eeec543ffc4338229568874d162003508a350a7d45733d6ddd87c6d6c5fb0491fc15576c5accdbcf1ad466d7c7115dbe263dc6f07c5bc178515f48e02c3e2679c8236e86a7f839df6f22d71d2230b7dd942b9d74392afa3e6897e2aa160bd568e4a36ef26bebb7127c21f81c87dd3c9e5a2530be616a141eb4098cee0786caa8322c2474fe2733800b3dffbf0932bacf3b066ba54e38f963c0420e1e77b0b8cef464255ae9f633f62bb68928c12162cb5c860aeec7c8ef57b9a6f95cbee974f0cf46b56225536266faf60369e8278da57f67c26c19384793ea9f8ed6c3f373b7bae6c73b19e7b22e557d83f6ae20d17980569271b5e91af02f0ebd5ce779ae79163799f6e6c440fa3d2863e4fa663b9bb7b38ac37193b6dc3b4ab1d81cd79d0376c4fa5d4020c3740a4018648ea7ad45c39f24d32af52358035ff2e6ba2bfc7e63c06b9ada4f4ea41ac5b1ef59b9426b0cdc350849bd18e39bdd625c4cf39287f821af548cc8072c5898fdf4c63212ec2f39998f46809f7d4f42f4b0fee1fcfc2d38b82f96de7acfa5c5566e6f93171fde39b9434c1ed1e0973696b67d6599e33a61c3591341c4a7814c0f516d7b0868a55b1f2e4461423dabf3b93b2b19e037a710f459d898069b26e9f343415af237ab15926f76d29419fea5d426cc6bc0b15d0e684af4f43067da9ddfb6b09bcaadb5814302ac5988900d2a335587993845dc35bf82815ac218a15d58cdfdc57eb189f73de513c20154e4aca8d2b51179ce7a35166986db41bac941d71cd21b610869b9010622cc9216921a2ca160e44f43adcb0048a254bb90d657f0114693f1b964906398f24aaa11b356c5c0434200303b12675178f40b431d0ddad1aaaf29948ee94dc8352b4f8ba3d05eed9c8339932cb70e683cf11d7570648e02a0f0fcceac0e8e8bf6c32f694911d948cc5e5c5d5e67a9db3d3bd5a87f6719318fae1aa507173292bf387fa8e9f50e30d5765583ebf67226d80e3d93d012611607d16050b70a0e38f178249e57c1663f09fe1025bd5c50e4b995c60bdc37782263bd8af93ed167d16abd8d317b21c0b366ef337a76256cfe6839becc117b8da623fd021c6968c2f42cf4b8077aca73411230508781db5c1155a44511c892073f652f22db35a0ed23d0ac60d395e8e723acbcb2398a083952fdc80e5734421249c23eb266937b28611e3a5d81cf8dc0ce160ff3cd6ee5d2bb3099a24bd218e9991265411ec1f08f4fa2ca857d8b708709bf5341915973d8da87f741681a6db57eedaeb4a9661652d76b24def3c7c7c6f0b98d226871485c147de2c1a2811ed56b48f1515f2803eeb5dbd572250362320a9d76b31404e3b752b8c7470622f7e6a99a2e53c87cb8a33aca4885ccaa259a848fdcde9cf3e457fc33d48566655460fac1b3b0c300a8c9964fef97552690dab8206fa6f4b2b059f16c69b11b5a51527bbdbfb39247da66c68fca53892279fc0bcf9e98c55603f4227799940cf3d91e7f955810814bbc5f1103362f9e1303c859ff43c0407deeef02bb491831ab632bca5b852eb5506cb2d0a09e8c7375035bed877d211e36c6a371f1422cc1e5df1b4615da566b292d5446667a384f32ec51622caaa7c189a2961f02507f90bd62ef583de780936a7eff4361afbadcef7009f4e3c96f66023e7e00dcef6da8f1b24fc020917bd917441c7bb32e42714cd02d1b873bde6db9a255c368fbbbe661bbc5fab131d8d7885e1a74a20edb9b71015cab7178a69a6df078d7289cc8d51293d1999e774f3ce3f2b02076bce892a72cbcdaa6c42d689fbd21689c735612bd8625478bcdf99be9fa256d85fccc00ff41ab302c61b9a57230aae1abeb297830e4156ac24c4f624f866325013151789786b78855dbde638c56bd9c19660b6dff9d7064d35f7b98418ce07817f77f7d9ed27f6336912df4d23dd09465b96cca586d2d7761065eed8d2db61ebe42fee1a6f98b443160f6f6247e38e2c789b2bbc65cfff076977de81bf2fc72f19969ff530b1515c4606cac71c0ae7662f5b81c473d39838ef60830efdb0e0b5db875f32d39c596430cf53e05652fe5a29ef9a070c5a3a6f6ec05a2e1a2dd74f33665ceed3dd620c96fb4e5399b3d95852bed8e1dbe5d10dc33615511932a52c88522a4c3c371def74b41bf86c04380521998117e8e17e25fc487cf09ef5951f107e320a5a698998851cb7b2a9b96abc33163812d39e0af0adc0659e43844a55ebe87755aa121810fc50d3f9847e41d62dd527987d5c2cf4fdf31bee1345aca9cae13bd1c7dfee9369b56abc865b436325602ed4eeba5bf488d2bc6776036fdfa4c4e361e23e18c996bda6c685215c50d80498c0646d6078cc99a82d37b1296c2abaf6cd456603761aa0b2fa7f33a34ec2d7446d294d59fc22cf567eb39fcc6e4e531a61011248c3623851cdf91b9b8aa0e24a28689ed68b357a534a89ae0c18eda3bc72f6bf888e4e8b869dcfdfcddaf992b073345f447a331ad058d3fedb3c38631feda210e0ac200249c4f0c535d77bf95e7154a098b1d8af53af79c7ccbebebed31ae7e41c326528d78a9e8e641c3190255fb64da61a9ef8d2107f257137a3174cf114decf3f45d481c05c14f7fe21ba90ac18393f4424f874bd3278577ba2ea2e1fc27af65a9dbe16f6131e0d508f3c99ce01d8af50d233a438d9ee50cbbc6de27bff00bd92caac988d7a25032000351a3f3035ffbf4bec01f2318dfaf6d4575890546aba154c9270ca1220fd925174b1c41a4c5046f27e5cd7c6e718394ac554bdc93e0dc83c2bb28c83cf10c68e248f3f742ad68044c2031614b5f9d2c1987ebbdbcdd72e69a3613d7b9915ede026d85d31b3f230b4c6699c872cb0c331004b2f36eb274925f25e2d4c2e64ba9479ae992176a6bf7131dd1c8adab485da6d7fb8ce1b2fd0655dea7fb4474021724393b2e7695cc63f6ea78a51795feb25fe6edf13d9bf409b7898da05d3343cabda46288e8a0904e7b4926a38ed25a43cbfd0e607487a7b823f7ff32ca3c3db9db41ca10c7cb0d15be8696fdcc4ff48a8d88099f7f6dd41ced08a6a734aa39359fafab56319387ad38b41d33c70258a2823433502ba6e3f50bf3440a58345dbc71d585a18543fa9a9382d864c0571df7bbf528bea6156c057615f3cdc155fc907cf250844b59a5a3babd514a282610089f7e1d3e9a9bb616cbd3c5ac48f12fa832e16e333a1c6863fbd5119f2531e81d4b0bb8e23ea008937f2ccb52431cba2036db7d8455a617084da04afc5e1d4348368b668817d9143c690e16ecd488b855284e0896d45835554fe929a06c2b8fa8a0e1315f558076346ce5254549782dcc609744cfb2d722a11535dd94e266672aee369ec2b3cd194313c7c4af5c0ed95ae71217318c2d99358adbfef00e1ccd4e4e7cc8ecbcc2fcada778016e979f5086bed7bc21fb4111d07e6376ce0e29195e9ff30b044b6beaf6dcf189b1887130d10ca4ccb8524da4992c5355c1de4e506ee8beb94c88dd466857af1bb7270b65ae426265b2ba4869afe99d344ae437142abaedfd1e2a4d7a33b911a1208eebbb11807641633ee87c9117684fbb5588f97fcccd1fc183db213ff56380a72261a4627a1a6f5d2615d76b51a4a4c12ddea603140b6a815f2fa388e51f5cec4ee0ace88c48b3a66674ea24980a28b75769b4864d3c5a7c31c126ed7a92ef93bf47d0a1503cd85bd7df3b7490924b0bd501c5d458f6b5ca15caa94cdbef0cb3ae1529c3bbf7a4140d6c7b4579d02253aa58f5b0d40667d7c4e9f895fca51a62a5f00b4008a4f36205ab3efe6318e7aac43e982155cf3c42bbe0740427a037afa9bdf21f3080677a43834d0c13889396628205672ba9d4f3dc56d0f77492a49d1a4839ef8582fb989e399a28e3cfe059959a33a5daf6138a920f1b571bfc7f71254cb4ef07316a551efcfca112798784f3f9e6066ad71dfa28ab26fb75f30e53f671b1857f120c33b52744d3ef8197810691491d82dc89bcd75f1f8a3a43970978b817200a876af71da03b75d611e3a5b063690bea866df06db799af9f7a3853b7662015f34c45af9ea04bcf21f0636e8ab5a9850d6487a9d85d474e601d86fe959691d952505e35581a9f4087b9896a81a7c57caa348f37f8108a0115c2d0ea9530653af823e56755b05898e0242677370f0daaf3225addff5d827a1fa3bbab873921c2fb98bb43f22dd939c12a1b585de18af018ccf22cbf575578835d282101cd3698999c85b9b6888bf5ebef96939d48c6d86cfc01b087b91d82c9d32af951f036d1c69e721feb9e0486d0b0dc845200fd4314f11e9638a6f7bdc0751b66409b28d954b2ef6bd3652ca9fddc9e91df3d2106b9f5c4094752727c5c5a251f445437b8dad2a08c67686d04c84bb6e1f9e3f0c8bc467e215d3a095ce1b6d304fe8b8917ed4684e2a184159d618af41180ae46d819fff39b228d2a345d49f87d1801303fc21ed70a7fd459197a63d7288df6dc09f88eb88dcf1712c48106822ccceee1dbb35d2e079b88a87fe971e20d2d345998cf765151b8238d392a6080f6cf1b7a84a804788be4063e58e16a7b8b74e8aab0ea1714a4f3dfa720c35dcd48b441925dffb1af42983e0b5f009cdd6f31bfa7f43a297d0965e5d2fb4fae692025d05d9d6004c38d29d0f50ffae829332813b7df9ec9866c15ac7ef1977bd865552534dc5344f32439168468e11e577e882c67d1e115b92b1a792d977ebb991a4e2da80e00654d6c8296a7b00966f99254feb7eea27a2d77a123d5f9aafd1f072042ac07ae2808af14fac3971e2cd83c479cd743bef02c47b0994aa63e72e088d1e505919ed7b011197e461718a6678277cc15fcb36038429a564380330f91069d972b82746fca23e7943a555b2d17d149e89e0b0385b3cdfe30e2800a732aa6e8364c3f426c582d158af19af9748cc688ca81fba611fc76c37bd56c444fecf9ccca217a6b6ba0aca29c7642a7b0c6cb07260c094ad6e966513bd318f4c7f57301ffe57e2e88c73282463885f6ca5118184e11fe015effd81df4389af34124dea6bbe055a9c4cc69be7ca8948997f11e0872fed840f793d087d23a8ed7b55629de47f866bbd5c5d54780a15f3e62646fc8f56c7a1419ee493b8d2aa8573a1dad430957e1a4b6f9c1f3aa9ef43dc6b8d9ca143873741b680ebfef61fee0d8e6714f352e4d080bc8ed3b18f5ab4b2c48c0bdf7c9a77de6ce505cf0a8a6696b3b9fe103498d5c260695c383be98d78ce66c95e72d10335e5d56c4e84534959158c18680114609a575017070d3f7e19fd85a4d59f820691cc19bd4a8743898c2424e1e2774437c09b51a8e93e1f7292b36e90f1cc1a7bc255edfa50da0669740d4c8386ea272c0b0691d3a1062a306b391d7f8cccfdf0c711735ac66eb16ff23d183f3fc38ef72427cd3e8fcfc707f1927a70afa60aa0071888f0588dddc927abf4cd80aefce5de106047340315d419c20708111820607e7d4cee6ef5e3ffcdccf5318ac46dd672b301da602ba7b298c3cb0138916b7ecdbd13b01792cf2c19715a21608accdaca30fca400f6aa27f4b0591f897698a4f4bde94fbd418118e544e3dc4b81d1a742d7694a4dafa9a66a24b40064f28379e0d7ef9967f6a58ac691204e3df16f6004093641e204e69d2e0a6ce4a1fed762c1790e2462e421caa5d0a19877bf961fe0b8c422f96a18c3ea0ea6c7eab37217c7d02c4065403418030c5810f13b938d84d098b9a1fa932496ea435ac8396930782a4001c83ce828289a10ef5fb8cb1a44a9b785cc73e7de3d4021946a77bb25ce86c9fb4cc452d379bd57cab4e922ca5aec45e1babff6c5fb33ab6eb297adcad851e0dc970da6f4a817b3e34954769135308199d0cf765eefecaeaeb36c273e5653a0d7881577c8bd43fdd813c4463c3d17cf51be0539180ab77605813e07ce1d1015de64fddf322aff963951738f5c6534f1fc6abec25d1bf6f4ecc1a06edffd4c8619d58b10da35cde9a162218353dbe71ae0789fe5aec6c84540a557d65db3d08b421cb29a3a6db53a973d9a0951a1ea69caff24a946d26305508dc49a659f576e70014e57231136c429f74bc9695e9ebe63f725431511ea9ee1dd54540e08d57c185ceed2d13084387d46a7b8a924c27959bd02f70f71946db0961b69090ca6c682d26d78352a59b4f6ea7e693471ccb028d53be5c69b0031030df80f42a385043fbfbba163613dfa8088c41f2ae081465c274e079fa0ca888c45a1100b8ae0caf0079d73ce6766065deeb4583e873b0da6138585b5069e1f0455434f28717141c6c8eba3fd9501ca8d91d7dc4149e469cdd5e39adc79303d77a94412fdaa1687deec342475f5b4698294fe8c3cd65301ec7e6021e67261ddf2eee710b80ce665f20a3fc7a2b99a36458e47288f59bee0c8f9ba7088449e0ceda553e8ce7357237f205fbc2dfbc40315ce4df204c8da9753d56313d7de8e779d4dc8b594b55b5ec0e2fff30a924f8643df877030961ff8fbf14361b5011827ea2c3a9a55447db75d0195dcacdc2ccbee0514bfbf97ccd950d20cc5c9f91dc7b5bb2e83281b3c5e51bafe8137f9ab97ec7beb57a137d617e93c362f6f176f40373fb1ce0f1828190763cba2fa719f4afee9924f2b8e347b38a2cbda299bca330b619341c7a9a9e3a676361acf5a4d5bc05201d66b011ff7f83694d7bd978197733adeea78d3a62b4e9e791f9e05c29474cb22be04dc2fd5bbcdc9fef78ad05c07cb5ba300babd146436b253f1473a6e089a69e1b8b7c6d51029af11c62bcd43b089144ffe25fbb6f47374847307d4553c44f75416df25b23e76426b1e1c3a32465a13d14964e1d4a11b88ecce939b773581fcdab70e8519fcf3f86a19e747793aa27e99f36ff81498d78367b12c07daacf12c65773911098b20bc7f45301fb82ff02c03b12d73a96e68a99425889f063f0f1175a7c2562fd3bc37e98c9cb4664c7b537d9aad0f735aed6d0cbb47e8e4f98a14178e4694ff77c7a003ce4c242c10fd06b7dd0d7e59678d1ee22235e7be8068b4619cc6bc9701659d1cc3bf11582949859cda2012565a0c3cd47cc30a60ac713d20641440c4c0a7a6163512fb98b156e8d78794a1e6a2eaed4aeb3914c82d3608d9e721377bb79602d8800e2014df16f900d137dc49cdc49a39a7a10ac97e51b42d324185a7d48ff495714b06d850b729ebf085db191a2e63f5cbe377869dff2e2d807634755948c66e5d5f449a1d5180569fd201b01087711f795e7170d57270a4316d414e19de8e33ff4a5a154fc490e1736b1a5b19b58d666959d79df4bef782fe8c9343358b534125e039cfd542ae2f7c0785aa605770736f65dd998299447acbd6f9ebcb57f7332f7ffc391b069f953cede9b86c4d6f34229813704238716b67271e8ed8e0facbcb38cff98063811c65efe9d8a278127175cd94cbb111b8b987875f2793dd2c10fcd1f7c7baaf28ad0a30b9f8c885b6b116c00dd96094d41645c8d335c4ca75bcaa0ee2343ab59c7c3f002ca87d7da646d2894631e1fff0222ee28ac2631f3164071613e5dba98b352ca3b3578be6159883f4b368bcdb0d0d25946675463cb3e876ce2e0aab64797f645d351570418caf19ecb036e58552a0621167ec367233285c9247046cc8bea6d4a5e74a1e0fd189dc8399ee526ac349c5c7c56b5d3fe3c25da0532e0782555889b2a71d91d6e24b55e512073d3421e3374c514b5fa736f7ba121760daec5f535175145f17f6ba321e1757432658510a1f39f25bfcf6ae3b7e38aaa8e43dd55b5a79e7ae2ce32f9924caa356de121c6dcc136bc440a4f44724703464f4af59d478a95362e96d4b9e25aa6b3685ddfd978dd005776913f697dfce472c9e66404ae39b49e1812b70595a9c6c09749881042780ae7acbb03adac83adda4c52780a35f0dafcf562fc9c9fdeae8444f6881f114fbc58e0e03dd376131c0a9f7e588b8b5843b9370be86e890ec0ecbb47bc9b3eb9f27f514fe380036a771e6f7423bc38978c742db5c1bf9c455164b31f74851573f618fe8606c7c7901d68142fa835cc39109ca497fef5b91c3668f84563dd7e6405e42347e17d2b61d57c4e52af60bc620fcf07a880eb43aa09664437d9a56369701a032a3d462a95f1a634ac54829d2e7faaf5a201f290aa95ae2eefeb7049445899d4df9f5558b8296ff7fbfaf16ecd05deb27e4555044c2772c51bf5c9ff6570c9991b70f3ab21450d9b75bb955c169feaf9bbc8a150dab2f296421da78d68bed9b59395516a0db9c5337781e9d41d02eefdc500e07d616da1ebb2b17787fec59edb3e6bd2baa4f5ffd30d294b085b4879935661669c87a21e8d3be8fa8ab90bce99bfd921438610effbe8009034e51c5b345ab66bc418cf233ad79c9d2c0922688290eae58c434dd73fc9975c48a14f0f7c07d45d991a210efb70fdd5d1eb9a6f6c078af1ee29fa84da862123b09685ffddb5851f8f78dcd470f277f3003ae87d41733bb4c6bbb97a67cf0b4cf9bdf7f9faea6b03f8d5225ec9dc767096a1931b403cae03fddfc511a3a7e1932d77456e937b8b8f00db4f328f3510b935918e60f799f11ae5a742869fd2b15033117fd1da12fe9681c53da23ca4c1178fdfc2e93a8c1c629fd7b6aeb15532851793b94136accf9227c9954e5a16d802c24c487d345ed0b4720aa2271694cbd661f1ba2b7789a0a62bfe32860baf90108ef0f605d13505032e466ef90ecbb915cd1eb04f200e4ee71fad73064f25ad444987244eee824893ff50128cc7370b8a0804eb911bc54c9cff7fba2b09a602584918221be33a26359c698ccbbb27951ae96bc7e73ee560910ccae68cfc0445d3c7e3ce5534069ad4ae2f0d4a966c83b3dc12716ce500eb52775ddebca260d9e46a3ff2b6d4b29bb48d40b94f58cb54be4fe74356fe6d3b4a874b95847bc7e99f80e0ee3e67878dd01a7e3e58f656c17caa773514b6f4ccb7e99bdd1003d45947b76713454747b4540766a8a75cb3f848886d95402233645a621dd4b471daf0a1d9c87835b7769c5e51e0d1eaf4c77492c03922fabf8aa7c3a5f93988fa3882eb36d885643e7dca67749c5b242f046d5b0987df246dc8480912d6ad88b6e308c47a5429e549b8819f3ba2e56a7f15d1b9cc8fad8742d00aae1a7afccff06deab68451facbe00a71f8ab26af68df322410b2befb5926471999538dc281c42dc631d5c1a6beebd88da5b13b10f03f8b613113cb6ff56e93c82e6c317ad8bbe4aa2ae7d6145b3cb693754aa5e057ed550520285c097ddd33409248279fbf769acc5000f88e3715a7100b05bd40c59732fc87e0e7bcb20539b04ce2fd691c23dc7220632fff3944d6cb9538fdec5e48d2ba80362c55deabaa4509e3b380c0a43cd149ee1d73fbcba318e541fc9f9145c5795ea5db5ca0ed25ad36f47c88cce583c9c51e37b185195f18d08b01ced61a4626341f1192e87dfdc1784ef1a4f30395506466bbd8c82ff1f70a2a9e44d62b25a2b418fc7fe1fa47d4c93cbd8c6fd4f0ba3589747687e46c20cbb6ba6d52c450e3c597acbe442d5b9a2c729db7d95f94e018c6107312c0c9c9c5bc2abeec05d18af859f83728ac9f0a308a823c1f6f1a4b8a1ffcdace5e0b53fa90fe4b97f0c22d8e57e0e3f92c9fab22db0023da5ff31052c6377d2ba6d79cc43f197fcab3ff524e2364e20d5b1b4529dadff4147b6895496ca249cb9fcd7c2e7d5d05c447d344ec149003fa4841180013524add71f79239d96c8a92fda435564355343d0fe25a60872e9427f250918209b2461111ebef2508e642eda0202d028f7484359529ed6a1ff424fcf9bda3ce513dd13004d9ac3605476512388abf8732fca59e168c0024d8eedc966488c706a87164e962b4b2df128fd82a5f41f22402ccc7796117ff0bce32db792deacdc50e00a58ce94261829d8f087ee5b299ec7188c5e4a3a3fc053c64e0d4ae3fdffc86f889119a985e3951b966aa7715a77809ff377d4e2209f03e63d5de295a10bc766a4054b9375b352b871dbd7e539bc26ff8bb1ab051372e0461321be52a076a40e792c20daafbf71b096164b1d705e89932d9e55f52d6189d3d724bc36ae313ae7aa74de2ec4f80c7ae55ca9e08f83b1796fa3d6e8ea7b3d2a34f2926184d0bd86439b7c84fc4994f4ce234f2aee0a8d3a209a0c61aed2a012ffcebf340985dd275b01434fc90f8b16e56810945208c501e52ab60f7ea3d33ac81e65152c191ad6b73948fbd229462b894edfa97ab4537f89748a7653302cb0f28864e057cf69081f4409f586d51ad4aa8ab75f2223c128a3bdca86dc3ff33bba36ed5eb0f0bd4b191b3b4489996a794b5eecd3102e7374957b8983be86a8b60f66cd840af2e88223c3ca4ab72b64d9c90aca2a7c2495dd9ee5847fe8fdf9341e23a1737b80c90ff3ad25dc4e286adee87d36c24ab35abcbe9ca62d17f3397b183eb0efce8ebf8e3bc052a2d45a439e4f91cbbf30e4d1d4833a83f786be327fd6e6e826b90f7878ce6fef0b2ce38a1b5ca6816e8bc8d750d3aef7043da3ae998126a14c2535785f3d30ca4261d3a6a05d937bb48cc6fb02d48cb3ba5e419e82f047c26c30c842b8fcea903f6f54372ce8a255fa6561c6a77f4e6784d6c85a104d1815e6d350c6e30a1bb246ec1e1245fd3a251474f2b7a1a41bf42ddf7c324ad2eb0309b1c9b583f3746051bb1ddada666521ffb309da4743c0623a5622630c07bcb5b17b6e2d5cc3ab9a83d640de152d935becbfa6818df879216b24d92f219f56d7db2f45fca61899db78f458107e74dd547aa81e02b96d8544a8ab4814a7ef0c4f7b2320db39365cc67a0f0851a3638a373e35120a29cc30906612e49754bebd3ff0ad304dde32a9377a62e9f0c603338ce9eb9eeff91bcf6d33933184c57cb84dea1fbc69fa96011cea0f2eb5caeb4a02e079e2315efaead6260e7b9094c9067b49dd377d7c241ccfedb709ee23a46bc23a03027a13cd99d4a2f0db737d37377a3b9dccfc6b5ecc5d7bc197ed919f47e63efee5073d7b45c6fabc16c4c0147a6477cf60d1c2166a64bd2f0c9cf21dd88998f4e5bfe21c9f5d8f9af6e39499b45f262bbaa7794412bcbd2950527fd6a0045a55c567d18d3dd2865af26ecb3be009bde47cdcaceb26c0eb8a6e6bbf72dc1d10c5c59dfa4575c7c74e4f8df917feb78a444e73dd3cafb69fb94d1bd115676e4b03c7c0e19ac06a0ffc6f6c43abbeceecb9e0b8f0ccb806100a669f848953b24ea6dbb8203cdffd1db417dcb139d4d3544b02a0cc3ec7cb4606ac0e0955c63ad25391d455a8c69472fcab9c67e145b9bdd1b4c4f9a4e8a2ae94533ee4c634148482636d911daf4c375afb1bb11dcc1400af0a65ea95bab73e675775b8d90de551a1f2bdd0aac0dd51139826adb746eb0699135600e39c4cd863e8dce48272991025cf0aaaa4d5c8abfd769672bfe29c5acb64723d0e157b0b4a1e7d8fbc4506318511e795b1eb50c160958e9089f1e7281dfba9ee3abeb2381d829eaa9feaf43b9304961c96dbda2efb23e5be28b039967e33143cba0ff305cc50bd8f970af76f1687a0e86589d5e6bbdf0df7a53627acf9464758b410175352de15d8e057693ecf549d4b3c2bd0ea3cb0fafe16f7ff6755d90482076708e01f0feb8bbe4ec3a19a17332ba30e91ac9b2ec52a2a0571dd40e516f7c95492c6ba32777d387a3609b2718b77208869c3038203672f10fb75949c9799e80f23b9c669741a2b07e03a225d09133cc72f6d94316c23e69a994d22fc46adf46e48630c59e4dd5298590e08bb6407c1f08a1d8a03b0ae8dd441de5ff66beed0bbb3f595abdc746c39e09fea186203f994670fce87b659c0e7abe908127738f0babb82e0810abf35c13136578ad14a307d751004318cf41fac09eed562bdefb6902e81649ce947e9cde9805360acb8b09e25015467d8d11efa12df5151b4edaac88ef412b4e33ae2f01b628ad4a5eab81b678a1aac3b096d29996f7335187dbb184c6829193536bb4cefcf6e7de6c25d31720eda28e933fe1279cea74c60abd58c30e6c27a9c6f1f2d3ce71458a4119ae5be6929cd429a8fd8119e54a0ba18718a68077f7a345b3b19c9cd8fc5f41c995ffb07a7208caabb3188a4952eb810728394fc3f1ec2be74c79948aabf5b248c23ec0b43dd39bbfa866ba243437e69bf73a2f7d5cd29ded24910fe0bca1df43873ec648d707d133350a455d97686add4c51f76f9dfe8a16e0aee7dae2d877d55533c51bc0b6ed28293560356252b07c226338b7d60df15523aea7be442d2e08ed6b10ae0cd271fdd0e82561077b5862241db915795570346f01bcf6df202535fbcfc96353768051051f35a1f21edb4ec4101c4a7aa77f77ead210e1830e7765c181efc61b1243acb5baa2e458cfe85d5311fe3ba571aa84402ce92c029a1c0b76b2f044df76005e9467d0d2b2b79bb232857857b7e82c3afc4270607c59f6fd47c898276e2a7b1e1baae894b63e0d36ba486bd35a3997d9366bfc97eac0fb8a9d80ef0857020e351b0fdbd76354b71126e4c89046799240438865fb9475140204c9d4f2e2c938f29d1fbce1b17d6fc9bdb6055175f296e31c8e23b057107b0a75e19bc2be9c0172bd33878f79bde0fe311b53db4031b5c4c568c09369eb4192b34b9945320704c5070ca04c56d13653548b42243caf6c92cdb3cc63fb31c61517e739d23fd8c110fb748a64c7257b1e789d1c976879e9121cc706b268efbb847a3e124a4a24742bc1b966193e462e1335031a012843d143135c3b8cb6017f7dbf1dcb4e9b791668534988648b36090c432ffa526acac56aa7686afa1e2f7b0c4d79dbb9e4c7f41b3eeff433556af3aa35295cbd598f5ee6f7c612b1a9d7baa436d1db2aa9b88ed75dba340a782cc177391cffbd0527ef7c211ba4a64e027474cb30fd1d52d5bd7d4b78eb5ceefe9174e03774317a325beb7fa30b7dfe20cfe1728c964a66dab0637b9591b31d5ae6ad2848ed3c6b4c3eb8f42a638aadd81916020f0a730d128f63e97f50a931e109076ab1a2b14aabd30dd574153bbcefc6c0d83c01d213845f3fa2681095840081102b175381585cd8d6a71a2903f2f8ed104a5ff06278b050970eef9852758f1fa3f3827b3433ed17b28fb999c40999054fe1ccf49d51b3ba5f49ce36506a59d19b1c1b96bfbda913cd685cad1961ad306a0abd7d98db471542c913fea913c333b356aff9fd712d4d27ec2b651fe8b227c1f520e03c2bcc8a1a5fcfa5589997e1f5153ed297053682e6d01473ceeadb581aef136db1b73ae880e6cc8b816fdac5f1d68fcb22cb02d65ce9c520f07d12b95b85fa28d2c7402a5ebc7cbcca28e86258bf7a8d58051a12dc0a6fcd6b04261ec36530fab0ed2b245cce2c970120aba6bf29d68ba80e50caa5648d7bcccbf3607faa6a4ef7c041d86cb2b6e28ebb3dcbbbd1eff96c99c2b4749a6260698ca90ff0fc9c8241833ba9f8b7a44eb763af872a8ee0c105113f5f093ecb6300f63129bcba8b81c7b58da186928f0408b67a07e545895ea523e8d3f34ad57415525827730fd6cb9c1df2d72964d7225174a7541227973445363bcd758e73191a13988d3945b57243dbb5f8d1ab9c9e410f9f387e1fc13516ffc65dcaa1881e239025fa7a661c0010066e1b68dd44789a6111c8e39c2ba5eb3650e0c9beb962cc42c730c70d744b57fd56eb11152a3184507aebd12a832f04ecbf7d99fbd22a109ac8f04cee24dc4f701267144baa0c3603e83d99f9eb2830994a6ae6855716a6ce985debdb6b2009a119cd1557e94da1e1cf58390c7e381fd456ef08cbf626158b2ad6e24c7b8021f57595c42f39c3cd3d9eb1c4e9a3abc0a6f682d1e34384c737be3e35f9e8a519942d865f18d8bab88968966fc92d7bc13b41a70314f383c65f9d7a9823f108ef2988b20a0c1f86287dc7c4478bc0f30641b6d1549a6303a99e37873bcc5e6e892453f98fb74f3be1b08b89cb5a3e05316bc081f5a6dd789f87d1c69652464a445026557265464979b5c771cbde8ba7bc41c8639a821b6432e9b9b6357099b6563a3c18e68480662a54e94e1dd30ec30f8b69de653f3e21b5d0ad7f30cf49397ed2135f9a3cc78002166fea5d64f82ffeedafe78f52270fb082c093120bfd1f37a38156b0c7e21b13609543e9003bda13b3f4985402c569a2a0e87f97ba4c388f607ed76c72b63042bd75e6232645f891dcc8592e0aa6067d0edaf5f7e6e12a8d5aecaa4828151ac23a826e66c76d1d39cc0c3e42be2e6e9a962853b500b3ff6d0ab57c8301618e34b41b252d15a88922cdb2e5a0efcc3d8bea91b8780f725c4efbcc830ec2b157ca15f066b50745e21b337726a8774a22ade98a9ea268c35ecd13b180ecc9abaf6a39dad0aa7d3d4016a5393d1668017cbd86dbdc47b9c6ce42a17bca41da6873b1f39ceda06cee99eebda76739b447bfcd6a93b20711303d4abf2707da80f2d14e3c36a05651d7dfdcef76754973dfcc1726ab8ac15b476834eda099bcdc4c7c2ea05d14eb29c83e934fbdcf3e71085febf06d0404e6b1b7d5edc6f06323cea9d8d8383ca426ac3c71fb43310f0c375133d8da84dba3af762f5e67586fc095ad8467dc90347382628845dacb7262d0956814b71a075a20e104984ff351f7f32bbc22d05387d7b049e3962e9916e8ad513165449cdc854a0b2784974da7b4191ef03f6478e894d11f4fe289ecc5a11210c5b6067fd2818592c2b8f263a5810e1368196d20d202d2400babae6bbac2ef5327a40ea52028a30c558af25126ab39ec84d25581b142654a0eff7f5d1240b00cd6d8d2818d5dc2544dd399f6a826d23a5c82ec2b0f375578d99b99bfdccb75f2088b54f7a64549df9d5b82fcc970c1872e91e95766d367e0363d6bb959144bc0fdf0a3e51c0caf1b3ccfab10c303482b54351020ac43e7b7a05e2a422f6b3193176362e6d351250a3bacb962aaa11a31ec6c6a85aa85bbbd87ddd87cd459492bfe03536a439670309b0f82ce70fe2d601c1a406dff4af467c437b38dac2679ae565cd803a6cd219c7e088a3bed88ffdd29d71e1a113e8597752c36d4531b28d8e7557b6e49d51c53c9915dbe7c0974a49bff0e46b87026f5fdc81b263245a2045e95611ac2bf21454b5de00435d51553c5f5f723274d9c0fa05ee5933ef6d6a7ce2ae9fac3a779c5c0e1bc49bfca1ab6c8bf1ee95030139a87b3d71f84ef57be2e6dff4f42f92bda77ebf2ed2f4cf0146a9aeaf0ba28e5436b98fb98fa240a12dfe71cb311a3ca23f4de19d332fc803a1c7de02033a563465854feaaff0f5b738b0045ad32cbb8a7806d29d3d7ac58857bae72fc194293da2de039735d9823fe9a5af59ae5826ac011f426eadc275634c3847c12cca61f8b4260f5001a5ab488b8e2ef9c12498ab4f5c3039b71129aa07036334cc03b4aefd8662a9f51cd9adc560748da6d1a0d11d42eec0d28f22684f8eb31980669bdeb2af48a7f34db81415b65953d4d68503340097bef9dbb85a9eb4975a820dd7f651a1ec038ea897347a935412c2427345e42f007b93523ff699abb94a53f722f069cbf6da15c2d27531d7282972959a276e756288048455cd98713ca611af10a49dd97c1623511acecf586abcb08ec29610f4b62b72238a287bb57790aaf68cbbbb41f8b79f634c95c952140714e2e1db1c05dc4f56597f641422e1a352c8f05b0ffb3b9f02bf2a1b6194ac203d07a39dd7b5c8ea3a7f18c7747d5af5377de883fa243a0714db0573f6ab5451c4e0fa063541f4838802f8ab24cb3f5bcc34f8a32106934fed5bab1f393017f306313cbfb1fdcf33967b4af00aca4027f64003101d92545b0a43901b638b086c421fa5362e35182a01121fa37651afe2c1ec1d2e17721cac4ab6c7456628e5c58a0b123294539fec5ce46b67c5e6893768c8d386d954674f7237f496540f73743ee515da3e44050a0a675d2ed99797062fc756a26bf874421c9d8d0140c7fb23a907d5f894241a78313a5b3984b6807a95d4bb47753ce59c75bf576801acc63cc829eef7674b9002094f0067e519915b25f48e1e265299b2fd69d543c3c328368a6b9de0d4cb6c1a87d99bbbc88e4a8dad4bc0fd92ece7c1813f8fd304561e13a1866990ff30960e5112679c556e43de26caf8f3ca5dc40de4fabfba5b713d696bc1df9082e662c7e80aa1d6be64f4acdecd4ca8ea7ffe84a1e8e65d4f735ee687e395b208772fbf4b267c9f4a1a0393873be077d6b0fa276e13b4fb924b85b4764b8c9e5ee8d431adf99691fe6cf8ef10eb840bbea7cae998d9fe614baa221d11e7cffbbc1ecab36ee6d8b0083962a5178817a3d11481809bec7b6352e22b38c62def735b2c57f73b53c15c5a4f718032589e0c3dcfa23f7ae1921ae238c1b4c45f5aa8147bb905d623636e4d94fabd4643cc1b158325c9b1b908c07cf8a476c622bb69f910bd996bd85694bc80092a7cedb0e8fc7952c9fd0f74684ed57daeec639957365a10c78485cd445c76f5689094da645dc7dce22a8158d19a2e9bcaf8cb0ff44987291c1676d9c943fd1cd7c8a3e2a900be31dc96d967e93ae8b2248311ca3f554b4b95ba545825160c72e86caf36f3b7b5a8d0277342a7bd016bb40d4d8c2d4bd3047c8ff233e0d794b5d501ca2a97b71a3cb752a4dc13315c5c6ea45c4a7f1d88e3074eb2961bb349f139ac63d4bd0302b8b3c3473bb8afd8c14428ff9ba3bd9c78b960f0321fefe10043ea6ff5035130da645e2ad87531f6ea2e7f19bd774437e8129151f722c9e5e87b7643ccdc511bcc8c4a95474b7f59c94cb974ef363cd82ad174d308e2d94f7cdee5cf7cb05c57562df2fd69613d1c8b4e1d5c670d3963ec0561ab016d8cc946fe2164cea6d3e823ca2c78766245e13e77b5449f9194a2dd10f0ed21723ecdd03721e5ef7814ada1b6fb3f380c95462fa8905f8c5376c8a9d8a1424f209e40a3a56fd9229d8203fcb7446b9fdfb3c14226b5a14c31085d15714ed21ad9f00f64824083e5cc0bad0a847a7c9bc3c506b792cf6664eb5073bf5e49d55ba187bff4ea52d8d654b64dc95d765b30ad94c4eb2f2244ac9e8eb9267f326da9ca5cdeaf783e41382503f7ac5769e9d94b36a8483b7ed9f7d78ff7276d58680</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <summary type="html">Here&#39;s something encrypted, password is required to continue reading.</summary>
    
    
    
    <category term="计算机专业" scheme="http://blog.zhuangzhihao.top/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%93%E4%B8%9A/"/>
    
    
    <category term="Operating System" scheme="http://blog.zhuangzhihao.top/tags/Operating-System/"/>
    
    <category term="极客时间" scheme="http://blog.zhuangzhihao.top/tags/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/"/>
    
  </entry>
  
  <entry>
    <title>机器学习（上）</title>
    <link href="http://blog.zhuangzhihao.top/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E4%B8%8A/"/>
    <id>http://blog.zhuangzhihao.top/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E4%B8%8A/</id>
    <published>2021-09-22T16:00:00.000Z</published>
    <updated>2021-09-24T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>机器学习是人工智能的重要技术基础，涉及的内容十分广泛，涵盖概率论知识，统计学知识，近似理论知识和复杂算法知识，使用计算机作为工具并致力于真实实时的模拟人类学习方式。我选择的课程是台湾大学电机工程系助理教授李宏毅的 <a href="https://speech.ee.ntu.edu.tw/~hylee/ml/2021-spring.html">ML 2021 Spring</a>，这门课程从最基本的观念讲到最前瞻的技术，重点讲解深度学习，同时新增了 Transformer、流模型 Glow 和对抗攻击等最新技术内容。以下为所记课堂笔记第一部分，包含机器学习基本概念理论、深度学习和自注意力机制，可供参考。其他部分笔记详见<a href="/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E4%B8%AD">机器学习（中）</a>和<a href="/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E4%B8%8B">机器学习（下）</a></p></blockquote><a id="more"></a><div class="img-wrap"><div class="img-bg"><img class="img" src="https://cdn.jsdelivr.net/gh/Bezhuang/Imgbed/blogimg/李宏毅机器学习01.jpg" style="width:500px;"></div></div><h3 id="机器学习介绍"><a href="#机器学习介绍" class="headerlink" title="机器学习介绍"></a>机器学习介绍</h3><h4 id="机器学习基本概念"><a href="#机器学习基本概念" class="headerlink" title="机器学习基本概念"></a>机器学习基本概念</h4><ul><li><p>Machine Learning ≈ Looking for Function（寻找复杂函数的过程）</p></li><li><p>机器学习的分类</p><ul><li>Regression（回归）: The function outputs a scalar</li><li>Classification（分类）: Given options (classes), the function outputs the correct one</li><li>Structured Learning（结构化学习）: create something with structure (image, document)</li></ul></li><li><p>Regression（回归）的 Training 过程</p><ol><li><p>Function with Unknown Parameters, which is based on domain knowledge</p><ul><li>Model: $y=b+w x_1$</li><li>$w$ (weight) and $b$ (bias) are unknown parameters learned from data（模型参数）</li></ul></li><li><p>Define Loss from Training Data</p><ul><li>Loss is a function of parameters: $L(b,w)$</li><li>Loss 用来评估未知参数准确度 (how good a set of values is): $L=\dfrac{1}{N}\sum <em>{n}e</em>{n}$</li><li>MAE（绝对平均误差）: 𝐿 is mean absolute error: $e=\left|y-\widehat{y}\right|$</li><li>MSE（均方误差）: 𝐿 is mean square error: $e=\left( y-\widehat{y}\right)^{2}$</li><li>If $𝑦$ and $\widehat{y}$ are both probability distributions（当预测值和真实值是概率分布时）：选择交叉熵（Cross-entropy）作为 Loss 函数</li></ul></li><li><p>Optimization（优化）: $w^{\ast },b^{\ast }=\arg \min _{w,b}L$</p><ul><li>最常用的方法：梯度下降（Gradient Descent）</li><li>首先随机初始化参数：(Randomly) Pick initial values $w^0,b^0$,</li><li>再计算该点的 Loss 关于参数的微分值：Compute $\dfrac{\partial L}{\partial w}| w=w^{0},b=b^{0}$</li><li>当微分为负数时，Loss 关于 w 递减，增大 w 使 Loss下降。当微分为正数时，Loss 关于 w 递增，减小 w 使 Loss 下降</li><li>随之用微分值去更新参数：Update $𝑤,b$ iteratively </li><li>跨越的大小通过学习率控制，方向通过符号实现：$w_{0}\rightarrow w_{1},b_{0}\rightarrow b_{1}$: $\eta \dfrac{2L}{\partial w}| w=w^{0},b=b^{0}$</li><li>学习率（Learning rate）是一种超参数（hyperparameter），记做：$\eta$</li></ul></li></ol></li><li><p>Linear models are too simple and have severe limitations (model bias), we need more sophisticated and flexible models</p></li></ul><h4 id="深度学习基本概念"><a href="#深度学习基本概念" class="headerlink" title="深度学习基本概念"></a>深度学习基本概念</h4><ul><li><p>足够多的分段线性曲线可以近似于连续曲线（Approximate continuous curve by a piecewise linear curve, to have good approximation, we need sufficient pieces），使模型更有弹性</p><ul><li>分段线性曲线（Piecewise linear curve）：a set of hard sigmoid 函数加上常数组成，分段线性曲线的折线越多，需要的 Hard sigmoid 函数就更多</li><li>Hard sigmoid 不能作为基础函数，因为折线的转角处无法求微分，所以要用一个平滑的曲线做为基础函数，也就是 Sigmoid（S型曲线）</li><li>使用不同的 $w$、$b$、$c$ 参数可以实现各种各样的 Sigmoid 函数，$w$ 控制 slopes ，$b$ 控制左右 shifts，$c$ 控制 height：$y=c\cdot \dfrac{1}{1+e^{-\left( b+wx_{1}\right) }}=c\cdot signoid\left( b+wx_{1}\right)$</li><li>Linear model 由 $y=b+wx_{1}$ 变为更有弹性的：$y=b+\sum <em>{i}c</em>{i}\cdot sigmoid\left( b_{i}+w_{i}x_{1}\right)$</li></ul></li><li><p>当模型有多个 Features（自变量）时：$y=b+\sum <em>{i}c</em>{i}\cdot sigmoid\left( b_{i}+\sum <em>{j}w</em>{ij}x_{j}\right)$</p></li><li></li></ul><h3 id="深度学习"><a href="#深度学习" class="headerlink" title="深度学习"></a>深度学习</h3><h4 id="机器学习任务攻略"><a href="#机器学习任务攻略" class="headerlink" title="机器学习任务攻略"></a>机器学习任务攻略</h4><h4 id="类神经网络训练不起来怎么办（一）？局部最小值与鞍点"><a href="#类神经网络训练不起来怎么办（一）？局部最小值与鞍点" class="headerlink" title="类神经网络训练不起来怎么办（一）？局部最小值与鞍点"></a>类神经网络训练不起来怎么办（一）？局部最小值与鞍点</h4><h4 id="类神经网络训练不起来怎么办（二）？批次与动量"><a href="#类神经网络训练不起来怎么办（二）？批次与动量" class="headerlink" title="类神经网络训练不起来怎么办（二）？批次与动量"></a>类神经网络训练不起来怎么办（二）？批次与动量</h4><h4 id="类神经网络训练不起来怎么办（三）？自动调整学习速率"><a href="#类神经网络训练不起来怎么办（三）？自动调整学习速率" class="headerlink" title="类神经网络训练不起来怎么办（三）？自动调整学习速率"></a>类神经网络训练不起来怎么办（三）？自动调整学习速率</h4><h4 id="类神经网络训练不起来怎么办（四）？损失函数也可能有影响"><a href="#类神经网络训练不起来怎么办（四）？损失函数也可能有影响" class="headerlink" title="类神经网络训练不起来怎么办（四）？损失函数也可能有影响"></a>类神经网络训练不起来怎么办（四）？损失函数也可能有影响</h4><h3 id="自注意力"><a href="#自注意力" class="headerlink" title="自注意力"></a>自注意力</h3><h4 id="卷积神经网络"><a href="#卷积神经网络" class="headerlink" title="卷积神经网络"></a>卷积神经网络</h4><h4 id="自注意力机制（上）"><a href="#自注意力机制（上）" class="headerlink" title="自注意力机制（上）"></a>自注意力机制（上）</h4><h4 id="自注意力机制（下）"><a href="#自注意力机制（下）" class="headerlink" title="自注意力机制（下）"></a>自注意力机制（下）</h4><h3 id="机器学习理论"><a href="#机器学习理论" class="headerlink" title="机器学习理论"></a>机器学习理论</h3><h4 id="Theory-of-ML"><a href="#Theory-of-ML" class="headerlink" title="Theory of ML"></a>Theory of ML</h4>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;机器学习是人工智能的重要技术基础，涉及的内容十分广泛，涵盖概率论知识，统计学知识，近似理论知识和复杂算法知识，使用计算机作为工具并致力于真实实时的模拟人类学习方式。我选择的课程是台湾大学电机工程系助理教授李宏毅的 &lt;a href=&quot;https://speech.ee.ntu.edu.tw/~hylee/ml/2021-spring.html&quot;&gt;ML 2021 Spring&lt;/a&gt;，这门课程从最基本的观念讲到最前瞻的技术，重点讲解深度学习，同时新增了 Transformer、流模型 Glow 和对抗攻击等最新技术内容。以下为所记课堂笔记第一部分，包含机器学习基本概念理论、深度学习和自注意力机制，可供参考。其他部分笔记详见&lt;a href=&quot;/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E4%B8%AD&quot;&gt;机器学习（中）&lt;/a&gt;和&lt;a href=&quot;/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E4%B8%8B&quot;&gt;机器学习（下）&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="计算机专业" scheme="http://blog.zhuangzhihao.top/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%93%E4%B8%9A/"/>
    
    
    <category term="Machine Learning" scheme="http://blog.zhuangzhihao.top/tags/Machine-Learning/"/>
    
  </entry>
  
  <entry>
    <title>操作系统（下）</title>
    <link href="http://blog.zhuangzhihao.top/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E4%B8%8B/"/>
    <id>http://blog.zhuangzhihao.top/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E4%B8%8B/</id>
    <published>2021-09-10T16:00:00.000Z</published>
    <updated>2021-11-30T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p> 操作系统（OS）是管理和控制计算机硬件与软件资源，是计算机上直接运行的最基本的系统软件，任何其他软件都必须在操作系统的支持下才能运行。操作系统是用户和计算机的接口，同时也是计算机硬件和其他软件的接口。操作系统的功能包括管理计算机系统的硬件、软件及数据资源，控制程序运行，提供人机交互界面，为其它应用软件提供支持等。我选择的课程是苏州大学的<a href="https://www.icourse163.org/course/SUDA-1001752241">国家精品课</a>和汤子瀛版教材，以下为所记课堂笔记下半部分，包含内存管理、文件管理和设备管理的知识点，可供参考。上半部分笔记请访问<a href="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E4%B8%8A">操作系统（上）</a></p></blockquote><a id="more"></a><h3 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h3><h4 id="内存管理概述"><a href="#内存管理概述" class="headerlink" title="内存管理概述"></a>内存管理概述</h4><ul><li>内存管理的功能是为多道程序的运行提供良好的环境<ul><li>内存的分配和回收：记住内存空间的使用情况、实施内存的分配、回收系统或用户释放的内存空间</li><li>地址变换：将逻辑地址转换为物理地址</li><li>扩充内存：虚拟存储技术或其他自动覆盖技术</li><li>存储保护：由硬件和软件配合完成</li></ul></li><li>应用程序的编译、链接与装入<ol><li>经过编译程序将源代码编译为若干个目标模块</li><li>通过链接程序将编译好的目标模块以及所需的库函数链接在一起，形成完整的装入模块</li><li>通过装入程序将这些装入模块装入内存并执行</li></ol></li><li>源程序（名地址）-&gt; 目标程序（逻辑地址）-&gt; 可执行程序（物理地址）<ul><li>对程序设计者来说，数据的存放地址由数据名称决定，称为名地址或符号名地址，即为源程序的地址空间</li><li>当链接程序将多个模块链接为装入模块时，链接程序会按照各个模块的相对地址，将其地址构成统一的从0号单元开始编址的相对地址</li><li>当装入程序将可执行代码装入内存时，程序的逻辑地址与程序存在内存的实际地址，通常不同这就需要通过地址转换将逻辑地址转为物理地址，这个过程叫重定位</li></ul></li><li>程序链接的 3 种方式<ul><li>静态链接：在程序运行之前，先将各目标模块及所需的库函数连接成一个完整的可执行程序（装入模块），之后不再拆开</li><li>装入时动态链接：将各目标模块装入内存时，边装入边链接的链接方式</li><li>运行时动态链接：在程序执行中需要该目标模块时，才对它进行链接。其优点是物理地址便于修改和更新，便于实现对目标模块的共享</li></ul></li><li>程序装入的 3 种方式<ul><li>绝对装入：在编译时就知道程序将要驻留在内存的物理地址，编译程序产生含有物理地址的目标代码</li><li>可重定位装入：根据内存当前情况将装入模块装入到内存的适当位置，地址变换通常在装入时一次完成，容易实现，无需增加硬件地址变换机构</li><li>动态运行装入：允许程序运行时在内存中移动位置，在程序执行过程中，每当访问到相应指令或数据时，才将要访问的程序或数据的相对地址转换为物理地址，可以将程序分配到不连续的存储区中</li></ul></li><li>在重定位中通常会设一个重定位寄存器，用来存放进程分配的内存空间的地址（基址寄存器）<ul><li>当 CPU 需要访问内存时，将逻辑地址转换为物理地址</li><li>物理地址 = 基址计算器内容 + 逻辑地址</li></ul></li><li>逻辑地址和物理地址<ul><li>逻辑地址是指由程序产生的与段相关的偏移部分地址（与页无关，因为只有段对用户可见）</li><li>物理地址是指出现在 CPU 外部地址总线上的寻址物理内存的地址信号，是逻辑地址变换后的最终结果地址，物理地址空间是指内存中物理地址单元的集合</li><li>从逻辑地址到物理地址的转换过程由硬件自动完成，这个转换过程叫做地址重定位</li></ul></li><li>内存保护<ol><li>界限寄存器方法<ul><li>上、下界寄存器方法：分别存放作业的结束地址和开始地址</li><li>基址和限长寄存器方法</li></ul></li><li>存储保护键方法：给每个存储块分配一个单独的保护键</li></ol></li></ul><h4 id="交换与覆盖"><a href="#交换与覆盖" class="headerlink" title="交换与覆盖"></a>交换与覆盖</h4><ul><li>覆盖技术，就是把一个大的程序划分为一系列覆盖，每个覆盖是一个相对独立的程序单位<ul><li>把程序执行时并不要求同时装入内存的复盖组成一组，称为覆盖段</li><li>将这个覆盖段分配到同一存储区域，这个存储区域称为覆盖区</li><li>覆盖区与覆盖段一一对应</li><li>覆盖技术只能覆盖与覆盖程序段无关的程序段</li><li>为了使一个覆盖区能被相应覆盖段中每个覆盖在不同时刻共享，其大小应由覆盖段中最大覆盖来确定</li><li>覆盖技术的特点是打破了必须将一个进程的全部信息装入主存后才能运行的限制，但当同时执行程序的代码量超过主存时，程序仍然不能运行</li></ul></li><li>交换技术就是把暂时不用的某个程序及数据部分从内存移到外存中，以便腾出必要的内存空间，或把指定的程序或数据从外存读到相应的内存中，并将控制权转让给他，让其在系统上运行的一种内存扩充技术<ul><li>处理器三级调度中的中级调度就是采用了交换技术</li><li>与覆盖技术相比，交换技术不要求程序员给出程序段之间的覆盖结构，且交换主要是在进程或作业之间进行，而覆盖主要在同一个作业或进程中进行</li><li>交换进程由换出和换入两个过程组成</li><li>交换技术的特点是打破了一个程序一旦进入主存便一直运行到结束的限制，但运行的进程大小仍然受实际主存的限制</li><li>交换需要备份存储</li><li>影响交换时间的因素主要是转移时间</li><li>如果换出进程，必须确保该进程完全空闲</li><li>交换空间通常作为磁盘的一整块，且独立于文件系统</li><li>交换通常在有许多进程运行，且内存空间紧张时开始启动，而在系统负荷减轻时暂停</li></ul></li></ul><h4 id="连续分配管理方式"><a href="#连续分配管理方式" class="headerlink" title="连续分配管理方式"></a>连续分配管理方式</h4><ul><li>内部碎片和外部碎片<ul><li>内部碎片是指已经分配给作业，但不能被利用的内部空间</li><li>外部碎片是指系统中还没有分配给作业，但由于碎片太小而无法分配给申请内存空间的新进程的存储块</li></ul></li><li>单一连续分配：将内存分为两个连续存储区域，其中一个存储区域固定的分配给操作系统使用，通常放在内存低地址部分，另一个存储区域给用户作业使用<ul><li>通常用户作业只占用所有分配空间的一部分，剩下一部分实际上浪费掉了</li><li>单一连续分配方式采用静态分配，适合单道程序，可采用覆盖技术</li><li>作业一旦进入内存，就要等到其结束后才能释放内存，因此这种分配方式不支持虚拟存储器的实现，无法实现多道程序共享主存</li><li>单一连续分配会产生内部碎片</li></ul></li><li>固定分区分配：将内存空间划分为若干个固定大小的分区，每个分区中可以装入一道程序<ul><li>分区的大小可以不等，但事先必须确定，在运行时不能改变</li><li>当有空闲分区时，便从后备队列中选择一个适当大小的作业装入运行</li><li>固定分区分配中程序通常采用静态重定位方式装入内存</li><li>固定分区分配的优点是可用于多道程序系统最简单的存储分配，缺点是不能实现多进程共享一个主存区，利用率较低，会产生内部碎片</li></ul></li><li>动态分区分配：作业进入主存时，根据作业的大小动态的建立分区，并使分区的大小正好满足作业的需要，因此系统中分区的大小是可变的，分区数目也是可变的<ul><li>空闲分区表、空闲分区链</li><li>首次适应算法（FF）、下次适应算法（NF）、最佳适应算法（BF）、最差适应算法（WF）</li><li>分区回收</li><li>分区分配的动态管理：拼接技术、动态重定位分区分配技术</li></ul></li><li>动态分区分配的优缺点<ul><li>优点：实现了多道程序共用主存、管理方案相对简单、实现存储保护的手段比较简单</li><li>缺点：主存利用不够充分，存在外部碎片、无法实现多进程共享存储器信息、无法实现主存的扩充，进程地址空间受实际存储空间的限制</li></ul></li></ul><h4 id="非连续分配管理方式"><a href="#非连续分配管理方式" class="headerlink" title="非连续分配管理方式"></a>非连续分配管理方式</h4><ul><li>非连续分配允许一个程序分散地装入到不相邻的内存分区中</li><li>非连续分配管理方式根据分区大小是否固定为分页存储管理方式和分段存储管理方式</li><li>分页存储管理方式根据运行作业时是否需要把作业的所有页都装入内存才能运行而分为基本分页存储管理方式和请求分页存储管理方式</li><li>基本分页存储管理方式（物理单位）<ul><li>分页原理：用户作业的地址空间被划分成若干个大小相等的区域，称为页或页面</li><li>将主存的存储空间分成与页面大小相等的区域，称为块或物理块</li><li>在为作业分配存储空间时，总是以块为单位来分配，可以将作业中的任意一页放到主存的任意一块中</li><li>主存中与页面大小相等的物理块也可称为页框</li><li>为了将逻辑地址上连续的页号映射到物理内存中后成为离散分布的多个物理块，需要将每个页面和每个物理块一一对应，这种映射关系体现在页表中</li><li>每个页表项由页号和块号组成</li><li>基本地址变换机构：页表寄存器（PTR）</li><li>具有快表（TLB）的地址的地址变换机构：具有并行查找功能的高度缓冲存储器</li><li>两级页表和多级页表</li></ul></li><li>基本分页存储管理方式优缺点<ul><li>优点：内存利用率高、实现了离散分配、便于存储访问控制、无外部碎片</li><li>缺点：需要硬件支持（快表）、内存访问效率下降、共享困难、内部碎片</li></ul></li><li>基本分段存储管理方式（逻辑单位）<ul><li>逻辑地址结构由段号 S 和段内位移 W（段内偏移量）组成</li><li>段的长度不定</li><li>作业空间地址是二维的</li><li>段表及地址变换过程</li></ul></li><li>基本分段存储管理方式优缺点<ul><li>优点：便于程序模块化处理和处理变换的数据结构、便于动态链接和共享、无内部碎片</li><li>缺点：与分页类似，需要硬件支持、为满足分段的动态增长和减少外部碎片，要采用拼接手段、分段的最大尺寸受到主存可用空间的限制、有外部碎片</li></ul></li></ul><h4 id="虚拟内存的基本概念"><a href="#虚拟内存的基本概念" class="headerlink" title="虚拟内存的基本概念"></a>虚拟内存的基本概念</h4><ul><li></li></ul>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt; 操作系统（OS）是管理和控制计算机硬件与软件资源，是计算机上直接运行的最基本的系统软件，任何其他软件都必须在操作系统的支持下才能运行。操作系统是用户和计算机的接口，同时也是计算机硬件和其他软件的接口。操作系统的功能包括管理计算机系统的硬件、软件及数据资源，控制程序运行，提供人机交互界面，为其它应用软件提供支持等。我选择的课程是苏州大学的&lt;a href=&quot;https://www.icourse163.org/course/SUDA-1001752241&quot;&gt;国家精品课&lt;/a&gt;和汤子瀛版教材，以下为所记课堂笔记下半部分，包含内存管理、文件管理和设备管理的知识点，可供参考。上半部分笔记请访问&lt;a href=&quot;/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E4%B8%8A&quot;&gt;操作系统（上）&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="计算机专业" scheme="http://blog.zhuangzhihao.top/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%93%E4%B8%9A/"/>
    
    
    <category term="Operating System" scheme="http://blog.zhuangzhihao.top/tags/Operating-System/"/>
    
  </entry>
  
  <entry>
    <title>数据结构（下）</title>
    <link href="http://blog.zhuangzhihao.top/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%B8%8B/"/>
    <id>http://blog.zhuangzhihao.top/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%B8%8B/</id>
    <published>2021-09-07T16:00:00.000Z</published>
    <updated>2021-09-25T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>数据结构是指数据的存储结构，是带有结构特性的数据元素的集合。精心选择的数据结构可以带来更好的运行或者存储效率。数据结构是计算机科学与技术专业、软件工程专业甚至于其它电气信息类专业的重要专业基础课程，在408计算机学科专业基础综合考试中占有45分。我选择的课程是浙江大学数据结构<a href="https://www.icourse163.org/course/ZJU-93001">国家精品课</a>，以下为所记课堂笔记第三部分，包含排序、查找算法和平衡二叉树的知识总结以及所需记忆的代码，另外我在开源仓库中还保持了浙大慕课版本的<a href="https://github.com/Bezhuang/LearnCS/tree/main/%E5%90%8D%E6%A0%A1%E5%85%AC%E5%BC%80%E8%AF%BE/%E6%B5%99%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84">代码</a>，可供参考。其他部分笔记详见<a href="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%B8%8A">数据结构（上）</a>和<a href="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%B8%AD">数据结构（中）</a></p></blockquote><a id="more"></a><h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><h4 id="排序的基本概念"><a href="#排序的基本概念" class="headerlink" title="排序的基本概念"></a>排序的基本概念</h4><ul><li>排序：将原本无序的序列重新排列成有序序列的过程，这个序列中的每一项可能是单独的数据元素，也可能是一条记录</li><li>记录由多个数据元素组成的，既可以按照记录的主关键字排序（主关键字唯一标识一条记录），也可以按照记录的次关键字排序</li><li>稳定性：当待排序序列中有两个或两个以上相同的关键字时，排序前和排序后这些关键字的相对位置，如果没有发生变化就是稳定的，否则就是不稳定的</li><li>排序算法的分类<ul><li>插入类的排序：直接插入、折半插入、希尔排序</li><li>交换类的排序：冒泡排序、快速排序</li><li>选择类的排序：简单选择、堆选择</li><li>归并类的排序：二路归并</li><li>基数类的排序：多关键字排序</li></ul></li></ul><h4 id="插入类的排序"><a href="#插入类的排序" class="headerlink" title="插入类的排序"></a>插入类的排序</h4><ul><li><p>插入排序</p><pre><code class="cpp">void InsertSort(int* h, size_t len)&#123;    if(h==NULL) return;    if(len&lt;=1) return;    int i,j;    //i是次数，也即排好的个数;j是继续排    for(i=1;i&lt;len;++i)        for(j=i;j&gt;0;--j)            if(h[j]&lt;h[j-1]) Swap(h[j],h[j-1]);            else break;    return;&#125;</code></pre></li><li><p>希尔排序</p><ul><li>缩小增量排序：把记录按下标的一定增量分组，对每组使用直接插入排序算法排序</li><li>随着增量逐渐减少，每组包含的关键词越来越多，当增量减至1时，整个文件恰被分成一组，算法便终止</li></ul><pre><code class="cpp">void ShellSort(int* h, size_t len)&#123;    if(h==NULL) return;    if(len&lt;=1) return;    for(int div=len/2;div&gt;=1;div/=2)        for(int k=0;k&lt;div;++k)            for(int i=div+k;i&lt;len;i+=div)                for(int j=i;j&gt;k;j-=div)                    if(h[j]&lt;h[j-div]) Swap(h[j],h[j-div]);                    else break;    return;&#125;</code></pre></li></ul><h4 id="交换类的排序"><a href="#交换类的排序" class="headerlink" title="交换类的排序"></a>交换类的排序</h4><ul><li><p>快速排序</p><pre><code class="cpp">void QuickSort(SeqList R，int low，int high) &#123; //对 R[low..high]快速排序     int pivotpos； //划分后的基准记录的位置         if (low &lt; high) &#123; //仅当区间长度大于 1 时才须排序             pivotpos = Partition(R，low，high)； //对 R[low..high]做划分                 QuickSort(R，low，pivo t   pos-1)； //对左区间递归排序                 QuickSort(R，pivotp o s+1，high)； //对右区间递归排序         &#125;&#125; //QuickSort</code></pre></li><li><p>冒泡排序</p><ul><li>通过依次交换相邻两个顺序不合法的元素位置，从而将当前最小（大）元素放到合适的位置</li></ul><pre><code class="cpp">void BubbleSort(int* h, size_t len)&#123;    if(h==NULL) return;    if(len&lt;=1) return;    //i是次数，j是具体下标    for(int i=0;i&lt;len-1;++i)        for(int j=0;j&lt;len-1-i;++j)            if(h[j]&gt;h[j+1])                Swap(h[j],h[j+1]);    return;&#125;</code></pre></li></ul><h4 id="选择类的排序"><a href="#选择类的排序" class="headerlink" title="选择类的排序"></a>选择类的排序</h4><ul><li><p>选择排序</p><ul><li>初始时在序列中找到最小（大）元素，放到序列的起始位置作为已排序序列，然后，再从剩余未排序元素中继续寻找最小（大）元素，放到已排序序列的末尾。以此类推，直到所有元素均排序完毕</li><li>每遍历一次都记住了当前最小（大）元素的位置，最后仅需一次交换操作即可将其放到合适的位置</li></ul><pre><code class="cpp">void SelectionSort(int* h, size_t len)&#123;    if(h==NULL) return;    if(len&lt;=1) return;    int minindex,i,j;    //i是次数，也即排好的个数;j是继续排    for(i=0;i&lt;len-1;++i)    &#123;        minindex=i;        for(j=i+1;j&lt;len;++j)        &#123;            if(h[j]&lt;h[minindex]) minindex=j;        &#125;        Swap(h[i],h[minindex]);    &#125;    return;&#125;</code></pre></li><li><p>堆排序</p><ul><li>堆实际上是一棵完全二叉树，堆的每一个父节点都大于（或小于）其子节点，堆的每个左子树和右子树也是一个堆</li><li>最大堆（大顶堆）：堆的每个父节点都大于其孩子节点；最小堆（小顶堆）：堆的每个父节点都小于其孩子节点</li><li>堆的第一个元素要么是最大值（大顶堆），要么是最小值（小顶堆），这样在排序的时候（假设共 n 个节点），直接将第一个元素和最后一个元素进行交换，然后从第一个元素开始进行向下调整至第 n-1 个元素。所以，如果需要升序，就建一个大堆，需要降序，就建一个小堆</li></ul><pre><code class="cpp">void HeapSort(SeqIAst R)&#123; //对 R[1..n]进行堆排序，不妨用 R[0]做暂存单元     int i；        BuildHeap(R)； //将 R[1-n]建成初始堆         for (i = n;i &gt; 1；  i  -)        &#123; //对当前无序区 R[1..i]进行堆排序，共做 n-1 趟            R[0] = R[1];            R[1] = R[i];            R[i] = R[0];//将堆顶和堆中最后一个记录交换             Heapify(R，1 ，i-1); //将 R[1..i-1]重新调整为堆，仅有 R[1]可能违反堆性质         &#125; //endfor &#125; //HeapSort</code></pre></li></ul><h4 id="二路归并排序"><a href="#二路归并排序" class="headerlink" title="二路归并排序"></a>二路归并排序</h4><ul><li><p>MERGE-SORT：利用归并的思想实现的排序方法，采用经典的分治（divide-and-conquer）策略</p></li><li><p>递归拆分子序列，将两个已经有序的子序列合并成一个有序序列</p><pre><code class="cpp">void MergeSortDC(SeqList R，int low，int high) &#123;//用分治法对 R[low..high]进行二路归并排序  int mid；  if(low&lt;high)&#123; //区间长度大于 1  mid=(low+high)/2； //分解  MergeSortDC(R，low，mid); //递归地对 R[low..mid]排序  MergeSortDC(R，mid+1，high)； //递归地对 R[mid+1..high]排序  Merge(R，low，mid，high)； //组合，将两个有序区归并为一个有序区  &#125; &#125;//MergeSortDC </code></pre></li></ul><h4 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h4><ul><li><p>不需要比较关键字的大小，根据关键字中各位的值，通过对排序的N个元素进行若干趟分配与收集来实现排序的</p></li><li><p>时间复杂度为 $O\left( d\left( n+r_{d}\right) \right)$</p><pre><code class="cpp">int GetMaxDight(int* h, int len)&#123;    if(h==NULL) return 0;    if(len&lt;1) return 0;    int max=h[0];    for(int i=1;i&lt;len;++i)    &#123;        if(h[i]&gt;max) max=h[i];    &#125;    int digit=1;    while(max/10!=0)    &#123;        max/=10;        ++digit;    &#125;    return digit;&#125;int GetReminder(int value,int digit)&#123;    int div=1;    for(int i=1;i&lt;digit;++i)        div*=10;    return value/div%10;&#125;void RadixSort_LSD(int* h, int len)&#123;    if(h==NULL) return;    if(len&lt;=1) return;    int digit=GetMaxDight(h,len);    //printf(&quot;MaxDigit:%d\n&quot;, digit);    int count[10]=&#123;0&#125;;    int *tmp=(int*)calloc(len,sizeof(int));    for(int d=1;d&lt;=digit;++d)    &#123;        memset(count,0,sizeof(count));        for(int i=0;i&lt;len;++i)        &#123;            count[GetReminder(h[i],d)]++;        &#125;        //求右边界        for(int i=1;i&lt;10;++i)        &#123;            count[i]+=count[i-1];        &#125;        for(int i=len-1;i&gt;=0;--i)        &#123;            int r=GetReminder(h[i],d);            int index=count[r];            tmp[index-1]=h[i];            count[r]--;        &#125;        memcpy(h,tmp,len*sizeof(int));    &#125;    free(tmp);&#125;void RadixSort_LSD_Reverse(int* h, int len)&#123;    if(h==NULL) return;    if(len&lt;=1) return;    int digit=GetMaxDight(h,len);    //printf(&quot;MaxDigit:%d\n&quot;, digit);    int count[10]=&#123;0&#125;;    int *tmp=(int*)calloc(len,sizeof(int));    for(int d=1;d&lt;=digit;++d)    &#123;        memset(count,0,sizeof(count));        for(int i=0;i&lt;len;++i)        &#123;            count[GetReminder(h[i],d)]++;        &#125;        //printf(&quot;haha\n&quot;);        //求右边界        for(int i=8;i&gt;=0;--i)        &#123;            count[i]+=count[i+1];        &#125;        for(int i=len-1;i&gt;=0;--i)        &#123;            int r=GetReminder(h[i],d);            int index=count[r];            tmp[index-1]=h[i];            count[r]--;        &#125;        memcpy(h,tmp,len*sizeof(int));    &#125;    free(tmp);&#125;</code></pre></li></ul><h4 id="排序知识点总结"><a href="#排序知识点总结" class="headerlink" title="排序知识点总结"></a>排序知识点总结</h4><ul><li>快速排序、希尔排序、归并排序、堆排序的平均时间复杂度都是 $O\left( n\log _{2}n\right)$，其他都是 $O(n^2)$</li><li>快速排序的空间复杂度为 $O\left( \log <em>{2}n\right)$，归并排序的空间复杂度为 $O\left( n\right)$，基数排序的空间复杂度为 $O\left( r</em>{d}\right)$，其他都是 $O(1)$</li><li>快速排序、希尔排序、简单选择排序、堆排序是不稳定的，其他都是稳定的</li><li>交换类和选择类的排序，经过一趟排序能够保证一个关键字到达最终位置</li><li>简单选择排序和折半插入排序的关键字比较次数和原始序列无关</li><li>交换类的排序趟数和原始序列有关</li><li>直接插入按顺序查找的方式，而折半插入按折半查找的方式排序</li><li>借助于比较进行排序的算法在最坏情况下的时间复杂度至少为 $O\left( n\log _{2}n\right)$</li></ul><h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3><h4 id="查找的基本概念"><a href="#查找的基本概念" class="headerlink" title="查找的基本概念"></a>查找的基本概念</h4><ul><li><p>给定一个值 K，在含有 n 个记录的表中找出关键字等于 K 的记录叫查找，记录即为关键字</p></li><li><p>通常把查找过程中对关键字的平均比较次数（也称平均查找长度）作为衡量一个查找算法优劣的标准</p></li><li><p>平均查找长度 $ASL=\sum ^{n}<em>{i=1}p</em>{i}\times c_{i}$</p><ul><li>$p_{i}$ 为查找第 i 个记录的概率，$c_{i}$ 为找到第 i 个记录所需要进行比较的次数（查找长度）</li></ul></li><li><p>顺序查找</p><ul><li>用待查找的关键字和给定序列中的各元素的关键字从左到右（或从右到左）依次进行比较，直到成功或失败</li><li>存储结构通常是顺序结构，也可是链式结构</li></ul><pre><code class="cpp">//顺序表的查找（不带监视哨）int SeqSearch(SSTable S, DataType x)&#123;    int i = 0;    while (i &gt; s.length &amp; S.list[i].key != x.key)        i++;    if (s.list[i].key == x.key)        return i + 1;    return 0;&#125;//顺序表的查找（带监视哨）int SeqSearch2(SSTable S, DataType x)&#123;    int i = S.length;    //将关键字存放在0位置处,防止越界    /*哨兵的主要作用就是在查找循环中监视下标i是否越界      一旦越界(i=0),因为可以和自己进行比较,循环判定条件      不成立就使得查找循环结束,就可以达到忽略判定边界条件的目的*/    s.list[o].key = x.key;    while (s.list[i].key != x.key)        i--;    return i;    // 实际上,一切为简化边界条件而引入的附加结点(元素)均可称为哨兵&#125;//顺序表的查找（链表实现）Node* Search(Lnode* head, int key)&#123;    LNode* p = head-&gt;next;    while (p != NUll)    &#123;        if (P-&gt;data == key)            return p;        p = p-&gt;next;    &#125;    return NULL;&#125;</code></pre></li><li><p>二分查找</p><ul><li>要求线性表是有序的</li><li>在给定序列是有序表的前提下，将表中间位置处的关键字和查找关键字比较，相 等则查找成功</li><li>否则从中间位置将表分成前后两个子表，如果中间位置处的关键字大于 查找关键字，则进一步查找前子表，否则查找后子表</li><li>重复以上过程，直到找到满足条件的记录，此时查找成功，或直到子表不存在为止，表示查找失败</li></ul><pre><code class="cpp">int BSearch(int arr[], int low, int high, int key) &#123;    while (low &lt;= high) &#123;        int mid = (low + high) / 2;        if (arr[mid == key])            return mid;        else if (arr[mid] &gt; key)            high = mid - 1;        else            low = mid + 1;    &#125;    return -1;&#125;</code></pre></li></ul><h4 id="二叉排序树（BST）"><a href="#二叉排序树（BST）" class="headerlink" title="二叉排序树（BST）"></a>二叉排序树（BST）</h4><ul><li><p>二叉排序树要么是空树,要么是满足下列要求的树</p><ul><li>若它的左子树不空，则左子树上所有的关键字的值均小于根节点关键字值</li><li>若它的右子树不空，则右子树上所有的关键字的值均大于根节点关键字值</li><li>左右子树又各是一棵二叉排序树</li></ul></li><li><p>Binary Search Tree 又被叫做二叉搜索树 or 二叉查找树</p></li><li><p>在对某个关键字进行查找的时候，首先和二叉排序树的根节点进行比较，若相等则査找成功</p></li><li><p>由于二叉排序树本身的性质，若该关键字小于根节点值，则再与其左子树进行比较,否则和其右子树进行比较，直到找到与之相等的节点，则查找成功</p></li><li><p>若待比较的位置来到空指针处，则表示査找失败，返回失败的标记</p><pre><code class="cpp">//非递归算法BTNode* BSTSearch(BTNode* p, int key) &#123;    while (p != NULL) &#123;        if (key == p-&gt;key)            return p;        else if (key &lt; p-&gt;key)            p = p-&gt;lChild;        else            p = p-&gt;rChild;    &#125;    return NULL;&#125;//递归算法BTNode* BSTSearch2(BTNode* p, int key) &#123;    if (p == NULL)        return NULL;    else&#123;        if (key == p-&gt;key)            return p;        else if (key &lt; p-&gt;key)            return BSTSearch2(p-&gt;lChild, key);        else            return BSTSearch2(p-&gt;rChild, key);    &#125;&#125;</code></pre></li></ul><h4 id="平衡二叉树（AVL-树）"><a href="#平衡二叉树（AVL-树）" class="headerlink" title="平衡二叉树（AVL 树）"></a>平衡二叉树（AVL 树）</h4><ul><li>平衡二叉树是一种特殊的二叉排序树，其左右子树都是平衡二叉树且左右子树高度之差的绝对值不超过1</li><li>一个节点的平衡因子为其左子树的高度减去右子树的高度，对于平衡二叉树，树中所有结点的平衡因子取值只可能是-1、0、1</li><li>若向平衡二叉树中插入一个新结点后破坏了平衡二叉树的平衡性，则首先要找出插入新节点后失去平衡的最小子树，然后再调整这颗子树使之成为平衡子树</li><li>当失去平衡的最小子树被调整为平衡子树后，无需调整原有其他所有的不平衡子树</li><li>最小不平衡子树：是以距离插入结点最近且以平衡因子绝对值大于1的结点作为跟的子树，又称为失去平衡的最小子树</li></ul><h4 id="散列表"><a href="#散列表" class="headerlink" title="散列表"></a>散列表</h4><ul><li><p>Hash：根据给定的关键字来计算出关键字在表中的地址</p></li><li><p>Hash table（哈希表）：是根据关键码值（Key value）而直接进行访问的数据结构，=通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度，这个映射函数叫做散列函数，存放记录的数组叫做散列表</p></li><li><p>给定表 M，存在函数 f(key)，对任意给定的关键字值 key，代入函数后若能得到包含该关键字的记录在表中的地址，则称表 M 为哈希表，函数 f(key) 为哈希函数</p></li><li><p>键（key）：又称为关键字。唯一的标示要存储的数据，可以是数据本身或者数据的一部分</p></li><li><p>槽（slot/bucket）：哈希表中用于保存数据的一个单元，也就是数据真正存放的容器</p></li><li><p>哈希函数（hash function）：将 key 映射 map 到数据应该存放的槽 slot 所在位置的函数</p></li><li><p>哈希冲突（hash collision）：哈希函数将两个不同的键映射到同一个索引的情况</p><pre><code class="cpp">int h1(int x)&#123;  return (x%5);&#125;int h2(char* x)&#123;  int i,sum;  for(sum=0, i=0; x[i] != &#39;\0&#39;; i++)    sum += (int)x[i];  return (sum%5);&#125;int ELFhash(char*key)&#123;    unsigned long h=0;    while(*key)    &#123;        h = (h &lt;&lt; 4) + *key++;        unsigned long g = h &amp; 0xF0000000L;        if(g)            h ^= g &gt;&gt; 24;        h &amp;= ~g;    &#125;    return h % MOD;&#125;</code></pre></li><li><p>散列表的性能分析（查找成功时的平均查找长度）：找到表中已有表项的平均次数</p></li><li><p>装填因子是关键字个数和表长度的比值</p></li></ul><h3 id="常用算法补充"><a href="#常用算法补充" class="headerlink" title="常用算法补充"></a>常用算法补充</h3><ul><li><p>动态规划算法</p><ul><li>处理多阶段决策问题，一般由初始状态开始，通过对中间阶段决策的选择，达到结束状态</li><li>这些决策形成了一个决策序列，同时确定了完成整个过程的一条活动路线（通常是求最优的活动路线）</li><li>动态规划往往可以用递归程序来实现，不过因为递推可以充分利用前面保存的子问题的解来减少重复计算，所以对于大规模问题来说，有递归不可比拟的优势，这也是动态规划算法的核心之处</li></ul><pre><code class="cpp">for (j = 1; j &lt;= m; j = j + 1) // 第一个阶段    xn[j] = 初始值;for (i = n - 1; i &gt; = 1; i = i - 1)// 其他n-1个阶段    for (j = 1; j &gt;= f(i); j = j + 1)//f(i)与i有关的表达式        xi[j] = j = max&#123; g(xi - 1[j1:j2]), ...... ,  g(xi - 1[jk:jk + 1]) &#125;;t = g(x1[j1:j2]); // 由子问题的最优解求解整个问题的最优解的方案print(x1[j1]);for (i = 2; i &lt;= n - 1; i = i + 1)&#123;    t = t - xi - 1[ji];    for (j = 1; j &gt;= f(i); j = j + 1)        if (t = xi[ji])            break;&#125;</code></pre></li><li><p>贪心算法</p><ul><li>在对问题求解时，总是做出在当前看来是最好的选择，局部最优解</li><li>整个问题的最优解一定由在贪心策略中存在的子问题的最优解得来的</li><li>贪心算法建立哈夫曼树</li></ul><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;using namespace std;typedef struct BTreeNode&#123;    int  data;    struct BTreeNode* left;    struct BTreeNode* right;&#125;btreenode;//建立哈夫曼树btreenode *CreateHuffman(int a[],int n)&#123;    int i;    btreenode *s[n+1], *ss;    for(int i = 0;i&lt;n;i++)&#123;        s[i] = new btreenode;  //初始化s指针数组，使每个指针元素指向a数组中对应的元素结点        s[i]-&gt;data = a[i];   //将树拆成森林，每棵树都只有一个根节点        s[i]-&gt;left = s[i]-&gt;right = NULL;    &#125;    for(int i  = 1;i&lt;n;i++)&#123;        //进行 n-1次循环建立哈夫曼树           int k = -1,t;           //k表示森林中具有最小权值的树根结点的下标，t为次最小的下标        for(int j = 0;j&lt;n;j++)&#123;   //k初始指向森林中第一棵树，t指向第二棵                if(s[j]&amp;&amp;k==-1)&#123;                   k = j;                   continue;                &#125;                if(s[j])&#123;                    t =  j;                    break;                &#125;        &#125;        for(int i = t;i&lt;n;i++)&#123;   //从当前森林中求出最小权值树和次最小 ；            if(s[i])&#123;                if(s[i]-&gt;data&lt;s[k]-&gt;data)&#123;        //比最小树小                    t = k;                    k = i;                &#125;                else if(s[i]-&gt;data&lt;s[t]-&gt;data)&#123;  //比次小树小                    t = i;                &#125;                else&#123;                    ;                &#125;            &#125;        &#125;           //由最小权值树和次最小权值树建立一棵新树，ss指向树根结点(以后依次建立)           ss  = new btreenode;     //ss = (btreenode *)malloc(sizeof(btreenode))           ss-&gt;data =   s[k]-&gt;data+s[t]-&gt;data;           ss-&gt;left =   s[k];           ss-&gt;right =  s[t];           s[k] =  ss;  //关键点:将ss赋给s[k](k为上述找到的最小树下标,但这是s[k]代表的值已改变，同时把s[t]失效的置空,                       //在这里起向下一个判断的作用if(s[j])&#123;t = j;break;&#125;           s[t] = NULL;    &#125;        free(s);   //释放分配空间        return ss;&#125;//求哈夫曼树的带权路径长度int WeightPathLength(btreenode* FBT, int len)&#123;          //参数len为树的层数    if(!FBT)&#123;        return 0;    &#125;    else&#123;        if(FBT-&gt;left ==NULL&amp;&amp;FBT-&gt;right ==NULL)//访问到叶子结点            return FBT-&gt;data*len;        else&#123;               //访问到非叶子结点，进行递归调用，返回左右子树的带权路径长度之和，len递增            return  WeightPathLength(FBT-&gt;left,len+1)+WeightPathLength(FBT-&gt;right,len+1);//一定要记得加1        &#125;    &#125;&#125;//哈夫曼编码void HuffManCoding(btreenode* FBT, int len)&#123;   //参数len为树的层数    static int a[20];                        //定义静态数组a，保存每个叶子的编码，数组长度至少是树深度减1    if(FBT)&#123;                                 //访问到叶子结点时输出其保存在数组a中的0和1序列编码        if(FBT-&gt;left == NULL&amp;&amp;FBT-&gt;right == NULL)&#123;             printf(&quot;结点权值为%d的编码:&quot;,FBT-&gt;data);             for(int i = 0;i&lt;len;i++)&#123;                 printf(&quot;%d&quot;,a[i]);            &#125;                printf(&quot;\n&quot;) ;        &#125;        else&#123;    //访问到非叶子结点时分别向左右子树递归调用，并把分支上的0、1编码保存到数组                //a的对应元素中，向下深入一层时len值增1               a[len] = 0;               HuffManCoding(FBT-&gt;left,len+1);               a[len] = 1;               HuffManCoding(FBT-&gt;right,len+1);            &#125;    &#125;&#125;int main()&#123;    btreenode *s;    int n;    printf(&quot;从键盘输入待构造的哈夫曼树中带权叶子结点数n：&quot;);    while(true)&#123;        scanf(&quot;%d&quot;,&amp;n);        if(n&gt;0)&#123;            break;        &#125;        else&#123;            printf(&quot;-------输入不合法,请重新输入!!\n&quot;);        &#125;    &#125;    int *a = (int *)malloc(n *sizeof(int));    printf(&quot;从键盘输入%d个整数作为权值:&quot;,n);    for (int i = 0; i &lt; n; i++)        scanf(&quot;%d&quot;, &amp;a[i]);    s = CreateHuffman(a,n);    printf(&quot;哈夫曼树的带权路径长度：&quot;);    printf(&quot;%d\n&quot;, WeightPathLength(s, 0));    printf(&quot;树中每个叶子结点的哈夫曼编码：\n&quot;);    HuffManCoding(s,0);    return 0;&#125;</code></pre></li></ul>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;数据结构是指数据的存储结构，是带有结构特性的数据元素的集合。精心选择的数据结构可以带来更好的运行或者存储效率。数据结构是计算机科学与技术专业、软件工程专业甚至于其它电气信息类专业的重要专业基础课程，在408计算机学科专业基础综合考试中占有45分。我选择的课程是浙江大学数据结构&lt;a href=&quot;https://www.icourse163.org/course/ZJU-93001&quot;&gt;国家精品课&lt;/a&gt;，以下为所记课堂笔记第三部分，包含排序、查找算法和平衡二叉树的知识总结以及所需记忆的代码，另外我在开源仓库中还保持了浙大慕课版本的&lt;a href=&quot;https://github.com/Bezhuang/LearnCS/tree/main/%E5%90%8D%E6%A0%A1%E5%85%AC%E5%BC%80%E8%AF%BE/%E6%B5%99%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84&quot;&gt;代码&lt;/a&gt;，可供参考。其他部分笔记详见&lt;a href=&quot;/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%B8%8A&quot;&gt;数据结构（上）&lt;/a&gt;和&lt;a href=&quot;/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%B8%AD&quot;&gt;数据结构（中）&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="计算机专业" scheme="http://blog.zhuangzhihao.top/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%93%E4%B8%9A/"/>
    
    
    <category term="Data Structure" scheme="http://blog.zhuangzhihao.top/tags/Data-Structure/"/>
    
  </entry>
  
  <entry>
    <title>基于Python和OpenCV实现人脸识别</title>
    <link href="http://blog.zhuangzhihao.top/Python-OpenCV%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%AB/"/>
    <id>http://blog.zhuangzhihao.top/Python-OpenCV%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%AB/</id>
    <published>2021-09-02T16:00:00.000Z</published>
    <updated>2021-09-14T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Open Source Computer Vision Library（OpenCV）是一个跨平台的计算机视觉库，可用于开发实时的图像处理、计算机视觉以及模式识别程序。OpenCV 用 C++ 语言编写，但本次实战项目使用的是 <code>python-opencv</code> 库实现的，主要是为了初步了解人脸识别的步骤和算法后面的原理。以下为项目笔记，源代码保存在 <a href="https://github.com/Bezhuang/PracticeMakesPerfect/tree/main/Python-OpenCV">Github 仓库</a>中，可供参考。</p></blockquote><a id="more"></a><h3 id="项目背景"><a href="#项目背景" class="headerlink" title="项目背景"></a>项目背景</h3><h4 id="人脸识别介绍"><a href="#人脸识别介绍" class="headerlink" title="人脸识别介绍"></a>人脸识别介绍</h4><ul><li>对人类来说，人脸识别很容易：我们的大脑有专门的神经细胞针对不同的场景或运动特征作出反应，视觉皮层再以某种方式把不同的信息来源转化成可用的模型</li><li>自动人脸识别就是研究如何从一幅图像中提取有意义的特征，形成可用的模型，然后对他们进行一些分类，因此基于几何特征的人脸的人脸识别可能是最直观的识别人脸的方法</li><li>但即使是使用最先进的算法，标记点的确定也是很复杂的，单靠几何特征不能提供足够的信息用于人脸识别</li><li>特征脸方法：把面部图像看作是一个点，从高维图像空间找到它在低维空间的表示，使用主元分析（Principal Component Analysis，PCA）可以找拥有最大方差的轴，但轴的最大方差不一定包含任何有鉴别性的信息</li><li>使用线性鉴别（Linear Discriminant Analysis，LDA）的特定类投影方法：使类内方差最小的同时，使类外方差最大</li><li>仅仅使用的局部特征描述图像的方法避免输入的图像的高维数据：提取的特征对于局部遮挡、光照变化、小样本等情况更强健<ul><li>盖伯小波：Gabor Waelets</li><li>离散傅立叶变换：Discrete Cosinus Transform（DCT）</li><li>局部二值模式：Local Binary Patterns（LBP）</li></ul></li></ul><h4 id="OpenCV-介绍"><a href="#OpenCV-介绍" class="headerlink" title="OpenCV 介绍"></a>OpenCV 介绍</h4><ul><li>从 OpenCV 2.4 开始，加入了新的类 FaceRecognizer，可以使用它便捷地进行人脸识别实验</li><li>FaceRecognizer 类目前包含三种人脸识别方法<ul><li>基于 PCA 变换的人脸识别：EigenFaceRecognizer</li><li>基于 Fisher 变换的人脸识别：FisherFaceRecognizer</li><li>基于局部二值模式的人脸识别：LBPHFaceRecognizer</li></ul></li><li>特征脸（Eigenfaces）：图像表示的问题是他的高维问题，如果数据有任何差异，可以通过寻找主元来知道主要信息，把一些可能相关的变量转换成一个更小的不相关的子集<ul><li>一个高维数据集经常被相关变量表示，因此只有一些的维上数据才是有意义的（包含最多的信息）</li><li>PCA 方法寻找数据中拥有最大方差的方向（主成分）</li><li>计算特征值和对应的特征向量，对特征值进行递减排序，特征向量和它顺序一致</li><li>k 个主成分也就是 k 个最大的特征值对应的特征向量</li><li>把所有的训练数据投影到 PCA 子空间 -&gt; 把待识别图像投影到 PCA 子空间 -&gt; 找到训练数据投影后的向量和待识别图像投影后的向量最近的那个</li></ul></li><li>FisherFaces：基于线性判别分析（Linear Discriminant Analysis，LDA）理论，在降维的同时考虑类别信息，基于特征脸的方法，找到使数据中最大方差的特征线性组合<ul><li>在低维表示下，相同的类应该紧紧的聚在一起，而不同的类别尽量距离越远</li></ul></li><li>局部二值模式直方图（Local Binary Patterns Histograms）：不把整个图像看成一个高维向量，仅用局部特征来描述一个物体，通过这种方式提取特征，获得一个低维隐式<ul><li>对图像的像素和它局部周围像素进行对比后的结果进行求和，把这个像素作为中心，对相邻像素进行阈值比较</li><li>如果中心像素的亮度大于等于他的相邻像素，标记为 1，否则标记为 0（用二进制数字来表示每个像素）</li></ul></li></ul><h3 id="OpenCV-的基本使用"><a href="#OpenCV-的基本使用" class="headerlink" title="OpenCV 的基本使用"></a>OpenCV 的基本使用</h3><h4 id="读取图片"><a href="#读取图片" class="headerlink" title="读取图片"></a>读取图片</h4><pre><code class="python">#导入模块import cv2 as cv#读取图片img=cv.imread(&#39;lena.jpg&#39;)    #加载图片路径中不能有中文#显示图片cv.imshow(&#39;read_img&#39;,img)#等待键盘输入 单位毫秒  传入0 则就是无限等待cv.waitKey(3000)#释放内存  由于OpenCV底层是C++编写的cv.destroyAllWindows()</code></pre><h4 id="图片灰度转换"><a href="#图片灰度转换" class="headerlink" title="图片灰度转换"></a>图片灰度转换</h4><pre><code class="python">import cv2 as cvimg=cv.imread(&#39;lena.jpg&#39;)cv.imshow(&#39;BGR_img&#39;,img)#将图片灰度转换gray_img=cv.cvtColor(img,cv.COLOR_BGR2GRAY)cv.imshow(&#39;gray_img&#39;,gray_img)#保存图片cv.imwrite(&#39;gray_lena.jpg&#39;,gray_img)cv.waitKey(0)cv.destroyAllWindows()</code></pre><h4 id="修改图片尺寸"><a href="#修改图片尺寸" class="headerlink" title="修改图片尺寸"></a>修改图片尺寸</h4><pre><code class="python">import cv2 as cvimg=cv.imread(&#39;lena.jpg&#39;)cv.imshow(&#39;img&#39;,img)print(&#39;原来图片的形状&#39;,img.shape)# 修改图片尺寸resize_img=cv.resize(img,dsize=(600,560))print(&#39;修改后图片的形状：&#39;,resize_img.shape)cv.imshow(&#39;resize_img&#39;,resize_img) #输入q时退出while True:    if ord(&#39;q&#39;)==cv.waitKey(0):        breakcv.destroyAllWindows()</code></pre><h4 id="画图"><a href="#画图" class="headerlink" title="画图"></a>画图</h4><pre><code class="python">import cv2 as cvimg=cv.imread(&#39;lena.jpg&#39;)#绘制矩形，左上角坐标(x,y) 矩形的宽度和高度(w,h)x,y,w,h=100,100,100,100cv.rectangle(img,(x,y,x+w,y+h),color=(0,255,255),thickness=3) #BGR#绘制圆形，圆点的坐标center，半径radiusx,y,r=200,200,100cv.circle(img,center=(x,y),radius=r,color=(0,0,255),thickness=2)#显示图片cv.imshow(&#39;rectangle_img&#39;,img)cv.waitKey(0)cv.destroyAllWindows()</code></pre><h3 id="人脸检测"><a href="#人脸检测" class="headerlink" title="人脸检测"></a>人脸检测</h3><h4 id="Haarcascades"><a href="#Haarcascades" class="headerlink" title="Haarcascades"></a>Haarcascades</h4><ul><li>提取出图像的细节对产生稳定分类结果和跟踪结果很有用，这些提取的结果被称为特征</li><li>虽然任意像素都可以能影响多个特征，但特征应该比像素少得多，两个图像的相似程度可以通过它们对应特征的欧氏距离来度量</li><li>Haar 特征是一种用于实现实时人脸跟踪的特征，每一个 Haar 特征都描述了相邻图像区域的对比模式，如边、顶点和细线都能生成具有判别性的特征</li></ul><h4 id="官方-demo"><a href="#官方-demo" class="headerlink" title="官方 demo"></a>官方 demo</h4><ul><li><p>下载：<a href="https://sourceforge.net/projects/opencvlibrary/files/4.5.3/opencv-4.5.3-vc14_vc15.exe/download">https://sourceforge.net/projects/opencvlibrary/files/4.5.3/opencv-4.5.3-vc14_vc15.exe/download</a></p></li><li><p>build 中是 OpenCV 使用时要用到的一些库文件</p></li><li><p>sources 中是 OpenCV 官方提供的 demo 示例源码</p></li><li><p>sources/data/haarcascades 文件夹包含了所有 OpenCV 的人脸检测的 XML 文件，可用于检测静止图像、视频和摄像头所得到图像中的人脸</p></li></ul><h4 id="静态人脸检测"><a href="#静态人脸检测" class="headerlink" title="静态人脸检测"></a>静态人脸检测</h4><pre><code class="python">import cv2 as cvdef face_detect_demo():    #将图片转换为灰度图片    gray=cv.cvtColor(img,cv.COLOR_BGR2GRAY)    #加载特征数据    face_detector=cv.CascadeClassifier(&#39;opencv/sources/data/haarcascades/haarcascade_frontalface_default.xml&#39;)    faces=face_detector.detectMultiScale(gray)    for x,y,w,h in faces:        cv.rectangle(img,(x,y),(x+w,y+h),color=(0,255,0),thickness=2)    cv.imshow(&#39;result&#39;,img)#加载图片img=cv.imread(&#39;lena.jpg&#39;)face_detect_demo()cv.waitKey(0)cv.destroyAllWindows()</code></pre><h4 id="检测多张人脸"><a href="#检测多张人脸" class="headerlink" title="检测多张人脸"></a>检测多张人脸</h4><pre><code class="python">import cv2 as cvdef face_detect_demo():    #将图片灰度    gray=cv.cvtColor(img,cv.COLOR_BGR2GRAY)    #加载特征数据    face_detector = cv.CascadeClassifier(        &#39;opencv/sources/data/haarcascades/haarcascade_frontalface_default.xml&#39;)    faces = face_detector.detectMultiScale(gray)    for x,y,w,h in faces:        print(x,y,w,h)        cv.rectangle(img,(x,y),(x+w,y+h),color=(0,0,255),thickness=2)        cv.circle(img,center=(x+w//2,y+h//2),radius=w//2,color=(0,255,0),thickness=2)    #显示图片    cv.imshow(&#39;result&#39;,img)#加载图片img=cv.imread(&#39;face3.jpg&#39;)#调用人脸检测方法face_detect_demo()cv.waitKey(0)cv.destroyAllWindows()</code></pre><h4 id="检测视频中的人脸"><a href="#检测视频中的人脸" class="headerlink" title="检测视频中的人脸"></a>检测视频中的人脸</h4><pre><code class="python">import cv2 as cvdef face_detect_demo(img):    #将图片灰度    gray=cv.cvtColor(img,cv.COLOR_BGR2GRAY)    #加载特征数据    face_detector = cv.CascadeClassifier(&#39;opencv/sources/data/haarcascades/haarcascade_frontalface_default.xml&#39;)    faces = face_detector.detectMultiScale(gray)    for x,y,w,h in faces:        cv.rectangle(img,(x,y),(x+w,y+h),color=(0,0,255),thickness=2)        cv.circle(img,center=(x+w//2,y+h//2),radius=(w//2),color=(0,255,0),thickness=2)    cv.imshow(&#39;result&#39;,img)#读取视频cap=cv.VideoCapture(&#39;video.mp4&#39;)while True:    flag,frame=cap.read()    print(&#39;flag:&#39;,flag,&#39;frame.shape:&#39;,frame.shape)    if not flag:        break    face_detect_demo(frame)    if ord(&#39;q&#39;) == cv.waitKey(10):        breakcv.destroyAllWindows()cap.release()</code></pre><h3 id="人脸识别"><a href="#人脸识别" class="headerlink" title="人脸识别"></a>人脸识别</h3><ul><li>用一系列分好类的图像来训练程序，并基于这些图像来进行识别</li><li>每个识别都具有转置信（confidence）评分，因此可在实际应用中通过对其设置阈值来进行筛选</li></ul><h4 id="训练数据"><a href="#训练数据" class="headerlink" title="训练数据"></a>训练数据</h4><ul><li><code>train()</code> 函数中有两个参数：图像数组和标签数组，这些标签表示进行识别时候某人人脸的ID</li><li>需要安装 <code>opencv-contrib-python</code> 模块</li></ul><pre><code class="python">import osimport cv2 as cvimport sysfrom PIL import Imageimport numpy as npdef getImageAndLabels(path):    facesSamples=[]    ids=[]    imagePaths=[os.path.join(path,f) for f in os.listdir(path)]    #检测人脸    face_detector = cv.CascadeClassifier(        &#39;opencv/sources/data/haarcascades/haarcascade_frontalface_default.xml&#39;)    #遍历列表中的图片    for imagePath in imagePaths:        #打开图片        PIL_img=Image.open(imagePath).convert(&#39;L&#39;)        #将图像转换为数组        img_numpy=np.array(PIL_img,&#39;uint8&#39;)        faces = face_detector.detectMultiScale(img_numpy)        #获取每张图片的id        id=int(os.path.split(imagePath)[1].split(&#39;.&#39;)[0])        for x,y,w,h in faces:            facesSamples.append(img_numpy[y:y+h,x:x+w])            ids.append(id)    return facesSamples,idsif __name__ == &#39;__main__&#39;:    #图片路径    path=&#39;./data/jm/&#39;    #获取图像数组和id标签数组    faces,ids = getImageAndLabels(path)    #获取训练对象    recognizer = cv.face.LBPHFaceRecognizer_create()    recognizer.train(faces,np.array(ids))    #保存文件    recognizer.write(&#39;trainer/trainer.yml&#39;)</code></pre><h4 id="基于-LBPH-的人脸识别"><a href="#基于-LBPH-的人脸识别" class="headerlink" title="基于 LBPH 的人脸识别"></a>基于 LBPH 的人脸识别</h4><ul><li>LBPH（Local Binary Pattern Histogram）将检测到的人脸分为小单元，并将其与模型中的对应单元进行比较，对每个区域的匹配值产生一个直方图</li><li>由于这种方法的灵活性，LBPH 是唯一允许模型样本人脸和检测到的人脸在形状、大小上可以不同的人脸识别算法</li><li>调整后的区域中调用 <code>predict()</code>函数，该函数返回两个元素的数组：第一个元素是所识别<br>个体的标签，第二个是置信度评分</li><li>所有的算法都有一个置信度评分阈值，置信度评分用来衡量所识别人脸与原模型的差距，0 表示完全匹配</li><li>可能有时不想保留所有的识别结果，则需要进一步处理，因此可用自己的算法来估算识别的置信度评分</li><li>一个好的 LBPH 识别参考值要低于50，任何高于80的参考值都会被认为是低的置信度评分</li></ul><pre><code class="python">import cv2 as cvimport numpy as npimport os# 加载训练数据集文件recognizer = cv.face.LBPHFaceRecognizer_create()recognizer.read(&#39;trainer/trainer.yml&#39;)# 准备识别的图片faceCascade = cv.CascadeClassifier(    &#39;opencv/sources/data/haarcascades/haarcascade_frontalface_default.xml&#39;)font = cv.FONT_HERSHEY_SIMPLEXid = 0img = cv.imread(&#39;19.pgm&#39;)gray_img=cv.cvtColor(img,cv.COLOR_BGR2GRAY)faces = faceCascade.detectMultiScale(gray_img)for x, y, w, h in faces:    cv.rectangle(img, (x, y), (x + w, y + h), (0, 255, 0), 2)    # 人脸识别    id, confidence = recognizer.predict(gray_img[y:y + h, x:x + w])    print(&#39;标签id:&#39;, id, &#39;置信评分：&#39;, confidence)cv.imshow(&#39;result&#39;, img)cv.waitKey(0)cv.destroyAllWindows()</code></pre><h3 id="摄像头人脸识别"><a href="#摄像头人脸识别" class="headerlink" title="摄像头人脸识别"></a>摄像头人脸识别</h3><h4 id="摄像头调试"><a href="#摄像头调试" class="headerlink" title="摄像头调试"></a>摄像头调试</h4><pre><code class="python">#导入opencv模块import cv2#捕捉帧，笔记本摄像头设置为0即可capture = cv2.VideoCapture(0)#循环显示帧while(True):    ret, frame = capture.read()    #显示窗口第一个参数是窗口名，第二个参数是内容    cv2.imshow(&#39;frame&#39;, frame)    if cv2.waitKey(1) == ord(&#39;q&#39;):      #按q退出        break</code></pre><h4 id="摄像头人脸识别-1"><a href="#摄像头人脸识别-1" class="headerlink" title="摄像头人脸识别"></a>摄像头人脸识别</h4><pre><code class="python">import cv2import numpy as npface_cascade = cv2.CascadeClassifier(    &quot;opencv\sources\data\haarcascades\haarcascade_frontalface_default.xml&quot;)eye_cascade = cv2.CascadeClassifier(&quot;opencv\sources\data\haarcascades\haarcascade_eye.xml&quot;)cap = cv2.VideoCapture(0)while True:    ret, img = cap.read()    gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)    faces = face_cascade.detectMultiScale(gray, 1.1, 5)    if len(faces) &gt; 0:        for faceRect in faces:            x, y, w, h = faceRect            cv2.rectangle(img, (x, y), (x + w, y + h), (255, 0, 0), 2)            roi_gray = gray[y:y + h // 2, x:x + w]            roi_color = img[y:y + h // 2, x:x + w]            eyes = eye_cascade.detectMultiScale(roi_gray, 1.1, 1, cv2.CASCADE_SCALE_IMAGE, (2, 2))            for (ex, ey, ew, eh) in eyes:                cv2.rectangle(roi_color, (ex, ey), (ex + ew, ey + eh), (0, 255, 0), 2)    cv2.imshow(&quot;img&quot;, img)    if cv2.waitKey(1) &amp; 0xFF == ord(&#39;q&#39;):        break</code></pre>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;Open Source Computer Vision Library（OpenCV）是一个跨平台的计算机视觉库，可用于开发实时的图像处理、计算机视觉以及模式识别程序。OpenCV 用 C++ 语言编写，但本次实战项目使用的是 &lt;code&gt;python-opencv&lt;/code&gt; 库实现的，主要是为了初步了解人脸识别的步骤和算法后面的原理。以下为项目笔记，源代码保存在 &lt;a href=&quot;https://github.com/Bezhuang/PracticeMakesPerfect/tree/main/Python-OpenCV&quot;&gt;Github 仓库&lt;/a&gt;中，可供参考。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="编程与开发" scheme="http://blog.zhuangzhihao.top/categories/%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="Python" scheme="http://blog.zhuangzhihao.top/tags/Python/"/>
    
    <category term="OpenCV" scheme="http://blog.zhuangzhihao.top/tags/OpenCV/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络（下）</title>
    <link href="http://blog.zhuangzhihao.top/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E4%B8%8B/"/>
    <id>http://blog.zhuangzhihao.top/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E4%B8%8B/</id>
    <published>2021-08-29T16:00:00.000Z</published>
    <updated>2021-10-25T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>计算机网络是计算机专业必修的重要课程之一，与现实世界结合得相当紧密，也是考研408计算机学科专业基础综合考试中的一门课程。计算机网络学习的核心内容就是网络协议的学习。网络协议是为计算机网络中进行数据交换而建立的规则、标准或者说是约定的集合。我选择的课程是哈工大的<a href="https://www.icourse163.org/learn/HIT-154005">国家精品课</a>和谢希仁版教材，以下为所记课堂笔记下半部分，包含网络层、传输层和应用层的知识点，可供参考。上半部分笔记请访问<a href="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E4%B8%8A">计算机网络（上）</a></p></blockquote><a id="more"></a><h3 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h3><h3 id="未完待续"><a href="#未完待续" class="headerlink" title="未完待续"></a>未完待续</h3>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;计算机网络是计算机专业必修的重要课程之一，与现实世界结合得相当紧密，也是考研408计算机学科专业基础综合考试中的一门课程。计算机网络学习的核心内容就是网络协议的学习。网络协议是为计算机网络中进行数据交换而建立的规则、标准或者说是约定的集合。我选择的课程是哈工大的&lt;a href=&quot;https://www.icourse163.org/learn/HIT-154005&quot;&gt;国家精品课&lt;/a&gt;和谢希仁版教材，以下为所记课堂笔记下半部分，包含网络层、传输层和应用层的知识点，可供参考。上半部分笔记请访问&lt;a href=&quot;/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E4%B8%8A&quot;&gt;计算机网络（上）&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="计算机专业" scheme="http://blog.zhuangzhihao.top/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%93%E4%B8%9A/"/>
    
    
    <category term="computer networking" scheme="http://blog.zhuangzhihao.top/tags/computer-networking/"/>
    
  </entry>
  
  <entry>
    <title>数据结构（中）</title>
    <link href="http://blog.zhuangzhihao.top/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%B8%AD/"/>
    <id>http://blog.zhuangzhihao.top/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%B8%AD/</id>
    <published>2021-08-16T16:00:00.000Z</published>
    <updated>2021-09-25T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>数据结构是指数据的存储结构，是带有结构特性的数据元素的集合。精心选择的数据结构可以带来更好的运行或者存储效率。数据结构是计算机科学与技术专业、软件工程专业甚至于其它电气信息类专业的重要专业基础课程，在408计算机学科专业基础综合考试中占有45分。我选择的课程是浙江大学数据结构<a href="https://www.icourse163.org/course/ZJU-93001">国家精品课</a>，以下为所记课堂笔记第二部分，包含树和图的知识总结以及所需记忆的代码，另外我在开源仓库中还保持了浙大慕课版本的<a href="https://github.com/Bezhuang/LearnCS/tree/main/%E5%90%8D%E6%A0%A1%E5%85%AC%E5%BC%80%E8%AF%BE/%E6%B5%99%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84">代码</a>，可供参考。其他部分笔记详见<a href="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%B8%8A">数据结构（上）</a>和<a href="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%B8%8B">数据结构（下）</a></p></blockquote><a id="more"></a><h3 id="矩阵与广义表"><a href="#矩阵与广义表" class="headerlink" title="矩阵与广义表"></a>矩阵与广义表</h3><h4 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵"></a>矩阵</h4><ul><li><p>矩阵的转置</p><pre><code class="cpp">void trsmat(int A[][maxSize],int B[][maxSize],int m, int n)&#123;    for (int i = 0;i &lt; m;++i)        for (int j = 0;j &lt; n;++j)            B[j][i] = A[i][j];&#125;</code></pre></li><li><p>矩阵相加</p><pre><code class="cpp">void addmat(int C[][maxSize],int A[][maxSize],int B[][maxSize],int m, int n)&#123;    for (int i = 0;i &lt; m;++i)        for (int j = 0;j &lt; n;++j)            C[i][j] = A[i][j] + B[i][j];&#125;</code></pre></li><li><p>矩阵相乘</p><pre><code class="cpp">void amutmat(int C[][maxSize],int A[][maxSize],int B[][maxSize],int m, int n,int k)&#123;    for (int i = 0;i &lt; m;++i)        for (int j = 0;j &lt; k;++j)        &#123;            C[i][j] = 0;            for int(h = 0;h &lt; n;++h)                C[i][j] += A[i][j] * B[i][j];        &#125;&#125;</code></pre></li><li><p>相同的元素或者零元素在矩阵中分布存在一定规律的矩阵称为特殊矩阵，反之称为稀疏矩阵</p><ul><li>对称矩阵、三角阵、对角矩阵</li></ul></li></ul><h4 id="广义表"><a href="#广义表" class="headerlink" title="广义表"></a>广义表</h4><ul><li>表元素可以是原子或者广义表的一种线性表的扩展结构</li><li>广义表可以是递归定义的，长度为表最上层元素的个数，深度为表中括号的最大的层数</li><li>当广义表非空时，第一个元素为广义表的表头，其余元素组成的表是广义表的表尾</li><li>原子结点有两个域：标志域和数据域</li><li>广义表结点有三个域：标志域，头指针域与尾指针域</li></ul><h3 id="树"><a href="#树" class="headerlink" title="树"></a>树</h3><h4 id="树的基本概念"><a href="#树的基本概念" class="headerlink" title="树的基本概念"></a>树的基本概念</h4><ul><li>树是一种非线性的数据结构，是若干个结点的集合，由唯一的根和若干个互不相交的子树组成<ul><li>结点不仅包含数据元素，并且包含指向子树的分支</li><li>结点的度是结点拥有的子树个数或者分支个数，树的度是树中各结点度的最大值</li><li>树的高度是树中结点的最大层次，根结点的高度为树的高度</li></ul></li><li>树的双亲存储结构：<code>int tree[maxSize]</code></li><li>树的链式存储结构<ul><li>邻接表：孩子存储结构</li><li>孩子兄弟存储结构</li></ul></li></ul><h4 id="二叉树的概念和性质"><a href="#二叉树的概念和性质" class="headerlink" title="二叉树的概念和性质"></a>二叉树的概念和性质</h4><ul><li><p>二叉树的定义</p><ul><li>每个结点最多只有两颗子树，即二叉树中的结点的度只能为0、1、2</li><li>子树有左右顺序之分，不能颠倒</li></ul></li><li><p>满二叉树：在一颗二叉树中，如果所有的分支节点都有左、右孩子节点，并且叶子节点都集中在二叉树的最下一层</p></li><li><p>完全二叉树由满二叉树从右至左、从上之下挨个删除结点得到的</p></li><li><p>二叉树的主要性质</p><ol><li><p>非空二叉树上叶子结点数等于双分支结点数加1，$n_0=n_2+1$</p></li><li><p>在二叉树的第 $i$ 层上最多有 $2^{i-1}$个节点，$(i&gt;=1)$</p></li><li><p>二叉树中如果深度为 $k$，那么最多有 $2^{k-1}$ 个节点，$(k&gt;=1)$</p></li><li><p>若对含 n 个结点的完全二叉树从上到下且从左至右进行 1 至 n 的编号，则对完全二叉树中任意一个编号为 i 的结点：</p><ul><li>若 i=1，则该结点是二叉树的根，无双亲，否则编号为 $\lfloor i/2\rfloor$ 的结点为其双亲结点（向下取整）</li><li>若 2i&gt;n，则该结点无左孩子，否则，编号为 2i 的结点为其左孩子结点</li><li>若 2i+1&gt;n，则该结点无右孩子，否则，编号为2i+1 的结点为其右孩子结点</li></ul></li><li><p>Catalan()：给定 n 个结点，能够成 $h\left( n\right) =\dfrac{C_{2n}^{n}}{n+1}$  棵不同的二叉树</p></li><li><p>在完全二叉树中，具有n个节点的完全二叉树的深度为 $\lfloor log2n\rfloor+1$</p></li></ol></li><li><p>二叉树的顺序存储结构最适用于完全二叉树</p></li><li><p>二叉树的链式存储结构</p><pre><code class="cpp">typedef struct BTNode&#123;    char  data;    //数据域    struct BTNoode* lchild;    struct BTNode* rchild;&#125; BTNode;</code></pre></li></ul><h4 id="二叉树的遍历算法"><a href="#二叉树的遍历算法" class="headerlink" title="二叉树的遍历算法"></a>二叉树的遍历算法</h4><ul><li><p>先序遍历</p><pre><code class="cpp">/*二叉树的非递归先序遍历*/void PreTraverseTree2(BitNode * root)&#123;    StackNode* S;   //定义一个栈指针    BitNode* p;   //工作指针    S = NULL;    p = root;    S = InitStack(S);   //初始化栈    if (NULL == p)    &#123;        printf(&quot;树为空！\n&quot;);        return;    &#125;     //end if    while (p || !StackEmpty(S))    &#123;     //如果树不空或者栈不空        if (p)        &#123;            StackPush(S, p);    //p 所指节点入栈            printf(&quot;%c &quot;, p-&gt;data);     //相当于 visit（p）            p = p-&gt;lchild ;     //指向 p 的左孩子         &#125;//end if        else        &#123;     //p 所指节点为空，则出栈赋给 p，遍历右子树            StackPop(S, p);            p = p-&gt;rchild;     //若右孩子有左子树则继续 while 将左孩子入栈        &#125;    //end else    &#125;    //end while    free(S);&#125;    //end PreTraverseTree2/*二叉树的递归先序遍历*/void preOrder(BiTNode *root)&#123;    if (root)    &#123;        printf(&quot;%d &quot;, root-&gt;data);        preOrder(root-&gt;lchild);        preOrder(root-&gt;rchild);    &#125;&#125;</code></pre></li><li><p>中序遍历</p><pre><code class="cpp">/*二叉树的非递归中序遍历*/void InOrderTraverseTree2(BitNode* root)&#123;    StackNode* S; //定义一个栈指针    BitNode* p; //工作指针    S = NULL;    p = root;    S = InitStack(S); //初始化栈    if (NULL == p) &#123; //如果是空树        printf(&quot;树为空！\n&quot;) ;        return;    &#125;//end if    while (p || !StackEmpty(S)) &#123; //如果树不空或者栈不空        if (p)        &#123;            StackPush(S, p); //将节点入栈            p = p-&gt;lchild; //指针一直向左孩子移动直到无左孩子        &#125;//end if        else        &#123;            StackPop(S, p); //p 左子树为空则出栈            printf(&quot;%c &quot;, p-&gt;data); //访问 p 节点            p = p-&gt;rchild; //向右子树移动        &#125;//end else    &#125;//end while    free(S);&#125;//end InOrderTraverseTree2/*二叉树的递归中序遍历*/void inOrder(BiTNode* root)&#123;    if (root)    &#123;        inOrder(root-&gt;lchild);        printf(&quot;%d &quot;, root-&gt;data);        inOrder(root-&gt;rchild);    &#125;&#125;</code></pre></li><li><p>后序遍历</p><pre><code class="CPP">/*二叉树非递归后序遍历*/void LastTraverseTree2(BiTNode* root)&#123;    StackNode* S; BiTNode* cur, * pre;//定义一个栈指针    S = NULL; S = InitStack(S); //cur 为当前节点指针，pre 保存上一节点    if (NULL == root)    &#123;        printf(&quot;树为空！\n&quot;);        return;    &#125;//end if    pre = NULL; cur = NULL;    StackPush(S, T); //根节点入栈    while (!StackEmpty(S))    &#123; //若栈非空        cur = NULL;        StackGetTop(S, cur); //将栈顶节点赋给 cur/*要保证根节点在左孩子和右孩子访问之后才能访问，因此对于任一节点 P，先将其入 栈。如果 P 不存在左孩子和右孩子，则可以直接访问它；或者 P 存在左孩子或者右孩子，但是其左孩子和右孩子都已被访问过了，则同样可以直接访问该节点。*/        if ((cur-&gt;lchild == NULL &amp;&amp; cur-&gt;rchild == NULL) ||            (pre != NULL &amp;&amp; (pre == cur-&gt;lchild || pre == cur-&gt;rchild)))        &#123;            printf(&quot;%c &quot;, cur-&gt;data);            pre = cur;            StackPop(S, cur);        &#125;//end if//若非上述两种情况，则将 P 的右孩子和左孩子依次入栈，这样就保证了每次取栈顶元素//的时候，左孩子在右孩子前面被访问，左孩子和右孩子都在根节点前面被访问。        else        &#123;            if (cur-&gt;rchild != NULL)                StackPush(S, cur-&gt;rchild);            if (cur-&gt;lchild != NULL)                StackPush(S, cur-&gt;lchild);        &#125;//end else    &#125;//end while    free(S);&#125;//end LastTraverseTree2/*二叉树递归后序遍历*/void postOrder(BiTNode* root)&#123;    if (root)    &#123;        postOrder(root-&gt;lchild);        postOrder(root-&gt;rchild);        printf(&quot;%d &quot;, root-&gt;data);    &#125; &#125;</code></pre></li><li><p>层次遍历：自上而下，自左向右</p><ul><li>首先，将二叉树的祖先节点入队列</li><li>然后循环执行以下步骤，直到队列为空：节点出队列进行相应操作，该节点如果有左孩子节点，左孩子节点入队列，该节点如果有右孩子节点，右孩子节点入队</li></ul><pre><code class="cpp">void LayerOrder(BiTreeNode* head)&#123;    LQueue Q;    Initiate_Queue(&amp;Q);    BiTreeNode* p;    if (head != NULL) AppendQueue(&amp;Q, head);    while (QueueNotEmpty(&amp;Q)) &#123;        p = QueueDelete(&amp;Q);        cout &lt;&lt; p-&gt;data &lt;&lt; &quot; &quot;;        if (p-&gt;LChild != NULL) AppendQueue(&amp;Q, p-&gt;LChild);        if (p-&gt;RChild != NULL) AppendQueue(&amp;Q, p-&gt;RChild);    &#125;&#125; </code></pre></li></ul><h4 id="哈夫曼树和哈夫曼编码"><a href="#哈夫曼树和哈夫曼编码" class="headerlink" title="哈夫曼树和哈夫曼编码"></a>哈夫曼树和哈夫曼编码</h4><ul><li><p>哈夫曼树又叫做最优二叉树，它的特点是带权路径最短</p><ul><li>树的路径长度是指从根到每个节点的路径长度之和</li><li>带权路径长度是从该节点到根节之间的路径长度乘以结点的权值</li><li>树的带权路径长度（WPL）是指树中所有叶子节点的带权路径长度之和</li></ul></li><li><p>求哈夫曼树的带权路径长度：WPL = 第 i 个节点的权值+ 第i个节点的长度</p><pre><code class="cpp">ElemType WeightPathLength(struct BTreeNode* FBT, int len)//len初始为0  &#123;      if (FBT == NULL) //空树返回0          return 0;      else      &#123;          if (FBT-&gt;left == NULL &amp;&amp; FBT-&gt;right == NULL)//访问到叶子结点              return FBT-&gt;data * len;          else //访问到非叶子结点，进行递归调用，返回左右子树的带权路径长度之和，len递增              return WeightPathLength(FBT-&gt;left,len+1)+WeightPathLength(FBT-&gt;right,len+1);      &#125;  &#125;  </code></pre></li><li><p>哈夫曼树的构造方法：根据数组 a 中 n 个权值建立一棵哈夫曼树，返回树根指针  </p><pre><code class="cpp">struct BTreeNode* CreateHuffman(ElemType a[], int n)  &#123;      int i, j;      struct BTreeNode **b, *q;      b = malloc(n*sizeof(struct BTreeNode));      for (i = 0; i &lt; n; i++) //初始化b指针数组，使每个指针元素指向a数组中对应的元素结点      &#123;          b[i] = malloc(sizeof(struct BTreeNode));          b[i]-&gt;data = a[i];          b[i]-&gt;left = b[i]-&gt;right = NULL;      &#125;      for (i = 1; i &lt; n; i++)//进行 n-1 次循环建立哈夫曼树      &#123;          //k1表示森林中具有最小权值的树根结点的下标，k2为次最小的下标          int k1 = -1, k2;          for (j = 0; j &lt; n; j++)//让k1初始指向森林中第一棵树，k2指向第二棵          &#123;              if (b[j] != NULL &amp;&amp; k1 == -1)              &#123;                  k1 = j;                  continue;              &#125;              if (b[j] != NULL)              &#123;                  k2 = j;                  break;              &#125;          &#125;          for (j = k2; j &lt; n; j++)//从当前森林中求出最小权值树和次最小          &#123;              if (b[j] != NULL)              &#123;                  if (b[j]-&gt;data &lt; b[k1]-&gt;data)                  &#123;                      k2 = k1;                      k1 = j;                  &#125;                  else if (b[j]-&gt;data &lt; b[k2]-&gt;data)                      k2 = j;              &#125;          &#125;          //由最小权值树和次最小权值树建立一棵新树，q指向树根结点          q = malloc(sizeof(struct BTreeNode));          q-&gt;data = b[k1]-&gt;data + b[k2]-&gt;data;          q-&gt;left = b[k1];          q-&gt;right = b[k2];          b[k1] = q;//将指向新树的指针赋给b指针数组中k1位置          b[k2] = NULL;//k2位置为空      &#125;      free(b); //删除动态建立的数组b      return q; //返回整个哈夫曼树的树根指针  &#125;  </code></pre></li><li><p>哈夫曼编码</p><ul><li>每个字符对应一个二进制编码，采用不等长编码方式，构造哈夫曼树</li><li>将每个字符的出现频率作为字符结点的权值赋予叶子结点，每个分支结点的左右分支分别用0和1编码</li><li>从树根结点到每个叶子结点的路径上所经分支的0、1编码序列等于该叶子结点的二进制编码</li><li>哈夫曼编码产生的是最短前缀码</li></ul><pre><code class="cpp">void HuffManCoding(struct BTreeNode* FBT, int len)//len初始值为0  &#123;      static int a[10];  //定义静态数组a，保存每个叶子的编码，数组长度至少是树深度减一      if (FBT != NULL)  //访问到叶子结点时输出其保存在数组a中的0和1序列编码      &#123;          if (FBT-&gt;left == NULL &amp;&amp; FBT-&gt;right == NULL)          &#123;              int i;              printf(&quot;结点权值为%d的编码：&quot;, FBT-&gt;data);              for (i = 0; i &lt; len; i++)                  printf(&quot;%d&quot;, a[i]);              printf(&quot;\n&quot;);          &#125;          else    //访问到非叶子结点时分别向左右子树递归调用，并把分支上的0、1编码保存到数组a          &#123;   //的对应元素中，向下深入一层时len值增1              a[len] = 0;              HuffManCoding(FBT-&gt;left, len + 1);              a[len] = 1;              HuffManCoding(FBT-&gt;right, len + 1);          &#125;      &#125;  &#125;  </code></pre></li></ul><h3 id="图"><a href="#图" class="headerlink" title="图"></a>图</h3><h4 id="图的基本概念"><a href="#图的基本概念" class="headerlink" title="图的基本概念"></a>图的基本概念</h4><ul><li>图由结点的有穷集合的 V 和边的集合  E 组成（<code>G(V,E)</code>）</li><li>图是按照无方向和有方向分为无向图和有向图，无向边用 $(v_i,v_j)$ 表示，有向边用 $&lt;v_i,v_j&gt;$ 表示</li><li>路径长度：路径上边或者弧的数目</li><li>顶点的度：顶点关联边的数目<ul><li>有向图中：方向指向顶点的边为入度；方向背向顶点的边为出度</li><li>在有向图中，顶点的度就是两者之和</li><li>在无向图中，任意两个顶点是相通的就是连通图，它的极大连通子图为连通分量</li><li>在向图中，任意两个顶点间互相都存在路径的就是强连通图，它的极大强连通子图为强连通分量</li></ul></li></ul><h4 id="图的存储结构"><a href="#图的存储结构" class="headerlink" title="图的存储结构"></a>图的存储结构</h4><ul><li><p>邻接矩阵</p><ul><li>图的顺序存储结构</li><li>用两个数组保存数据：一个一维数组存储图中顶点信息，一个二维数组存储图中边或弧的信息</li><li>无向图中邻接矩阵是个对称矩阵</li><li>0表示无边，1表示有边</li><li>顶点的度是行内数组之和，有向图中各行之和是出度，各列之和是入度 </li><li>邻接矩阵对于边数相对顶点较少的图，就是对存储空间极大的浪费</li></ul><pre><code class="cpp">typedef struct&#123;  int no;  char info;&#125; VertexType;typedef struct&#123;  int edges[maxSize][maxSize];    //有权图中int改为float  int n,e;    //顶点数和边数  VertexType vex[maxSize];    //存放结点信息&#125; MGragh;</code></pre></li><li><p>邻接表</p><ul><li>数组和链表相结合的存储方法，图的链式存储结构</li><li>图中顶点用一个一维数组存储</li><li>图中每个顶点 $V_i$ 的所有邻接点构成一个线性表</li><li>顶点表的各个结点由 data 和 Firstedge 两个域表示<ul><li>data 是数据域，存储顶点信息</li><li>firstedge 是指针域，指向边表的第一个结点，即顶点的第一个邻接点</li></ul></li><li>边表结点由 adjvex 和 next 两个域组成<ul><li>adjvex 是邻接点域，存储某顶点的邻接点在顶点表中坐标</li><li>next 存储边表中下一个结点指针</li></ul></li><li>有向图也可以用邻接表，出度表叫邻接表，入度表尾逆邻接表</li></ul><pre><code class="cpp">typedef struct ArcNode&#123;    int adnex;    //该边所指向的结点的位置    struct ArcNode * nextarc;    //指向下一条边的指针    int info;    //该边的相关信息(如权值)&#125; ArcNode;typedef struct&#123;    char data;    //顶点信息    ArcNode* firstarc;    //指向第一条边的指针&#125;VNode;typedef struct&#123;    VNode adjlist[maxSize];    //邻接表    int n, e;    //顶点数和边数&#125; AGraph;    //图的邻接表类型</code></pre></li><li><p>十字链表</p><ul><li>在邻接表中针对有向图，分为邻接表和逆邻接表，导致无法从一个表中获取图的入读和出度的情况，有人提出了十字链表</li><li>定点表<ul><li>firstin：入边表头指针，指向顶点入边表的第一个结点</li><li>firstout：出边表头指针，指向顶点出边表第一个结点</li></ul></li><li>边表<ul><li>tailvex 是指弧起点在顶点表的下标，headvex 弧终点在顶点表的下标</li><li>headlink 入边表指针域，指向终点相同的下一条边</li><li>taillink 是指边表指针域，指向起点相同的下一条边</li></ul></li></ul></li><li><p>邻接多重表</p><ul><li>ivex 和 jvex 是与某条边依附的两个顶点在顶点表中的下标</li><li>ilink 指向依附项点 ivex 的下一条边</li><li>jlink 指向依附顶点 jvex 的下一条边</li></ul></li></ul><h4 id="图的遍历算法"><a href="#图的遍历算法" class="headerlink" title="图的遍历算法"></a>图的遍历算法</h4><ul><li><p>深度优先遍历（DFS，Depth First Search） </p><ul><li>首先从图中某个顶点 $v_0$ 出发，访问此顶点，然后依次从 $v_0$ 相邻的顶点出发 深度优先遍历，直至图中所有与 $v_0$ 路径相通的顶点都被访问了</li><li>若此时尚有顶点未被访问， 则从中选一个顶点作为起始点，重复上述过程，直到所有的顶点都被访问</li><li>深度优先遍历是一个递归的过程，这种遍历过程类似树的先序遍历，均是先访问节点，再从该节点出发继续向下遍历</li></ul><pre><code class="cpp">bool visited[Max_Vex];    //定义访问标记数组，为了防止重复访问void DFSTraverse(Graph G)&#123;    for (v = 0;v &lt; G.vexnum;++v)        visited[v] = false;    //初始化标记数组    for (v = 0;v &lt; G.vexnum;++v)        if (!visited[v])    //如果 v 未被访问，那么从 v 起，开始做深度优先遍历            DFS(G, v);&#125;void DFS(Graph G, int v)&#123;    visit(v);    visited[v] = true; //定义为已访问    for (w = FirstNeighbor(G, v);w &gt;= 0;w = NextNeighbor(G, v, w))        if (!visited[w])            DFS(G, w);&#125;</code></pre></li><li><p>广度优先遍历（BFS，Breadth First Search）</p><ul><li>首先从图的某个顶点 $v_0$ 出发，访问了 $v_0$ 之后，依次访问与 $v_0$ 相邻的未被访 问的顶点</li><li>然后分别从这些顶点出发，广度优先遍历，直至所有的顶点都被访问完</li><li>BFS 遍历的方式类似于树的层次遍历</li></ul><pre><code class="cpp">bool visited[Max_Vex];    //定义访问标记数组void BFSTraverse(Graph G)&#123;    for (i = 0;i &lt; G.vexnum;++i)        visited[v] = false;    //初始化标记数组    InitQueue(Q);    for (v = 0;v &lt; G.vexnum;++v)        if (!visited[v])    //如果 v 未被访问，那么从 v 起，开始做广度优先遍历            BFS(G, v);&#125;void BFS(Graph G, int v)&#123;    visit(v);    visited[v] = true;    //定义为已访问    while (!isEmpty(Q))    &#123;        DeQueue(Q, v);        for (w = FirstNeighbor(G, v);w &gt;= 0;w = NextNeighbor(G, v, w))            if (!visited[w])            &#123;                visit(w);                visited[w] = true;                EnQueue(Q, w)            &#125;    //if    &#125;    //while&#125;</code></pre></li></ul><h4 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h4><ul><li><p>Prim 算法</p><ul><li>从图中仼意取出一个顶点，把它当成一棵树，然后从与这棵树相接的边中选取一条最短（权值最小）的边，并将这条边及其所连接的顶点也并入这棵树中，此时得到了一棵有两个顶点的树</li><li>然后从与这棵树相接的边中选取一条最短的边，并将这条边及其所连顶点并入当前树中，得到一棵有3个顶点的树</li><li>以此类推，直到图中所有顶点都被并入树中为止，此时得到的生成树就是最小生成树</li></ul><pre><code class="cpp">void prim (G,T)&#123;    T = ∅;    U = &#123;w&#125;;    while ((V - U) != ∅  )    &#123; //若图中不含全部顶点        设  (u，v) 是使 u∈U 与 v∈ (V-U)，且权值最小的边;        T = T∪ (u，v); //边归入树        U = U∪ &#123;v&#125;;     //顶点归入树    &#125;&#125;</code></pre></li><li><p>Kruskal 算法</p><ul><li>将图中边按照权值从小到大排序，然后从最小边开始扫描各边，并检测当前边是否为候选边，即是否该边的并入会构成回路，如不构成回路，则将该边并入当前生成树中，直到所有边都被检测完为止</li><li>Kruskal 算法的时间复杂度主要由选取的排序算法决定，排序算法所处理数据的规模由图的边数e 决定，与顶点数无关，因此克鲁斯卡尔算法适用于稀疏图</li><li>普里姆算法和克鲁斯卡尔算法都是针对于无向图的</li><li>判断是否产生回路要用到并查集，并查集中保存了一棵或者几棵树<ul><li>通过树中一个结点，可以找到其双亲结点，进而找到根结点（可以快速地将两个含有很多元素的集合并为一个，两个集合就是并査集中的两棵树，只需找到其中一棵树的根，然后将其作为另一棵树中任何个结点的孩子结点即可，可以方便地判断两个元素是否属于同一个集合</li><li>通过这两个元素所在的结点找到它们的根结点，如果它们有相同的根，则说明它们属于同一个集合，否则属于不同集合</li></ul></li></ul><pre><code class="cpp">void kruskal（V，T）&#123;    T = V;    //初始化树，仅含顶点    numS = n;    //不连分量的数目    while (numS &gt; 1)    &#123;        从 E 中取出权值最小的边（v,u）;        if（v 和 u 属于 T 中不同的连通分量）        &#123;            T = T∪（u，v）;//将此边加入到生成树中；            numS--; //不连通的分量减少 1        &#125;    &#125;&#125;</code></pre></li></ul><h4 id="最短路径"><a href="#最短路径" class="headerlink" title="最短路径"></a>最短路径</h4><ul><li><p>Dijkstra 算法</p><ul><li>通常用于求图中某一顶点到其余各顶点的最短路径</li><li>设  G=(V,E) 是一个带权有向图，把图中顶点集合 V 分成两组</li><li>第一组为已求出最短路径的顶点集合（用 S 表示，初始时 S 中只有一个源点，,以后每求得一条最短路径就将求得的顶点加入到集合 S 中，直到全部顶点都加入到 S 中）</li><li>第二组为其余未确定最短路径的顶点集合（用 U 表示），按最短路径长度的递增次序依次把第二组的顶点加入 S 中，在加入的过程中，总保持从源点 V 到 S 中各顶点的最短路径长度不大于从源点 V 到 U 中任何顶点的最短路径长度</li></ul></li><li><p>Dijkstra 算法步骤</p><ol><li>初始时，S 只包含源点，即 S＝{v}，v 的距离为 0，U 包含除 v 外的其他顶点，即:U={其 余顶点}，若 v 与 U 中顶点 u 有边，则正常有权值，若 u 不是 v 的出边邻接点，则 权值为 $∞$</li><li>从 U 中选取一个距离 v 最小的顶点 k，把 k 加入 S 中（该选定的距离就是 v 到 k 的最短路 径长度）</li><li>以 k 为新考虑的中间点，修改 U 中各顶点的距离值：若从源点 v 到顶点 u 的距离（经过顶点 k）比原来距离（不经过顶点 k）短，则修改顶点 u 的距离值，修改后的距离值为 v 到 k 的距离加上 k 到 u 的距离</li><li>重复步骤 b 和 c 直到所有顶点都包含在 S 中</li></ol><pre><code class="cpp">void Dijkstra(int v0)&#123;  　　bool S[MAXNUM];                                  // 判断是否已存入该点到S集合中      int n=MAXNUM;  　　for(int i=1; i&lt;=n; ++i) 　　 &#123;      　　dist[i] = A[v0][i];      　　S[i] = false;                                // 初始都未用过该点      　　if(dist[i] == MAXINT)                　　prev[i] = -1; 　　     else             　　prev[i] = v0;   　　&#125;   　 dist[v0] = 0;   　 S[v0] = true; 　　 　　 for(int i=2; i&lt;=n; i++) 　　 &#123;       　　int mindist = MAXINT;       　　int u = v0; 　　                            // 找出当前未使用的点j的dist[j]最小值      　　 for(int j=1; j&lt;=n; ++j)      　　    if((!S[j]) &amp;&amp; dist[j]&lt;mindist)      　　    &#123;         　　       u = j;                             // u保存当前邻接点中距离最小的点的号码          　 　      mindist = dist[j];       　　   &#125;       　　S[u] = true;        　　for(int j=1; j&lt;=n; j++)       　　    if((!S[j]) &amp;&amp; A[u][j]&lt;MAXINT)       　　    &#123;           　    　if(dist[u] + A[u][j] &lt; dist[j])     //在通过新加入的u点路径找到离v0点更短的路径             　    　&#123;                   　　dist[j] = dist[u] + A[u][j];    //更新dist                    　　prev[j] = u;                    //记录前驱顶点             　　    &#125;        　    　&#125;   　　&#125;&#125;</code></pre></li><li><p>Floyd 算法</p><ul><li>Floyd-Warshall算法（Floyd-Warshall algorithm）是解决任意两点间的最短路径的一种算法，可以正确处理有向图或负权的最短路径问题，同时也被用于计算有向图的传递闭包</li><li>Floyd-Warshall 算法的时间复杂度为  $O(N^3)$，空间复杂度为  $O(N^2)$</li><li>Floyd 算法是一个经典的动态规划算法，目标是寻找从点 i 到点 j 的最短路径，假设 Dis(i,j) 为节点 u 到节点 v 的最短路径的距离</li><li>对于每一个节点 k，检查 Dis(i,k) + Dis(k,j) &lt; Dis(i,j) 是否成立，如果成立，证明从 i 到 k 再到 j 的路径比 i 直接到j的路径短，便设置 Dis(i,j) = Dis(i,k) + Dis(k,j)，这样当遍历完所有节点 k，Dis(i,j) 中记录的便是 i 到 j 的最短路径的距离</li></ul></li><li><p>Floyd 算法步骤</p><ul><li>从任意一条单边路径开始，所有两点之间的距离是边的权，如果两点之间没有边相连，则权为无穷大　　</li><li>对于每一对顶点 u 和 v，看看是否存在一个顶点 w 使得从 u 到 w 再到 v 比己知的路径更短，如果是更新它</li></ul><pre><code class="cpp">for (k = 1;k &lt;= n;k++)    for (i = 1;i &lt;= n;i++)        for (j = 1;j &lt;= n;j++)            if (a[i][j] &gt; a[i][k] + a[k][j])                a[i][j] = a[i][k] + a[k][j];</code></pre></li></ul><h4 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h4><ul><li><p>对一个有向无环图 G 进行拓扑排序，是将 G 中所有顶点排成一个线性序列，使得图中任意一对顶点 u 和 v，若存在由 u 到 v 的路径，则在拓扑排序序列中一定是 u 出现在 v 的前边</p><ol><li>从 DAG 图中选择一个没有前驱的节点并输出</li><li>从图中删除该节点和所有以它为起点的有向边</li><li>重复上两步直到当前的 DAG 图为空或不存在无前驱的顶点为止</li></ol><pre><code class="cpp">bool topologicalSort(Graph GL)&#123;    EdgeNode* e;    int top = 0; //用于栈指针下标     int count = 0; // 用于统计输出顶点的个数     int* stack; // 建栈将入度为 0 的顶点入栈     stack = (int*)malloc(GL-&gt;numVertexes * sizeof(int));    for (i = 0; i &lt; GL-&gt;numVertexes; i++)        if (0 == GL-&gt;adjList[i].in) //将入度为 0 的顶点入栈             stack[++top] = i;    while (top != 0)    &#123;        gettop = stack[top--];        printf(&quot;%d -&gt; &quot;, GL-&gt;adjList[gettop].data);        count++; //输出 i 号顶点，并计数         for (e = GL-&gt;adjList[gettop].firstedge; e; e = e-&gt;next) &#123;            k = e-&gt;adjvex;            if (!(--GL-&gt;adjList[k].in))                //将 i 顶点的邻接点入度减 1，如果减 1 后为 0，则入栈                 stack[++top] = k;        &#125;    &#125;    if (count &lt; GL-&gt;numVertexes) return false;    else return true;&#125;</code></pre></li></ul>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;数据结构是指数据的存储结构，是带有结构特性的数据元素的集合。精心选择的数据结构可以带来更好的运行或者存储效率。数据结构是计算机科学与技术专业、软件工程专业甚至于其它电气信息类专业的重要专业基础课程，在408计算机学科专业基础综合考试中占有45分。我选择的课程是浙江大学数据结构&lt;a href=&quot;https://www.icourse163.org/course/ZJU-93001&quot;&gt;国家精品课&lt;/a&gt;，以下为所记课堂笔记第二部分，包含树和图的知识总结以及所需记忆的代码，另外我在开源仓库中还保持了浙大慕课版本的&lt;a href=&quot;https://github.com/Bezhuang/LearnCS/tree/main/%E5%90%8D%E6%A0%A1%E5%85%AC%E5%BC%80%E8%AF%BE/%E6%B5%99%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84&quot;&gt;代码&lt;/a&gt;，可供参考。其他部分笔记详见&lt;a href=&quot;/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%B8%8A&quot;&gt;数据结构（上）&lt;/a&gt;和&lt;a href=&quot;/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%B8%8B&quot;&gt;数据结构（下）&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="计算机专业" scheme="http://blog.zhuangzhihao.top/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%93%E4%B8%9A/"/>
    
    
    <category term="Data Structure" scheme="http://blog.zhuangzhihao.top/tags/Data-Structure/"/>
    
  </entry>
  
  <entry>
    <title>考研政治小抄</title>
    <link href="http://blog.zhuangzhihao.top/%E8%80%83%E7%A0%94%E6%94%BF%E6%B2%BB%E5%B0%8F%E6%8A%84/"/>
    <id>http://blog.zhuangzhihao.top/%E8%80%83%E7%A0%94%E6%94%BF%E6%B2%BB%E5%B0%8F%E6%8A%84/</id>
    <published>2021-07-31T16:00:00.000Z</published>
    <updated>2021-09-20T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>“思想政治理论”是研究生招生考试必考科目之一（为什么！┗|｀O′|┛），分为马原、毛中特、史纲、思修和时政5个大类。政治内容众多且杂，如果对基础概念和知识进行具体总结，篇幅非常长，本篇笔记只是以一个“Cheat-sheet”的形式尽可能包含所有考试重点，至于系统的归纳梳理则以肖精讲精练为准。</p></blockquote><a id="more"></a><h3 id="马克思主义基本原理概论"><a href="#马克思主义基本原理概论" class="headerlink" title="马克思主义基本原理概论"></a>马克思主义基本原理概论</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><ul><li>马克思主义哲学（科学方法）<ul><li>哲学的基本问题哲学的基本问题，不同的哲学流派</li><li>马哲</li><li>唯物论——世界的本源是什么</li><li>辩证法——世界是怎样的</li><li>认识论——如何认知世界</li><li>唯物史观——人类历史发展规律</li></ul></li><li>马克思主义政治经济学（主体）<ul><li>简单商品经济时期（资本主义以前的商品经济就叫简单经济时期）</li><li>发达商品经济时期</li><li>自由竞争资本主义（考试重点）</li><li>垄断竞争资本主义</li></ul></li><li>科学社会主义理论（目的和归宿）<ul><li>社会主义：从空想到实</li><li>共产主义：社会的终极形态</li></ul></li><li>恩格斯的《反杜林论》把马原分为哲学、政经、科社</li></ul><h4 id="唯物论"><a href="#唯物论" class="headerlink" title="唯物论"></a>唯物论</h4><ul><li>世界的本原<ul><li>主观唯心：世界的本原在我心里（王阳明心学）</li><li>客观唯心：世界的本原是脱离物质世界、不依赖于个人意识而独立存在的精神（佛教中的“缘”、道教中的“道”）</li><li>马克思主义哲学认为世界的本原是一切客观实在</li><li>客观实在：不以人的意志为转移</li></ul></li><li>物质决定意识，物质派生出意识</li></ul><h4 id="辩证法"><a href="#辩证法" class="headerlink" title="辩证法"></a>辩证法</h4><ul><li>物质世界是联系和发展的</li><li>辩证法的两大总特征：联系、发展<ul><li>联系：世界上的万事万物都与其他事物发生某种关联、产生某种联系，这个世界是联系的统一体，不存在完全孤立的事物</li><li>发展：任何事物都有它的过去、现在与将来，要立足于过去，展望将来</li></ul></li><li>事物是一对一对联系的<ul><li>一个事物与另一个事物发生联系，而另一个事物又与另一个事物发生联系，如此循环往复</li><li>世界就是靠一对一对相互交织的联系，构建出一张普遍交织的大网，这就是联系的普遍性</li></ul></li><li>辩证法的三大规律：对立统一、量变质变、否定之否定<ul><li>对立统一：是世间万事万物发展的原因和动力</li><li>量变质变：不断地进行星的积累，最终实现质的突破，不断地积累与突破</li><li>否定之否定：波浪式地上升、螺旋式的前进，是事物发展的方向与归宿</li></ul></li></ul><h4 id="认识论"><a href="#认识论" class="headerlink" title="认识论"></a>认识论</h4><ul><li>认识的本质是人类头脑对外部世界的能动反映</li><li>实践是认识的来源</li><li>没有人类的实践，就不会有人类的认识<ul><li>感性认识（浅显）：外部世界直接作用于感官而形成的认识</li><li>理性认识（深刻）：基于感性素材，对其概括、抽象、提炼、加工、思考，获得理性认识</li></ul></li><li>真理：脑子里面的东西与外部世界相致</li><li>谬误：脑子里面的东西与外部世界不一致</li><li>真理的绝对性与相对性：任何一个真理既是绝对的,又是相对的（从不同角度来看）<ul><li>真理的绝对性（通俗）：我既然是真理，我肯定是对的</li><li>真理的相对性（通俗）：我虽然是对的，但我未来有可能不对</li></ul></li></ul><h4 id="唯物史观"><a href="#唯物史观" class="headerlink" title="唯物史观"></a>唯物史观</h4><ul><li>历史进程中的决定性力量<ul><li>唯心史观:由精神力量所决定</li><li>唯物史观:由物质力量所决定（社会生产劳动及其生产力水平的提高决定历史发展）</li></ul></li><li>历史是什么人创造的<ul><li>唯心史观：历史是由英雄人物创造</li><li>唯物史观：历史是由人民群众创造</li></ul></li><li>历史向前发展是统一性和多样性的统一<ul><li>自然界：不以人的意志为转移的客观规律</li><li>人类社会：历史发展规律（取决定性作用）+ 人的主观能动性（对其选择）</li><li>规律使得人类社会的发展具有统一性，能动使得人类社会的发展具有多样性</li></ul></li></ul><h4 id="马克思主义政治经济学"><a href="#马克思主义政治经济学" class="headerlink" title="马克思主义政治经济学"></a>马克思主义政治经济学</h4><ul><li>商品价值的本质是劳动者通过劳动创造的价值</li><li>商品的价值：隐藏在商品里面、用作交换的、人的劳动</li><li>资本主社会以前：劳动的过程以及劳动的成果都归劳动者本人所有</li><li>资本主义社会以后：劳动的过程以及劳动的成果都归资本家所有</li><li>为什么资本主义社会存在剥削<ul><li>劳动创造价值，其中一部分价值通过工资的形式给了劳动者，多出来的部分（剩余价值）被资本家无偿占有</li></ul></li></ul><h4 id="科学社会主义发展进程"><a href="#科学社会主义发展进程" class="headerlink" title="科学社会主义发展进程"></a>科学社会主义发展进程</h4><ul><li>社会主义的发展进程<ul><li>空想 -&gt; 科学</li><li>理论 -&gt; 实践</li></ul></li><li>共产主义的基本特征<ul><li>物质财富极大丰富（产品）</li><li>精神境界极大提高</li><li>每个人自由而全面的发展</li></ul></li></ul><h3 id="思想道德修养与法律基础"><a href="#思想道德修养与法律基础" class="headerlink" title="思想道德修养与法律基础"></a>思想道德修养与法律基础</h3><h4 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h4><ul><li>思想修养<ul><li>人生观：如何树立正确的人生观</li><li>理想信念：如何树立远大的理想，理想和现实是怎样的关系</li><li>中国精神：什么是中国精神，如何去弘扬中国精神</li><li>社会主义核心价值观：当代中国人的思想标准</li></ul></li><li>道德修养<ul><li>道德的基本问题：概念、本质、特征、功能、历史发展脉络</li><li>两个维度<ul><li>不同时期的道德：古代的道德、近代的道德、今天的道德</li><li>不同领域的道德：社会工作中的道德提倡、职场工作中的道德提倡、自身修养的道德报倡、家庭生活中的道德提倡</li></ul></li></ul></li><li>法律基础：基础常识</li></ul><h4 id="思想修养"><a href="#思想修养" class="headerlink" title="思想修养"></a>思想修养</h4><ul><li>人生价值<ul><li>人生观：指我们对自己的人生的整体看法和整体观点</li><li>人生观属于世界观，世界观包含人生观</li><li>人生目的：在人生观中居于核心地位</li><li>人生目的是人生观的核心，可以决定人生态度和人生价值</li></ul></li><li>理想信念<ul><li>理想通过实践实现现实</li><li>实践是理想变成现实的根本途径</li><li>理想 -&gt; 信念 -&gt; 信仰 -&gt; 科学/非科学的信仰</li><li>信仰一般不会改变,但是不是不能改变</li><li>个人理想服从于社会理想，社会理想为个人理想提供保障</li></ul></li><li>中国精神<ul><li>以爱国主义为核心的民族精神</li><li>以改革创新为核心的时代精神</li></ul></li><li>社会主义核心价值观</li></ul><h4 id="道德修养"><a href="#道德修养" class="headerlink" title="道德修养"></a>道德修养</h4><ul><li>道德是上层建筑，由经济基础决定<ul><li>社会主义国家的经济基础：公有制（集体利益大于个人利益）</li><li>资本主义国家的经济基础：私有制（个人利益至上）</li></ul></li><li>道德的功能<ul><li>行为前：认识功能</li><li>行为中：规范功能</li><li>行为后：调节功能</li></ul></li><li>不同时期的道德<ul><li>古代的道德：传统美德</li><li>近代的道德：革命道德</li><li>现代的的道德：社会主义道德</li></ul></li><li>不同领域的道德<ul><li>社会公德</li><li>职业道德</li><li>家庭美德</li><li>个人品德</li></ul></li></ul><h4 id="法律基础"><a href="#法律基础" class="headerlink" title="法律基础"></a>法律基础</h4><ul><li>法律的基本问题<ul><li>法律的概念、功能、历史发展的脉络</li><li>法律是统治阶级的整体意志的体现，是统治阶级进行阶级统治的工具</li></ul></li><li>法律的运行：立法 -&gt; 执法 -&gt; 司法 -&gt; 守法</li><li>法律体系<ul><li>实体法律部门：宪法、民法等</li><li>程序法律部门：诉讼法、非诉讼法等</li></ul></li><li>法治体系：法律体系、法律实施体系、法律监督体系</li><li>法治思维：坚持法治思维，就要批判人治思维</li><li>法律权威：外在（强制性）和内在（合理性）</li><li>法律权利和义务</li></ul><h3 id="中国近代史纲要"><a href="#中国近代史纲要" class="headerlink" title="中国近代史纲要"></a>中国近代史纲要</h3><h4 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h4><ul><li>不考历史的细节，而考历史背后的政治逻辑</li><li>1840年鸦片战争：中国近代史开端</li><li>1911年辛亥革命：清朝政府结束，北洋政府开始</li><li>1919年五四运动：新旧民主主义革命分界线</li><li>1928年东北易帜：北洋政府结束，国民政府开始</li><li>1949年新中国成立：中国现代史开端</li></ul><h4 id="国情（从实际出发）"><a href="#国情（从实际出发）" class="headerlink" title="国情（从实际出发）"></a>国情（从实际出发）</h4><ul><li>国情是一切历史理论研究的起点</li><li>近代中国的国情：半殖民地半封建社会（1840年—1949年）</li></ul><h4 id="二、矛盾"><a href="#二、矛盾" class="headerlink" title="二、矛盾"></a>二、矛盾</h4><ul><li>近代中国主要矛盾<ul><li>半殖民：帝国主义与中华民族之间的矛盾</li><li>半封建：封建主义与人民大众之间的矛盾</li></ul></li></ul><h4 id="任务和对象"><a href="#任务和对象" class="headerlink" title="任务和对象"></a>任务和对象</h4><ul><li>近中国的任务<ul><li>帝国主义与中华民族之间的矛盾的任务：反帝</li><li>封建主义与人民大众之间的矛盾的任务：反封建</li></ul></li></ul><h4 id="中国革命的性质"><a href="#中国革命的性质" class="headerlink" title="中国革命的性质"></a>中国革命的性质</h4><ul><li>中国的革命是一场以反帝反封建为任务为对象的革命</li><li>革命的性质：资产阶级民族革命</li><li>新民主义革命是由无产阶级领导，但性质却是资产阶级革命<ul><li>决定革命性肤的不是革命的领导者，而是革命的任务和对象</li></ul></li><li>革命：推翻旧制度、确立新制度、确立新的生产关系的行为</li><li>奴隶社会：封建地主推翻奴隶主，奴隶主居于统治地位，奴隶处于被统治地位</li><li>封建社会：资产阶级推翻封建地主，封建地主居于统治地位，农民处于被统治地位</li><li>资本主义社会：无产阶级推翻资产阶级，资本主义居于统治地位，无产阶级处于被统治地位</li><li>因为中国革命的任务是反帝反封建，所以中国革命的性质就是资产阶级革命，无论谁来<br>做</li></ul><h4 id="史纲总结"><a href="#史纲总结" class="headerlink" title="史纲总结"></a>史纲总结</h4><ul><li>近代中国我们要做反帝反封建的任务，这件事情理应由资产阶级去做，是资产阶级的历<br>史使命</li><li>但是因为资产阶级的软弱本身没有实力去完成反帝反封建的历史使命，于是就由中国的无产阶级替资产阶级去完成本该由资产阶级完成的反帝反封建的历史使命</li><li>中国的革命也因此变成了由无产阶级领导的、资产阶级性质的、反帝反封建的、新式的<br>民主主义革命</li></ul><h3 id="毛泽东思想和中国特色社会主义理论体系概论"><a href="#毛泽东思想和中国特色社会主义理论体系概论" class="headerlink" title="毛泽东思想和中国特色社会主义理论体系概论"></a>毛泽东思想和中国特色社会主义理论体系概论</h3><h4 id="毛泽东思想"><a href="#毛泽东思想" class="headerlink" title="毛泽东思想"></a>毛泽东思想</h4><ul><li>理论的形成</li><li>理论内容<ul><li>新民主主义革命理论：1949年之前</li><li>社会主义改造理论：1949—1956年</li><li>社会主义建设道路的初步探索：1956—1976年</li></ul></li></ul><h4 id="中国特色主义理论体系"><a href="#中国特色主义理论体系" class="headerlink" title="中国特色主义理论体系"></a>中国特色主义理论体系</h4><ul><li>社会主义应该具有先进的、发达的生产力</li><li>怎样建设社会主义<ul><li>解放生产力，发展生产力</li><li>消灭剥削，消灭两极分化</li><li>最终达到共同富裕</li></ul></li><li>邓小平理论</li><li>“三个代表”重要思想<ul><li>建设什么样的党？怎样建设党？</li><li>要始终代表先进生产力的发展方向</li><li>要始终代表先进文化的发展方向</li><li>要始终代表广大人民的根本利益</li></ul></li><li>科学发展观<ul><li>实现什么样的发展？怎样发展？</li></ul></li><li>习近平新时代中国特色社会主义思想<ul><li>新时代、新思想</li><li>全面小康社会</li><li>建党一百年全面脱贫</li><li>2035年基本实现社会主义现代化</li><li>21世界中叶，建成社会主义现代化强国，实现中华民族伟大复兴</li><li>总任务：实现社会主义现代化，中华民族伟大复兴</li><li>布局理论：五位一体总体布局、四个全面战略布局</li><li>内外条件：国防军队建设、中国的外交问题、党的建设</li></ul></li></ul><h4 id="马克思主义中国化"><a href="#马克思主义中国化" class="headerlink" title="马克思主义中国化"></a>马克思主义中国化</h4><ul><li>新文化运动：学习西方资产阶级民族思想，来改造中国人的思想文化</li><li>十月革命：给中国送来了马克思列宁主义</li><li>五四运动：马克思列宁主义得到广泛传播</li><li>中共一大：以无产阶级革命推翻资产阶级，应联合资产阶级一起反帝反封建</li><li>六届六中全会：首次提出“马克思主义中国话”的命题</li><li>中共七大：实现了第一次飞跃，成果即为毛泽东思想</li><li>1956年《论十大关系》：第二次马克思主义中国化开始</li><li>改革开放：实现了马克思主义中国化的第二次飞跃，成果即为中国特色社会主义理论体系</li></ul><h4 id="新民主主义理论"><a href="#新民主主义理论" class="headerlink" title="新民主主义理论"></a>新民主主义理论</h4><ul><li>革命路线：无产阶级领导的人民大众的反帝反封建反官资的革命</li><li>革命纲领<ul><li>政治上：各革命阶级联合专政</li><li>经济上：没收地主、官资，保护民资</li><li>文化上：民族的、科学的、大众的</li></ul></li><li>革命道路：农村包围城市，武装夺取政权</li><li>革命经验（三大法宝）：统战线、武装斗争、党的建设</li></ul><h4 id="社会主义建设初步探索理论"><a href="#社会主义建设初步探索理论" class="headerlink" title="社会主义建设初步探索理论"></a>社会主义建设初步探索理论</h4><ul><li>《论十大关系》<ul><li>第二次马克思主义中国化开始</li><li>方针：调动一切积极因素为社会主义建设服务</li><li>指导思想：独立自主的符合中国特点的社会主义建设道路</li></ul></li><li>《关于正确处理人民内部矛盾的问题》<ul><li>基本矛盾：生产力和生产关系、经济基础和上层建筑</li><li>主要矛盾：作为一个落后的农业国与先进的工业国需求之间存在的矛盾、人民日益增长的物质文化需要同当前的发展不满足人民需要状况之间的矛盾</li><li>两类矛盾：敌我矛盾、人民内部矛盾</li></ul></li><li>中国工业化道路：农轻重</li></ul><h3 id="当代世界经济与政治"><a href="#当代世界经济与政治" class="headerlink" title="当代世界经济与政治"></a>当代世界经济与政治</h3><h4 id="当代世界政治与经济"><a href="#当代世界政治与经济" class="headerlink" title="当代世界政治与经济"></a>当代世界政治与经济</h4><ul><li>当今世界形势：百年未有之大变局，机遇与挑战并存</li><li>国际行为体：大国、欧盟</li><li>地区热点问题：朝韩问题，伊朗问题，叙利亚问题等</li><li>中国对外战略：和平发展道路、合作共赢的新型国际关系、人类命运共同体、一带一路</li></ul><h4 id="时事政治"><a href="#时事政治" class="headerlink" title="时事政治"></a>时事政治</h4><ul><li>重大会议：国际、国内（两会）</li><li>重大改革举措：雄安新区、深圳、粤港澳大湾区</li><li>科技创新：神舟、天宫、嫦娥</li><li>中国对外战略：事件、人物、政策</li></ul>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;“思想政治理论”是研究生招生考试必考科目之一（为什么！┗|｀O′|┛），分为马原、毛中特、史纲、思修和时政5个大类。政治内容众多且杂，如果对基础概念和知识进行具体总结，篇幅非常长，本篇笔记只是以一个“Cheat-sheet”的形式尽可能包含所有考试重点，至于系统的归纳梳理则以肖精讲精练为准。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="学习生活" scheme="http://blog.zhuangzhihao.top/categories/%E5%AD%A6%E4%B9%A0%E7%94%9F%E6%B4%BB/"/>
    
    
  </entry>
  
  <entry>
    <title>操作系统（上）</title>
    <link href="http://blog.zhuangzhihao.top/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E4%B8%8A/"/>
    <id>http://blog.zhuangzhihao.top/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E4%B8%8A/</id>
    <published>2021-07-27T16:00:00.000Z</published>
    <updated>2021-09-19T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p> 操作系统（OS）是管理和控制计算机硬件与软件资源，是计算机上直接运行的最基本的系统软件，任何其他软件都必须在操作系统的支持下才能运行。操作系统是用户和计算机的接口，同时也是计算机硬件和其他软件的接口。操作系统的功能包括管理计算机系统的硬件、软件及数据资源，控制程序运行，提供人机交互界面，为其它应用软件提供支持等。我选择的课程是苏州大学的<a href="https://www.icourse163.org/course/SUDA-1001752241">国家精品课</a>和汤子瀛版教材，以下为所记课堂笔记上半部分，包含计算机操作系统概述、处理器管理的知识点，可供参考。下半部分笔记请访问<a href="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E4%B8%8B">操作系统（下）</a></p></blockquote><a id="more"></a><h3 id="操作系统概述"><a href="#操作系统概述" class="headerlink" title="操作系统概述"></a>操作系统概述</h3><h4 id="操作系统基本概念"><a href="#操作系统基本概念" class="headerlink" title="操作系统基本概念"></a>操作系统基本概念</h4><ul><li>冯诺依曼模型：运算器、存储器、控制器、输入设备和输出设备</li><li>引入操作系统的目的：提供一个计算机用户与计算机硬件系统之间的接口、有效的控制和管理计算机系统中的各种硬件和软件资源、合理地组织计算机系统的工作流程</li><li>操作系统是计算机系统的资源管理程序</li><li>操作系统的核心是控制和协调进程的运行，解决进程之间的通信</li><li>操作系统的发展：无操作系统阶段 -&gt; 单道批处理系统 -&gt; 多道批处理系统</li></ul><h4 id="操作系统的特征"><a href="#操作系统的特征" class="headerlink" title="操作系统的特征"></a>操作系统的特征</h4><ul><li>并行性：2个或多个事件在同一时刻发生</li><li>并发性：2个或多个事件在同一时间间隔内发生</li><li>并发和共享是操作系统的2个最基本的特征，二者之间互为存在条件</li><li>资源共享方式：互斥共享、同时访问</li><li>虚拟是指把一个物理上的实体变为若干个逻辑上的对应物</li><li>异步性</li></ul><h4 id="操作系统的功能和服务"><a href="#操作系统的功能和服务" class="headerlink" title="操作系统的功能和服务"></a>操作系统的功能和服务</h4><ul><li>处理器管理：进程控制、进程同步、进程通信、进程调度</li><li>存储器管理：内存分配、内存保护、内存扩充</li><li>设备管理：设备分配、设备传输控制、设备独立性</li><li>文件管理：文件存储空间的管理、目录管理、文件操作管理、文件保护</li><li>用户接口：命令接口、程序接口、图形接口<ul><li>联机命令接口又称交互式命令结构</li><li>脱机命令接口又称批处理命令接口</li></ul></li><li>操作系统3种基本类型：批处理操作系统、分时操作系统、实时操作系统</li><li>其他操作系统：嵌入式操作系统、集群系统、网络操作系统、分布式操作系统</li></ul><h4 id="操作系统的运行环境"><a href="#操作系统的运行环境" class="headerlink" title="操作系统的运行环境"></a>操作系统的运行环境</h4><ul><li>处理器的执行状态分为核心态与用户态<ul><li>核心态是操作系统管理程序执行时机器所处的状态</li><li>用户态是用户程序执行时机器所处的状态</li></ul></li><li>特权指令是只能由操作系统内核部分使用，不允许用户直接使用的指令，如I/O指令、设置中断屏蔽指令、清内存指令、存储保护指令和设置时钟指令</li><li>内核的指令操作工作在核心态<ul><li>时钟管理</li><li>中断机制</li><li>原语</li><li>系统控制的数据结构及处理</li></ul></li><li>异常，也称内中断，是由错误引起的</li><li>通常异常会引起中断，而中断未必是由异常引起的</li><li>系统调用（API）：进程控制、文件系统控制、系统控制、内存管理、网络管理、socket 管控、制用户管理以及进程间通信</li></ul><h4 id="操作系统的体系结构"><a href="#操作系统的体系结构" class="headerlink" title="操作系统的体系结构"></a>操作系统的体系结构</h4><ul><li>操作系统的体系结构主要包括模块组合结构、层次结构和微内核结构</li><li>模块组合结构<ul><li>接口简单直接，系统的效率相对较高</li><li>系统结构不清晰、可扩展性差、可适应性差</li></ul></li><li>层次结构<ul><li>按功能的调用次序排列成若干层</li><li>组织和依赖关系清晰明了，可读性、可适应性及可靠性都得到了增强</li><li>通常要将为进程提供服务的系统调用模块放在系统的内层。</li></ul></li><li>微内核结构<ul><li>客户服务器模式（C/S 模式）</li><li>每个服务进程运行在独立的用户进程中，可靠性好，灵活性好，便于维护</li><li>适合分布式处理的计算环境</li><li>效率不高，尤其是通信频繁的系统</li></ul></li></ul><h3 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h3><h4 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h4><ul><li><p>在计算机操作系统中，进程是资源分配的基本单位，也是独立运行的基本单位</p><ul><li>程序顺序执行时的特征：顺序性，封闭性，可再现性</li><li>程序的并发执行的特征：间断性，失去封闭性，不可再现性</li></ul></li><li><p>程序并发执行且其结果具有可再现性的条件（Bernstein 条件）</p><ul><li>R(p1) ∩ W(p2) = ∅</li><li>R(p2) ∩ W(p1) = ∅</li><li>W(p1) ∩ W(p2) = ∅</li></ul></li><li><p>进程的特征：动态性、并发性、独立性、异步性、结构特征（程序段、数据段和进程控制块）</p></li><li><p>进程和程序的关系</p><ul><li>进程和程序的关系程序是静止的</li><li>进程是暂时的，程序是永久的</li><li>进程的组成包括程序段、数据块和进程控制块（Process Control Block）</li><li>通过多次执行，一个程序可以产生多个不同的进程，通过调用关系，一个进程可以执行多个程序</li><li>进程可创建其他进程，而程序不能形成新的程序</li></ul></li><li><p>由程序段、相关数据段和PCB三部分构成的是进程映像，也叫进程实体</p><ul><li>映像是静态的，进程是动态的，进程是进程实体的运行过程</li></ul></li><li><p>进程和作业的区别</p><ul><li>作业是用户需要计算机完成某项任务而要求计算机所做的工作的集合</li><li>作业提交、作业收容、作业执行、作业完成</li><li>进程是已提交完毕的作业的执行过程，是资源分配的基本单位</li><li>作业是用户向计算机提交任务的任务实体，而进程是完成用户任务的执行实体</li><li>这个作业可由多个进程组成，而必须至少由一个进程组成，但一个进程不能构成多个作业</li></ul></li><li><p>进程的组成</p><ul><li>进程控制块（PCB）：标识进程的存在，刻画执行瞬间特征的数据机构</li><li>其他组成部分：程序段、数据段、进程标识符（PID）、进程当前状态、进程队列指针、程序和数据地址，进程优先级、CPU 现场保护区、通信信息、家族联系、占有资源清单</li></ul></li><li><p>PCB 是进程存在的唯一标志</p><ul><li>PCB 存在是为了保证程序的并发执行</li><li>创建进程实质上是创建进程的 PCB，而撤销进程实质上是撤销进程的 PCB</li><li>系统总是通过 PCB 对进程进行控制的</li></ul></li><li><p>进程的5种基本状态：就续状态、执行状态、阻塞状态、创建状态、结束状态</p><ul><li>执行状态只能由就绪状态转换，而无法由阻塞状态直接转换</li><li>不能从就绪状态变为阻塞状态</li><li>进程状态是唯一的</li></ul></li><li><p>进程的创建</p><ul><li>进程创建是通过创建原语实现的</li><li>申请一个空闲 PCB，并指定唯一的 PID -&gt; 分配必要的资源 -&gt; 将新进程的PCB初始化 -&gt; 插入到就绪队列</li><li>导致进程创建的事件：用户登录、作业调度和请求服务</li></ul></li><li><p>撤销一个进程：撤销原语</p><ul><li>找到被撤销进程的PCB -&gt; 停止该进程的执行 -&gt; 回收被撤销进程所占用的资源 -&gt; 回收PCB</li></ul></li><li><p>进程的阻塞与唤醒：两条低级进程通讯原语</p><ul><li>阻塞原语（P 原语）的功能是将进行进程由执行状态转为阻塞状态</li><li>唤醒原语（V 原语）的功能是将进程由阻塞状态变为就绪状态</li><li>一个进程由执行状态变为阻塞状态，是由这个进程自己调用阻塞原语去完成的</li><li>进程由阻塞状态变为就绪状态，是由另一个发现者进程调用唤醒原语去实现的。一般这个发现者进程与被唤醒进程是合作的并发进程</li></ul></li><li><p>调度是决定将系统资源分配给哪个进程，进程切换是实际分配系统资源</p><ul><li>进程切换一定会产生中断，但处理器模式切换不一定产生进程切换</li></ul></li><li><p>进程的互斥与同步就是一种进程间的通信方式</p><ul><li>高级进程通信方式：共享存储器系、消息传递系统、管道（共享文件）通信系统</li></ul></li></ul><h4 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h4><ul><li>线程是进程内一个相对独立的可调度的执行单元<ul><li>内核级线程依赖于内核，一个内核级线程由于 I/O 操作而阻塞时不会影响其他线程的运行</li><li>用户级线程不依赖于操作系统核心，由于操作系统内核不了解用户线程的存在，当一个线程阻塞时，整个进程必须等待</li></ul></li><li>进程与线程<ul><li>线程谁独立调度的基本单位，进程是拥有资源的基本单位</li><li>线程不拥有资源，但线程可以访问其隶属进程的系统资源</li><li>进程之间可以并发执行，同一进程内的多个线程之间也可以并发执行</li><li>多线程之间的同步与通信非常容易实现</li></ul></li><li>多线程模型：多对一模型，一对一模型，多对多模型（将多个用户级线程映射到多个内核级线程）</li></ul><h4 id="处理器的三级调度"><a href="#处理器的三级调度" class="headerlink" title="处理器的三级调度"></a>处理器的三级调度</h4><ul><li>高级调度（作业调度）：从外存上处于后备状态的作业中选择一个或多个，给他们分配内存等必要资源并建立相应的进程，以便该作业具有获得竞争处理器的权利<ul><li>作业调度每次要接纳多少个作业进入内存取决于多道程序的并发程度</li><li>多道程序的并发程度应根据系统的规模和运算速度来决定</li><li>应将哪些作业从外存调入内存取决于所采取的调度算法</li></ul></li><li>中级调度（交换调度）：按照给定的原则和策略，将处于外存对换区中具备运行条件的进程调入内存，并将其状态修改为就绪状态，挂在就绪队列上等待</li><li>低级调度（进程调度）：按照某种策略和方法，从就绪队列中选取一个进程，将处理器先分配给他<ul><li>进程调度的运行频率很高</li><li>作业调度的结果是为作业创造进程，而进程调度的结果是进程被执行</li></ul></li><li>衡量调度算法的性能： CPU利用率、系统吞吐量、响应时间、周转时间<ul><li>作业的周转时间 = 作业的完成时间 - 作业的提交时间</li><li>平均周转时间：多个作业周转时间的平均值</li><li>带权周转时间是作业周转时间与运行时间的比</li></ul></li></ul><h4 id="进程调度"><a href="#进程调度" class="headerlink" title="进程调度"></a>进程调度</h4><ul><li>处理器分配的任务由进程调度程序完成</li><li>进程调度的功能：记录系统中所有进程的有关情况以及状态特征，选择获得处理器的进程和处理器分配</li><li>引起进程调度的原因<ul><li>当前运行进程运行结束</li><li>当前运行进程因某种原因从运行状态进入阻塞状态</li><li>执行完系统调用等系统程序后返回用户进程</li><li>在采用抢占调度方式的系统中，一个更高优先级的进程要求使用处理器</li><li>在分时系统中分配给该进程的时间片已用完</li></ul></li><li>不能进行进程调度的情况<ul><li>处理中断的过程中</li><li>在操作系统内核程序临界区中</li><li>其他需要完全屏蔽中断的原子操作过程中</li></ul></li><li>进程调度的方式：抢占方式、非抢占方式</li></ul><h4 id="常见调度算法"><a href="#常见调度算法" class="headerlink" title="常见调度算法"></a>常见调度算法</h4><ul><li>先来先服务调度算法（作业调度、进程调度）<ul><li>FCFS：按照进程进入就绪队列的先后次序来分配处理器</li></ul></li><li>短作业优先调度算法（作业调度、进程调度）<ul><li>SJF：把处理器分配给最快完成的作业或进程</li></ul></li><li>优先级调度算法（作业调度、进程调度）<ul><li>静态优先级是在创建进程时确定的，确定之后整个进程运行期间不再改变</li><li>按进程类、作业的资源要求、用户类型和要求确定静态优先级</li><li>动态优先级是指在创建进程时根据进程的特点及相关情况确定一个优先级</li><li>根据进程占有CPU时间的长短和就绪进程等待CPU时间的长短确定动态优先级</li><li>基于优先级的调度算法还可按调度方式的不同，分为非抢占优先级调度算法和抢占优先级调度算法</li><li>在优先级相同的情况下，通常按照先来先服务或者短作业优先的顺序执行</li></ul></li><li>时间片轮转调度算法（进程调度）<ul><li>分时系统必须满足系统对响应时间的要求</li><li>就绪队列中的进程数与时间片的大小成反比</li><li>系统的处理能力决定时间片的大小</li></ul></li><li>高响应比优先调度算法（作业调度）<ul><li>响应比 = 作业响应时间 / 估计运行时间</li><li>作业响应时间 = 作业等待时间 + 估计运行时间</li></ul></li><li>多级反馈队列调度算法（作业调度）<ul><li>时间片轮转调度算法和优先级调度算法的综合与发展</li></ul></li></ul><h4 id="同步与互斥"><a href="#同步与互斥" class="headerlink" title="同步与互斥"></a>同步与互斥</h4><ul><li><p>互斥是间接相互制约关系，而同步是直接相互制约关系</p></li><li><p>只要是同类进程即为互斥关系，不同类进程即为同步关系</p></li><li><p>临界资源：同时仅允许一个进程使用的资源</p><ul><li>进入区、临界区、退出区、剩余区</li><li>临界区：进程中用于访问临界资源的代码，又称临界段</li><li>临界资源是必须互斥访问的资源，这种资源同时只能被一个进程所使用，但需要这种资源的进程不止一个，因此需要对使用临界资源的进程进行管理</li><li>每个进程的临界区代码可以不相同</li></ul></li><li><p>互斥的要求：空闲让进，忙则等待，有限等待，让权等待</p></li><li><p>互斥实现方法</p><ul><li>软件实现方法</li><li>互斥实现的硬件方法：中断屏蔽、硬件指令</li><li>硬件方法适用范围广，支持多个临界区，但不能实现让权等待</li></ul></li></ul><h4 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h4><ul><li>信号量 <code>(s,q)</code> 及同步原语<ul><li>整型变量 s 表示系统中某类资源的数目，q 是一个初始状态为空的队列</li><li>信号量的值仅能由 P 操作（wait）操作和 V 操作（signal）操作改变，操作系统利用它的状态对进程和资源进行管理</li><li> P 操作相当于申请资源，V 操作相当于释放资源</li></ul></li><li>信号量分为整型信号量和记录型信号量（资源信号量）<ul><li>记录型信号量添加了链表结构用于链接所有等待该资源的进程，解决忙等的问题</li></ul></li><li>信号量可以用来实现进程互斥和描述前趋关系</li></ul><h4 id="经典同步问题"><a href="#经典同步问题" class="headerlink" title="经典同步问题"></a>经典同步问题</h4><ul><li>生产者-消费者问题<ul><li>P(full) / P(empty) 与 P(mutex) 的顺序不可倒，必须先对资源信号量进行 P 操作，再对互斥信号量进行 P 操作。否则会导致死锁</li><li>互斥信号量就是给同类进程准备的</li></ul></li><li>读者写者问题（许多进程共享数据区）<ul><li>读者不互斥，写者必须互斥</li><li>读者优先，公平情况和写者优先三种不同算法</li></ul></li><li>哲学家进餐问题<ul><li>最多允许4个哲学家同时进餐</li><li>仅当一个哲学家左右两边的筷子同时可用时，他才可以拿起筷子</li><li>将哲学家编号要求奇数号的哲学家先拿左边筷子，偶数号的哲学家先拿右边筷子</li></ul></li><li>理发师问题</li><li>信号量机制问题的解题步骤分析<ul><li>关系分析</li><li>确定临界资源</li><li>整理思路</li></ul></li><li>实现同步互斥的 P、V 操作必须成对出现，先进行 P 操作进入临界区，后进行 V 操作退出临界区</li><li> P、V操作要分别紧靠临界区的头尾部</li><li>通常用于互斥的信号量初值设为 1</li></ul><h4 id="管程"><a href="#管程" class="headerlink" title="管程"></a>管程</h4><ul><li>管程定义了一个数据结构和能为并发进程所执行的一组操作<ul><li>局部于管程的数据只能被局部于管程内的过程所访问</li><li>一个进程只有通过调用管程内的过程才能进入管程访问共享数据</li><li>每次仅允许一个进程在管程内执行某个内部过程，即进程互斥地通过调用内部过程进入管程</li></ul></li><li>管程的互斥访问完全由编译程序在编译时自动添加</li><li>为实现进程间的同步，管程还必须包含若干用于同步的设施<ul><li>局限于管程并仅能从管程内进行访问的若干变量，用于区别各种不同的等待原因</li><li>在条件变量上进行操作的两个函数过程，wait 和 signal</li></ul></li></ul><h4 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h4><ul><li>死锁的概念<ul><li>参死锁的进程至少有两个</li><li>每个参与死锁的进程均等待资源</li><li>参与死锁的进程中至少有两个进程占有资源</li><li>死锁进程是系统中当前进程集合的一个子集</li></ul></li><li>死锁产生的原因是竞争资源<ul><li>一个资源是否属于可剥夺资源，完全取决于资源本身的性质</li></ul></li><li>死锁产生的必要条件<ul><li>互斥条件</li><li>不剥夺条件</li><li>请求于保持条件：可采用预先静态分配方法</li><li>环路等待条件：可采用有序资源分配法</li></ul></li><li>处理死锁的方法：鸵鸟算法、预防死锁、避免死锁、检测及解除死锁（被动）<ul><li>死锁预防对系统加的限制条件通常很严格，对系统的并发性会产生很大的副作用</li><li>死锁避免往往在资源被分配出去之前，要计算分配之后系统是否安全</li></ul></li><li>死锁的避免<ul><li>系统在进行资源分配之前，先计算资源分配的安全性（安全序列）</li><li>并非所有不安全状态都是死锁状态，死锁是不安全状态的真子集</li><li>银行家算法</li></ul></li><li>死锁的检测和解除<ul><li>系统资源分配图（system resource allocation graph）可定义为一个二元组</li><li><code>SRAG = (V,E)</code></li><li>死锁定理：不同简化顺序将得到相同的不可简化图。系统状态 S 为死锁状态的条件是当且仅当 S 状态的资源分配图是不可完全简化的</li><li>死锁检测算法：available、allocation、request、临时变量（work与finish）</li><li>死锁解除：剥夺资源，撤销进程，进程回退</li></ul></li><li>进程与饿死<ul><li>当等待时间给进程推进和响应带来明显影响时，发生进程饥饿</li><li>当饥饿到一定程度，进程所赋予的任务即使完成也不再具有实际意义时，进程被饿死</li><li>活锁：在忙时等待条件下发生的饥饿</li><li>饥饿和饿死与资源分配策略有关，因而可从公平性方面考虑防止饥饿与饿死</li></ul></li></ul>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt; 操作系统（OS）是管理和控制计算机硬件与软件资源，是计算机上直接运行的最基本的系统软件，任何其他软件都必须在操作系统的支持下才能运行。操作系统是用户和计算机的接口，同时也是计算机硬件和其他软件的接口。操作系统的功能包括管理计算机系统的硬件、软件及数据资源，控制程序运行，提供人机交互界面，为其它应用软件提供支持等。我选择的课程是苏州大学的&lt;a href=&quot;https://www.icourse163.org/course/SUDA-1001752241&quot;&gt;国家精品课&lt;/a&gt;和汤子瀛版教材，以下为所记课堂笔记上半部分，包含计算机操作系统概述、处理器管理的知识点，可供参考。下半部分笔记请访问&lt;a href=&quot;/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E4%B8%8B&quot;&gt;操作系统（下）&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="计算机专业" scheme="http://blog.zhuangzhihao.top/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%93%E4%B8%9A/"/>
    
    
    <category term="Operating System" scheme="http://blog.zhuangzhihao.top/tags/Operating-System/"/>
    
  </entry>
  
  <entry>
    <title>计算机组成原理（上）</title>
    <link href="http://blog.zhuangzhihao.top/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E4%B8%8A/"/>
    <id>http://blog.zhuangzhihao.top/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E4%B8%8A/</id>
    <published>2021-07-13T16:00:00.000Z</published>
    <updated>2021-08-14T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>计算机组成原理是计算机专业本科教学中的重要课程，它可以帮助我们系统地理解计算机硬件系统的组织结构和工作原理、掌握计算机硬件系统的基本分析与设计方法以及建立计算机系统的整体概念，为进一步学习计算机设计实践课程、培养系统开发、调试以及设计创新能力奠定良好的基础。计组是考研的最重最难点，在408计算机学科专业基础综合考试中占有45分。我选择的课程是哈工大的<a href="https://www.icourse163.org/course/hit-309001">国家精品课</a>，配合天勤高分笔记，以下为所记课堂笔记上半部分，包含计算机系统概论、数据的表示和运算、存储器和指令系统的知识点，可供参考。下半部分笔记请访问<a href="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E4%B8%8B">计算机组成原理（下）</a></p></blockquote><a id="more"></a><h3 id="计算机系统概论"><a href="#计算机系统概论" class="headerlink" title="计算机系统概论"></a>计算机系统概论</h3><h4 id="计算机的发展历程"><a href="#计算机的发展历程" class="headerlink" title="计算机的发展历程"></a>计算机的发展历程</h4><ul><li>电子管时代 -&gt; 晶体管时代 -&gt; 中小规模集成电路时代 -&gt; 超大规模集成电路时代 -&gt; 智能计算机 -&gt; 生物计算机/量子计算机</li><li>冯·诺依曼计算机（SISD）<ol><li>由运算器、存储器、控制器、输入设备和输出设备组成</li><li>指令和数据用二进制表示，以同等地位存于存储器，可按地址寻访</li><li>指令由操作码和地址码组成</li><li>存储程序，且以运算器为中心</li></ol></li></ul><h4 id="计算机的基本组成"><a href="#计算机的基本组成" class="headerlink" title="计算机的基本组成"></a>计算机的基本组成</h4><ul><li>计算机系统由硬件和软件组成，软件分为系统软件和应用软件</li><li>软硬件在逻辑上是等效的</li><li>计算机硬件主要由存储器、运算器、控制器、输入设备和输出设备组成<ul><li>运算器 ALU + 控制器 CU = CPU</li><li>主存 + 辅存 = 存储器</li><li>CPU + 主存储器 = 主机</li><li>现代计算机为以存储器为中心，指令和数据都是保存在存储器中的</li></ul></li><li>存储器的基本组成：存储体 -&gt; 存储单元 -&gt; 存储元<ul><li>存储单元：存放一串二进制代码，每个存储单元赋予一个地址号</li><li>存储字：存储单元中二进制代码的组合</li><li>存储字长：存储字的位数</li><li>地址寄存器 MAR：存放访存地址，N 位长的 MAR 可映射到 $2^N$ 个地址</li><li>数据寄存器 MDR：暂存从主存中读写的信息，MDR 长度等于存储字长</li><li>按字节寻址和数据线无关，只和地址线有关</li><li>按字寻址，数据线个数等于存储字长位数</li><li>字地址是连续存储单元地址中的最小值</li></ul></li><li>运算器的核心是算术逻辑单元 ALU<table><thead><tr><th></th><th>ACC 累加器</th><th>MQ 乘商寄存器</th><th>X 操作数寄存器</th></tr></thead><tbody><tr><td>加法</td><td>被加数、和</td><td></td><td>加数</td></tr><tr><td>减法</td><td>被减数、差</td><td></td><td>减数</td></tr><tr><td>乘法</td><td>乘积高位</td><td>乘数、乘积地位</td><td>被乘数</td></tr><tr><td>除法</td><td>被除数、余数</td><td>商</td><td>除数</td></tr></tbody></table></li><li>控制器的功能：解释指令、保证指令的按序执行<ul><li>取指令 -&gt; 分析指令 -&gt; 执行指令</li><li>程序计数器 PC：存放当前欲执行指令的地址，具有计数功能（PC）+1 -&gt; PC</li><li>指令寄存器 IR：存放当前欲执行的指令，IR 的内容来自主存的 MDR</li><li>控制单元 CU</li></ul></li><li>主机完成一条指令的过程：<ul><li>输入程序 -&gt; 程序首地址 -&gt; PC -&gt; 启动程序运行</li><li>取指令：PC -&gt; MAR -&gt; M -&gt; MDR -&gt;IR</li><li>分析指令：OP（IR）-&gt; CU</li><li>执行指令：Ad（IR）-&gt; MAR -&gt; M -&gt; MDR -&gt; ACC</li></ul></li><li>计算机系统的层次结构：高级语言 -&gt; 汇编语言 -&gt; 操作系统 -&gt; 机器语言 -&gt; 微指令系统</li></ul><h4 id="计算机硬件的主要技术指标"><a href="#计算机硬件的主要技术指标" class="headerlink" title="计算机硬件的主要技术指标"></a>计算机硬件的主要技术指标</h4><ul><li>机器字长：CPU一次能处理数据的位数，与CPU中的寄存器位数有关</li><li>运算速度：主频、核数及每个核支持的线程数<ul><li>吉普森法：$T_{M}=\sum ^{n}<em>{i=1}f</em>{i}t_{i}$</li><li>CPI：执行一条指令所需时钟周期数</li><li>MIPS：每秒执行百万条指令</li><li>FLOPS：每秒浮点运算次数</li><li>在指令数和时钟周期一定的前提下，CPI越大，执行时间越长</li></ul></li><li>存储容量：存放二进制信息的总位数<ul><li>主存容量：存储单元个数 × 存储字长，字节数</li><li>辅存容量：字节数</li></ul></li></ul><h3 id="数据的表示和运算"><a href="#数据的表示和运算" class="headerlink" title="数据的表示和运算"></a>数据的表示和运算</h3><h4 id="数制与编码"><a href="#数制与编码" class="headerlink" title="数制与编码"></a>数制与编码</h4><ul><li>十进制换二进制：整数除二取余，由下而上；小数乘二取整，由上而下 </li><li>二进制基本符号少，易于用稳态电路实现，编码、计数、逻辑运算规则简单</li><li>八进制 Q，十六进制 H</li><li>真值换机器数：0正1负</li><li>有权BCD码（8421）：逢1001进位，4位一数，C正D负放队尾，偶数位数高位补零</li><li>余3码：8421码的基础上加十进制3（0011）</li><li>ASCII：”0”：48；”A”：65；”a”：97</li><li>国标码 = (区位码)H + 2020H</li><li>汉字内码 = (国标码)H + 8080H</li><li>奇偶校验码：添加一位校验码后使整个码字里1的个数为奇数/偶数</li><li>循环冗余校验码 CRC：检错编码</li><li>海明码：纠错编码</li></ul><h4 id="定点数"><a href="#定点数" class="headerlink" title="定点数"></a>定点数</h4><p>- </p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;计算机组成原理是计算机专业本科教学中的重要课程，它可以帮助我们系统地理解计算机硬件系统的组织结构和工作原理、掌握计算机硬件系统的基本分析与设计方法以及建立计算机系统的整体概念，为进一步学习计算机设计实践课程、培养系统开发、调试以及设计创新能力奠定良好的基础。计组是考研的最重最难点，在408计算机学科专业基础综合考试中占有45分。我选择的课程是哈工大的&lt;a href=&quot;https://www.icourse163.org/course/hit-309001&quot;&gt;国家精品课&lt;/a&gt;，配合天勤高分笔记，以下为所记课堂笔记上半部分，包含计算机系统概论、数据的表示和运算、存储器和指令系统的知识点，可供参考。下半部分笔记请访问&lt;a href=&quot;/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E4%B8%8B&quot;&gt;计算机组成原理（下）&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="计算机专业" scheme="http://blog.zhuangzhihao.top/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%93%E4%B8%9A/"/>
    
    
    <category term="Computer Organization" scheme="http://blog.zhuangzhihao.top/tags/Computer-Organization/"/>
    
  </entry>
  
  <entry>
    <title>冒泡排序</title>
    <link href="http://blog.zhuangzhihao.top/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/"/>
    <id>http://blog.zhuangzhihao.top/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/</id>
    <published>2021-07-04T16:00:00.000Z</published>
    <updated>2022-07-31T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>偶然刷到一篇名为<a href="https://www.cnblogs.com/techflow/p/13998832.html">《一半人写不出冒泡排序，你的同龄人都躺下了》</a>的文章，其中提到轮子哥毕业去参加面试的时候，第一轮笔试考察冒泡排序，结果现场的一半学生都没写出来。自己回想了一下，也有一些遗忘。冒泡排序（Bubble Sort）作为最简单直观的排序算法是需要要求做到条件反射般熟练的，故作此笔记记录以防止哪天再次遇到。</p></blockquote><a id="more"></a><h3 id="冒泡排序的思想"><a href="#冒泡排序的思想" class="headerlink" title="冒泡排序的思想"></a>冒泡排序的思想</h3><ul><li>从头开始两两比较，把较大的元素与较小的元素进行交换</li><li>每轮把当前最大的一个元素存入到数组当前的末尾</li></ul><h3 id="冒泡排序的实现步骤"><a href="#冒泡排序的实现步骤" class="headerlink" title="冒泡排序的实现步骤"></a>冒泡排序的实现步骤</h3><ul><li>定义一个外部循环控制冒泡的轮数（<code>数组.length-1</code>）</li><li>定义一个内部循环控制每轮依次往后比较几个位置（<code>数组.length-i-1</code>）</li><li>如果当前位置的元素值 <code>&gt;</code> 后一个位置的元素值，两者交换</li></ul><h3 id="Java-版代码"><a href="#Java-版代码" class="headerlink" title="Java 版代码"></a>Java 版代码</h3><pre><code class="java">public class BubbleSort &#123;    public static void main(String[] args) &#123;        int[] arr = &#123;5, 2, 3, 1&#125;;        for (int i = 1; i &lt;= arr.length - 1; i++) &#123;            for (int j = 0; j &lt; arr.length - i; j++) &#123;                if (arr[j] &gt; arr[j + 1]) &#123;                    int temp = arr[j + 1];                    arr[j + 1] = arr[j];                    arr[j] = temp;                &#125;            &#125;        &#125;        for (int i = 0; i &lt; arr.length; i++) &#123;            System.out.println(arr[i]);        &#125;    &#125;&#125;</code></pre><h3 id="Python-版代码"><a href="#Python-版代码" class="headerlink" title="Python 版代码"></a>Python 版代码</h3><pre><code class="python">def bubbleSort(arr):    for i in range(1, len(arr)):        for j in range(0, len(arr) - i):            if arr[j] &gt; arr[j + 1]:                arr[j], arr[j + 1] = arr[j + 1], arr[j]    return arr</code></pre>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;偶然刷到一篇名为&lt;a href=&quot;https://www.cnblogs.com/techflow/p/13998832.html&quot;&gt;《一半人写不出冒泡排序，你的同龄人都躺下了》&lt;/a&gt;的文章，其中提到轮子哥毕业去参加面试的时候，第一轮笔试考察冒泡排序，结果现场的一半学生都没写出来。自己回想了一下，也有一些遗忘。冒泡排序（Bubble Sort）作为最简单直观的排序算法是需要要求做到条件反射般熟练的，故作此笔记记录以防止哪天再次遇到。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="算法与数据结构" scheme="http://blog.zhuangzhihao.top/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="Python" scheme="http://blog.zhuangzhihao.top/tags/Python/"/>
    
    <category term="Java" scheme="http://blog.zhuangzhihao.top/tags/Java/"/>
    
  </entry>
  
</feed>
