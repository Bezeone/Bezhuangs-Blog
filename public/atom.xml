<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Bezhuang&#39;s Blog</title>
  
  
  <link href="http://blog.zhuangzhihao.top/atom.xml" rel="self"/>
  
  <link href="http://blog.zhuangzhihao.top/"/>
  <updated>2021-12-14T16:00:00.000Z</updated>
  <id>http://blog.zhuangzhihao.top/</id>
  
  <author>
    <name>Bezhuang</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Machine Learning with Python</title>
    <link href="http://blog.zhuangzhihao.top/Machine-Learning-with-Python/"/>
    <id>http://blog.zhuangzhihao.top/Machine-Learning-with-Python/</id>
    <published>2021-11-09T16:00:00.000Z</published>
    <updated>2021-12-14T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>This course provided by IBM dives into the basics of machine learning using an approachable, and well-known programming language, Python. In this course, I’ve learned about the purpose of Machine Learning and where it applies to the real world and had a general overview of Machine Learning topics such as supervised vs unsupervised learning, model evaluation, and Machine Learning algorithms. The following are the notes I took during this course.</p></blockquote><a id="more"></a><div class="row">    <embed src="/pdf/ml-with-py.pdf" width="100%" height="550" type="application/pdf"></div><h3 id="Introduction-to-Machine-Learning"><a href="#Introduction-to-Machine-Learning" class="headerlink" title="Introduction to Machine Learning"></a>Introduction to Machine Learning</h3><h4 id="What-is-machine-learning"><a href="#What-is-machine-learning" class="headerlink" title="What is machine learning"></a>What is machine learning</h4><ul><li>Machine learning is the subfield of computer science that gives “computers the ability to learn without being explicitly programmed.”</li><li>Major machine learning techniques<ul><li>Regression/Estimation: Predicting continuous values</li><li>Classification: Predicting the item class/category of a case</li><li>Clustering: Finding the structure of data, summarization</li><li>Associations: Associating frequent co-occurring items/events</li><li>Anomaly detection: Discovering abnormal and unusual cases</li><li>Sequence mining: Predicting next events, click-stream (Markov Model, HMM)</li><li>Dimension Reduction: Reducing the size of data (PCA)</li><li>Recommendation systems: Recommending items</li></ul></li><li>Difference between artificial intelligence, machine learning and deep learning<ul><li>AI components: Computer Vision, Language Processing, Creativity, etc</li><li>Machine learning: Classification, Clustering, Neural Network, etc</li><li>Revolution in ML: Deep learning</li></ul></li></ul><h4 id="Python-libraries-for-machine-learning"><a href="#Python-libraries-for-machine-learning" class="headerlink" title="Python libraries for machine learning"></a>Python libraries for machine learning</h4><ul><li>NumPy, SciPy, Matplotlib, pandas, Scikit Learn</li><li>Scikit Learn: Classification, Regression and Clustering algorithms, Works with NumPy and SciPy, Easy to implement<pre><code class="python">from sklearn import preprocessingx = preprocessing.StandardScaler().fit(X).transform(X)</code></pre></li></ul><p>from sklearn.model_selection import train_test_split<br>X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.33)</p><p>from sklearn import svm<br>clf = svm.SVC(gamma=0.001, C=100.)<br>clf.fit(X_train, y_train)<br>clf.predict(X_test)</p><p>from sklearn.metrics import confusion_matrix<br>print(confusion_matrix(y_test, yhat, labels=[1,0]))</p><p>import pickle<br>s = pickle.dump(clf)</p><p>```</p><h4 id="Supervised-vs-Unsupervised-learning"><a href="#Supervised-vs-Unsupervised-learning" class="headerlink" title="Supervised vs Unsupervised learning"></a>Supervised vs Unsupervised learning</h4><ul><li>Supervised learning: Teach the model with labeled data, then with that knowledge, it can predict unknown or future instances</li><li>Types of supervised learning: Classification and Regression<ul><li>Classification is the process of predicting discrete class labels or categories (Classifies labeled data)</li><li>Regression is the process of predicting continuous values (Predicts trends using previous labeled data)</li></ul></li><li>Unsupervised learning: The model works on its own to discover information</li><li>Unsupervised learning techniques: Dimension reduction, Density estimation, Market basket analysis, Clustering</li><li>Clustering is grouping of data points or objects that are somehow similar by Discovering structure, Summarization and Anomaly detection (Finds patterns and groupings from unlabeled data)</li><li>Supervised Learning has more evaluation methods than unsupervised learning, whereas unsupervised learning is a less controlled environment</li></ul><h3 id="Linear-Regression"><a href="#Linear-Regression" class="headerlink" title="Linear Regression"></a>Linear Regression</h3><h4 id="Regression"><a href="#Regression" class="headerlink" title="Regression"></a>Regression</h4><ul><li>Regression is the process of predicting a continuous value</li><li>Two types of regression model: Simple Regression and Multiple Regression</li><li>Applications of regression: Sales forecasting, Satisfaction analysis, Price estimation, Employment income, etc.</li><li>Regression algorithms<ul><li>Ordinal regression</li><li>Poisson regression</li><li>Fast forest quantile regression</li><li>Linear, Polynomial, Lasso, Stepwise, Ridge regression</li><li>Bayesian linear regression</li><li>Neural network regression</li><li>Decision forest regression</li><li>Boosted decision tree regression</li><li>KNN (K-nearest neighbors)</li></ul></li></ul><h4 id="Simple-Linear-Regression"><a href="#Simple-Linear-Regression" class="headerlink" title="Simple Linear Regression"></a>Simple Linear Regression</h4>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;This course provided by IBM dives into the basics of machine learning using an approachable, and well-known programming language, Python. In this course, I’ve learned about the purpose of Machine Learning and where it applies to the real world and had a general overview of Machine Learning topics such as supervised vs unsupervised learning, model evaluation, and Machine Learning algorithms. The following are the notes I took during this course.&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="人工智能与大数据" scheme="http://blog.zhuangzhihao.top/categories/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E4%B8%8E%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
    
    <category term="Coursera" scheme="http://blog.zhuangzhihao.top/tags/Coursera/"/>
    
    <category term="Python" scheme="http://blog.zhuangzhihao.top/tags/Python/"/>
    
    <category term="Machine Learning" scheme="http://blog.zhuangzhihao.top/tags/Machine-Learning/"/>
    
  </entry>
  
  <entry>
    <title>白话机器学习算法</title>
    <link href="http://blog.zhuangzhihao.top/%E7%99%BD%E8%AF%9D%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95/"/>
    <id>http://blog.zhuangzhihao.top/%E7%99%BD%E8%AF%9D%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95/</id>
    <published>2021-10-30T16:00:00.000Z</published>
    <updated>2021-11-23T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>机器学习算法是数据科学的力量之源，它和数据一起产生极其宝贵的知识并且帮助我们以新的方式利用已有信息。<a href="https://book.douban.com/subject/30442187/">白话机器学习算法</a>一书用通俗易懂的语言以及大量有趣的示例和插图讲解10多种前沿的机器学习算法。内容涵盖k均值聚类、主成分分析、关联规则、社会网络分析等无监督学习算法，以及回归分析、k最近邻、支持向量机、决策树、随机森林、神经网络等监督学习算法，并概述强化学习算法的思想。以下为阅读过程中所作的读书笔记，可供参考。</p></blockquote><a id="more"></a><h3 id="为何需要数据科学"><a href="#为何需要数据科学" class="headerlink" title="为何需要数据科学"></a>为何需要数据科学</h3><ul><li>借助现代计算机和高级算法，我们能够做到以下几点：<ol><li>从大型数据集中发现隐藏的趋势</li><li> 充分利用发现的趋势做预测</li><li>计算每种结果出现的概率</li><li>快速获取准确结果</li></ol></li></ul><h3 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h3><h4 id="准备数据"><a href="#准备数据" class="headerlink" title="准备数据"></a>准备数据</h4><ul><li>数据格式：数据点、数据集</li><li>变量（variable）：用于描述数据点，又叫属性、特征或维度<ul><li>二值变量（binary variable）：最简单的变量类型，只有2个可选值</li><li>分类变量（categorical variable）：用来表示有2个以上选择的情况</li><li>整型变量（integer variable）：用来表示整数</li><li>连续变量（continuous variable）：用来表示小数</li></ul></li><li>变量选择是一个试错的过程，需要根据反馈结果不断更换变量，选取那些最有希望的变量，以待进一步分析</li><li>特征工程（feature engineering）是将原始数据转化成更好的表达问题本质的特征的过程，使得将这些特征运用到预测模型中能提高对不可见数据的模型预测精度</li><li>解决数据缺失：近似、计算、移除</li></ul><h4 id="选择算法"><a href="#选择算法" class="headerlink" title="选择算法"></a>选择算法</h4><ul><li>无监督学习（unsupervised learning）：依靠算法从数据中找出隐藏的模式<ul><li>k 均值聚类、主成分分析、关联规则、社会网络分析</li><li>通过间接手段，可以对无监督学习模型输出的结果进行验证</li></ul></li><li>监督学习（supervised learning）：基于数据中已有的模式做预测<ul><li>回归分析、k 最近邻、支持向量机、决策树、随机森林（random forest）、神经网络</li></ul></li><li>强化学习（reinforcement learning）：使用数据中的模式做预测，并根据越来越多的反馈结果不断改进</li><li>除了要了解算法使用的任务类型外，还要了解各种算法对不同数据类型的分析能力，以及结果的本质</li></ul><h4 id="参数调优（parameter-tuning）"><a href="#参数调优（parameter-tuning）" class="headerlink" title="参数调优（parameter tuning）"></a>参数调优（parameter tuning）</h4><ul><li>不同的算法有不同的调节参数，即便是同一个算法，如果参数调的不一样，所产生的结果也各不相同</li><li>过拟合模型：过度敏感，把数据中的随机波动当成持久模式，对当前数据有着很高的预测准确度，但是对未知数据的预测准确度较差（泛化能力不强）</li><li>欠拟合模型（underfitting）：过于愚钝，很可能会忽视数据中的重要趋势，这会导致模型对当前数据和未知数据的预测准确度下降</li><li>理想拟合：算法能在识别主要趋势和忽视微小变化之间找到平衡，使最终得到的模型非常适合做预测</li><li>对于大多数模型而言，过拟合（overfitting）是常见问题，所以增加预测模型的复杂度能最大限度的减少预测误差，但容易出现预测边界过度复杂</li><li>通过正则化（regularization）引入惩罚参数，通过人为增大预测误差，对模型复杂度的增加进行惩罚，从而使算法同时考虑复杂度和准确度使模型保持简单，有助于提高模型的泛化能力</li></ul><h4 id="评价模型"><a href="#评价模型" class="headerlink" title="评价模型"></a>评价模型</h4><ul><li>使用一些评价指标来比较模型的预测准确度：预测准确率、混淆矩阵和均方根误差（root mean squared error）</li><li>分类指标（classification）<ul><li>预测准确率：正确预测所占的比率，无法通过预测准确率得知预测误差是如何产生的</li><li>混淆矩阵（confusion matrix）：在预测准确率的基础上添加假正类型和假负类型，辨别预测误差数</li></ul></li><li>回归指标<ul><li>由于回归预测使用连续值，因此误差一般被量化成预测值和实际值之差，惩罚随误差大小而不同</li><li>均方根误差：将每个误差都取平方，放大大误差，这使得均方根误差对异常值极其敏感，对这些值的惩罚力度也更大，避免较大的误差</li></ul></li><li>验证：评估模型对新数据的预测准确度，避免过拟合模型在面对当前数据表现良好而面对新数据时可能表现糟糕的情况</li><li>在评估模型时并不一定非要使用新数据，而是可以把当前的数据集划分成训练集（training dataset）和测试集（test dataset）<ul><li>训练集用来生成和调整预测模型，测试集用来充当新数据并评估模型的预测准确度</li><li>最好的模型针对测试集所做的预测一定是最准确的</li><li>为了使验证（validation）过程行之有效，需要不带偏差的把数据点随机分派到数据集和测试集中</li></ul></li><li>交叉验证（cross-validation）：使用同一个数据集进行训练和测试，避免因为原始数据集很小而无法留出足够的数据形成测试集的情况<ul><li>把数据集划分成若干组用来对模型进行反复测试</li><li>在单次迭代中除了某一组外其他各组都被用来训练预测模型，然后留下来的那组被用来测试模型</li><li>这个过程重复进行直到每一个组都测试过模型，并且只测试过一次</li></ul></li></ul><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><ul><li>数据科学研究的 4 个主要步骤：<ol><li>准备待分析的数据</li><li>根据研究需求挑选合适的算法，为数据建立模型</li><li>对算法的参数进行调优，优化模型</li><li>根据准确度评价模型</li></ol></li></ul><h3 id="k-均值聚类（k-means-clustering）"><a href="#k-均值聚类（k-means-clustering）" class="headerlink" title="k 均值聚类（k-means clustering）"></a>k 均值聚类（k-means clustering）</h3><h4 id="定义群组"><a href="#定义群组" class="headerlink" title="定义群组"></a>定义群组</h4><ul><li>群组数量要足够大，以便提取有意义的模式用作商业决策参考，还要足够小，能够确保各个群组之间有明显的区别</li><li>使用陡坡图（scree plot）确定合适的群组数量<ul><li>陡坡图可以展现群组内散度随群组数量增加而降低的过程</li><li>陡坡图曲线的拐弯处表示最佳群组数量，此处的群组内散度较为合理</li></ul></li><li>通过检查群组成员与群组中心点的距离判断该群组的有效性（群组最好由密集的数据点组成）<ol><li>猜测每个群组的中心点，因为暂时不能确定通过猜测得到的中心点是否正确，所以称它们为伪中心点</li><li>把每个数据点分配给最近的伪中心点</li><li>根据群组成员的分布调整为中心点的位置</li><li>重复步骤 2 和步骤 3 直至群组成员不再发生变化</li></ol></li><li>聚类也可以在更多的维度上进行，虽然多维度分析很难进行可视化，但是可以借助程序计算数据点和群组中心点在多维度情形下的距离</li></ul><h4 id="局限性"><a href="#局限性" class="headerlink" title="局限性"></a>局限性</h4><ul><li>每个数据点只能属于一个群组：恰好位于两个群组中间的数据点无法确定应属于哪个群组</li><li>群组被假定是正圆形的：若群组的实际形状是椭圆形，那么位于椭圆两端的数据点可能被划入邻近的其他群组</li><li>群组被假定是离散的：k 均值聚类既不允许群组重叠，也不允许它们相互嵌套</li><li>弥补局限性的方法：先用 k 均值聚类方法大致了解数据结构，再综合运用其他更高级的方法进行深入分析</li></ul><h4 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h4><ul><li>k 均值聚类用于把相似的数据点划入同一个群组，群组数量 k 必须事先指定</li><li>给数据点分组时，首先把各个数据点分配到距离最近的群组中，然后调整群组中心点的位置，重复这2个步骤直到群组中的成员不再发生变化</li><li>k 均值聚类最适用于正圆形、非重叠的群组</li></ul><h3 id="主成分分析（principal-component-analysis）"><a href="#主成分分析（principal-component-analysis）" class="headerlink" title="主成分分析（principal component analysis）"></a>主成分分析（principal component analysis）</h3><h4 id="主成分"><a href="#主成分" class="headerlink" title="主成分"></a>主成分</h4><ul><li>主成分分析用于找出最能区分数据点的变量，这种变量被称为主成分，数据点会沿着主成分的维度最大限度地分散开</li><li>主成分可以用已有的一个或多个变量表示</li><li>标准化（standardization）类似于使用百分位数表示每个变量，以此将所有变量统一到一个标准尺度上</li><li>采用主成分分析之后，可以不再通过试错法组合变量，而是通过精确计算各个变量的权重来获得最优变量组合</li></ul><h4 id="确定主成分数量"><a href="#确定主成分数量" class="headerlink" title="确定主成分数量"></a>确定主成分数量</h4><ul><li>由于主成分来源于原始变量，因此用来区分数据点的可用信息会受到原始变量个数的制约</li><li>为了让结果更简单、更通用，应该只选择前几个主成分进行可视化和后续分析<ul><li>将主成分按照其对数据点的区分效果进行排列</li><li>随着主成分个数增多，区分数据点的效果会变差</li><li>陡坡图曲线的拐弯处往往体现了最佳主成分数量</li></ul></li><li>对当前的数据样本进行解释时，使用的主成分越少，泛化能力就越强</li></ul><h4 id="局限性-1"><a href="#局限性-1" class="headerlink" title="局限性"></a>局限性</h4><ul><li>散度最大化：主成分分析有个重要假设，即数据点最分散的维度是最有用的</li><li>解释成分：主成分分析必须对其产生的成分进行解释，但有时可能很难解释变量按某种方式进行组合的原因</li><li>正交成分：主成分分析算法成分之间存在正交关系，然而真实信息维度之间可能不存在正交关系</li><li>弥补局限性的方法：独立成分分析（不需要假设正交关系，在确定成分时还无需考虑数据的散度）</li></ul><h4 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h4><ul><li>主成分分析是一种降维技巧，它使得我们可以使用较小的变量来描述数据，这些变量即为主成分</li><li>每个主成分都是原始变量的某种加权组合，最好的主成分可以用来改进数据分析和可视化</li><li>当信息最丰富的几个维度拥有最大的数据散度，并且彼此正交时，主成分分析能有最佳效果</li></ul><h3 id="关联规则（association-rule）"><a href="#关联规则（association-rule）" class="headerlink" title="关联规则（association rule）"></a>关联规则（association rule）</h3><h4 id="支持度、置信度和提升度"><a href="#支持度、置信度和提升度" class="headerlink" title="支持度、置信度和提升度"></a>支持度、置信度和提升度</h4><ul><li>识别关联规则的常用指标有3个：支持度、置信度和提升度</li><li>支持度：某个项集出现的频率，可以人为设定一个支持度阈值，当某个项集的支持度高于这个阈值时，就把它称为频繁项集</li><li>置信度：当 X 项出现时 Y 项同时出现的频率，记为 {X-&gt;Y} ，但它可能会错估某个关联规则的重要性</li><li>提升度：X 项和 Y 项一同出现的频率，同时考虑这两项各自出现的频率</li><li>{X-&gt;Y} 的提升度 = {X-&gt;Y} 的置信度 / {Y} 的支持度</li></ul><h4 id="先验原则（apriori-principal）"><a href="#先验原则（apriori-principal）" class="headerlink" title="先验原则（apriori principal）"></a>先验原则（apriori principal）</h4><ul><li>先验原则是指如果某个项集出现的不频繁那么包含它的任何更大的项集必定也出现的不频繁</li><li>寻找具有高支持度的项集<ol><li>列出只包含一个元素的项集</li><li>计算每个项集的支持度，保留那些满足最小支持度阈值条件的项集，淘汰不满足的项集</li><li>项候选项集中增加一个元素，并利用在步骤2中保留下来的项集产生所有可能的组合</li><li>重复步骤2和步骤3，为越来越大的项集确定支持度，直到没有待检查的新项集</li></ol></li><li>寻找具有高置信度或高提升度的关联规则<ul><li>因为置信度和提升度都是基于支持度计算出来的，因此一旦识别出具有高支持度的项集，寻找关联规则就不会那么费劲了</li></ul></li></ul><h4 id="局限性-2"><a href="#局限性-2" class="headerlink" title="局限性"></a>局限性</h4><ul><li>计算成本高：当库存量很大或者支持度阈值很低时，候选项集仍然会很多</li><li>假关联：当元素的数量很大时，偶尔会出现假关联，为了确保所发现的关联规则具有普遍性，应该对他们进行验证</li><li>弥补局限性的方法：使用高级数据结构对候选项集进行更高效的分类，从而减少比较的次数</li></ul><h4 id="小结-3"><a href="#小结-3" class="headerlink" title="小结"></a>小结</h4><ul><li>关联规则用于揭示某一元素出现的频率以及它与其他元素的关系</li><li>识别关联规则的常用指标有3个<ol><li>{X} 的支持度表示 X 项出现的频率</li><li>{X-&gt;Y} 的置信度表示当 X 项出现时，Y 项同时出现的频率</li><li>{X-&gt;Y} 的提升度表示 X 项和 Y 项一同出现的频率，并且考虑每项各自出现的频率</li><li>利用先验原则可以淘汰一大部分非频繁项集，从而大大地加快搜索频繁相机的速度</li></ol></li></ul><h3 id="社会网络分析"><a href="#社会网络分析" class="headerlink" title="社会网络分析"></a>社会网络分析</h3><h4 id="Louvain-方法（Louvain-method）"><a href="#Louvain-方法（Louvain-method）" class="headerlink" title="Louvain 方法（Louvain method）"></a>Louvain 方法（Louvain method）</h4><ul><li>通过对节点分组可以找出网络中存在的群组，研究这些群组有助于理解网络各部分的区别和联系</li><li>Louvain 方法用来在网络中找出群组，它会尝试使用不同的聚类配置来做如下两种事：<ol><li>同一群组中各个节点间的边数和强度最大化</li><li>把属于不同群组的节点间的边数和强度最小化</li></ol></li><li>模块度用于表示上述两件事的完成程度，模块度越高，群组越理想</li><li>为了获得理想的聚类配置，Louvain 方法会不断迭代<ol><li>把每个节点看作一个群组，即一开始群组数和节点数相同</li><li>把一个节点重新分配给对提高模块度有最大帮助的群组，如果无法进一步提高，模块度节点保持不动，针对每个节点重复这个过程直到不能再分配</li><li>把步骤2中发现的每个群组作为一个节点构建出一个粗粒度网络，并且把以前的群间边合并成连接新结点且带权重的边</li><li>重复步骤2和步骤3直到无法再重新分配和合并</li></ol></li><li>Louvain 方法先发现小群组，然后在适当的情况下合并它们，帮助我们找出更重要的群组，但它有一定的局限性<ul><li>重要但较小的群组可能会被合并：需要检查在中间迭代阶段被发现的群组，如果有必要就把它们保留下来</li><li>有多种可能的聚类配置：若网络中包含重叠或嵌套的群组，需要依据其他信息源对群组予以验证</li></ul></li></ul><h4 id="PageRank-算法（PageRank-algorithm）"><a href="#PageRank-算法（PageRank-algorithm）" class="headerlink" title="PageRank 算法（PageRank algorithm）"></a>PageRank 算法（PageRank algorithm）</h4><ul><li>虽然群组可以反映出相互作用高度集中的区域，但是这些相互作用可能受占主导地位的节点支配，群组则围绕着这些主导节点形成，为了找出占主导地位的节点，需要对节点进行排序</li><li>PageRank 算法是谷歌公司最初用来为网页排名的算法之一，以 Larry Page 的姓氏命名</li><li>在PageRank 算法中，决定一个网页排名的因素有如下3个：<ol><li>链接数量：被其他网页链接的次数越多，该网页的访问者可能就越多</li><li>链接强度：这些链接被访问的次数越多，该网页的流量就越大</li><li>链接来源：如果被其他有较高排名的网页链接，那么该网页的排名也会升高</li></ol></li><li>尽管 PageRank 算法易于使用，但它有偏向于旧节点的局限性：如果一个新网页包含非常棒的内容但一开始访问者人数很少，那么它的排名就比较低</li><li>可以定期更新 PageRank 值，让新网页随着自身知名度的提高获得提高排名的机会</li></ul><h4 id="小结-4"><a href="#小结-4" class="headerlink" title="小结"></a>小结</h4><ul><li>社会网络分析可用于绘制和分析多个实体之间的关系</li><li>Louvain 方法用于在一个网络中找出群组，具体做法是将群组内部的相互作用最大化，同时把群组之间的相互作用最小化，当群组大小相同且相互分离时，该方法的效果最佳</li><li>PageRank 算法根据链接的数量强度以及来源对网络中的节点进行排序，这个算法有助于找出网络中占主导地位的节点，但对链接数不太多的新节点并不友好</li></ul><h3 id="回归分析（regression-analysis）"><a href="#回归分析（regression-analysis）" class="headerlink" title="回归分析（regression analysis）"></a>回归分析（regression analysis）</h3><h4 id="趋势线"><a href="#趋势线" class="headerlink" title="趋势线"></a>趋势线</h4><ul><li>趋势线是做预测时常用的工具，他们很容易生成，也很容易理解</li><li>一般的趋势往往只涉及单个预测变量，这个变量用来产生预测结果，不过通过添加更多预测变量可以改善预测结果</li><li>回归分析不但可以通过考虑更多预测变量改善预测结果，还可以比较各个预测变量的强弱</li></ul><h4 id="梯度下降法（gradient-decent）"><a href="#梯度下降法（gradient-decent）" class="headerlink" title="梯度下降法（gradient decent）"></a>梯度下降法（gradient decent）</h4><ul><li>在回归分析中预测变量的权重是主要参数，通过解方程可以求得最优权重</li><li>梯度下降法先初步猜测合适的权重组合，再通过一个迭代过程，把这些权重应用于每个数据点做预测，然后调整权重以减少整体预测误差</li><li>这个过程类似于一步步走到山底下，每走一步梯度下降法都要判断从哪个方向下是最陡峭的，然后朝着那个方向重新校准权重，最终到达最低点，这个点的预测误差最小（经过优化的回归趋势线与梯度上的最低点相对应）</li><li>除了回归之外，梯度下降法也能用来优化其他模型中的参数，比如支持向量机和神经网络</li><li>梯度下降法的结果可能会受到初始参数值（下山起点）的影响，若起点下方恰好有一个小凹坑，那么梯度下降法可能会将其误认为是最优点</li><li>为了降低陷入这种凹坑的风险，可以使用随机梯度下降法，每次迭代并不是采用所有的数据点，而是只从其中选取一个来调整参数，引入多变性，有助于算法逃离凹坑</li></ul><h4 id="回归系数"><a href="#回归系数" class="headerlink" title="回归系数"></a>回归系数</h4><ul><li>在为回归预测变量求得最佳权重之后，需要对它们进行解释</li><li>回归系数：回归预测变量权重，它表示某个预测变量相比于其他预测变量的影响大小</li><li>预测变量的度量单位不同也会影响对回归系数的解释，因此应该在做回归分析之前先对预测变量的度量单位进行标准化，经过标准化之后预测变量的系数被称为标准化回归系数</li></ul><h4 id="相关系数（correlation-coefficient）"><a href="#相关系数（correlation-coefficient）" class="headerlink" title="相关系数（correlation coefficient）"></a>相关系数（correlation coefficient）</h4><ul><li>相关系数：当只存在一个预测变量时，该预测变量的标准化回归系数</li><li>关联方向：相关系数为正表示预测变量和结果变化的方向一致，为负则表示两者变化方向相反</li><li>关联强度：r 值越接近于 -1 或 1，预测变量的作用就越大，若值为 0 则表示预测变量和结果之间不存在关系</li><li>因为相关系数表示单个预测变量的绝对强度，所以相比于回归系数，相关系数在对预测变量进行排序时更可靠</li></ul><h4 id="局限性-3"><a href="#局限性-3" class="headerlink" title="局限性"></a>局限性</h4><ul><li>对异常值敏感：回归分析平等地对待所有的数据点，只要存在几个有异常值的数据点，就会给趋势线造成很大的影响，因此在做进一步分析之前，可以先使用散点图找出异常值</li><li>多重共线性问题（multicollinearity）：如果回归模型包含高度相关的预测变量，就会造成相关预测变量权重失真，因此可以使用更高级的技术，如套索回归或岭回归</li><li>弯曲的趋势：需要对预测变量的值进行转换，或使用支持向量机等其他算法</li><li>并不说明存在因果关系</li></ul><h4 id="小结-5"><a href="#小结-5" class="headerlink" title="小结"></a>小结</h4><ul><li>回归分析用于寻找最佳拟合线（best-fit line），使得尽可能多的数据点位于这条线上或附近</li><li>趋势线由带权重的组合预测变量得到，这些权重被称为回归系数，表示某个预测变量相对于其他预测变量的影响强度</li><li>以下情况下，回归分析的效果最好：<ol><li>预测变量之间的关系不强</li><li>无异常值</li><li>趋势可以用直线表示</li></ol></li></ul><h3 id="k-最近邻算法（k-Nearest-Neighbors）和异常检测"><a href="#k-最近邻算法（k-Nearest-Neighbors）和异常检测" class="headerlink" title="k 最近邻算法（k-Nearest Neighbors）和异常检测"></a>k 最近邻算法（k-Nearest Neighbors）和异常检测</h3><h4 id="k-最近邻算法"><a href="#k-最近邻算法" class="headerlink" title="k 最近邻算法"></a>k 最近邻算法</h4><ul><li>k 最近邻算法根据周围数据点的类型对某个数据点进行分类（物以类聚，人以群分）</li><li>在 k 最近邻算法中，参数 k 表示周围数据点的个数，选择 k 值的过程叫做参数调优，它对预测的准确度起着至关重要的作用</li><li>使用不同的 k 值进行拟合：<ul><li>如果 k 值太小，数据点只与最近的邻居匹配，并且随机造成所产生的误差也会被放大</li><li>如果 k 值太大，数据点会尝试与更远的邻居匹配，其中隐含的模式会被忽略</li><li>只有当 k 值恰到好处时，数据点才会参考合适数量的邻居，使得误差相互抵消，有利于揭示数据中隐藏的趋势</li></ul></li><li>为实现理想拟合并把误差降到最低，可以使用交叉验证法对参数 k 进行调优</li><li>对于二分类问题，可以把 k 设置成一个奇数，以避免出现平局的情况</li><li>除了用来为数据点分类，k 最近邻算法还可以通过合计周围数据点的值来预测连续值</li><li>通过使用加权平均值，能够进一步改善预测结果，离数据点越近的邻居，其值越能反映该数据点的真实值，因此赋给它的权重应该更大</li></ul><h4 id="异常检测"><a href="#异常检测" class="headerlink" title="异常检测"></a>异常检测</h4><ul><li>k 最近邻算法不仅可以用来预测数据点的类别和取值，还可以用来识别异常，比如检测欺诈行为</li><li>在异常检测的过程中还可能会有新发现，比如发现之前被忽略的预测变量</li><li>事实上任何能够产生预测模型的算法都可以用来检测异常，比如在回归分析中，如果某个数据点明显偏离最佳拟合线，那么就会被识别为异常点</li><li>异常数据点既可能因缺失预测变量所致，也可能因预测模型缺少足够的训练数据所致</li><li>一旦找到异常数据点，就要将它们从数据集中移除，然后再训练预测模型，减少数据中包含的噪声，进而提高模型的准确度</li></ul><h4 id="局限性-4"><a href="#局限性-4" class="headerlink" title="局限性"></a>局限性</h4><ul><li>类别不平衡：可以使用加权投票法来取代少数服从多数原则，确保较近数据点类别的权重比较远的更大</li><li>预测变量过多：在多个维度上识别和处理近邻会导致你计算量大增，需要降维（dimension reduction）</li></ul><h4 id="小结-6"><a href="#小结-6" class="headerlink" title="小结"></a>小结</h4><ul><li>k 最近邻算法根据周围数据点的类型对某个数据点进行分类</li><li>k 表示用作参考的数据点的个数，可以使用交叉验证法来确定</li><li>当预测变量数目不多，并且类别大小差别不大时，k 最近邻算法才能产生非常好的效果</li><li>不准确的分类可能会被标记为潜在异常</li></ul><h3 id="支持向量机（support-vector-machine）"><a href="#支持向量机（support-vector-machine）" class="headerlink" title="支持向量机（support vector machine）"></a>支持向量机（support vector machine）</h3><h4 id="勾画最佳分界线"><a href="#勾画最佳分界线" class="headerlink" title="勾画最佳分界线"></a>勾画最佳分界线</h4><ul><li>支持向量机的主要目标是得到一条能用于分组的最佳分界线，需要注意的是，能用于分组的分界线可能有很多条</li><li>为了找出最佳分界线，首先需要从一组中找出距离另一组最近的外围数据点，然后在两组的外围数据点之间画出最佳分界线，由于这些外围数据点在寻找最佳分界线的过程中起了支持作用，因此叫做支持向量</li><li>支持向量机的一个优点是计算速度很快，仅依靠外围数据点就能找到决策边界</li><li>这种对数据点子集的依赖也有缺点，这是因为决策边界对支持向量的位置比较敏感，选取不同的数据点作为训练数据，相应支持向量的位置也不同</li><li>支持向量机算法有一个关键特征——缓冲带<ul><li>缓冲带允许一定数量的训练数据点位于错误的一边，由此得到一条更软的分界线</li><li>缓冲带对异常值有更强的耐扰性，因此对新数据有更强的泛化能力</li><li>缓冲带通过调整惩罚参数得到，这个参数决定了对分类误差的宽容度，惩罚参数越大，宽容度就越大，缓冲带也就越宽</li><li>为了让模型对当前数据和新数据有较高的预测准确度，可以使用交叉验证法求得最佳惩罚参数</li></ul></li><li>支持向量机的另一个强项是找到决策边界的凸弧，它在发现错综复杂的凸弧时有着更出众的计算效率<ul><li>支持向量机的秘诀是核技巧（kernel trick）</li><li>支持向量机不会直接在在数据平面上绘制有凸弧的分界线，而是会首先把数据映射到高维空间，然后在高维空间中将数据点用直线分开，这些直线容易计算，并且当映射回低维空间时，也很容易转化成曲线</li></ul></li><li>支持向量机具备在高维空间操纵数据的能力，使得它在分析有多个变量的数据集时大受欢迎</li><li>支持向量机的常见应用场景包括遗传信息破译以及文本情感分析</li></ul><h4 id="局限性-5"><a href="#局限性-5" class="headerlink" title="局限性"></a>局限性</h4><ul><li>小数据集：由于支持向量机依靠支持向量确定决策边界，因此样本量少，用来对分界线进行准确定位的数据也少</li><li>多组数据：支持向量机每次只能对两组进行分类，如果存在2个以上的组，则需要对每一组都应用支持向量机（多类支持向量机）</li><li>两组之间存在大量重叠：靠近边界的数据点可能更容易发生分类错误，而且支持向量机没有给出每个数据点遭遇错误分类的概率，但可以通过数据点到决策边界的距离来估计其被正确分类的可能性</li></ul><h4 id="小结-7"><a href="#小结-7" class="headerlink" title="小结"></a>小结</h4><ul><li>支持向量机用来把数据点分为两组，其方法是在两组的外围数据点（支持向量）的中间画一条分界线</li><li>支持向量机对异常值有较好的容忍度，它通过一个缓冲带允许少量数据点位于错误的一边，此外他还通过核技巧高效地求得带凸弧的决策边界</li><li>当需要把大样本中的数据点分为两组时，支持向量机能够发挥最佳作用</li></ul><h3 id="决策树（decision-tree）"><a href="#决策树（decision-tree）" class="headerlink" title="决策树（decision tree）"></a>决策树（decision tree）</h3><h4 id="生成决策树"><a href="#生成决策树" class="headerlink" title="生成决策树"></a>生成决策树</h4><ul><li>递归拆分（recursive partitioning）<ol><li>确定一个二元选择题，它能够把数据点拆分成两组，并最大限度地提高每组数据点的同质性</li><li>针对每个叶结点重复步骤1，直到满足终止条件</li></ol></li><li>终止条件可能有多个，可以使用交叉验证法进行选取<ul><li>每个叶节点的数据全属于同一类或有相同的值</li><li>叶节点包含的数据点少于5个</li><li>进一步分支会超出阈值并且不能提高同质性</li></ul></li><li>由于递归拆分只用最佳二元选择题来生成决策树，因此不显著的变量并不会影响结果</li><li>而且二元选择题往往围绕着最重要的值划分数据点，所以决策树对异常值有较强的耐扰性</li><li>决策树易于可视化，使我们更容易评估预测变量及其相互作用</li></ul><h4 id="局限性-6"><a href="#局限性-6" class="headerlink" title="局限性"></a>局限性</h4><ul><li>不稳定：决策树是通过把数据点分组生成的，数据中的细微变化可能影响拆分结果，并导致生成的决策树截然不同</li><li>容易产生过拟合：决策树每次拆分数据点时都力求找到最佳拆分方式</li><li>不准确：一开始就是用最佳二元选择题拆分数据点并不能保证结果最准确</li><li>弥补局限性的方法：每次拆分时可以不采用最佳拆分方式，而是尽量让决策树多样化，然后综合不同的决策树产生的预测结果，让最终预测结果具有更好的稳定性和准确性</li></ul><h4 id="决策树的多样化方法"><a href="#决策树的多样化方法" class="headerlink" title="决策树的多样化方法"></a>决策树的多样化方法</h4><ul><li>随机森林：随机选择不同的二元选择题，生成多棵决策树，然后综合这些决策树的预测结果</li><li>梯度提升（gradient boosting）：有策略地选择二元选择题，以逐步提高决策树的预测准确度，然后将所有的预测结果的加权平均数作为最终结果</li></ul><p>虽然随机森林的和梯度提升能够产生更准确的预测结果，但是它们往往比较复杂并且很难进行可视化（黑盒）</p><h4 id="小结-8"><a href="#小结-8" class="headerlink" title="小结"></a>小结</h4><ul><li>决策树通过询问一系列二元选择题来做预测</li><li>若想生成决策树，就要不断拆分数据样本以获得同质组，直到满足终止条件，这个过程被称为递归拆分</li><li>虽然决策树易于使用和理解，但是容易造成过拟合问题，导致出现不一致的结果，为了尽量避免出现这种情况，可以采用随机森林等替代方法</li></ul><h3 id="随机森林"><a href="#随机森林" class="headerlink" title="随机森林"></a>随机森林</h3><h4 id="集成模型"><a href="#集成模型" class="headerlink" title="集成模型"></a>集成模型</h4><ul><li>集成方法（ensembling）：通过组合有不同优缺点的模型来提高预测准确度的方法</li><li>集成模型：通过组合许多模型的预测结果得到的预测模型，在组合模型时，既可以遵循少数服从多数的原则，也可以取平均值</li><li>随机森林是决策树的集成模型</li><li>相比于子模型，集成模型的预测准确度更高，这是因为准确的预测模型会彼此强化，错误的则会彼此抵消<ul><li>为了达到这种效果，集成模型的子模型一定不能犯同类错误，换言之，子模型必须是不相关的</li></ul></li><li>自助聚集法：用来生成不相关的决策树的系统化方法</li></ul><h4 id="自助聚集法（bootstrap-aggregating）"><a href="#自助聚集法（bootstrap-aggregating）" class="headerlink" title="自助聚集法（bootstrap aggregating）"></a>自助聚集法（bootstrap aggregating）</h4><ul><li>自助聚集法用来生成数千棵决策树，这些树彼此有明显的不同</li><li>为使决策树之间的关联度最小化，每棵树都由训练数据集的一个随机子集产生，并且使用的是预测变量的一个随机子集，这让生成的决策树各不相同，但仍然保留了一定的预测能力</li><li>通过限制每次拆分时所用的预测变量，能够生成各不相同的决策树，从而避免发生过拟合问题</li><li>为进一步降低发生过拟合问题的可能性，可以增加随机森林中决策树的数量，使模型更通用、更准确</li></ul><h4 id="局限性-7"><a href="#局限性-7" class="headerlink" title="局限性"></a>局限性</h4><ul><li>随机森林由随机生成的决策树组成，并不存在明确的预测规则，这种不可解释性可能会带来一些伦理问题</li><li>因此随机森林适用于那些预测准确度比可解释性更重要的场合</li></ul><h4 id="小结-9"><a href="#小结-9" class="headerlink" title="小结"></a>小结</h4><ul><li>随机森林的预测结果往往比单棵决策树更准确，这是因为它充分利用了两种技术：自助聚集法和集成方法</li><li>自助聚集法通过随机限制数据拆分过程所用的变量来生成一系列不相关的决策树</li><li>集成方法则把决策树的预测结果组合在一起</li><li>虽然随机森林的预测结果不具有可解释性，但仍然可以根据对预测结果的贡献度大小对各个预测变量进行排序</li></ul><h3 id="神经网络（neural-network）"><a href="#神经网络（neural-network）" class="headerlink" title="神经网络（neural network）"></a>神经网络（neural network）</h3><h4 id="神经网络的诞生"><a href="#神经网络的诞生" class="headerlink" title="神经网络的诞生"></a>神经网络的诞生</h4><ul><li>数据存储和共享技术取得进步：为训练神经网络提供了海量数据，有助于改善神经网络的性能</li><li>计算能力越来越强大：GPU的运行速度最快能达到CPU的150倍，能为在大数据集上训练神经网络提供强大的支持</li><li>算法获得改进</li></ul><h4 id="神经网络的构成"><a href="#神经网络的构成" class="headerlink" title="神经网络的构成"></a>神经网络的构成</h4><ul><li>输入层：该层处理输入图像的每个像素<ul><li>为提高预测准确度，可以使用卷积层</li><li>卷积层并不处理单个像素，而是识别像素组合的特征，这种分析只关注特征是否出现而不关注出现的位置</li><li>所以即使某些关键特征偏离了中心，神经网络仍然能够正确识别，这种特性叫做平移不变性（translational invariance）</li></ul></li><li>隐藏层：在像素进入神经网络之后，通过层层转换不断提高和那些标签已知的图像的相似度<ul><li>标签已知是指神经网络以前见过这些图像</li><li>虽然转换得越多，预测准确度就会越高，但是处理时间就会明显增加，一般来说几个隐藏层就足够了</li><li>每层的神经元数量要和图像的像素数成比例</li></ul></li><li>输出层：该层产生最终预测结果，在这一层中神经元可以只有一个，也可以和结果一样多</li><li>损失层：该层通常位于最后，并提供有关输入是否识别正确的反馈，如果不正确则给出误差量<ul><li>在训练神经网络的过程中，损失层至关重要，若预测准确，来自于损失层的反馈会强化产生该预测结果的激活路径</li><li>若预测错误，则错误会沿着路径逆向返回，这条路径上的神经元的激活条件就会被重新调整，以减少错误，这个过程称为反向传播（back propagation）</li></ul></li><li>通过不断重复这个训练过程，神经网络会学习输入信号和正确输出标签之间的联系，并且把这些联系作为激活规则（activation rule）编入每个神经元，因此为了提高神经网络的预测准确度，需要调整管理激活规则的部件</li></ul><h4 id="激活规则"><a href="#激活规则" class="headerlink" title="激活规则"></a>激活规则</h4><ul><li>为了产生预测结果，需要沿着一条路径依次激活神经元，每个神经元的激活过程都由其激活规则所控制，激活规则指定了输入信号的来源和强度，在神经网络的训练过程中激活规则会不断调整</li><li>良好的激活规则有助于产生准确的预测结果，其关键在于确定合适的权重和阈值</li><li>另外神经网络的其他参数也需要调整，比如隐藏层的数量、每层的神经元数量等。可以使用梯度下降法优化这些参数</li></ul><h4 id="局限性-8"><a href="#局限性-8" class="headerlink" title="局限性"></a>局限性</h4><ul><li>需要大样本：神经网络的复杂性使之能够识别带有复杂特征的输入，但前提是我们能为他提供大量训练数据，如果训练集太小就会出现过拟合问题</li><li>降低过拟合风险：<ul><li>二次取样（subsampling）：为了降低神经元对噪声的敏感度，需要对神经网络的输入进行平滑化处理，即针对信号样本取平均值</li><li>畸变：当缺少训练数据时，可以通过向每幅图像引入畸变，来产生更多数据，每幅畸变图像都可以作为新的输入，以此扩大训练数据的规模，畸变应该能够反映原数据集的特征（弹性变形）</li><li>丢弃（dropout）：为解决小的神经元集群之间彼此产生过度依赖，可以在训练期间随机丢弃一半的神经元，这些遭丢弃的神经元将处于未激活的状态，剩下的神经元则正常工作，下一次训练丢弃一组不同的神经元，迫使不同的神经元协同工作，从而揭示训练样本所包含的更多特征</li></ul></li><li>计算成本高：训练一个由几千个神经元组成的神经网络可能需要很长时间，一个简单的解决方法是升级硬件</li><li>另一个解决方法是调整算法，用稍低一些的预测准确度换取更快的处理速度<ul><li>随机梯度下降法：为了更新某一个参数，经典的梯度下降法在一次迭代中使用所有的训练样本，当数据集很大时这样做会耗时，随机梯度下降法是在每次迭代中只用一个训练样本来更新参数，虽然使用这个方法得到的最终参数可能不是最优的，但是准确度不会太低</li><li>小批次梯度下降法：虽然使用随机梯度下降法能够提升速度，但最终参数可能不准确，算法也可能无法收敛，导致某个参数上下波动，小批次梯度下降法是每次迭代使用训练样本的一个子集</li><li>全连接层：随着加入的神经元越来越多，路径的数量呈指数增长，为避免查看所有可能的组合，可以使初始层（处理更小、更低级的特征）的神经元部分连接，只有最后几层（处理更大、更高级的特征）才对相邻层的神经元进行全连接</li></ul></li><li>不可解释：神经网络由多层组成，每层都有几百个神经元，这些神经元有不同的激活规则控制，这使得我们很难准确地找到产生正确预测结果的输入信号组合<ul><li>但和回归分析不同，回归分析能明确地识别重要的预测变量，并比较它们的强度，神经网络的特性使之难以证明其使用得当，在涉及伦理问题时尤其如此</li></ul></li><li>尽管存在上述局限性，但是神经网络本身拥有的强大能力，使之得以应用于虚拟助手、自动驾驶等前沿领域，随着算法不断改进以及计算能力不断提升，神经网络将在物联网时代发挥关键作用</li></ul><h4 id="小结-10"><a href="#小结-10" class="headerlink" title="小结"></a>小结</h4><ul><li>神经网络由多个神经元组成，训练期间，第1层的神经元首先被输入数据激活，然后将激活状态传播到后续各层的神经元，最终在输出层产生预测结果</li><li>一个神经元是否被激活取决于输入信号的来源和强度，这由其激活规则指定，激活规则会根据预测结果的反馈不断调整，这个过程被称为反向传播</li><li>在大数据集和先进的计算硬件可用的情况下，神经网络的表现最好，然而预测结果在大部分的时候都是无法解释的</li></ul><h3 id="A-B-测试（A-B-testing）和多臂老虎机（multi-arm-bandit-problem）"><a href="#A-B-测试（A-B-testing）和多臂老虎机（multi-arm-bandit-problem）" class="headerlink" title="A/B 测试（A/B testing）和多臂老虎机（multi-arm bandit problem）"></a>A/B 测试（A/B testing）和多臂老虎机（multi-arm bandit problem）</h3><h4 id="A-B-测试的局限性"><a href="#A-B-测试的局限性" class="headerlink" title="A/B 测试的局限性"></a>A/B 测试的局限性</h4><ul><li>测试结果具有偶然性：为提高测试结果的可信度可以增加受测人数，但是会导致另一个问题</li><li>潜在的收入损失：如果把受测顾客增加一倍，那么看到糟糕广告的人数也会增加一倍，这有流失的顾客的风险</li><li>这两个问题体现了 A/B 测试中的两个权衡因素：探索和利用</li></ul><h4 id="epsilon-递减策略（epsilon-decreasing-strategy）"><a href="#epsilon-递减策略（epsilon-decreasing-strategy）" class="headerlink" title="epsilon 递减策略（epsilon-decreasing strategy）"></a>epsilon 递减策略（epsilon-decreasing strategy）</h4><ul><li>epsilon 指的是探索时间与总时间的比例，随着对效果较好的广告越来越有信心，我们使 epsilon 值递减，这个方法属于强化学习的范畴</li><li>A/B 测试由探索和利用前后两个阶段组成，而在 epsilon 递减策略中，探索阶段和利用阶段是分散的，并且一开始时探索得多一些，越接近尾声，探索得越少</li></ul><h4 id="多臂老虎机"><a href="#多臂老虎机" class="headerlink" title="多臂老虎机"></a>多臂老虎机</h4><ul><li>假设有两台老虎机 A 和 B 可供选择，玩2000个回合，每个回合要么赢1美元，要么没有收益，老虎机 A 的返还率为50%，老虎机 B 的则为40%，但我们事先并不知道这些信息，问要怎么玩才能多赢钱？<ul><li>全探索：如果随机选择老虎机，平均会赢900美元</li><li>A/B 测试：用前200个回合探索哪台老虎机的返还率更高，然后在剩下的1800个回合中选择这台老虎机，平均会赢976美元，但由于两台老虎机的返还率接近，由此存在误判的可能性（误判概率8%）</li><li>为降低误判的风险，可以把A/B 测试的探索范围扩大到500个回合，这样做可以把误判概率降到1%，但是平均中奖金额也会减少到963美元</li><li>epsilon 递减策略：如果采用 epsilon 递减策略边探索边利用，平均会赢984美元，并且误判概率为4%，通过增加探索比例（增加 epsilon 值）能够降低误判概率，但仍会减少平均中奖金额</li><li>全利用：如果一开始就掌握内部消息并选择返还率最高的老虎机 A，平均会赢1000美元，但这个假设不现实</li></ul></li><li>由此看到，在不掌握内部消息的情况下，采用 epsilon 递减策略的收益最高，而且由于存在收敛性这一数学特征，由此 epsilon 递减策略能确保在回合数足够多的情况下找出返还率最高的老虎机</li><li>胜者为先：范加尔在曼联采用了一个非常规策略来决定罚点球的球员，第一个被指定罚点球的球员会负责到底，除非他没有打进球，接下来新换的球员继续负责罚点球，如果没有罚进就再换一名球员，依此类推<ul><li>频繁地换老虎机，会导致探索过多而利用过少，只比随机选择老虎机稍好一些，而且胜者为先策略只根据上一次的结果来评估老虎机，这忽略了老虎机之前的表现</li></ul></li></ul><h4 id="epsilon-递减策略的局限性"><a href="#epsilon-递减策略的局限性" class="headerlink" title="epsilon 递减策略的局限性"></a>epsilon 递减策略的局限性</h4><ul><li>采用 epsilon 递减策略的关键在于控制好 epsilon 值，如果 epsilon 值递减的过慢，就会失去利用老虎机的机会，而如果递减得过快，就可能会选错老虎机</li><li>epsilon 值的最佳递减速度主要取决于两台老虎机返还率的相似程度，采用汤普森取样方法，可以计算 epsilon 值</li><li>epsilon 递减策略还依赖于如下假设：<ul><li>返还率恒定不变</li><li>返还率与上一次游戏无关</li><li>玩游戏和观察返还率之间的延迟极小</li></ul></li></ul><h4 id="小结-11"><a href="#小结-11" class="headerlink" title="小结"></a>小结</h4><ul><li>多臂老虎机问题的实质是如何以最佳方式分配资源</li><li>一种策略是先探索可用选项，然后把所有剩余资源分配给表现最佳的选项，这个策略叫做 A/B 测试</li><li>另一个策略是给表现最佳的选项，逐渐分配更多的资源，这个策略叫做 epsilon 递减策略</li><li>虽然 epsilon 递减策略在大多数情况下能够提供比 A/B 测试更高的回报，但是确定资源分配的最佳更新速度并非易事</li></ul><h3 id="更多评价指标"><a href="#更多评价指标" class="headerlink" title="更多评价指标"></a>更多评价指标</h3><h4 id="分类指标"><a href="#分类指标" class="headerlink" title="分类指标"></a>分类指标</h4><ul><li>接受者操作特征曲线下面积（曲线下面积）：这个指标允许我们在最大化正例率和最小化假正例率之间做权衡<ul><li>正例率：被模型正确预测为正类别的样本所占的比例</li><li>正例率 = 正例数 / ( 正例数 + 假负例数 )</li><li>假正例率：被模型错误预测为正类别的样本所占的比例</li><li>假正例率 = 假正例数 / ( 假正例数 + 负例数 )</li><li>在极端情况下，可以把所有样本全部预测为正类别，以此实现正例率最大化（正例率为1），虽然这样做可以避免出现假负例但会明显增加假正例</li><li>接受者操作特征曲线（ROC 曲线）体现了最大化正例率和最小化假正例率之间的权衡</li><li>模型性能通过 ROC 曲线下方的面积来衡量，所以该指标被称为曲线下面积，模型的准确度越高，曲线越靠近左上角</li><li>完美的预测模型会产生一条曲线下面积为1的曲线（曲线下面积等于整个图形的面积）</li></ul></li><li>对数损失指标利用置信度来校正其对预测误差的惩罚，具体来说，模型对错误预测的置信度越高，惩罚就越重<ul><li>由于对数损失指标根据对预测结果的置信度来调整惩罚程度，因此它通常用于错误预测极其有害的情况</li></ul></li></ul><h4 id="回归指标"><a href="#回归指标" class="headerlink" title="回归指标"></a>回归指标</h4><ul><li>平均绝对误差：平等的惩罚所有预测误差，具体做法是对所有数据点的预测值和实际值之差取平均值</li><li>除了考虑误差大小之外，还可以通过均方根对数误差把误差方向纳入考虑范围</li></ul>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;机器学习算法是数据科学的力量之源，它和数据一起产生极其宝贵的知识并且帮助我们以新的方式利用已有信息。&lt;a href=&quot;https://book.douban.com/subject/30442187/&quot;&gt;白话机器学习算法&lt;/a&gt;一书用通俗易懂的语言以及大量有趣的示例和插图讲解10多种前沿的机器学习算法。内容涵盖k均值聚类、主成分分析、关联规则、社会网络分析等无监督学习算法，以及回归分析、k最近邻、支持向量机、决策树、随机森林、神经网络等监督学习算法，并概述强化学习算法的思想。以下为阅读过程中所作的读书笔记，可供参考。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="读书笔记" scheme="http://blog.zhuangzhihao.top/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Machine Learning" scheme="http://blog.zhuangzhihao.top/tags/Machine-Learning/"/>
    
  </entry>
  
  <entry>
    <title>计算机组成原理（下）</title>
    <link href="http://blog.zhuangzhihao.top/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E4%B8%8B/"/>
    <id>http://blog.zhuangzhihao.top/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E4%B8%8B/</id>
    <published>2021-10-11T16:00:00.000Z</published>
    <updated>2021-11-26T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>计算机组成原理是计算机专业本科教学中的重要课程，它可以帮助我们系统地理解计算机硬件系统的组织结构和工作原理、掌握计算机硬件系统的基本分析与设计方法以及建立计算机系统的整体概念，为进一步学习计算机设计实践课程、培养系统开发、调试以及设计创新能力奠定良好的基础。计组是考研的最重最难点，在408计算机学科专业基础综合考试中占有45分。我选择的课程是哈工大的<a href="https://www.icourse163.org/course/hit-309001">国家精品课</a>，配合天勤高分笔记，以下为所记课堂笔记下半部分，包含CPU、总线和I/O系统的知识点，可供参考。上半部分笔记请访问<a href="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E4%B8%8A">计算机组成原理（上）</a></p></blockquote><a id="more"></a><h3 id="计算机系统概论"><a href="#计算机系统概论" class="headerlink" title="计算机系统概论"></a>计算机系统概论</h3><h4 id="计算机的发展历程"><a href="#计算机的发展历程" class="headerlink" title="计算机的发展历程"></a>计算机的发展历程</h4><ul><li>电子管时代 -&gt; 晶体管时代 -&gt; 中小规模集成电路时代 -&gt; 超大规模集成电路时代 -&gt; 智能计算机 -&gt; 生物计算机/量子计算机</li><li>冯·诺依曼计算机（SISD）<ol><li>由运算器、存储器、控制器、输入设备和输出设备组成</li><li>指令和数据用二进制表示，以同等地位存于存储器，可按地址寻访</li><li>指令由操作码和地址码组成</li><li>存储程序，且以运算器为中心</li></ol></li></ul><h4 id="计算机的基本组成"><a href="#计算机的基本组成" class="headerlink" title="计算机的基本组成"></a>计算机的基本组成</h4><ul><li>计算机系统由硬件和软件组成，软件分为系统软件和应用软件</li><li>软硬件在逻辑上是等效的</li><li>计算机硬件主要由存储器、运算器、控制器、输入设备和输出设备组成<ul><li>运算器 ALU + 控制器 CU = CPU</li><li>主存 + 辅存 = 存储器</li><li>CPU + 主存储器 = 主机</li><li>现代计算机为以存储器为中心，指令和数据都是保存在存储器中的</li></ul></li><li>存储器的基本组成：存储体 -&gt; 存储单元 -&gt; 存储元<ul><li>存储单元：存放一串二进制代码，每个存储单元赋予一个地址号</li><li>存储字：存储单元中二进制代码的组合</li><li>存储字长：存储字的位数</li><li>地址寄存器 MAR：存放访存地址，N 位长的 MAR 可映射到 $2^N$ 个地址</li><li>数据寄存器 MDR：暂存从主存中读写的信息，MDR 长度等于存储字长</li><li>按字节寻址和数据线无关，只和地址线有关</li><li>按字寻址，数据线个数等于存储字长位数</li><li>字地址是连续存储单元地址中的最小值</li></ul></li><li>运算器的核心是算术逻辑单元 ALU<table><thead><tr><th></th><th>ACC 累加器</th><th>MQ 乘商寄存器</th><th>X 操作数寄存器</th></tr></thead><tbody><tr><td>加法</td><td>被加数、和</td><td></td><td>加数</td></tr><tr><td>减法</td><td>被减数、差</td><td></td><td>减数</td></tr><tr><td>乘法</td><td>乘积高位</td><td>乘数、乘积地位</td><td>被乘数</td></tr><tr><td>除法</td><td>被除数、余数</td><td>商</td><td>除数</td></tr></tbody></table></li><li>控制器的功能：解释指令、保证指令的按序执行<ul><li>取指令 -&gt; 分析指令 -&gt; 执行指令</li><li>程序计数器 PC：存放当前欲执行指令的地址，具有计数功能（PC）+1 -&gt; PC</li><li>指令寄存器 IR：存放当前欲执行的指令，IR 的内容来自主存的 MDR</li><li>控制单元 CU</li></ul></li><li>主机完成一条指令的过程：<ul><li>输入程序 -&gt; 程序首地址 -&gt; PC -&gt; 启动程序运行</li><li>取指令：PC -&gt; MAR -&gt; M -&gt; MDR -&gt;IR</li><li>分析指令：OP（IR）-&gt; CU</li><li>执行指令：Ad（IR）-&gt; MAR -&gt; M -&gt; MDR -&gt; ACC</li></ul></li><li>计算机系统的层次结构：高级语言 -&gt; 汇编语言 -&gt; 操作系统 -&gt; 机器语言 -&gt; 微指令系统</li></ul><h4 id="计算机硬件的主要技术指标"><a href="#计算机硬件的主要技术指标" class="headerlink" title="计算机硬件的主要技术指标"></a>计算机硬件的主要技术指标</h4><ul><li>机器字长：CPU一次能处理数据的位数，与CPU中的寄存器位数有关</li><li>运算速度：主频、核数及每个核支持的线程数<ul><li>吉普森法：$T_{M}=\sum ^{n}<em>{i=1}f</em>{i}t_{i}$</li><li>CPI：执行一条指令所需时钟周期数</li><li>MIPS：每秒执行百万条指令</li><li>FLOPS：每秒浮点运算次数</li><li>在指令数和时钟周期一定的前提下，CPI越大，执行时间越长</li></ul></li><li>存储容量：存放二进制信息的总位数<ul><li>主存容量：存储单元个数 × 存储字长，字节数</li><li>辅存容量：字节数</li></ul></li></ul><h3 id="数据的表示和运算"><a href="#数据的表示和运算" class="headerlink" title="数据的表示和运算"></a>数据的表示和运算</h3><h4 id="数制与编码"><a href="#数制与编码" class="headerlink" title="数制与编码"></a>数制与编码</h4><ul><li>十进制换二进制：整数除二取余，由下而上；小数乘二取整，由上而下 </li><li>二进制基本符号少，易于用稳态电路实现，编码、计数、逻辑运算规则简单</li><li>八进制 Q，十六进制 H</li><li>真值换机器数：0正1负</li><li>有权BCD码（8421）：逢1001进位，4位一数，C正D负放队尾，偶数位数高位补零</li><li>余3码：8421码的基础上加十进制3（0011）</li><li>ASCII：”0”：48；”A”：65；”a”：97</li><li>国标码 = (区位码)H + 2020H</li><li>汉字内码 = (国标码)H + 8080H</li><li>奇偶校验码：添加一位校验码后使整个码字里1的个数为奇数/偶数</li><li>循环冗余校验码 CRC：检错编码</li><li>海明码：纠错编码</li></ul><h4 id="定点数"><a href="#定点数" class="headerlink" title="定点数"></a>定点数</h4><p>- </p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;计算机组成原理是计算机专业本科教学中的重要课程，它可以帮助我们系统地理解计算机硬件系统的组织结构和工作原理、掌握计算机硬件系统的基本分析与设计方法以及建立计算机系统的整体概念，为进一步学习计算机设计实践课程、培养系统开发、调试以及设计创新能力奠定良好的基础。计组是考研的最重最难点，在408计算机学科专业基础综合考试中占有45分。我选择的课程是哈工大的&lt;a href=&quot;https://www.icourse163.org/course/hit-309001&quot;&gt;国家精品课&lt;/a&gt;，配合天勤高分笔记，以下为所记课堂笔记下半部分，包含CPU、总线和I/O系统的知识点，可供参考。上半部分笔记请访问&lt;a href=&quot;/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E4%B8%8A&quot;&gt;计算机组成原理（上）&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="计算机专业" scheme="http://blog.zhuangzhihao.top/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%93%E4%B8%9A/"/>
    
    
    <category term="Computer Organization" scheme="http://blog.zhuangzhihao.top/tags/Computer-Organization/"/>
    
  </entry>
  
  <entry>
    <title>开发团队调度软件实战</title>
    <link href="http://blog.zhuangzhihao.top/%E5%BC%80%E5%8F%91%E5%9B%A2%E9%98%9F%E8%B0%83%E5%BA%A6%E8%BD%AF%E4%BB%B6/"/>
    <id>http://blog.zhuangzhihao.top/%E5%BC%80%E5%8F%91%E5%9B%A2%E9%98%9F%E8%B0%83%E5%BA%A6%E8%BD%AF%E4%BB%B6/</id>
    <published>2021-10-08T16:00:00.000Z</published>
    <updated>2021-11-10T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>在学习完 <a href="/Java%E5%9F%BA%E7%A1%80">Java 基础编程</a>的全部知识点后，为了更加熟悉 Java 面向对象的高级特性，进一步掌握编程技巧和调试技巧，实现模拟一个基于文本界面的开发团队调度软件，并以文档的形式记录软件设计结构、实现方法和一些疑难之处，主要涉及类的继承性和多态性、对象的值传递和接口、static 和 final 修饰符、特殊类的使用（包装类、抽象类、内部类）、异常处理等知识点。</p></blockquote><a id="more"></a><h3 id="软件需求"><a href="#软件需求" class="headerlink" title="软件需求"></a>软件需求</h3><ul><li>软件启动时，根据给定的数据创建公司部分成员列表（数组）</li><li>根据菜单提示，基于现有的公司成员，组建一个开发团队以开发一个新的项目</li><li>组建过程包括将成员插入到团队中，或从团队中删除某成员，还可以列出团队中现有成员的列表</li><li>开发团队成员包括架构师、设计师和程序员</li></ul><h4 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h4><ul><li>软件采用单级菜单方式工作，当软件运行时，主界面显示公司成员的列表</li><li>当选择“添加团队成员”菜单时，将执行从列表中添加指定（通过 ID）成员到开发团队的功能</li><li>如果添加操作因某种原因失败，将显示失败信息（失败原因视具体原因而不同）</li><li>当选择“删除团队成员”菜单时，将执行从开发团队中删除指定（通过 TeamID）成员的功能</li><li>当选择“团队列表”菜单时，将列出开发团队中的现有成员</li></ul><h3 id="软件设计结构"><a href="#软件设计结构" class="headerlink" title="软件设计结构"></a>软件设计结构</h3><ul><li>软件由 view、service、domain 三个模块组成<ul><li><code>com.atguigu.team.view</code> 模块为主控模块，负责菜单的显示和处理用户操作</li><li><code>com.atguigu.team.service</code> 模块为实体对象（Employee 及其子类如程序员等）的管理模块，<code>NameListService</code> 和 <code>TeamService</code> 类分别用各自的数组来管理公司员工和开发团队成员对象</li><li>domain 模块为 Employee 及其子类等 JavaBean 类所在的包</li></ul></li><li><code>com.atguigu.team.domain</code> 模块中包含了所有实体类<ul><li>其中 Programmer 及其子类，均会领用 Equipment</li></ul></li></ul><h3 id="创建项目基本组件"><a href="#创建项目基本组件" class="headerlink" title="创建项目基本组件"></a>创建项目基本组件</h3><ol><li>创建 <code>TeamSchedule</code> 项目，按照设计要求创建所有包，将项目提供的几个类复制到相应的包中<ul><li>view 包中：TSUtility.java</li><li>service包中：Data.java</li></ul></li><li>   按照设计要求，在 com.atguigu.team.domain 包中，创建 Equipment 接口及其各实现子类代码</li><li>   按照设计要求，在 com.atguigu.team.domain 包中，创建 Employee 类及其各子类代码</li><li>   检验代码的正确性</li></ol><h4 id="键盘访问的实现"><a href="#键盘访问的实现" class="headerlink" title="键盘访问的实现"></a>键盘访问的实现</h4><ul><li>项目 view 包中提供了 TSUtility.java 类，提供了以下静态方法，可用来方便地实现键盘访问<ul><li>public static char readMenuSelection()：该方法读取键盘，如果用户键入’1’-’4’中的任意字符，则方法返回。返回值为用户键入字符</li><li>public static void readReturn()：该方法提示并等待，直到用户按回车键后返回</li><li>public static int readInt()：该方法从键盘读取一个长度不超过2位的整数，并将其作为方法的返回值</li><li>public static char readConfirmSelection()：从键盘读取‘Y’或’N’，并将其作为方法的返回值</li></ul></li></ul><h4 id="Equipment-接口及其实现子类的设计"><a href="#Equipment-接口及其实现子类的设计" class="headerlink" title="Equipment 接口及其实现子类的设计"></a>Equipment 接口及其实现子类的设计</h4><ul><li>根据需要提供各属性的 get/set 方法以及重载构造器</li><li>实现类实现接口的方法，返回各自属性的信息</li></ul><h4 id="Employee-类及其子类的设计"><a href="#Employee-类及其子类的设计" class="headerlink" title="Employee 类及其子类的设计"></a>Employee 类及其子类的设计</h4><ul><li>memberId 用来记录成员加入开发团队后在团队中的 ID</li><li>Status 是项目 service 包下自定义的类，声明三个对象属性，分别表示成员的状态<ol><li>FREE-空闲</li><li>BUSY-已加入开发团队</li><li>VOCATION-正在休假</li></ol></li><li>equipment 表示该成员领用的设备</li><li>bonus 表示奖金</li><li>stock 表示公司奖励的股票数量</li><li>可根据需要为类提供各属性的 get/set 方法以及重载构造器</li></ul><h4 id="Status-类"><a href="#Status-类" class="headerlink" title="Status 类"></a>Status 类</h4><ul><li><p>Status 枚举类位于 com.atguigu.team.service 包中，封装员工的状态</p><pre><code class="java">package com.atguigu.team.service;public class Status &#123;    private final String NAME;  private Status(String name) &#123;      this.NAME = name;  &#125;  public static final Status FREE = new Status(&quot;FREE&quot;);  public static final Status VOCATION = new Status(&quot;VOCATION&quot;);   public static final Status BUSY = new Status(&quot;BUSY&quot;);  public String getNAME() &#123;      return NAME;  &#125;  @Override  public String toString() &#123;      return NAME;  &#125;&#125;</code></pre></li></ul><h3 id="实现-service-包中的类"><a href="#实现-service-包中的类" class="headerlink" title="实现 service 包中的类"></a>实现 service 包中的类</h3><ol><li>   按照设计要求编写 NameListService 类</li><li>   在 NameListService 类中临时添加一个 main 方法中，作为单元测试方法</li><li>在方法中创建 NameListService 对象，然后分别用模拟数据调用该对象的各个方法，以测试是否正确<ul><li>测试应细化到包含了所有非正常的情况，以确保方法完全正确</li></ul></li><li>   重复以上3步，完成 TeamService 类的开发</li></ol><h4 id="NameListService-类的设计"><a href="#NameListService-类的设计" class="headerlink" title="NameListService 类的设计"></a>NameListService 类的设计</h4><ul><li>负责将 Data 中的数据封装到 Employee[] 数组中，同时提供相关操作 Employee[] 的方法</li><li>employees 用来保存公司所有员工对象</li><li>NameListService() 构造器<ul><li>根据项目提供的 Data 类构建相应大小的 employees 数组</li><li>再根据 Data 类中的数据构建不同的对象，包括 Employee、Programmer、Designer 和 Architect 对象，以及相关联的 Equipment 子类的对象</li><li>将对象存于数组中</li><li>Data类位于 com.atguigu.team.service 包中</li></ul></li><li>getAllEmployees()：获取当前所有员工<ul><li>返回：包含所有员工对象的数组</li></ul></li><li>getEmployee(id : int)：获取指定ID的员工对象<ul><li>参数：指定员工的 ID</li><li>返回：指定员工对象</li><li>异常：找不到指定的员工</li></ul></li><li>在 service 子包下提供自定义异常类：TeamException</li><li>另外，可根据需要自行添加其他方法或重载构造器</li></ul><h4 id="TeamService-类的设计"><a href="#TeamService-类的设计" class="headerlink" title="TeamService 类的设计"></a>TeamService 类的设计</h4><ul><li>关于开发团队成员的管理：添加、删除等</li><li>counter 为静态变量，用来为开发团队新增成员自动生成团队中的唯一 ID，即 memberId（应使用增1的方式）</li><li>MAX_MEMBER：表示开发团队最大成员数</li><li>team数组：用来保存当前团队中的各成员对象</li><li>total：记录团队成员的实际人数</li><li>getTeam() ：返回当前团队的所有对象<ul><li>返回：包含所有成员对象的数组，数组大小与成员人数一致</li></ul></li><li>addMember(e: Employee)：向团队中添加成员<ul><li>参数：待添加成员的对象</li><li>异常：添加失败，TeamException 中包含了失败原因</li></ul></li><li>removeMember(memberId: int)：从团队中删除成员<ul><li>参数：待删除成员的 memberId</li><li>异常：找不到指定 memberId 的员工，删除失败</li></ul></li><li>另外，可根据需要自行添加其他方法或重载构造器</li></ul><h3 id="实现-view-包中类"><a href="#实现-view-包中类" class="headerlink" title="实现 view 包中类"></a>实现 view 包中类</h3><ol><li>   按照设计要求编写 TeamView 类，逐一实现各个方法，并编译</li><li>   执行 main 方法中，测试软件全部功能</li></ol><h4 id="TeamView-类的设计"><a href="#TeamView-类的设计" class="headerlink" title="TeamView 类的设计"></a>TeamView 类的设计</h4><ul><li>listSvc 和 teamSvc 属性：供类中的方法使用</li><li>enterMainMenu()：主界面显示及控制方法</li><li>以下方法仅供 enterMainMenu() 调用：<ul><li>listAllEmployees()：以表格形式列出公司所有成员</li><li>getTeam()：显示团队成员列表操作</li><li>addMember()：实现添加成员操作</li><li>deleteMember()：实现删除成员操作</li></ul></li></ul>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;在学习完 &lt;a href=&quot;/Java%E5%9F%BA%E7%A1%80&quot;&gt;Java 基础编程&lt;/a&gt;的全部知识点后，为了更加熟悉 Java 面向对象的高级特性，进一步掌握编程技巧和调试技巧，实现模拟一个基于文本界面的开发团队调度软件，并以文档的形式记录软件设计结构、实现方法和一些疑难之处，主要涉及类的继承性和多态性、对象的值传递和接口、static 和 final 修饰符、特殊类的使用（包装类、抽象类、内部类）、异常处理等知识点。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="开源项目" scheme="http://blog.zhuangzhihao.top/categories/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/"/>
    
    
    <category term="Java" scheme="http://blog.zhuangzhihao.top/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>操作系统实战（上）</title>
    <link href="http://blog.zhuangzhihao.top/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E6%88%98/"/>
    <id>http://blog.zhuangzhihao.top/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E6%88%98/</id>
    <published>2021-09-30T16:00:00.000Z</published>
    <updated>2021-09-30T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="a0ca48ec6fb8d558c804ee3d7dd79789351285adfd65951e5eabc47d6e163bbc">b37d745af087d2d9e578b95e0003d73e377d41fda17ca438dfaf10c27a76f56d6ab9646df156900f40d29bb0cd704be3d65fbe15454f5466d1245a41dbe4e35619d827bc290fa83b407ed5df72f385918378e68d704f95abd0325f710232fa6ae30794a1b5cbd00457cb516017d56b61e82999e197176a6dea9bc3eb33b35a4987f9765c4e9adc8c967218be3e522b6e73b516e023ca7959e7432d01bb4845c3ec70d30b763cade7e8e8dcde23a037e6f1867d025c00b59a4872572720384b2cb9e0008e97cad84800840075cbee98e004cc119d3bb76c461d2d39d134963d0e169dd2739b2e5d3a3a872efd5f1cb6031fa821fe73e01c3506d596979f271dc177ebb440ea2834ddc9fd6a0589bb180386c467397a4e7a389662fd8e1b17a5e36dbd5ea608551d001a1b8374447af8206982153540ce96a4066112e49b9d7248b40f7345ed95d07ec83ce0ef74406fd04b5f3b3d3c84ee6978c4bf15a843c2ddcbfb9e9649c5b6cf3f8fec8ee2de55b64ed823fb41d453337c43c925243966800bc5be90e777d4bfffb86a4cf5bc730b5ee299aa63a2afb04fea34ef346c5b9ee4eef5edf6ff9291592f872893f2c5789ee609d37f1ed3c8f3eb32c37cb8ba144e3e8bbb2dc93979e98141ec75c88f19ac33ee042f8b2ce7124b23d89d0ce590e4f6a0c7ea1dd92e44be7b26981836bcf71efc0c1e8a5d4a639e826c72d0fd6c5a470be5457cf82852dd9b1cd821f15d05f819250360e256e8563be25416dbcb9023f22059c4a1fd34be8ab9fd124c071ef625c490edc398de74510a5fae7800993300489b9fd6f3ab733c415c9eabd95f87190481aee138e8119ca2f6f7b233907c9cc6503172ba42e3b2ca4b8c2363ce899739e2ea5eecfe4b652082d3c11074f361912b8f2e4698bcffd9ba8d9981830117da5458679eadbc5209c8130df6e046b6a1d06baef3f94f7bb4884b103fcaa31fde43073c43960d0797e83a4a8129e988bffd0180e4aa5a3d31cb8aa4045b3befd2aa8c07d18a34247b04e494e472f2485b17f1993a3eb7e8b746093f32f2c4d2009c7e9bfe1c2d274f4fff78041b5483542bbd3190ca09f9fd4976c5b11a86c1c3afab76dba5896f2609f3b3396a9f673a41f56c183b0de8f99e66c47b0e778fc8b64cba59660b833b5cc9a3c2edb87a62ca80b59f6c9e3b66f82d45a00007589bdb51d6ed717718e61448f153207a54172d293982f1ad60d2b3d3d2d0ce881f66a33766a9f09fa646928a9aaf4ebd0b8656c60cb3e55fd5dac7f907ad59af8cfd5e3550b742ee74aff6331d16821ef8ee766fa5be6ed00977b38b2bdc06a53a486cff8577d9134f60530e0ce86b52c032f2a2fae4a1862f0700a1f2eb2aad69937d1dcf0be9eeb0752c4fcda27f8ae4d4821231d698a3811b0512aeca4a1493a9a267f5b59b55351f836e7d5d88683537e8cbbda415e504b7def1c806f3ea45c99599adaf4637f5e619a9011337e30f05865d100bb0f5c72b1e5c4897163cf2e458a97a8b76767d9cb75740fdce94004731e45b64f8541494e7b38174d6207884e2436a129cbde5a47582a7524fde50cade10b658012d1ed4dcfd68d4216d3cdd608f2001b4836dbc185ca94ab8f8baaefcec6be0b46c44271d904cc683eee0c7978e72395a97b573d3858cb5faae2657a2371ee010c44525b832f102f212552ec398c922756fe229f528861ef97380262914b28f74e6fa5a2b7db37126dbd168da2005b0cb68c777eeab4193ea78a408fd8e5d69478cb39008cf2a154efff41e4e67cc0eba66315976c94ea1be21f53c1861b96800db8afe168dd09cc1f7a12df642ebf372f2fbeb9b4ccc4b49619316265b057ff65cc46a8b6952069d457434bbfda5b25ce8cfc1d352c9ab2f0bd0799b8ed7bd529389bb41ade544ddb7953157e7662bac170bf1d55051e984ab441fa12bcf93af93a960689111afb31fa9315ab351244e57173216edb4509d58e156dc135e45e02b8be498f1d13099bd8a615838fdf21f8dbd5f83dfe230a72892637ab78c804dfb3c82d80a78ecfff2e75a25c15f543dc612f9f3ddaaa9db9898d55d0d7a404b9d7f05e8bc7a330a1943c9483533e537a6fd9b75f9a2e1252b5430bb163332b4305ecc81b5a5c2addc8707f33ab4169ecc112d046e95475288dbfb0b42f5af3bf47dc255edabd1d38dea9473efcf497d85e4b33c5864187be95c684500ff8a8415023fe6859344d58da8c827a91daa1677de1d89a7959779c2ea54605c339a72dd2a751dca4c82046a6ecec6683599019391522e074f585ab26899c34a9dd9bd28fe6b744aec5abd6818e18da69a6e410d0ae9b64cee92bc09bb70b5cb98cc13ae2585e843c054e004eb061394e35e952b9cb1b7125c254a819512a92659b16eecf5943c17dd6d60de1a5dfe93178a2801a8b4ce043ac542545979e8951f535767e3a02f0235367729efca6ab79928619074e3d3f1076991480ba49122275f6e5d1cba8282f4fd7efc7a411a336837c77e755dde7b66142610db2406c56a802ddf3f9c59793a699168e720fa2c96298551697f3a6b06b9023ded770ac049549fd56137099456f7473e69ffffe01f9b1a9ad04db9622265cea490da2cc37a7585dc9b6a44d2debe7a755a787bce0b9e9aaca50be01ad060a2f6878dfd60f15a577dd9c5037e40ab611a4066c460e3bf5cfa901cc2d108c346cd5f0a3a97ae28513627831d9fd70ff4606c90d10deceba9639298c441c86c65ab71426402141447044f08e577f038c6bd65a907aec80450c2d6f7a74134e742a3a7b6a8b30221fb7a3adca9078933ddfeccede7ae33459995c958cc3dc536781fc2d76da7ee29d155362510825a2a88f43b3c9e197c2b4a997d465c98db1b04ece35a6a6c8e88232e9167bc88e4cb8cb50e544b75b3cdea3a3582c33014d05537d3ecc851d29f7e151edfe566c90886eac01e3f21321394391c43fee3c44b096e3a25b340cdbb0f4950f23e7a53ede26b4315dc7d48c2275b774e923faab2bc39f3c64a3837c5b5ac257740523d202d8abb1bcc16cc21ea8dfc7ab86c7afb0cb6f6a2d3fb4b019e495341eb98797b57d94ea3612f2e4cfec7c76288e6e879d3b55dcf722357d968d5286ed087f7c4597674d4dca2049eb3f98b218a07b5885beceb019fe1aec457c1b7542f64a66d81be1e82586c71cd05a2b5c066dd8a8a4d80f1f48fb91f5b175e0860dc90778a1f73447bca863c8ac2e93684631c261c5a433a89ea7afb45b790e7cfd4d93ca67d68e4494aa6ad6b0471e73e23ba80b41e8312507bf1b6485b36c3252b4777628dadcaafe642d0055a9e34f8997278dc5409aae2ccfc394170234f0e0f004498a57ed94cd586379c9675ae2eba2e1def184da21b1e162207c79554e081d5c9b228a0a89551026c756d8e2c57d2ebf77593d5942a72be80f04cff2d1a28fc1eec474f224121624f641d696aa19741905a1fcc1425f4846eac9aceb572447eb852f87b093f3f720e9f57892fad7b21b9226c7b1c2cff166d293fa833cca363260aa28f2e194c6f3e30ccec9966ed6ba0ce5cccc40d99dd0767dcddff998a1350aef2418abcb845678a6b79c7f5405b94be342d6ed8cc15f26beccf931337aca4f28d870c3440b155dd9e91268b7199b180310a07cddfde6e5c3bb9f2ade6c4db3d769297a393f08ca23f42ea36daf686ec241c8101726c3bfce43db36a2b14422a553bfad766a6e97e516dee6d4bb56ad29d398032423be105fc6e0aaba63c466b949d78561c49ee84706e36a6abbdb535f885e4a9f6bbc9b50630cb197dacd5883d4283930b55a60f1d6480624c108016e6cb9c75d54d73b12d0c8b48792c1ae31f05a6de21a4006b63a10d2d10df162854461c6a4f7d853a0d52b74806988adedefcd4cf3124b74e0efa2bce77dbf96ae65c0d9dd4f024d4c71623ae72fc47613a03fd09dc2da6d0d827a60ce2570ea707e0e1ae7aabffcf7161418d4fee9c7b4f06076ae0f2b99a3ed8cdacece538605b8bdcb1b5faf3b271c3eaf7533f66d53ad83906be1c29892da8229b96c1f6f095fe1a24c6f0e6ceaf443482e00ccd1542957faad89d57e581eeed80cdd4acb2fc06eeec11bc2b147d58813e95993bd4fbd4113bf186f4b49ba7b2ba652970fac0a852b9692491c408c7066c3554b9acf9d526a81300ea79d3fae1b4e6511a888df5b78c3473a1a5b4c1182650171485db8416ae3f67537e32ad2dc4f63d42672b27068bc9c8eea61f289dc949beed02cdcdc1853d7098b980094d80a967546a43b0b6b78e6299c4e8ac39acfa7ff6c293e843cd6783228b825988cb688ad3a5757ce964a980a1a7bd4c6239f60f0bfc868fd483c869755f4bccc85aba7f1caba4c73f30fa2bf517bcb4528479de41bda1e5fc85e8b88a0edbe9214c37e4355c865be6260f031245cd38c4967abbdaf0e008657047f9d36eedb38b2a012e86346efe807faa32a9c70da9948074b4614ead16cc1758c1e56399bf07b03a8f3ffda1bce2fbebee02fe0320f46a8a31bc9b883b34969bbb85e54096ec7371ad515f20c5b7596d36c9d0fc03f0f31644d27acfbebedca44d4add3fe8bffd0bcaafbdd036f54209fb0d9827a040993ae53d4c1e3a2c6cf00e45a6557ba06e794dca1bdc0bf771a4b42df81b016de63bc23e46147cf100f4c4f8b1bd4f214d2355c130a547a8b9ce21729bbc93785535789e2029e9e099f66fb12b9574249847e18fd9ea6830fdc2ca0da6fe51bb21f61220c7cd90d00985ba76ebcf11fe4751b2e52d975870f5620aea19ac0274fb245a9a4cd2a2ec24ad75bf1b67dc9b0213fc7e6796f02cd8507d64ff64317d17bc19c548df65beea1bbc4c15555330d5822761efccdc3cf0e916a38a663a17ae46f95a050f9ea8838a5392317c8f989a8baca64c9574c6a2ba9dd7e4092a56e70cc172bde2c54c1192b4a75a3ac56071b632fdc9d6da81d3532b73ebe63680b0ae2308e98e250b20b081d1f57403a19b53fe023d5f0eb22cbdcdddc8e703b9a78f70cb5a817ecc27cd083564ab9eccad105e761a8128e7442e8bede4d6dadb789ec94467a8af1c2f12b6b37cd054c7a715543cae5a8d54164051843ed47a6b69091e2ccbd9eb154c2200eb3067954624709e3bda3a3cfe51476e3066d11877dff957c6dd1b274e657e1e0636b52a2c76169adee9a07ba7214924e57fe7babf3a1e9ca2aa1c2623c5280bb77e2e1b1b4cf9375ad67ba9459eac0664bf72fa0ebd3b3be699b110b08c07f8d2eea4a2491f922441850663924ab8f223724ab469db20bf6cc95db59c7603e71dac0ebfea3a79f4a213c27d031044e81e56f71168a9dc9414f4828b7bfd07550f7958c5b35f193e1096553a0179ceba89b97a4aa5eca076807e68c9a8904af98c20f3465073a13d4b558b3af01fa63e972218ee7fd323dda368b017de2e03c8b5b4355e73ff7aa3431387268a3197fa89e3adc6d1bb5fc7c54b4a487f5cff42945594f73bce0ac8745b07c9e15fdfb3359d2e10945069cb088252a1e9009ef43b2e0ebd982f0c3694c60c2d199b778cfefd1e28d86633f976bc8cfb4f02754951b2b056403f3db75a7ad826e5697fef305fa208e693e986fe8f2fd9ecef00c402a7f90874698441024951f2891139555c465e159bd3151e9d7505cf137d9c0c5cd27b508cf61fef1084765fef8efc3b188e553dd2ab1b745b73623378b231b48eef20aa4eeefff3747fcb9e0712b9e03168de51b52e8be2a7ee126c64fe62e9bbf7df64bd1037d0fc0c340465481d12d8527f60d27a168dd2cb95a77fdb109ee5cb4488cf29fa4a11af9a7865ce48425282cb584cbe211a9b6281e0f38c12cccf2f35598bd133c026a31d0935c7214b28c7a2a6633f70801bbcefa1b7a4eddbf424733141685fa340dbd9fc21ae590172f869795b303040a61230b8e68e11343cb3696fe0fa03356b67b380c6f8e4049c4121a78ffb19cce5adaa79bbf34cce7237037921cf5b3d0fcd472aea33b0b7a3aba1e5c40c8627698d80212106b7cb8b1f80e796c67d8d2ab02ca891bf6cb2692b69cb9a65a16eee365c3bd923de8b238ea0cf59a7d73b8f3876ba488db630642d53231a8cff7dc726e5a1a5a85547c9d5a50c5cb4e8c06c943b7264551297e0a6b82fe8f2df278b1d44ed2b3b811f4d38c853ed6ddd1a6c6c683e02447cc62f6b206422c182a04004b2e2eae7e869eba3fe1aadddc801b267f6625a0eed28d7c7e0280b2b3e13ad0f0fef76bad1d39f7a65b7a3eecf3d0684d603ee4112499e8e73d29d71ce5477af39d6318d58dfff3c2967e39554ba98577edf520183475282fe319ff6cc118dd76264ef6c334b14d9c9b102195e3ba197430c051ece5fac6dc5f00626bfd78881b60c7c30ef62f8627c54b8b812f2bf06aa1f0de09141250df30b9685211fcf1c8a59fc661d6085501a3af6028a9faf8be9a17712e3d3445131a556c162821913db98da90508900f36adf276ba7f402a485c386efd286b0481c91e42281d1ece09dc6c327d716ccec49e8aa48ea0e5b0d07dff3f705f187477a57de92da8e7070c4528576633092796fd25c6dd66352039033595ba0650d9af993ccb41b9c9f02b5215199846c352a8c813c31511c1349d70ec08427dca234e3e105ea4fe3d40b4fc97d9c048960bca90a3722b897855fcd14e359c9977bd6ca5f89064a88134bd32f6cbbd6eb86759a47a415dc37b048e6f747f3d2775f0f494cb55d66d92e446e592c84133a1c66485cc422579640e8c8f4dc2c88b8e200d560448afc9b61caf8421be6645dfda28fca69b758370bf18174df3d34b60875d0c5f587e2266429234d4f7a38a1fb7adbafdd6cecd408b8bee302eaee53bb45ace3420a6fcdb18b3477d03bad9cf4ba4efd6016a78947af1cb65c7000a467378d362ac57ef8f33ebfc6451f0581e66dbc74d17ce17a53a736ce5b35511e35b2cd0d511323c29043e35a37462e0c3c6e869bc915b307005669eddc6d442652013cf9a24f44b4aab9f4c06312538e3af2ed88447ed59075d393ef926ed681002a79be8c089a2674fd8c79caa1d9b8dd3e5d19601d69e4b04f5aa1e937ea36d749449ed59bf765f981f6fc4a9d712a4f71497a07501597d74e9a95af35a28f6ae337085830952952316339c2c7ce5dddd1039b873d1ebbf0537ceeee2eb752c6575375b6885a031168de3c7ee370b59bf9eae003bdb2324df365bf106b93ea2970e08af09f1e70c7701a3deb7131d78468d27cb80f2d7ea35c0b08f3cf95f688efca2fd06d5e0c86f22077ba9024dc521242da7c18ee88946a4b7a1feef41eefcf9f47be41e4ecc0ec6c326da5ce078619dc01e45999ce95aeaf35136fc50905b6534893bec74e27bb4749b4264b1cc4e027ffea859358f6d072d332bf0582e7e22a7bdeab148dcef8aede71277fd1fc37b51ba86c45bfd991f0b555b4da6d5f87ac221da5c3e1a2b77b40a17ff1257c79e3f280085de9877ad1d2579f58692b98a3dd21b2e7f4a192dd2872f5db967845d290b23eab177cfa64b5ce20ba094a8c46829e24e60ff452ef9fe5c0a190ea9486de1296fddefc028dac6b4a561fe074814f4a4ebb7b3d52c975a5bc3ae4419e07bd392400301de4c17f0cc24937198da75818dbbcddedb26e8507f3faa6de2801280061fe640491be77c36b1999145728603f435595284b34bfb92c852712fe7fa9feb605b944cbeb8f019bdd1b34c0b5fdac4f5815faae353e10fb4105380e7f837e497f69fb7342d26ba81f05d1d8e01348ce4adea5a4795c4a7a3eaecabf57259def1ea758e4ea9517b39efc0d01c709dd42e2bc6d15f06a3655d26a2416089c5cfed20b56908b86db2fe25b1d38f5ac87933131b844bce566315a187e81b8b7ec2a9de5ddd4513e729ad5b6d9289285b9e7f31194048fc31e1903ae2d8592e65f0308b5050444336be0d39faab04ea99ce8395736c3b90f05c82a883746e7ef15a9fab370effb0ca5246f5b944903f7f4d69cc23b3323e497f97c61bd383e02d67e3a9b99b53d5538d5adb09c65ba49f4483e1d9c4f75b459685fd607d4242320914b35824036ccaf3c02df15966a3be2d1ead23188ad141e88ca17487bed5a3f2d5c4de44097843cb72ad416bee00274a2b9a3493e2ffdbdee9e480d68cac42b80f5731045c39064fe958af9f5297cff25357f57a87735c6708938e5dc8e9a47b2e43a94c00f2fc899470a961a45818698dffa498aa4ace9bdc13cf0d0350876a42a26a79079ea821bac2de3081cdebd687abee64fd30578fc502a161c7e61c7abf937040b7fb33016cb45c685702b287a268a17e06c6fa6291e2f6850bb8de747aba9730d01358af3a9c9679cc8dc6a83a7e1384830c945fb3872d06c9b5ddbbef15de8d096b19ee1ea298d0616ecc0ca96a51724b7b173b1b6cf8ff81c0dc1f30e19f969405842a32f7e6b9a6bcf9b1734cad9738dc2f9e6609a308497ae9ec0dbf36599cf99c5f01d3b16ec87642c2fef1216a93c73f647111415a3da390d7c28519ddb0ee39748b0bf09ec5a89cec1bd7acbf9854ceacae1068e1c21ff05cab9c55a664f9ffe3f1e45bbe2bffcfb692697ce8a752c6f1fb975f35314cd56a8b1142fe39c682e5a433749e0048ae2a757e9143bb43bc468e105c7a55254accb4263b341e0dbc2530627118400d2107974e9a3973e948fe74d5d1e5a1dfd8a3ca372f76dcbab28af0dfb231690a7633dac9caa5a63b9bcba47efb78235ffcb3374604a60d679c83ecedfa55e4c83a677044c60ce48e2f743e76fbcf218aec41934dbab24c9a6e312c11645cfd3c42244c15272869cbd036d56a1b0502d88a34c5796d0d9b3c04ee50e86ad1f6c201072b367ec2fe49b86e85d90e92a702de388e9142fb209f0cdd5607a38562542dea8b35c6d8ca1d885e7d7eff9d46d1cdedf314033905e5fb4b7f7e5098a0ad73b2cb83f3f215642ca1fbd28166145a8b64ccd7308aea44cf755985301d43270bba6a0c91c4364158c113d48ebaed030ce1f5be20dda6e5df54629ccc5934968a09aee20ee53833570665d35c970740368c4785f13753857a05605c087ebb7fd291ac1aa17628e600e4cd5929dde3db6f076b418b0c81b788a953ba8ecef9375e4104baba219027c879647215020bdc42a35b51266616873956b2c83457cdb929c2487ea3430203e9a25214425626c97a52da5a738a6e97281755a2e6500db8c1729129f4e82d3aead1ce704c97efe9edcec4c0b75cadeb2cabc136a73bd4d25d52a01ca80e3ec25b23fc93adcf9c07e9cc4ff97d97463008db857f5fb0c7d157e82cfeb7e5861ce50d844c437eb8901e12f9e427f25546be19c4e759fd32a62125bf9baefc30ffbbc2f9a79797add08b2e90522a50d05c421d3354a0b1024a291d2620e92f2273554b563c6409f488bf00a29f542d09d1f0a190c9b074436ac6a3c5e38b2268e6ffda4582ef4ec315b962d205e7652c35f73f149db7246fde7723c070c2d7ea56237605bc8f7582e858904c8bc03a01965a1972d3a040418cd6380c97285ddb35d3b3694f68f4ad4dace843f81291ec1e3a5402e37ef680e25c0ad25955852c624c4c00e8c51deea280527b981904cdb91a73361e6920c1b87c2b0dc2d8203b056dc5c32ee0bb4b6dcf465eb71cff83e4d9b3418b91f51503643d76c7aa7f0aafbd415be61d4b403c8b37b6e52f03c363f1728bf26a4d734864893b4d31b35bc7696b91a1b09f64d6454ffd36be15f7a69ee2f3a8c3588ecdfadf4c5e888ea94275e2eb668ba3a981a07293ea5ce13ae0c61867f2793929000337ddb92305e4b194551abe151e6f9223c5559227095db4a4222cdfb7f171d54441d342945fe39eeabf423c22e636659ce80b7ce51d14f4e5d2ae60130372a21b640a15e2fe2d67fa009da2635e6654fab357a7547bcde31119cb38b5cb13acd06fc1f1b854ffeffba438b099c10a74a6cca788eff5ca188fb69bcfde10cb3f9fe243e9ee8930d1fb969e875a91390e9a17f4c3be198bd69dfa5454e420ac57a5b421e5474e23538770effdb7992288f21461d19e85284c7e97ea09514374a74e6a9760788c7af523894434a49c5e49af1a54ee1629486652986d6fe21f0c58184e1a51a695cb29f1322b8d4bd5c75f7514851c903f4df6510c8c41fae2cf643144a6d41eb80d8615bada2cab1f924ab7552dc3bae5e3cabbe3b9725769957d0c87d19cb9ef0d6d22fd7dc14b7f5883e1b4a4a4645f463ab1a57291f0c752ef79ab9d96c8920e79ae071e22307947a74de38c1f9ce3b53db5fab46a3edeb2fbd85c2946df495d79d58e12e35d213c4b5def73b405322824a6991dc0d0b4b8a99adf6b345f65f767db78e94edcff8d1160294a0287f73cccd9c692968bfb84932e4423e53a7837426aaf86051f83b9bc953b4d4dfadb77f0d40314100bac3d835bc06aee0a79ce52a84e36c30ec70eebc81824495e11b65c9c0fde9026c93085f898d8cdad217084b62b67e80352e563ef73aeedd8601216f6a603622e3fa97bb4e41445b126dc28a52885eec9c83e32e2ebb446db7d6873085da9d1abedd52b230124ed5780abf8acad1665f20a8eb43c85de93de051f3fddda447212d7b364bbe22ded83a6069cd75e7b3fb5c94b65ef8c2679cec492e0b7f81d2553f9b457b4dc9d30040500a95d2266c09776fcd5d7fea84962015edae1e80586bafadbb744a534f9a52d1641a06fd35cb9477c4fba3064adbceb7ab66814553908a554178c88cd6f6e7db4174db2118fa13388b88c5535f6fbfe773d1ce7f50ac12cb5e5df23c82c8b5be33616305ae12f6b2c625585b6efc7c7b0a65bc9d4c6d757d8ecf43c3c52c21b09c2b56c3311f4b07435aa53d8120e09ca3e9a9a36c58d34e2a08057d6734e63d12efef6ea44e1c304a3b7b43bee00a4b14f2cab82fb0fc246af3b44ceba91e2952e13a8a8a1278cd10ef104007392a20e949814ff7b0027c8841f4328c4d7ed6e2efb6b6b37e1b81b67d14c5115f01a1fbc3d4c3ee2627e62a23921f95e885e04511a99aa604b7759c51a608d591e9dbed33a70abf8d4af7a451d79cd83771821e902b54cadd5d520c5236a9f77abe266feb4cdde2177d445885bd1c68a45ed64db0816d93cc1d514d67e2595c8f52c600499e67ed93fd241cc9caa712fe8f066429e04f176a597dbc7d29cb3a6ff0d496f4604d20e8e8b9851c2719ff0b00a363fc81d4c9c44db9d3a4c34d505bee1600285024e63cc054b81c5a2ffd1d87603527e675a924e3a8ac4bfe154122b54c86fa00b38d66877111efa0541906de9b40fcb02b2da8b7feaaa05a0699870dc3ef7998d92d97cae62bb9f1b1c8d368ec3420e9919c16df30714ebcb77516a88d0a221fdbc69d2521ad8775621115736ac93eeb4abeab1f46df0ebbc97161c208cc080f9faa02c6812fbce9fb4f320c213508db41c828a27d5d721fd76f5b89ee79ffee15409fad9f6e21ce17ba80fd1d6fd0c83188a12edf631565633d977d98df2c7383c61562af72e85ce5538f555394d3fb6c63788abc3dd967ef29ddcd7725cea19e611ba1a1d150a7b2d30b9906e3199482896f4e9edceedaf7b00f76abe08e807d6bbae2f2d2431b0b4a5d31ac47ad08bfe83377d41a851b17e6e4b23f9ac408587e610c643c947bd8893f2ca52685066bddf8767e1f7e681f534ca5308430a4e8cd8f18cee3db667650cda0f0f750e66ab34a75d3f1615d99254ca1304104a74d86a804c3241c2302dfc0911c9d709d8512f7d92dd90d673ba46aca744e16662c9de69ea433a016e7e04e7ea8b8c6957e9e73d6dd0dd7544d93b993e3d855d0af96266c5647e4affd6f290d3cf37b1301da561f3b7da4332bb11521b8eea24e0d7daf40aa3d097dbedec0df166746ba1d368634806957203f4b6acd781dc6a1a4bb15b4138340843ce0e605e71c4717b3e5eec7fa0f2351423d90432db0259601403a323c4b53221e81ec7d51c8aaa6d1db4ab2465cb629b2881cb4e9afdca43f77671b6dada43734c66d98f67f4b522862fd4e9d9e70c34ff55b71c14943529c7d1866bb124b82a58fedec0c42e8eca1bc0a4b2a545657ee39e39114d44a262fe12d69d854e9b2f57a3dfdddff646535f5dbb17544c4c5bf37a918ff79b87b794d49cfc7381941e0a2c74ca246c53c172f1136a597a471281e4922f2fd61eebde248cb2cb043fc311cfcc8fa4e41b12d882278182a2524edd396893d2a82967d5bbf7d537e2a11e4d88a7300d537e36b7cdc6392b3a92f55d65d13693ae0a436bb80bacec63238650d21f04ba2468364f7a32dfca696442ca9c7e089bd4d4350153d555f9d73e562b6006530da3d7f97fb89a80769186219f8596f9b8398302634f6b2eebc99d011d99ec78bf83e1f215dd804d4b8b7799675a97b56ea52d67efad19be8c171bbfac16012b0dae2c98654905c904850f29153912172f9e1963a6c695d106b17a447909bddbd4da85eb7ac39e24e27a3427431a66d2055a157255510965eb92cf05da198f7af93a06752f219a09134bad24d188e905af9e0597c8d6555727b71c682df42ee9fd4d1bdeebc37575e456ad572b61c81e9fa87409b45b5259f12b3cbb7e184dcaed1e19d028dbcf07af9a26253537491f4f3817697cadc4a438fb15e358061344f5f40135d0bed6ca59b0b067bfd479e0660fda903a4606824ac10260160cf908b661877847da86f9c6c167c7b61432a1ab471c6ed80a5ccbc4d0a6e685914aefca0f3312d8fa08727b2c50af32721a6b46dc23048a171a67fa917af8946c7b07f42ecddfbe1c39dda19b9216b34a7abdc7435251e8e60375847908787cbfed58eafdccad62bb3debfec3a7866d42fb74dae46b092dc735c710a57e42fc299c3d88e9d29c1433b68a94814dd5d8e0735d6ba5e4e568840ec31f08f8fdebf81c8e8a30a8afa242d4b8b2c10b80f661bdbe882d935d6caf66e2e399ccddc35e0e22635850a48ee90a520c8936058d11966cec04d20741f648deadd95d6e2e4d7cdc0f2f082d16083038848e6d46a122a4df8374b0a2840f5d3feeefe588c057e671b5c7b9d86b568b087e017c843bbb12aa89f42f0e7e1c2fe7d66a0bd6aa4fe85257831ab0e39f784eb0400dea3d6aa96dfdeb435a90d94112887d98d0bd1fa6c12e06da47f99d2656b41d92b684c230a98d40847b0d3d0c080402c81636d6463df08a49b4c528785c8515ffeee6d78f1ab73d578eabe330e7cd6129dc2ab5366d4387f32b802b2742339269d5398ed981870b08f8fdc2e078b4efb7713fd25740ccd282adda8cf08de92f5cbae8d70e1870e560f5609f5b0617f343e9d51dcb7fe871ac279f9afbff6404e7b7adc37c94d3ed01a2dd1afd3415c5c8490e676789f1572f95480fe86479a0d59ff94f8719c89f49ea9c13d119e8c7185c8b1d87490b2383801a56ea4b6084a5e13b9f45ba152580ca78e9bd7010abfea4193ca6b03985bc2d2d5c472bda0913915daaea391d4b9884730a7ce51f25fff60a719f269bba21fb5cff4eb141f9f7f0b03c7098efd5b5a56dae47a43ea7e8f1efa11093749303862fa0f7ee4fba573c63cd29870273ace39c8effad263830063d5b8d99efbb1e61c515dc164f36ca4b9136cfed1e1e45ef178e2ce637f2649933e75d27f20354e1a301e1757b7241b9e3d093474094e322fbbe076a29401d71fc672c9727136d611638f46d42f6e474f9f9feb80d490cdd84ac3bc2c872dbaafd173ecc12630f44e1671fc079c91615535a423be7ff6adc367f037a3f5cb20dbae8ab3a483d8e923cc533d36f7ee0c3197956ba6660d039254ff2f53c9fb6282c6413ae7771436b56992886957b25ca84673785bad32cdb99fa672096946e077c02e4ca9034aa06eb9a7dba1d335a36f73f003b4f072961c14ef858a1cf45ffc88e4484410f6cd8311c07317ed07b0cfe3752fce33ad197c99f6fa845081139ccfbca400af05404d635adca89549e41f2a90c2f51f656485ad65ac8a547e3ea980ed4ff5e7715891a6f2b1dee469afc3cc4d8e8d0d5542bf776a4a741e297d0d42c41ee39fc03e47f2dd865b4872a9ff9bf53ea442c77ac0d393d893fdeb122736a11963b0655cea97660200579333d612ec04ca423dfeff9219fc824720f7da1e1b75bbb0a5778e2c52eb5d7f86c0d22f860974ab4fe4ca2d59c5a9286d1cc5da9ada5e30135c7776dc817dc8112d4c8b80a0bd01d2baffb1059415fd971c5e470df8e32d72285b0b3bfd3b0cfb5e7866684c01b29a1502220efdfebbb2c17585cf30eb4588db843435dbd274c631374a5b13fadbef3aa7b6a4869b7e353eba32487368620cad095113693f8327992944cbd00d509e8486f20fa956e1eeec543ffc4338229568874d162003508a350a7d45733d6ddd87c6d6c5fb0491fc15576c5accdbcf1ad466d7c7115dbe263dc6f07c5bc178515f48e02c3e2679c8236e86a7f839df6f22d71d2230b7dd942b9d74392afa3e6897e2aa160bd568e4a36ef26bebb7127c21f81c87dd3c9e5a2530be616a141eb4098cee0786caa8322c2474fe2733800b3dffbf0932bacf3b066ba54e38f963c0420e1e77b0b8cef464255ae9f633f62bb68928c12162cb5c860aeec7c8ef57b9a6f95cbee974f0cf46b56225536266faf60369e8278da57f67c26c19384793ea9f8ed6c3f373b7bae6c73b19e7b22e557d83f6ae20d17980569271b5e91af02f0ebd5ce779ae79163799f6e6c440fa3d2863e4fa663b9bb7b38ac37193b6dc3b4ab1d81cd79d0376c4fa5d4020c3740a4018648ea7ad45c39f24d32af52358035ff2e6ba2bfc7e63c06b9ada4f4ea41ac5b1ef59b9426b0cdc350849bd18e39bdd625c4cf39287f821af548cc8072c5898fdf4c63212ec2f39998f46809f7d4f42f4b0fee1fcfc2d38b82f96de7acfa5c5566e6f93171fde39b9434c1ed1e0973696b67d6599e33a61c3591341c4a7814c0f516d7b0868a55b1f2e4461423dabf3b93b2b19e037a710f459d898069b26e9f343415af237ab15926f76d29419fea5d426cc6bc0b15d0e684af4f43067da9ddfb6b09bcaadb5814302ac5988900d2a335587993845dc35bf82815ac218a15d58cdfdc57eb189f73de513c20154e4aca8d2b51179ce7a35166986db41bac941d71cd21b610869b9010622cc9216921a2ca160e44f43adcb0048a254bb90d657f0114693f1b964906398f24aaa11b356c5c0434200303b12675178f40b431d0ddad1aaaf29948ee94dc8352b4f8ba3d05eed9c8339932cb70e683cf11d7570648e02a0f0fcceac0e8e8bf6c32f694911d948cc5e5c5d5e67a9db3d3bd5a87f6719318fae1aa507173292bf387fa8e9f50e30d5765583ebf67226d80e3d93d012611607d16050b70a0e38f178249e57c1663f09fe1025bd5c50e4b995c60bdc37782263bd8af93ed167d16abd8d317b21c0b366ef337a76256cfe6839becc117b8da623fd021c6968c2f42cf4b8077aca73411230508781db5c1155a44511c892073f652f22db35a0ed23d0ac60d395e8e723acbcb2398a083952fdc80e5734421249c23eb266937b28611e3a5d81cf8dc0ce160ff3cd6ee5d2bb3099a24bd218e9991265411ec1f08f4fa2ca857d8b708709bf5341915973d8da87f741681a6db57eedaeb4a9661652d76b24def3c7c7c6f0b98d226871485c147de2c1a2811ed56b48f1515f2803eeb5dbd572250362320a9d76b31404e3b752b8c7470622f7e6a99a2e53c87cb8a33aca4885ccaa259a848fdcde9cf3e457fc33d48566655460fac1b3b0c300a8c9964fef97552690dab8206fa6f4b2b059f16c69b11b5a51527bbdbfb39247da66c68fca53892279fc0bcf9e98c55603f4227799940cf3d91e7f955810814bbc5f1103362f9e1303c859ff43c0407deeef02bb491831ab632bca5b852eb5506cb2d0a09e8c7375035bed877d211e36c6a371f1422cc1e5df1b4615da566b292d5446667a384f32ec51622caaa7c189a2961f02507f90bd62ef583de780936a7eff4361afbadcef7009f4e3c96f66023e7e00dcef6da8f1b24fc020917bd917441c7bb32e42714cd02d1b873bde6db9a255c368fbbbe661bbc5fab131d8d7885e1a74a20edb9b71015cab7178a69a6df078d7289cc8d51293d1999e774f3ce3f2b02076bce892a72cbcdaa6c42d689fbd21689c735612bd8625478bcdf99be9fa256d85fccc00ff41ab302c61b9a57230aae1abeb297830e4156ac24c4f624f866325013151789786b78855dbde638c56bd9c19660b6dff9d7064d35f7b98418ce07817f77f7d9ed27f6336912df4d23dd09465b96cca586d2d7761065eed8d2db61ebe42fee1a6f98b443160f6f6247e38e2c789b2bbc65cfff076977de81bf2fc72f19969ff530b1515c4606cac71c0ae7662f5b81c473d39838ef60830efdb0e0b5db875f32d39c596430cf53e05652fe5a29ef9a070c5a3a6f6ec05a2e1a2dd74f33665ceed3dd620c96fb4e5399b3d95852bed8e1dbe5d10dc33615511932a52c88522a4c3c371def74b41bf86c04380521998117e8e17e25fc487cf09ef5951f107e320a5a698998851cb7b2a9b96abc33163812d39e0af0adc0659e43844a55ebe87755aa121810fc50d3f9847e41d62dd527987d5c2cf4fdf31bee1345aca9cae13bd1c7dfee9369b56abc865b436325602ed4eeba5bf488d2bc6776036fdfa4c4e361e23e18c996bda6c685215c50d80498c0646d6078cc99a82d37b1296c2abaf6cd456603761aa0b2fa7f33a34ec2d7446d294d59fc22cf567eb39fcc6e4e531a61011248c3623851cdf91b9b8aa0e24a28689ed68b357a534a89ae0c18eda3bc72f6bf888e4e8b869dcfdfcddaf992b073345f447a331ad058d3fedb3c38631feda210e0ac200249c4f0c535d77bf95e7154a098b1d8af53af79c7ccbebebed31ae7e41c326528d78a9e8e641c3190255fb64da61a9ef8d2107f257137a3174cf114decf3f45d481c05c14f7fe21ba90ac18393f4424f874bd3278577ba2ea2e1fc27af65a9dbe16f6131e0d508f3c99ce01d8af50d233a438d9ee50cbbc6de27bff00bd92caac988d7a25032000351a3f3035ffbf4bec01f2318dfaf6d4575890546aba154c9270ca1220fd925174b1c41a4c5046f27e5cd7c6e718394ac554bdc93e0dc83c2bb28c83cf10c68e248f3f742ad68044c2031614b5f9d2c1987ebbdbcdd72e69a3613d7b9915ede026d85d31b3f230b4c6699c872cb0c331004b2f36eb274925f25e2d4c2e64ba9479ae992176a6bf7131dd1c8adab485da6d7fb8ce1b2fd0655dea7fb4474021724393b2e7695cc63f6ea78a51795feb25fe6edf13d9bf409b7898da05d3343cabda46288e8a0904e7b4926a38ed25a43cbfd0e607487a7b823f7ff32ca3c3db9db41ca10c7cb0d15be8696fdcc4ff48a8d88099f7f6dd41ced08a6a734aa39359fafab56319387ad38b41d33c70258a2823433502ba6e3f50bf3440a58345dbc71d585a18543fa9a9382d864c0571df7bbf528bea6156c057615f3cdc155fc907cf250844b59a5a3babd514a282610089f7e1d3e9a9bb616cbd3c5ac48f12fa832e16e333a1c6863fbd5119f2531e81d4b0bb8e23ea008937f2ccb52431cba2036db7d8455a617084da04afc5e1d4348368b668817d9143c690e16ecd488b855284e0896d45835554fe929a06c2b8fa8a0e1315f558076346ce5254549782dcc609744cfb2d722a11535dd94e266672aee369ec2b3cd194313c7c4af5c0ed95ae71217318c2d99358adbfef00e1ccd4e4e7cc8ecbcc2fcada778016e979f5086bed7bc21fb4111d07e6376ce0e29195e9ff30b044b6beaf6dcf189b1887130d10ca4ccb8524da4992c5355c1de4e506ee8beb94c88dd466857af1bb7270b65ae426265b2ba4869afe99d344ae437142abaedfd1e2a4d7a33b911a1208eebbb11807641633ee87c9117684fbb5588f97fcccd1fc183db213ff56380a72261a4627a1a6f5d2615d76b51a4a4c12ddea603140b6a815f2fa388e51f5cec4ee0ace88c48b3a66674ea24980a28b75769b4864d3c5a7c31c126ed7a92ef93bf47d0a1503cd85bd7df3b7490924b0bd501c5d458f6b5ca15caa94cdbef0cb3ae1529c3bbf7a4140d6c7b4579d02253aa58f5b0d40667d7c4e9f895fca51a62a5f00b4008a4f36205ab3efe6318e7aac43e982155cf3c42bbe0740427a037afa9bdf21f3080677a43834d0c13889396628205672ba9d4f3dc56d0f77492a49d1a4839ef8582fb989e399a28e3cfe059959a33a5daf6138a920f1b571bfc7f71254cb4ef07316a551efcfca112798784f3f9e6066ad71dfa28ab26fb75f30e53f671b1857f120c33b52744d3ef8197810691491d82dc89bcd75f1f8a3a43970978b817200a876af71da03b75d611e3a5b063690bea866df06db799af9f7a3853b7662015f34c45af9ea04bcf21f0636e8ab5a9850d6487a9d85d474e601d86fe959691d952505e35581a9f4087b9896a81a7c57caa348f37f8108a0115c2d0ea9530653af823e56755b05898e0242677370f0daaf3225addff5d827a1fa3bbab873921c2fb98bb43f22dd939c12a1b585de18af018ccf22cbf575578835d282101cd3698999c85b9b6888bf5ebef96939d48c6d86cfc01b087b91d82c9d32af951f036d1c69e721feb9e0486d0b0dc845200fd4314f11e9638a6f7bdc0751b66409b28d954b2ef6bd3652ca9fddc9e91df3d2106b9f5c4094752727c5c5a251f445437b8dad2a08c67686d04c84bb6e1f9e3f0c8bc467e215d3a095ce1b6d304fe8b8917ed4684e2a184159d618af41180ae46d819fff39b228d2a345d49f87d1801303fc21ed70a7fd459197a63d7288df6dc09f88eb88dcf1712c48106822ccceee1dbb35d2e079b88a87fe971e20d2d345998cf765151b8238d392a6080f6cf1b7a84a804788be4063e58e16a7b8b74e8aab0ea1714a4f3dfa720c35dcd48b441925dffb1af42983e0b5f009cdd6f31bfa7f43a297d0965e5d2fb4fae692025d05d9d6004c38d29d0f50ffae829332813b7df9ec9866c15ac7ef1977bd865552534dc5344f32439168468e11e577e882c67d1e115b92b1a792d977ebb991a4e2da80e00654d6c8296a7b00966f99254feb7eea27a2d77a123d5f9aafd1f072042ac07ae2808af14fac3971e2cd83c479cd743bef02c47b0994aa63e72e088d1e505919ed7b011197e461718a6678277cc15fcb36038429a564380330f91069d972b82746fca23e7943a555b2d17d149e89e0b0385b3cdfe30e2800a732aa6e8364c3f426c582d158af19af9748cc688ca81fba611fc76c37bd56c444fecf9ccca217a6b6ba0aca29c7642a7b0c6cb07260c094ad6e966513bd318f4c7f57301ffe57e2e88c73282463885f6ca5118184e11fe015effd81df4389af34124dea6bbe055a9c4cc69be7ca8948997f11e0872fed840f793d087d23a8ed7b55629de47f866bbd5c5d54780a15f3e62646fc8f56c7a1419ee493b8d2aa8573a1dad430957e1a4b6f9c1f3aa9ef43dc6b8d9ca143873741b680ebfef61fee0d8e6714f352e4d080bc8ed3b18f5ab4b2c48c0bdf7c9a77de6ce505cf0a8a6696b3b9fe103498d5c260695c383be98d78ce66c95e72d10335e5d56c4e84534959158c18680114609a575017070d3f7e19fd85a4d59f820691cc19bd4a8743898c2424e1e2774437c09b51a8e93e1f7292b36e90f1cc1a7bc255edfa50da0669740d4c8386ea272c0b0691d3a1062a306b391d7f8cccfdf0c711735ac66eb16ff23d183f3fc38ef72427cd3e8fcfc707f1927a70afa60aa0071888f0588dddc927abf4cd80aefce5de106047340315d419c20708111820607e7d4cee6ef5e3ffcdccf5318ac46dd672b301da602ba7b298c3cb0138916b7ecdbd13b01792cf2c19715a21608accdaca30fca400f6aa27f4b0591f897698a4f4bde94fbd418118e544e3dc4b81d1a742d7694a4dafa9a66a24b40064f28379e0d7ef9967f6a58ac691204e3df16f6004093641e204e69d2e0a6ce4a1fed762c1790e2462e421caa5d0a19877bf961fe0b8c422f96a18c3ea0ea6c7eab37217c7d02c4065403418030c5810f13b938d84d098b9a1fa932496ea435ac8396930782a4001c83ce828289a10ef5fb8cb1a44a9b785cc73e7de3d4021946a77bb25ce86c9fb4cc452d379bd57cab4e922ca5aec45e1babff6c5fb33ab6eb297adcad851e0dc970da6f4a817b3e34954769135308199d0cf765eefecaeaeb36c273e5653a0d7881577c8bd43fdd813c4463c3d17cf51be0539180ab77605813e07ce1d1015de64fddf322aff963951738f5c6534f1fc6abec25d1bf6f4ecc1a06edffd4c8619d58b10da35cde9a162218353dbe71ae0789fe5aec6c84540a557d65db3d08b421cb29a3a6db53a973d9a0951a1ea69caff24a946d26305508dc49a659f576e70014e57231136c429f74bc9695e9ebe63f725431511ea9ee1dd54540e08d57c185ceed2d13084387d46a7b8a924c27959bd02f70f71946db0961b69090ca6c682d26d78352a59b4f6ea7e693471ccb028d53be5c69b0031030df80f42a385043fbfbba163613dfa8088c41f2ae081465c274e079fa0ca888c45a1100b8ae0caf0079d73ce6766065deeb4583e873b0da6138585b5069e1f0455434f28717141c6c8eba3fd9501ca8d91d7dc4149e469cdd5e39adc79303d77a94412fdaa1687deec342475f5b4698294fe8c3cd65301ec7e6021e67261ddf2eee710b80ce665f20a3fc7a2b99a36458e47288f59bee0c8f9ba7088449e0ceda553e8ce7357237f205fbc2dfbc40315ce4df204c8da9753d56313d7de8e779d4dc8b594b55b5ec0e2fff30a924f8643df877030961ff8fbf14361b5011827ea2c3a9a55447db75d0195dcacdc2ccbee0514bfbf97ccd950d20cc5c9f91dc7b5bb2e83281b3c5e51bafe8137f9ab97ec7beb57a137d617e93c362f6f176f40373fb1ce0f1828190763cba2fa719f4afee9924f2b8e347b38a2cbda299bca330b619341c7a9a9e3a676361acf5a4d5bc05201d66b011ff7f83694d7bd978197733adeea78d3a62b4e9e791f9e05c29474cb22be04dc2fd5bbcdc9fef78ad05c07cb5ba300babd146436b253f1473a6e089a69e1b8b7c6d51029af11c62bcd43b089144ffe25fbb6f47374847307d4553c44f75416df25b23e76426b1e1c3a32465a13d14964e1d4a11b88ecce939b773581fcdab70e8519fcf3f86a19e747793aa27e99f36ff81498d78367b12c07daacf12c65773911098b20bc7f45301fb82ff02c03b12d73a96e68a99425889f063f0f1175a7c2562fd3bc37e98c9cb4664c7b537d9aad0f735aed6d0cbb47e8e4f98a14178e4694ff77c7a003ce4c242c10fd06b7dd0d7e59678d1ee22235e7be8068b4619cc6bc9701659d1cc3bf11582949859cda2012565a0c3cd47cc30a60ac713d20641440c4c0a7a6163512fb98b156e8d78794a1e6a2eaed4aeb3914c82d3608d9e721377bb79602d8800e2014df16f900d137dc49cdc49a39a7a10ac97e51b42d324185a7d48ff495714b06d850b729ebf085db191a2e63f5cbe377869dff2e2d807634755948c66e5d5f449a1d5180569fd201b01087711f795e7170d57270a4316d414e19de8e33ff4a5a154fc490e1736b1a5b19b58d666959d79df4bef782fe8c9343358b534125e039cfd542ae2f7c0785aa605770736f65dd998299447acbd6f9ebcb57f7332f7ffc391b069f953cede9b86c4d6f34229813704238716b67271e8ed8e0facbcb38cff98063811c65efe9d8a278127175cd94cbb111b8b987875f2793dd2c10fcd1f7c7baaf28ad0a30b9f8c885b6b116c00dd96094d41645c8d335c4ca75bcaa0ee2343ab59c7c3f002ca87d7da646d2894631e1fff0222ee28ac2631f3164071613e5dba98b352ca3b3578be6159883f4b368bcdb0d0d25946675463cb3e876ce2e0aab64797f645d351570418caf19ecb036e58552a0621167ec367233285c9247046cc8bea6d4a5e74a1e0fd189dc8399ee526ac349c5c7c56b5d3fe3c25da0532e0782555889b2a71d91d6e24b55e512073d3421e3374c514b5fa736f7ba121760daec5f535175145f17f6ba321e1757432658510a1f39f25bfcf6ae3b7e38aaa8e43dd55b5a79e7ae2ce32f9924caa356de121c6dcc136bc440a4f44724703464f4af59d478a95362e96d4b9e25aa6b3685ddfd978dd005776913f697dfce472c9e66404ae39b49e1812b70595a9c6c09749881042780ae7acbb03adac83adda4c52780a35f0dafcf562fc9c9fdeae8444f6881f114fbc58e0e03dd376131c0a9f7e588b8b5843b9370be86e890ec0ecbb47bc9b3eb9f27f514fe380036a771e6f7423bc38978c742db5c1bf9c455164b31f74851573f618fe8606c7c7901d68142fa835cc39109ca497fef5b91c3668f84563dd7e6405e42347e17d2b61d57c4e52af60bc620fcf07a880eb43aa09664437d9a56369701a032a3d462a95f1a634ac54829d2e7faaf5a201f290aa95ae2eefeb7049445899d4df9f5558b8296ff7fbfaf16ecd05deb27e4555044c2772c51bf5c9ff6570c9991b70f3ab21450d9b75bb955c169feaf9bbc8a150dab2f296421da78d68bed9b59395516a0db9c5337781e9d41d02eefdc500e07d616da1ebb2b17787fec59edb3e6bd2baa4f5ffd30d294b085b4879935661669c87a21e8d3be8fa8ab90bce99bfd921438610effbe8009034e51c5b345ab66bc418cf233ad79c9d2c0922688290eae58c434dd73fc9975c48a14f0f7c07d45d991a210efb70fdd5d1eb9a6f6c078af1ee29fa84da862123b09685ffddb5851f8f78dcd470f277f3003ae87d41733bb4c6bbb97a67cf0b4cf9bdf7f9faea6b03f8d5225ec9dc767096a1931b403cae03fddfc511a3a7e1932d77456e937b8b8f00db4f328f3510b935918e60f799f11ae5a742869fd2b15033117fd1da12fe9681c53da23ca4c1178fdfc2e93a8c1c629fd7b6aeb15532851793b94136accf9227c9954e5a16d802c24c487d345ed0b4720aa2271694cbd661f1ba2b7789a0a62bfe32860baf90108ef0f605d13505032e466ef90ecbb915cd1eb04f200e4ee71fad73064f25ad444987244eee824893ff50128cc7370b8a0804eb911bc54c9cff7fba2b09a602584918221be33a26359c698ccbbb27951ae96bc7e73ee560910ccae68cfc0445d3c7e3ce5534069ad4ae2f0d4a966c83b3dc12716ce500eb52775ddebca260d9e46a3ff2b6d4b29bb48d40b94f58cb54be4fe74356fe6d3b4a874b95847bc7e99f80e0ee3e67878dd01a7e3e58f656c17caa773514b6f4ccb7e99bdd1003d45947b76713454747b4540766a8a75cb3f848886d95402233645a621dd4b471daf0a1d9c87835b7769c5e51e0d1eaf4c77492c03922fabf8aa7c3a5f93988fa3882eb36d885643e7dca67749c5b242f046d5b0987df246dc8480912d6ad88b6e308c47a5429e549b8819f3ba2e56a7f15d1b9cc8fad8742d00aae1a7afccff06deab68451facbe00a71f8ab26af68df322410b2befb5926471999538dc281c42dc631d5c1a6beebd88da5b13b10f03f8b613113cb6ff56e93c82e6c317ad8bbe4aa2ae7d6145b3cb693754aa5e057ed550520285c097ddd33409248279fbf769acc5000f88e3715a7100b05bd40c59732fc87e0e7bcb20539b04ce2fd691c23dc7220632fff3944d6cb9538fdec5e48d2ba80362c55deabaa4509e3b380c0a43cd149ee1d73fbcba318e541fc9f9145c5795ea5db5ca0ed25ad36f47c88cce583c9c51e37b185195f18d08b01ced61a4626341f1192e87dfdc1784ef1a4f30395506466bbd8c82ff1f70a2a9e44d62b25a2b418fc7fe1fa47d4c93cbd8c6fd4f0ba3589747687e46c20cbb6ba6d52c450e3c597acbe442d5b9a2c729db7d95f94e018c6107312c0c9c9c5bc2abeec05d18af859f83728ac9f0a308a823c1f6f1a4b8a1ffcdace5e0b53fa90fe4b97f0c22d8e57e0e3f92c9fab22db0023da5ff31052c6377d2ba6d79cc43f197fcab3ff524e2364e20d5b1b4529dadff4147b6895496ca249cb9fcd7c2e7d5d05c447d344ec149003fa4841180013524add71f79239d96c8a92fda435564355343d0fe25a60872e9427f250918209b2461111ebef2508e642eda0202d028f7484359529ed6a1ff424fcf9bda3ce513dd13004d9ac3605476512388abf8732fca59e168c0024d8eedc966488c706a87164e962b4b2df128fd82a5f41f22402ccc7796117ff0bce32db792deacdc50e00a58ce94261829d8f087ee5b299ec7188c5e4a3a3fc053c64e0d4ae3fdffc86f889119a985e3951b966aa7715a77809ff377d4e2209f03e63d5de295a10bc766a4054b9375b352b871dbd7e539bc26ff8bb1ab051372e0461321be52a076a40e792c20daafbf71b096164b1d705e89932d9e55f52d6189d3d724bc36ae313ae7aa74de2ec4f80c7ae55ca9e08f83b1796fa3d6e8ea7b3d2a34f2926184d0bd86439b7c84fc4994f4ce234f2aee0a8d3a209a0c61aed2a012ffcebf340985dd275b01434fc90f8b16e56810945208c501e52ab60f7ea3d33ac81e65152c191ad6b73948fbd229462b894edfa97ab4537f89748a7653302cb0f28864e057cf69081f4409f586d51ad4aa8ab75f2223c128a3bdca86dc3ff33bba36ed5eb0f0bd4b191b3b4489996a794b5eecd3102e7374957b8983be86a8b60f66cd840af2e88223c3ca4ab72b64d9c90aca2a7c2495dd9ee5847fe8fdf9341e23a1737b80c90ff3ad25dc4e286adee87d36c24ab35abcbe9ca62d17f3397b183eb0efce8ebf8e3bc052a2d45a439e4f91cbbf30e4d1d4833a83f786be327fd6e6e826b90f7878ce6fef0b2ce38a1b5ca6816e8bc8d750d3aef7043da3ae998126a14c2535785f3d30ca4261d3a6a05d937bb48cc6fb02d48cb3ba5e419e82f047c26c30c842b8fcea903f6f54372ce8a255fa6561c6a77f4e6784d6c85a104d1815e6d350c6e30a1bb246ec1e1245fd3a251474f2b7a1a41bf42ddf7c324ad2eb0309b1c9b583f3746051bb1ddada666521ffb309da4743c0623a5622630c07bcb5b17b6e2d5cc3ab9a83d640de152d935becbfa6818df879216b24d92f219f56d7db2f45fca61899db78f458107e74dd547aa81e02b96d8544a8ab4814a7ef0c4f7b2320db39365cc67a0f0851a3638a373e35120a29cc30906612e49754bebd3ff0ad304dde32a9377a62e9f0c603338ce9eb9eeff91bcf6d33933184c57cb84dea1fbc69fa96011cea0f2eb5caeb4a02e079e2315efaead6260e7b9094c9067b49dd377d7c241ccfedb709ee23a46bc23a03027a13cd99d4a2f0db737d37377a3b9dccfc6b5ecc5d7bc197ed919f47e63efee5073d7b45c6fabc16c4c0147a6477cf60d1c2166a64bd2f0c9cf21dd88998f4e5bfe21c9f5d8f9af6e39499b45f262bbaa7794412bcbd2950527fd6a0045a55c567d18d3dd2865af26ecb3be009bde47cdcaceb26c0eb8a6e6bbf72dc1d10c5c59dfa4575c7c74e4f8df917feb78a444e73dd3cafb69fb94d1bd115676e4b03c7c0e19ac06a0ffc6f6c43abbeceecb9e0b8f0ccb806100a669f848953b24ea6dbb8203cdffd1db417dcb139d4d3544b02a0cc3ec7cb4606ac0e0955c63ad25391d455a8c69472fcab9c67e145b9bdd1b4c4f9a4e8a2ae94533ee4c634148482636d911daf4c375afb1bb11dcc1400af0a65ea95bab73e675775b8d90de551a1f2bdd0aac0dd51139826adb746eb0699135600e39c4cd863e8dce48272991025cf0aaaa4d5c8abfd769672bfe29c5acb64723d0e157b0b4a1e7d8fbc4506318511e795b1eb50c160958e9089f1e7281dfba9ee3abeb2381d829eaa9feaf43b9304961c96dbda2efb23e5be28b039967e33143cba0ff305cc50bd8f970af76f1687a0e86589d5e6bbdf0df7a53627acf9464758b410175352de15d8e057693ecf549d4b3c2bd0ea3cb0fafe16f7ff6755d90482076708e01f0feb8bbe4ec3a19a17332ba30e91ac9b2ec52a2a0571dd40e516f7c95492c6ba32777d387a3609b2718b77208869c3038203672f10fb75949c9799e80f23b9c669741a2b07e03a225d09133cc72f6d94316c23e69a994d22fc46adf46e48630c59e4dd5298590e08bb6407c1f08a1d8a03b0ae8dd441de5ff66beed0bbb3f595abdc746c39e09fea186203f994670fce87b659c0e7abe908127738f0babb82e0810abf35c13136578ad14a307d751004318cf41fac09eed562bdefb6902e81649ce947e9cde9805360acb8b09e25015467d8d11efa12df5151b4edaac88ef412b4e33ae2f01b628ad4a5eab81b678a1aac3b096d29996f7335187dbb184c6829193536bb4cefcf6e7de6c25d31720eda28e933fe1279cea74c60abd58c30e6c27a9c6f1f2d3ce71458a4119ae5be6929cd429a8fd8119e54a0ba18718a68077f7a345b3b19c9cd8fc5f41c995ffb07a7208caabb3188a4952eb810728394fc3f1ec2be74c79948aabf5b248c23ec0b43dd39bbfa866ba243437e69bf73a2f7d5cd29ded24910fe0bca1df43873ec648d707d133350a455d97686add4c51f76f9dfe8a16e0aee7dae2d877d55533c51bc0b6ed28293560356252b07c226338b7d60df15523aea7be442d2e08ed6b10ae0cd271fdd0e82561077b5862241db915795570346f01bcf6df202535fbcfc96353768051051f35a1f21edb4ec4101c4a7aa77f77ead210e1830e7765c181efc61b1243acb5baa2e458cfe85d5311fe3ba571aa84402ce92c029a1c0b76b2f044df76005e9467d0d2b2b79bb232857857b7e82c3afc4270607c59f6fd47c898276e2a7b1e1baae894b63e0d36ba486bd35a3997d9366bfc97eac0fb8a9d80ef0857020e351b0fdbd76354b71126e4c89046799240438865fb9475140204c9d4f2e2c938f29d1fbce1b17d6fc9bdb6055175f296e31c8e23b057107b0a75e19bc2be9c0172bd33878f79bde0fe311b53db4031b5c4c568c09369eb4192b34b9945320704c5070ca04c56d13653548b42243caf6c92cdb3cc63fb31c61517e739d23fd8c110fb748a64c7257b1e789d1c976879e9121cc706b268efbb847a3e124a4a24742bc1b966193e462e1335031a012843d143135c3b8cb6017f7dbf1dcb4e9b791668534988648b36090c432ffa526acac56aa7686afa1e2f7b0c4d79dbb9e4c7f41b3eeff433556af3aa35295cbd598f5ee6f7c612b1a9d7baa436d1db2aa9b88ed75dba340a782cc177391cffbd0527ef7c211ba4a64e027474cb30fd1d52d5bd7d4b78eb5ceefe9174e03774317a325beb7fa30b7dfe20cfe1728c964a66dab0637b9591b31d5ae6ad2848ed3c6b4c3eb8f42a638aadd81916020f0a730d128f63e97f50a931e109076ab1a2b14aabd30dd574153bbcefc6c0d83c01d213845f3fa2681095840081102b175381585cd8d6a71a2903f2f8ed104a5ff06278b050970eef9852758f1fa3f3827b3433ed17b28fb999c40999054fe1ccf49d51b3ba5f49ce36506a59d19b1c1b96bfbda913cd685cad1961ad306a0abd7d98db471542c913fea913c333b356aff9fd712d4d27ec2b651fe8b227c1f520e03c2bcc8a1a5fcfa5589997e1f5153ed297053682e6d01473ceeadb581aef136db1b73ae880e6cc8b816fdac5f1d68fcb22cb02d65ce9c520f07d12b95b85fa28d2c7402a5ebc7cbcca28e86258bf7a8d58051a12dc0a6fcd6b04261ec36530fab0ed2b245cce2c970120aba6bf29d68ba80e50caa5648d7bcccbf3607faa6a4ef7c041d86cb2b6e28ebb3dcbbbd1eff96c99c2b4749a6260698ca90ff0fc9c8241833ba9f8b7a44eb763af872a8ee0c105113f5f093ecb6300f63129bcba8b81c7b58da186928f0408b67a07e545895ea523e8d3f34ad57415525827730fd6cb9c1df2d72964d7225174a7541227973445363bcd758e73191a13988d3945b57243dbb5f8d1ab9c9e410f9f387e1fc13516ffc65dcaa1881e239025fa7a661c0010066e1b68dd44789a6111c8e39c2ba5eb3650e0c9beb962cc42c730c70d744b57fd56eb11152a3184507aebd12a832f04ecbf7d99fbd22a109ac8f04cee24dc4f701267144baa0c3603e83d99f9eb2830994a6ae6855716a6ce985debdb6b2009a119cd1557e94da1e1cf58390c7e381fd456ef08cbf626158b2ad6e24c7b8021f57595c42f39c3cd3d9eb1c4e9a3abc0a6f682d1e34384c737be3e35f9e8a519942d865f18d8bab88968966fc92d7bc13b41a70314f383c65f9d7a9823f108ef2988b20a0c1f86287dc7c4478bc0f30641b6d1549a6303a99e37873bcc5e6e892453f98fb74f3be1b08b89cb5a3e05316bc081f5a6dd789f87d1c69652464a445026557265464979b5c771cbde8ba7bc41c8639a821b6432e9b9b6357099b6563a3c18e68480662a54e94e1dd30ec30f8b69de653f3e21b5d0ad7f30cf49397ed2135f9a3cc78002166fea5d64f82ffeedafe78f52270fb082c093120bfd1f37a38156b0c7e21b13609543e9003bda13b3f4985402c569a2a0e87f97ba4c388f607ed76c72b63042bd75e6232645f891dcc8592e0aa6067d0edaf5f7e6e12a8d5aecaa4828151ac23a826e66c76d1d39cc0c3e42be2e6e9a962853b500b3ff6d0ab57c8301618e34b41b252d15a88922cdb2e5a0efcc3d8bea91b8780f725c4efbcc830ec2b157ca15f066b50745e21b337726a8774a22ade98a9ea268c35ecd13b180ecc9abaf6a39dad0aa7d3d4016a5393d1668017cbd86dbdc47b9c6ce42a17bca41da6873b1f39ceda06cee99eebda76739b447bfcd6a93b20711303d4abf2707da80f2d14e3c36a05651d7dfdcef76754973dfcc1726ab8ac15b476834eda099bcdc4c7c2ea05d14eb29c83e934fbdcf3e71085febf06d0404e6b1b7d5edc6f06323cea9d8d8383ca426ac3c71fb43310f0c375133d8da84dba3af762f5e67586fc095ad8467dc90347382628845dacb7262d0956814b71a075a20e104984ff351f7f32bbc22d05387d7b049e3962e9916e8ad513165449cdc854a0b2784974da7b4191ef03f6478e894d11f4fe289ecc5a11210c5b6067fd2818592c2b8f263a5810e1368196d20d202d2400babae6bbac2ef5327a40ea52028a30c558af25126ab39ec84d25581b142654a0eff7f5d1240b00cd6d8d2818d5dc2544dd399f6a826d23a5c82ec2b0f375578d99b99bfdccb75f2088b54f7a64549df9d5b82fcc970c1872e91e95766d367e0363d6bb959144bc0fdf0a3e51c0caf1b3ccfab10c303482b54351020ac43e7b7a05e2a422f6b3193176362e6d351250a3bacb962aaa11a31ec6c6a85aa85bbbd87ddd87cd459492bfe03536a439670309b0f82ce70fe2d601c1a406dff4af467c437b38dac2679ae565cd803a6cd219c7e088a3bed88ffdd29d71e1a113e8597752c36d4531b28d8e7557b6e49d51c53c9915dbe7c0974a49bff0e46b87026f5fdc81b263245a2045e95611ac2bf21454b5de00435d51553c5f5f723274d9c0fa05ee5933ef6d6a7ce2ae9fac3a779c5c0e1bc49bfca1ab6c8bf1ee95030139a87b3d71f84ef57be2e6dff4f42f92bda77ebf2ed2f4cf0146a9aeaf0ba28e5436b98fb98fa240a12dfe71cb311a3ca23f4de19d332fc803a1c7de02033a563465854feaaff0f5b738b0045ad32cbb8a7806d29d3d7ac58857bae72fc194293da2de039735d9823fe9a5af59ae5826ac011f426eadc275634c3847c12cca61f8b4260f5001a5ab488b8e2ef9c12498ab4f5c3039b71129aa07036334cc03b4aefd8662a9f51cd9adc560748da6d1a0d11d42eec0d28f22684f8eb31980669bdeb2af48a7f34db81415b65953d4d68503340097bef9dbb85a9eb4975a820dd7f651a1ec038ea897347a935412c2427345e42f007b93523ff699abb94a53f722f069cbf6da15c2d27531d7282972959a276e756288048455cd98713ca611af10a49dd97c1623511acecf586abcb08ec29610f4b62b72238a287bb57790aaf68cbbbb41f8b79f634c95c952140714e2e1db1c05dc4f56597f641422e1a352c8f05b0ffb3b9f02bf2a1b6194ac203d07a39dd7b5c8ea3a7f18c7747d5af5377de883fa243a0714db0573f6ab5451c4e0fa063541f4838802f8ab24cb3f5bcc34f8a32106934fed5bab1f393017f306313cbfb1fdcf33967b4af00aca4027f64003101d92545b0a43901b638b086c421fa5362e35182a01121fa37651afe2c1ec1d2e17721cac4ab6c7456628e5c58a0b123294539fec5ce46b67c5e6893768c8d386d954674f7237f496540f73743ee515da3e44050a0a675d2ed99797062fc756a26bf874421c9d8d0140c7fb23a907d5f894241a78313a5b3984b6807a95d4bb47753ce59c75bf576801acc63cc829eef7674b9002094f0067e519915b25f48e1e265299b2fd69d543c3c328368a6b9de0d4cb6c1a87d99bbbc88e4a8dad4bc0fd92ece7c1813f8fd304561e13a1866990ff30960e5112679c556e43de26caf8f3ca5dc40de4fabfba5b713d696bc1df9082e662c7e80aa1d6be64f4acdecd4ca8ea7ffe84a1e8e65d4f735ee687e395b208772fbf4b267c9f4a1a0393873be077d6b0fa276e13b4fb924b85b4764b8c9e5ee8d431adf99691fe6cf8ef10eb840bbea7cae998d9fe614baa221d11e7cffbbc1ecab36ee6d8b0083962a5178817a3d11481809bec7b6352e22b38c62def735b2c57f73b53c15c5a4f718032589e0c3dcfa23f7ae1921ae238c1b4c45f5aa8147bb905d623636e4d94fabd4643cc1b158325c9b1b908c07cf8a476c622bb69f910bd996bd85694bc80092a7cedb0e8fc7952c9fd0f74684ed57daeec639957365a10c78485cd445c76f5689094da645dc7dce22a8158d19a2e9bcaf8cb0ff44987291c1676d9c943fd1cd7c8a3e2a900be31dc96d967e93ae8b2248311ca3f554b4b95ba545825160c72e86caf36f3b7b5a8d0277342a7bd016bb40d4d8c2d4bd3047c8ff233e0d794b5d501ca2a97b71a3cb752a4dc13315c5c6ea45c4a7f1d88e3074eb2961bb349f139ac63d4bd0302b8b3c3473bb8afd8c14428ff9ba3bd9c78b960f0321fefe10043ea6ff5035130da645e2ad87531f6ea2e7f19bd774437e8129151f722c9e5e87b7643ccdc511bcc8c4a95474b7f59c94cb974ef363cd82ad174d308e2d94f7cdee5cf7cb05c57562df2fd69613d1c8b4e1d5c670d3963ec0561ab016d8cc946fe2164cea6d3e823ca2c78766245e13e77b5449f9194a2dd10f0ed21723ecdd03721e5ef7814ada1b6fb3f380c95462fa8905f8c5376c8a9d8a1424f209e40a3a56fd9229d8203fcb7446b9fdfb3c14226b5a14c31085d15714ed21ad9f00f64824083e5cc0bad0a847a7c9bc3c506b792cf6664eb5073bf5e49d55ba187bff4ea52d8d654b64dc95d765b30ad94c4eb2f2244ac9e8eb9267f326da9ca5cdeaf783e41382503f7ac5769e9d94b36a8483b7ed9f7d78ff7276d58680</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <summary type="html">Here&#39;s something encrypted, password is required to continue reading.</summary>
    
    
    
    <category term="计算机专业" scheme="http://blog.zhuangzhihao.top/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%93%E4%B8%9A/"/>
    
    
    <category term="Operating System" scheme="http://blog.zhuangzhihao.top/tags/Operating-System/"/>
    
    <category term="极客时间" scheme="http://blog.zhuangzhihao.top/tags/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/"/>
    
  </entry>
  
  <entry>
    <title>机器学习（上）</title>
    <link href="http://blog.zhuangzhihao.top/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E4%B8%8A/"/>
    <id>http://blog.zhuangzhihao.top/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E4%B8%8A/</id>
    <published>2021-09-22T16:00:00.000Z</published>
    <updated>2021-09-24T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>机器学习是人工智能的重要技术基础，涉及的内容十分广泛，涵盖概率论知识，统计学知识，近似理论知识和复杂算法知识，使用计算机作为工具并致力于真实实时的模拟人类学习方式。我选择的课程是台湾大学电机工程系助理教授李宏毅的 <a href="https://speech.ee.ntu.edu.tw/~hylee/ml/2021-spring.html">ML 2021 Spring</a>，这门课程从最基本的观念讲到最前瞻的技术，重点讲解深度学习，同时新增了 Transformer、流模型 Glow 和对抗攻击等最新技术内容。以下为所记课堂笔记第一部分，包含机器学习基本概念理论、深度学习和自注意力机制，可供参考。其他部分笔记详见<a href="/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E4%B8%AD">机器学习（中）</a>和<a href="/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E4%B8%8B">机器学习（下）</a></p></blockquote><a id="more"></a><div class="img-wrap"><div class="img-bg"><img class="img" src="https://cdn.jsdelivr.net/gh/Bezhuang/Imgbed/blogimg/李宏毅机器学习01.jpg" style="width:500px;"></div></div><h3 id="机器学习介绍"><a href="#机器学习介绍" class="headerlink" title="机器学习介绍"></a>机器学习介绍</h3><h4 id="机器学习基本概念"><a href="#机器学习基本概念" class="headerlink" title="机器学习基本概念"></a>机器学习基本概念</h4><ul><li><p>Machine Learning ≈ Looking for Function（寻找复杂函数的过程）</p></li><li><p>机器学习的分类</p><ul><li>Regression（回归）: The function outputs a scalar</li><li>Classification（分类）: Given options (classes), the function outputs the correct one</li><li>Structured Learning（结构化学习）: create something with structure (image, document)</li></ul></li><li><p>Regression（回归）的 Training 过程</p><ol><li><p>Function with Unknown Parameters, which is based on domain knowledge</p><ul><li>Model: $y=b+w x_1$</li><li>$w$ (weight) and $b$ (bias) are unknown parameters learned from data（模型参数）</li></ul></li><li><p>Define Loss from Training Data</p><ul><li>Loss is a function of parameters: $L(b,w)$</li><li>Loss 用来评估未知参数准确度 (how good a set of values is): $L=\dfrac{1}{N}\sum <em>{n}e</em>{n}$</li><li>MAE（绝对平均误差）: 𝐿 is mean absolute error: $e=\left|y-\widehat{y}\right|$</li><li>MSE（均方误差）: 𝐿 is mean square error: $e=\left( y-\widehat{y}\right)^{2}$</li><li>If $𝑦$ and $\widehat{y}$ are both probability distributions（当预测值和真实值是概率分布时）：选择交叉熵（Cross-entropy）作为 Loss 函数</li></ul></li><li><p>Optimization（优化）: $w^{\ast },b^{\ast }=\arg \min _{w,b}L$</p><ul><li>最常用的方法：梯度下降（Gradient Descent）</li><li>首先随机初始化参数：(Randomly) Pick initial values $w^0,b^0$,</li><li>再计算该点的 Loss 关于参数的微分值：Compute $\dfrac{\partial L}{\partial w}| w=w^{0},b=b^{0}$</li><li>当微分为负数时，Loss 关于 w 递减，增大 w 使 Loss下降。当微分为正数时，Loss 关于 w 递增，减小 w 使 Loss 下降</li><li>随之用微分值去更新参数：Update $𝑤,b$ iteratively </li><li>跨越的大小通过学习率控制，方向通过符号实现：$w_{0}\rightarrow w_{1},b_{0}\rightarrow b_{1}$: $\eta \dfrac{2L}{\partial w}| w=w^{0},b=b^{0}$</li><li>学习率（Learning rate）是一种超参数（hyperparameter），记做：$\eta$</li></ul></li></ol></li><li><p>Linear models are too simple and have severe limitations (model bias), we need more sophisticated and flexible models</p></li></ul><h4 id="深度学习基本概念"><a href="#深度学习基本概念" class="headerlink" title="深度学习基本概念"></a>深度学习基本概念</h4><ul><li><p>足够多的分段线性曲线可以近似于连续曲线（Approximate continuous curve by a piecewise linear curve, to have good approximation, we need sufficient pieces），使模型更有弹性</p><ul><li>分段线性曲线（Piecewise linear curve）：a set of hard sigmoid 函数加上常数组成，分段线性曲线的折线越多，需要的 Hard sigmoid 函数就更多</li><li>Hard sigmoid 不能作为基础函数，因为折线的转角处无法求微分，所以要用一个平滑的曲线做为基础函数，也就是 Sigmoid（S型曲线）</li><li>使用不同的 $w$、$b$、$c$ 参数可以实现各种各样的 Sigmoid 函数，$w$ 控制 slopes ，$b$ 控制左右 shifts，$c$ 控制 height：$y=c\cdot \dfrac{1}{1+e^{-\left( b+wx_{1}\right) }}=c\cdot signoid\left( b+wx_{1}\right)$</li><li>Linear model 由 $y=b+wx_{1}$ 变为更有弹性的：$y=b+\sum <em>{i}c</em>{i}\cdot sigmoid\left( b_{i}+w_{i}x_{1}\right)$</li></ul></li><li><p>当模型有多个 Features（自变量）时：$y=b+\sum <em>{i}c</em>{i}\cdot sigmoid\left( b_{i}+\sum <em>{j}w</em>{ij}x_{j}\right)$</p></li><li></li></ul><h3 id="深度学习"><a href="#深度学习" class="headerlink" title="深度学习"></a>深度学习</h3><h4 id="机器学习任务攻略"><a href="#机器学习任务攻略" class="headerlink" title="机器学习任务攻略"></a>机器学习任务攻略</h4><h4 id="类神经网络训练不起来怎么办（一）？局部最小值与鞍点"><a href="#类神经网络训练不起来怎么办（一）？局部最小值与鞍点" class="headerlink" title="类神经网络训练不起来怎么办（一）？局部最小值与鞍点"></a>类神经网络训练不起来怎么办（一）？局部最小值与鞍点</h4><h4 id="类神经网络训练不起来怎么办（二）？批次与动量"><a href="#类神经网络训练不起来怎么办（二）？批次与动量" class="headerlink" title="类神经网络训练不起来怎么办（二）？批次与动量"></a>类神经网络训练不起来怎么办（二）？批次与动量</h4><h4 id="类神经网络训练不起来怎么办（三）？自动调整学习速率"><a href="#类神经网络训练不起来怎么办（三）？自动调整学习速率" class="headerlink" title="类神经网络训练不起来怎么办（三）？自动调整学习速率"></a>类神经网络训练不起来怎么办（三）？自动调整学习速率</h4><h4 id="类神经网络训练不起来怎么办（四）？损失函数也可能有影响"><a href="#类神经网络训练不起来怎么办（四）？损失函数也可能有影响" class="headerlink" title="类神经网络训练不起来怎么办（四）？损失函数也可能有影响"></a>类神经网络训练不起来怎么办（四）？损失函数也可能有影响</h4><h3 id="自注意力"><a href="#自注意力" class="headerlink" title="自注意力"></a>自注意力</h3><h4 id="卷积神经网络"><a href="#卷积神经网络" class="headerlink" title="卷积神经网络"></a>卷积神经网络</h4><h4 id="自注意力机制（上）"><a href="#自注意力机制（上）" class="headerlink" title="自注意力机制（上）"></a>自注意力机制（上）</h4><h4 id="自注意力机制（下）"><a href="#自注意力机制（下）" class="headerlink" title="自注意力机制（下）"></a>自注意力机制（下）</h4><h3 id="机器学习理论"><a href="#机器学习理论" class="headerlink" title="机器学习理论"></a>机器学习理论</h3><h4 id="Theory-of-ML"><a href="#Theory-of-ML" class="headerlink" title="Theory of ML"></a>Theory of ML</h4>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;机器学习是人工智能的重要技术基础，涉及的内容十分广泛，涵盖概率论知识，统计学知识，近似理论知识和复杂算法知识，使用计算机作为工具并致力于真实实时的模拟人类学习方式。我选择的课程是台湾大学电机工程系助理教授李宏毅的 &lt;a href=&quot;https://speech.ee.ntu.edu.tw/~hylee/ml/2021-spring.html&quot;&gt;ML 2021 Spring&lt;/a&gt;，这门课程从最基本的观念讲到最前瞻的技术，重点讲解深度学习，同时新增了 Transformer、流模型 Glow 和对抗攻击等最新技术内容。以下为所记课堂笔记第一部分，包含机器学习基本概念理论、深度学习和自注意力机制，可供参考。其他部分笔记详见&lt;a href=&quot;/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E4%B8%AD&quot;&gt;机器学习（中）&lt;/a&gt;和&lt;a href=&quot;/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E4%B8%8B&quot;&gt;机器学习（下）&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="计算机专业" scheme="http://blog.zhuangzhihao.top/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%93%E4%B8%9A/"/>
    
    
    <category term="Machine Learning" scheme="http://blog.zhuangzhihao.top/tags/Machine-Learning/"/>
    
  </entry>
  
  <entry>
    <title>操作系统（下）</title>
    <link href="http://blog.zhuangzhihao.top/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E4%B8%8B/"/>
    <id>http://blog.zhuangzhihao.top/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E4%B8%8B/</id>
    <published>2021-09-10T16:00:00.000Z</published>
    <updated>2021-11-30T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p> 操作系统（OS）是管理和控制计算机硬件与软件资源，是计算机上直接运行的最基本的系统软件，任何其他软件都必须在操作系统的支持下才能运行。操作系统是用户和计算机的接口，同时也是计算机硬件和其他软件的接口。操作系统的功能包括管理计算机系统的硬件、软件及数据资源，控制程序运行，提供人机交互界面，为其它应用软件提供支持等。我选择的课程是苏州大学的<a href="https://www.icourse163.org/course/SUDA-1001752241">国家精品课</a>和汤子瀛版教材，以下为所记课堂笔记下半部分，包含内存管理、文件管理和设备管理的知识点，可供参考。上半部分笔记请访问<a href="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E4%B8%8A">操作系统（上）</a></p></blockquote><a id="more"></a><h3 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h3><h3 id="未完待续"><a href="#未完待续" class="headerlink" title="未完待续"></a>未完待续</h3>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt; 操作系统（OS）是管理和控制计算机硬件与软件资源，是计算机上直接运行的最基本的系统软件，任何其他软件都必须在操作系统的支持下才能运行。操作系统是用户和计算机的接口，同时也是计算机硬件和其他软件的接口。操作系统的功能包括管理计算机系统的硬件、软件及数据资源，控制程序运行，提供人机交互界面，为其它应用软件提供支持等。我选择的课程是苏州大学的&lt;a href=&quot;https://www.icourse163.org/course/SUDA-1001752241&quot;&gt;国家精品课&lt;/a&gt;和汤子瀛版教材，以下为所记课堂笔记下半部分，包含内存管理、文件管理和设备管理的知识点，可供参考。上半部分笔记请访问&lt;a href=&quot;/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E4%B8%8A&quot;&gt;操作系统（上）&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="计算机专业" scheme="http://blog.zhuangzhihao.top/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%93%E4%B8%9A/"/>
    
    
    <category term="Operating System" scheme="http://blog.zhuangzhihao.top/tags/Operating-System/"/>
    
  </entry>
  
  <entry>
    <title>数据结构（下）</title>
    <link href="http://blog.zhuangzhihao.top/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%B8%8B/"/>
    <id>http://blog.zhuangzhihao.top/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%B8%8B/</id>
    <published>2021-09-07T16:00:00.000Z</published>
    <updated>2021-09-25T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>数据结构是指数据的存储结构，是带有结构特性的数据元素的集合。精心选择的数据结构可以带来更好的运行或者存储效率。数据结构是计算机科学与技术专业、软件工程专业甚至于其它电气信息类专业的重要专业基础课程，在408计算机学科专业基础综合考试中占有45分。我选择的课程是浙江大学数据结构<a href="https://www.icourse163.org/course/ZJU-93001">国家精品课</a>，以下为所记课堂笔记第三部分，包含排序、查找算法和平衡二叉树的知识总结以及所需记忆的代码，另外我在开源仓库中还保持了浙大慕课版本的<a href="https://github.com/Bezhuang/LearnCS/tree/main/%E5%90%8D%E6%A0%A1%E5%85%AC%E5%BC%80%E8%AF%BE/%E6%B5%99%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84">代码</a>，可供参考。其他部分笔记详见<a href="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%B8%8A">数据结构（上）</a>和<a href="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%B8%AD">数据结构（中）</a></p></blockquote><a id="more"></a><h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><h4 id="排序的基本概念"><a href="#排序的基本概念" class="headerlink" title="排序的基本概念"></a>排序的基本概念</h4><ul><li>排序：将原本无序的序列重新排列成有序序列的过程，这个序列中的每一项可能是单独的数据元素，也可能是一条记录</li><li>记录由多个数据元素组成的，既可以按照记录的主关键字排序（主关键字唯一标识一条记录），也可以按照记录的次关键字排序</li><li>稳定性：当待排序序列中有两个或两个以上相同的关键字时，排序前和排序后这些关键字的相对位置，如果没有发生变化就是稳定的，否则就是不稳定的</li><li>排序算法的分类<ul><li>插入类的排序：直接插入、折半插入、希尔排序</li><li>交换类的排序：冒泡排序、快速排序</li><li>选择类的排序：简单选择、堆选择</li><li>归并类的排序：二路归并</li><li>基数类的排序：多关键字排序</li></ul></li></ul><h4 id="插入类的排序"><a href="#插入类的排序" class="headerlink" title="插入类的排序"></a>插入类的排序</h4><ul><li><p>插入排序</p><pre><code class="cpp">void InsertSort(int* h, size_t len)&#123;    if(h==NULL) return;    if(len&lt;=1) return;    int i,j;    //i是次数，也即排好的个数;j是继续排    for(i=1;i&lt;len;++i)        for(j=i;j&gt;0;--j)            if(h[j]&lt;h[j-1]) Swap(h[j],h[j-1]);            else break;    return;&#125;</code></pre></li><li><p>希尔排序</p><ul><li>缩小增量排序：把记录按下标的一定增量分组，对每组使用直接插入排序算法排序</li><li>随着增量逐渐减少，每组包含的关键词越来越多，当增量减至1时，整个文件恰被分成一组，算法便终止</li></ul><pre><code class="cpp">void ShellSort(int* h, size_t len)&#123;    if(h==NULL) return;    if(len&lt;=1) return;    for(int div=len/2;div&gt;=1;div/=2)        for(int k=0;k&lt;div;++k)            for(int i=div+k;i&lt;len;i+=div)                for(int j=i;j&gt;k;j-=div)                    if(h[j]&lt;h[j-div]) Swap(h[j],h[j-div]);                    else break;    return;&#125;</code></pre></li></ul><h4 id="交换类的排序"><a href="#交换类的排序" class="headerlink" title="交换类的排序"></a>交换类的排序</h4><ul><li><p>快速排序</p><pre><code class="cpp">void QuickSort(SeqList R，int low，int high) &#123; //对 R[low..high]快速排序     int pivotpos； //划分后的基准记录的位置         if (low &lt; high) &#123; //仅当区间长度大于 1 时才须排序             pivotpos = Partition(R，low，high)； //对 R[low..high]做划分                 QuickSort(R，low，pivo t   pos-1)； //对左区间递归排序                 QuickSort(R，pivotp o s+1，high)； //对右区间递归排序         &#125;&#125; //QuickSort</code></pre></li><li><p>冒泡排序</p><ul><li>通过依次交换相邻两个顺序不合法的元素位置，从而将当前最小（大）元素放到合适的位置</li></ul><pre><code class="cpp">void BubbleSort(int* h, size_t len)&#123;    if(h==NULL) return;    if(len&lt;=1) return;    //i是次数，j是具体下标    for(int i=0;i&lt;len-1;++i)        for(int j=0;j&lt;len-1-i;++j)            if(h[j]&gt;h[j+1])                Swap(h[j],h[j+1]);    return;&#125;</code></pre></li></ul><h4 id="选择类的排序"><a href="#选择类的排序" class="headerlink" title="选择类的排序"></a>选择类的排序</h4><ul><li><p>选择排序</p><ul><li>初始时在序列中找到最小（大）元素，放到序列的起始位置作为已排序序列，然后，再从剩余未排序元素中继续寻找最小（大）元素，放到已排序序列的末尾。以此类推，直到所有元素均排序完毕</li><li>每遍历一次都记住了当前最小（大）元素的位置，最后仅需一次交换操作即可将其放到合适的位置</li></ul><pre><code class="cpp">void SelectionSort(int* h, size_t len)&#123;    if(h==NULL) return;    if(len&lt;=1) return;    int minindex,i,j;    //i是次数，也即排好的个数;j是继续排    for(i=0;i&lt;len-1;++i)    &#123;        minindex=i;        for(j=i+1;j&lt;len;++j)        &#123;            if(h[j]&lt;h[minindex]) minindex=j;        &#125;        Swap(h[i],h[minindex]);    &#125;    return;&#125;</code></pre></li><li><p>堆排序</p><ul><li>堆实际上是一棵完全二叉树，堆的每一个父节点都大于（或小于）其子节点，堆的每个左子树和右子树也是一个堆</li><li>最大堆（大顶堆）：堆的每个父节点都大于其孩子节点；最小堆（小顶堆）：堆的每个父节点都小于其孩子节点</li><li>堆的第一个元素要么是最大值（大顶堆），要么是最小值（小顶堆），这样在排序的时候（假设共 n 个节点），直接将第一个元素和最后一个元素进行交换，然后从第一个元素开始进行向下调整至第 n-1 个元素。所以，如果需要升序，就建一个大堆，需要降序，就建一个小堆</li></ul><pre><code class="cpp">void HeapSort(SeqIAst R)&#123; //对 R[1..n]进行堆排序，不妨用 R[0]做暂存单元     int i；        BuildHeap(R)； //将 R[1-n]建成初始堆         for (i = n;i &gt; 1；  i  -)        &#123; //对当前无序区 R[1..i]进行堆排序，共做 n-1 趟            R[0] = R[1];            R[1] = R[i];            R[i] = R[0];//将堆顶和堆中最后一个记录交换             Heapify(R，1 ，i-1); //将 R[1..i-1]重新调整为堆，仅有 R[1]可能违反堆性质         &#125; //endfor &#125; //HeapSort</code></pre></li></ul><h4 id="二路归并排序"><a href="#二路归并排序" class="headerlink" title="二路归并排序"></a>二路归并排序</h4><ul><li><p>MERGE-SORT：利用归并的思想实现的排序方法，采用经典的分治（divide-and-conquer）策略</p></li><li><p>递归拆分子序列，将两个已经有序的子序列合并成一个有序序列</p><pre><code class="cpp">void MergeSortDC(SeqList R，int low，int high) &#123;//用分治法对 R[low..high]进行二路归并排序  int mid；  if(low&lt;high)&#123; //区间长度大于 1  mid=(low+high)/2； //分解  MergeSortDC(R，low，mid); //递归地对 R[low..mid]排序  MergeSortDC(R，mid+1，high)； //递归地对 R[mid+1..high]排序  Merge(R，low，mid，high)； //组合，将两个有序区归并为一个有序区  &#125; &#125;//MergeSortDC </code></pre></li></ul><h4 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h4><ul><li><p>不需要比较关键字的大小，根据关键字中各位的值，通过对排序的N个元素进行若干趟分配与收集来实现排序的</p></li><li><p>时间复杂度为 $O\left( d\left( n+r_{d}\right) \right)$</p><pre><code class="cpp">int GetMaxDight(int* h, int len)&#123;    if(h==NULL) return 0;    if(len&lt;1) return 0;    int max=h[0];    for(int i=1;i&lt;len;++i)    &#123;        if(h[i]&gt;max) max=h[i];    &#125;    int digit=1;    while(max/10!=0)    &#123;        max/=10;        ++digit;    &#125;    return digit;&#125;int GetReminder(int value,int digit)&#123;    int div=1;    for(int i=1;i&lt;digit;++i)        div*=10;    return value/div%10;&#125;void RadixSort_LSD(int* h, int len)&#123;    if(h==NULL) return;    if(len&lt;=1) return;    int digit=GetMaxDight(h,len);    //printf(&quot;MaxDigit:%d\n&quot;, digit);    int count[10]=&#123;0&#125;;    int *tmp=(int*)calloc(len,sizeof(int));    for(int d=1;d&lt;=digit;++d)    &#123;        memset(count,0,sizeof(count));        for(int i=0;i&lt;len;++i)        &#123;            count[GetReminder(h[i],d)]++;        &#125;        //求右边界        for(int i=1;i&lt;10;++i)        &#123;            count[i]+=count[i-1];        &#125;        for(int i=len-1;i&gt;=0;--i)        &#123;            int r=GetReminder(h[i],d);            int index=count[r];            tmp[index-1]=h[i];            count[r]--;        &#125;        memcpy(h,tmp,len*sizeof(int));    &#125;    free(tmp);&#125;void RadixSort_LSD_Reverse(int* h, int len)&#123;    if(h==NULL) return;    if(len&lt;=1) return;    int digit=GetMaxDight(h,len);    //printf(&quot;MaxDigit:%d\n&quot;, digit);    int count[10]=&#123;0&#125;;    int *tmp=(int*)calloc(len,sizeof(int));    for(int d=1;d&lt;=digit;++d)    &#123;        memset(count,0,sizeof(count));        for(int i=0;i&lt;len;++i)        &#123;            count[GetReminder(h[i],d)]++;        &#125;        //printf(&quot;haha\n&quot;);        //求右边界        for(int i=8;i&gt;=0;--i)        &#123;            count[i]+=count[i+1];        &#125;        for(int i=len-1;i&gt;=0;--i)        &#123;            int r=GetReminder(h[i],d);            int index=count[r];            tmp[index-1]=h[i];            count[r]--;        &#125;        memcpy(h,tmp,len*sizeof(int));    &#125;    free(tmp);&#125;</code></pre></li></ul><h4 id="排序知识点总结"><a href="#排序知识点总结" class="headerlink" title="排序知识点总结"></a>排序知识点总结</h4><ul><li>快速排序、希尔排序、归并排序、堆排序的平均时间复杂度都是 $O\left( n\log _{2}n\right)$，其他都是 $O(n^2)$</li><li>快速排序的空间复杂度为 $O\left( \log <em>{2}n\right)$，归并排序的空间复杂度为 $O\left( n\right)$，基数排序的空间复杂度为 $O\left( r</em>{d}\right)$，其他都是 $O(1)$</li><li>快速排序、希尔排序、简单选择排序、堆排序是不稳定的，其他都是稳定的</li><li>交换类和选择类的排序，经过一趟排序能够保证一个关键字到达最终位置</li><li>简单选择排序和折半插入排序的关键字比较次数和原始序列无关</li><li>交换类的排序趟数和原始序列有关</li><li>直接插入按顺序查找的方式，而折半插入按折半查找的方式排序</li><li>借助于比较进行排序的算法在最坏情况下的时间复杂度至少为 $O\left( n\log _{2}n\right)$</li></ul><h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3><h4 id="查找的基本概念"><a href="#查找的基本概念" class="headerlink" title="查找的基本概念"></a>查找的基本概念</h4><ul><li><p>给定一个值 K，在含有 n 个记录的表中找出关键字等于 K 的记录叫查找，记录即为关键字</p></li><li><p>通常把查找过程中对关键字的平均比较次数（也称平均查找长度）作为衡量一个查找算法优劣的标准</p></li><li><p>平均查找长度 $ASL=\sum ^{n}<em>{i=1}p</em>{i}\times c_{i}$</p><ul><li>$p_{i}$ 为查找第 i 个记录的概率，$c_{i}$ 为找到第 i 个记录所需要进行比较的次数（查找长度）</li></ul></li><li><p>顺序查找</p><ul><li>用待查找的关键字和给定序列中的各元素的关键字从左到右（或从右到左）依次进行比较，直到成功或失败</li><li>存储结构通常是顺序结构，也可是链式结构</li></ul><pre><code class="cpp">//顺序表的查找（不带监视哨）int SeqSearch(SSTable S, DataType x)&#123;    int i = 0;    while (i &gt; s.length &amp; S.list[i].key != x.key)        i++;    if (s.list[i].key == x.key)        return i + 1;    return 0;&#125;//顺序表的查找（带监视哨）int SeqSearch2(SSTable S, DataType x)&#123;    int i = S.length;    //将关键字存放在0位置处,防止越界    /*哨兵的主要作用就是在查找循环中监视下标i是否越界      一旦越界(i=0),因为可以和自己进行比较,循环判定条件      不成立就使得查找循环结束,就可以达到忽略判定边界条件的目的*/    s.list[o].key = x.key;    while (s.list[i].key != x.key)        i--;    return i;    // 实际上,一切为简化边界条件而引入的附加结点(元素)均可称为哨兵&#125;//顺序表的查找（链表实现）Node* Search(Lnode* head, int key)&#123;    LNode* p = head-&gt;next;    while (p != NUll)    &#123;        if (P-&gt;data == key)            return p;        p = p-&gt;next;    &#125;    return NULL;&#125;</code></pre></li><li><p>二分查找</p><ul><li>要求线性表是有序的</li><li>在给定序列是有序表的前提下，将表中间位置处的关键字和查找关键字比较，相 等则查找成功</li><li>否则从中间位置将表分成前后两个子表，如果中间位置处的关键字大于 查找关键字，则进一步查找前子表，否则查找后子表</li><li>重复以上过程，直到找到满足条件的记录，此时查找成功，或直到子表不存在为止，表示查找失败</li></ul><pre><code class="cpp">int BSearch(int arr[], int low, int high, int key) &#123;    while (low &lt;= high) &#123;        int mid = (low + high) / 2;        if (arr[mid == key])            return mid;        else if (arr[mid] &gt; key)            high = mid - 1;        else            low = mid + 1;    &#125;    return -1;&#125;</code></pre></li></ul><h4 id="二叉排序树（BST）"><a href="#二叉排序树（BST）" class="headerlink" title="二叉排序树（BST）"></a>二叉排序树（BST）</h4><ul><li><p>二叉排序树要么是空树,要么是满足下列要求的树</p><ul><li>若它的左子树不空，则左子树上所有的关键字的值均小于根节点关键字值</li><li>若它的右子树不空，则右子树上所有的关键字的值均大于根节点关键字值</li><li>左右子树又各是一棵二叉排序树</li></ul></li><li><p>Binary Search Tree 又被叫做二叉搜索树 or 二叉查找树</p></li><li><p>在对某个关键字进行查找的时候，首先和二叉排序树的根节点进行比较，若相等则査找成功</p></li><li><p>由于二叉排序树本身的性质，若该关键字小于根节点值，则再与其左子树进行比较,否则和其右子树进行比较，直到找到与之相等的节点，则查找成功</p></li><li><p>若待比较的位置来到空指针处，则表示査找失败，返回失败的标记</p><pre><code class="cpp">//非递归算法BTNode* BSTSearch(BTNode* p, int key) &#123;    while (p != NULL) &#123;        if (key == p-&gt;key)            return p;        else if (key &lt; p-&gt;key)            p = p-&gt;lChild;        else            p = p-&gt;rChild;    &#125;    return NULL;&#125;//递归算法BTNode* BSTSearch2(BTNode* p, int key) &#123;    if (p == NULL)        return NULL;    else&#123;        if (key == p-&gt;key)            return p;        else if (key &lt; p-&gt;key)            return BSTSearch2(p-&gt;lChild, key);        else            return BSTSearch2(p-&gt;rChild, key);    &#125;&#125;</code></pre></li></ul><h4 id="平衡二叉树（AVL-树）"><a href="#平衡二叉树（AVL-树）" class="headerlink" title="平衡二叉树（AVL 树）"></a>平衡二叉树（AVL 树）</h4><ul><li>平衡二叉树是一种特殊的二叉排序树，其左右子树都是平衡二叉树且左右子树高度之差的绝对值不超过1</li><li>一个节点的平衡因子为其左子树的高度减去右子树的高度，对于平衡二叉树，树中所有结点的平衡因子取值只可能是-1、0、1</li><li>若向平衡二叉树中插入一个新结点后破坏了平衡二叉树的平衡性，则首先要找出插入新节点后失去平衡的最小子树，然后再调整这颗子树使之成为平衡子树</li><li>当失去平衡的最小子树被调整为平衡子树后，无需调整原有其他所有的不平衡子树</li><li>最小不平衡子树：是以距离插入结点最近且以平衡因子绝对值大于1的结点作为跟的子树，又称为失去平衡的最小子树</li></ul><h4 id="散列表"><a href="#散列表" class="headerlink" title="散列表"></a>散列表</h4><ul><li><p>Hash：根据给定的关键字来计算出关键字在表中的地址</p></li><li><p>Hash table（哈希表）：是根据关键码值（Key value）而直接进行访问的数据结构，=通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度，这个映射函数叫做散列函数，存放记录的数组叫做散列表</p></li><li><p>给定表 M，存在函数 f(key)，对任意给定的关键字值 key，代入函数后若能得到包含该关键字的记录在表中的地址，则称表 M 为哈希表，函数 f(key) 为哈希函数</p></li><li><p>键（key）：又称为关键字。唯一的标示要存储的数据，可以是数据本身或者数据的一部分</p></li><li><p>槽（slot/bucket）：哈希表中用于保存数据的一个单元，也就是数据真正存放的容器</p></li><li><p>哈希函数（hash function）：将 key 映射 map 到数据应该存放的槽 slot 所在位置的函数</p></li><li><p>哈希冲突（hash collision）：哈希函数将两个不同的键映射到同一个索引的情况</p><pre><code class="cpp">int h1(int x)&#123;  return (x%5);&#125;int h2(char* x)&#123;  int i,sum;  for(sum=0, i=0; x[i] != &#39;\0&#39;; i++)    sum += (int)x[i];  return (sum%5);&#125;int ELFhash(char*key)&#123;    unsigned long h=0;    while(*key)    &#123;        h = (h &lt;&lt; 4) + *key++;        unsigned long g = h &amp; 0xF0000000L;        if(g)            h ^= g &gt;&gt; 24;        h &amp;= ~g;    &#125;    return h % MOD;&#125;</code></pre></li><li><p>散列表的性能分析（查找成功时的平均查找长度）：找到表中已有表项的平均次数</p></li><li><p>装填因子是关键字个数和表长度的比值</p></li></ul><h3 id="常用算法补充"><a href="#常用算法补充" class="headerlink" title="常用算法补充"></a>常用算法补充</h3><ul><li><p>动态规划算法</p><ul><li>处理多阶段决策问题，一般由初始状态开始，通过对中间阶段决策的选择，达到结束状态</li><li>这些决策形成了一个决策序列，同时确定了完成整个过程的一条活动路线（通常是求最优的活动路线）</li><li>动态规划往往可以用递归程序来实现，不过因为递推可以充分利用前面保存的子问题的解来减少重复计算，所以对于大规模问题来说，有递归不可比拟的优势，这也是动态规划算法的核心之处</li></ul><pre><code class="cpp">for (j = 1; j &lt;= m; j = j + 1) // 第一个阶段    xn[j] = 初始值;for (i = n - 1; i &gt; = 1; i = i - 1)// 其他n-1个阶段    for (j = 1; j &gt;= f(i); j = j + 1)//f(i)与i有关的表达式        xi[j] = j = max&#123; g(xi - 1[j1:j2]), ...... ,  g(xi - 1[jk:jk + 1]) &#125;;t = g(x1[j1:j2]); // 由子问题的最优解求解整个问题的最优解的方案print(x1[j1]);for (i = 2; i &lt;= n - 1; i = i + 1)&#123;    t = t - xi - 1[ji];    for (j = 1; j &gt;= f(i); j = j + 1)        if (t = xi[ji])            break;&#125;</code></pre></li><li><p>贪心算法</p><ul><li>在对问题求解时，总是做出在当前看来是最好的选择，局部最优解</li><li>整个问题的最优解一定由在贪心策略中存在的子问题的最优解得来的</li><li>贪心算法建立哈夫曼树</li></ul><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;using namespace std;typedef struct BTreeNode&#123;    int  data;    struct BTreeNode* left;    struct BTreeNode* right;&#125;btreenode;//建立哈夫曼树btreenode *CreateHuffman(int a[],int n)&#123;    int i;    btreenode *s[n+1], *ss;    for(int i = 0;i&lt;n;i++)&#123;        s[i] = new btreenode;  //初始化s指针数组，使每个指针元素指向a数组中对应的元素结点        s[i]-&gt;data = a[i];   //将树拆成森林，每棵树都只有一个根节点        s[i]-&gt;left = s[i]-&gt;right = NULL;    &#125;    for(int i  = 1;i&lt;n;i++)&#123;        //进行 n-1次循环建立哈夫曼树           int k = -1,t;           //k表示森林中具有最小权值的树根结点的下标，t为次最小的下标        for(int j = 0;j&lt;n;j++)&#123;   //k初始指向森林中第一棵树，t指向第二棵                if(s[j]&amp;&amp;k==-1)&#123;                   k = j;                   continue;                &#125;                if(s[j])&#123;                    t =  j;                    break;                &#125;        &#125;        for(int i = t;i&lt;n;i++)&#123;   //从当前森林中求出最小权值树和次最小 ；            if(s[i])&#123;                if(s[i]-&gt;data&lt;s[k]-&gt;data)&#123;        //比最小树小                    t = k;                    k = i;                &#125;                else if(s[i]-&gt;data&lt;s[t]-&gt;data)&#123;  //比次小树小                    t = i;                &#125;                else&#123;                    ;                &#125;            &#125;        &#125;           //由最小权值树和次最小权值树建立一棵新树，ss指向树根结点(以后依次建立)           ss  = new btreenode;     //ss = (btreenode *)malloc(sizeof(btreenode))           ss-&gt;data =   s[k]-&gt;data+s[t]-&gt;data;           ss-&gt;left =   s[k];           ss-&gt;right =  s[t];           s[k] =  ss;  //关键点:将ss赋给s[k](k为上述找到的最小树下标,但这是s[k]代表的值已改变，同时把s[t]失效的置空,                       //在这里起向下一个判断的作用if(s[j])&#123;t = j;break;&#125;           s[t] = NULL;    &#125;        free(s);   //释放分配空间        return ss;&#125;//求哈夫曼树的带权路径长度int WeightPathLength(btreenode* FBT, int len)&#123;          //参数len为树的层数    if(!FBT)&#123;        return 0;    &#125;    else&#123;        if(FBT-&gt;left ==NULL&amp;&amp;FBT-&gt;right ==NULL)//访问到叶子结点            return FBT-&gt;data*len;        else&#123;               //访问到非叶子结点，进行递归调用，返回左右子树的带权路径长度之和，len递增            return  WeightPathLength(FBT-&gt;left,len+1)+WeightPathLength(FBT-&gt;right,len+1);//一定要记得加1        &#125;    &#125;&#125;//哈夫曼编码void HuffManCoding(btreenode* FBT, int len)&#123;   //参数len为树的层数    static int a[20];                        //定义静态数组a，保存每个叶子的编码，数组长度至少是树深度减1    if(FBT)&#123;                                 //访问到叶子结点时输出其保存在数组a中的0和1序列编码        if(FBT-&gt;left == NULL&amp;&amp;FBT-&gt;right == NULL)&#123;             printf(&quot;结点权值为%d的编码:&quot;,FBT-&gt;data);             for(int i = 0;i&lt;len;i++)&#123;                 printf(&quot;%d&quot;,a[i]);            &#125;                printf(&quot;\n&quot;) ;        &#125;        else&#123;    //访问到非叶子结点时分别向左右子树递归调用，并把分支上的0、1编码保存到数组                //a的对应元素中，向下深入一层时len值增1               a[len] = 0;               HuffManCoding(FBT-&gt;left,len+1);               a[len] = 1;               HuffManCoding(FBT-&gt;right,len+1);            &#125;    &#125;&#125;int main()&#123;    btreenode *s;    int n;    printf(&quot;从键盘输入待构造的哈夫曼树中带权叶子结点数n：&quot;);    while(true)&#123;        scanf(&quot;%d&quot;,&amp;n);        if(n&gt;0)&#123;            break;        &#125;        else&#123;            printf(&quot;-------输入不合法,请重新输入!!\n&quot;);        &#125;    &#125;    int *a = (int *)malloc(n *sizeof(int));    printf(&quot;从键盘输入%d个整数作为权值:&quot;,n);    for (int i = 0; i &lt; n; i++)        scanf(&quot;%d&quot;, &amp;a[i]);    s = CreateHuffman(a,n);    printf(&quot;哈夫曼树的带权路径长度：&quot;);    printf(&quot;%d\n&quot;, WeightPathLength(s, 0));    printf(&quot;树中每个叶子结点的哈夫曼编码：\n&quot;);    HuffManCoding(s,0);    return 0;&#125;</code></pre></li></ul>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;数据结构是指数据的存储结构，是带有结构特性的数据元素的集合。精心选择的数据结构可以带来更好的运行或者存储效率。数据结构是计算机科学与技术专业、软件工程专业甚至于其它电气信息类专业的重要专业基础课程，在408计算机学科专业基础综合考试中占有45分。我选择的课程是浙江大学数据结构&lt;a href=&quot;https://www.icourse163.org/course/ZJU-93001&quot;&gt;国家精品课&lt;/a&gt;，以下为所记课堂笔记第三部分，包含排序、查找算法和平衡二叉树的知识总结以及所需记忆的代码，另外我在开源仓库中还保持了浙大慕课版本的&lt;a href=&quot;https://github.com/Bezhuang/LearnCS/tree/main/%E5%90%8D%E6%A0%A1%E5%85%AC%E5%BC%80%E8%AF%BE/%E6%B5%99%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84&quot;&gt;代码&lt;/a&gt;，可供参考。其他部分笔记详见&lt;a href=&quot;/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%B8%8A&quot;&gt;数据结构（上）&lt;/a&gt;和&lt;a href=&quot;/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%B8%AD&quot;&gt;数据结构（中）&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="计算机专业" scheme="http://blog.zhuangzhihao.top/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%93%E4%B8%9A/"/>
    
    
    <category term="Data Structure" scheme="http://blog.zhuangzhihao.top/tags/Data-Structure/"/>
    
  </entry>
  
  <entry>
    <title>基于Python和OpenCV实现人脸识别</title>
    <link href="http://blog.zhuangzhihao.top/Python-OpenCV%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%AB/"/>
    <id>http://blog.zhuangzhihao.top/Python-OpenCV%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%AB/</id>
    <published>2021-09-02T16:00:00.000Z</published>
    <updated>2021-09-14T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Open Source Computer Vision Library（OpenCV）是一个跨平台的计算机视觉库，可用于开发实时的图像处理、计算机视觉以及模式识别程序。OpenCV 用 C++ 语言编写，但本次实战项目使用的是 <code>python-opencv</code> 库实现的，主要是为了初步了解人脸识别的步骤和算法后面的原理。以下为项目笔记，源代码保存在 <a href="https://github.com/Bezhuang/PracticeMakesPerfect/tree/main/Python-OpenCV">Github 仓库</a>中，可供参考。</p></blockquote><a id="more"></a><h3 id="项目背景"><a href="#项目背景" class="headerlink" title="项目背景"></a>项目背景</h3><h4 id="人脸识别介绍"><a href="#人脸识别介绍" class="headerlink" title="人脸识别介绍"></a>人脸识别介绍</h4><ul><li>对人类来说，人脸识别很容易：我们的大脑有专门的神经细胞针对不同的场景或运动特征作出反应，视觉皮层再以某种方式把不同的信息来源转化成可用的模型</li><li>自动人脸识别就是研究如何从一幅图像中提取有意义的特征，形成可用的模型，然后对他们进行一些分类，因此基于几何特征的人脸的人脸识别可能是最直观的识别人脸的方法</li><li>但即使是使用最先进的算法，标记点的确定也是很复杂的，单靠几何特征不能提供足够的信息用于人脸识别</li><li>特征脸方法：把面部图像看作是一个点，从高维图像空间找到它在低维空间的表示，使用主元分析（Principal Component Analysis，PCA）可以找拥有最大方差的轴，但轴的最大方差不一定包含任何有鉴别性的信息</li><li>使用线性鉴别（Linear Discriminant Analysis，LDA）的特定类投影方法：使类内方差最小的同时，使类外方差最大</li><li>仅仅使用的局部特征描述图像的方法避免输入的图像的高维数据：提取的特征对于局部遮挡、光照变化、小样本等情况更强健<ul><li>盖伯小波：Gabor Waelets</li><li>离散傅立叶变换：Discrete Cosinus Transform（DCT）</li><li>局部二值模式：Local Binary Patterns（LBP）</li></ul></li></ul><h4 id="OpenCV-介绍"><a href="#OpenCV-介绍" class="headerlink" title="OpenCV 介绍"></a>OpenCV 介绍</h4><ul><li>从 OpenCV 2.4 开始，加入了新的类 FaceRecognizer，可以使用它便捷地进行人脸识别实验</li><li>FaceRecognizer 类目前包含三种人脸识别方法<ul><li>基于 PCA 变换的人脸识别：EigenFaceRecognizer</li><li>基于 Fisher 变换的人脸识别：FisherFaceRecognizer</li><li>基于局部二值模式的人脸识别：LBPHFaceRecognizer</li></ul></li><li>特征脸（Eigenfaces）：图像表示的问题是他的高维问题，如果数据有任何差异，可以通过寻找主元来知道主要信息，把一些可能相关的变量转换成一个更小的不相关的子集<ul><li>一个高维数据集经常被相关变量表示，因此只有一些的维上数据才是有意义的（包含最多的信息）</li><li>PCA 方法寻找数据中拥有最大方差的方向（主成分）</li><li>计算特征值和对应的特征向量，对特征值进行递减排序，特征向量和它顺序一致</li><li>k 个主成分也就是 k 个最大的特征值对应的特征向量</li><li>把所有的训练数据投影到 PCA 子空间 -&gt; 把待识别图像投影到 PCA 子空间 -&gt; 找到训练数据投影后的向量和待识别图像投影后的向量最近的那个</li></ul></li><li>FisherFaces：基于线性判别分析（Linear Discriminant Analysis，LDA）理论，在降维的同时考虑类别信息，基于特征脸的方法，找到使数据中最大方差的特征线性组合<ul><li>在低维表示下，相同的类应该紧紧的聚在一起，而不同的类别尽量距离越远</li></ul></li><li>局部二值模式直方图（Local Binary Patterns Histograms）：不把整个图像看成一个高维向量，仅用局部特征来描述一个物体，通过这种方式提取特征，获得一个低维隐式<ul><li>对图像的像素和它局部周围像素进行对比后的结果进行求和，把这个像素作为中心，对相邻像素进行阈值比较</li><li>如果中心像素的亮度大于等于他的相邻像素，标记为 1，否则标记为 0（用二进制数字来表示每个像素）</li></ul></li></ul><h3 id="OpenCV-的基本使用"><a href="#OpenCV-的基本使用" class="headerlink" title="OpenCV 的基本使用"></a>OpenCV 的基本使用</h3><h4 id="读取图片"><a href="#读取图片" class="headerlink" title="读取图片"></a>读取图片</h4><pre><code class="python">#导入模块import cv2 as cv#读取图片img=cv.imread(&#39;lena.jpg&#39;)    #加载图片路径中不能有中文#显示图片cv.imshow(&#39;read_img&#39;,img)#等待键盘输入 单位毫秒  传入0 则就是无限等待cv.waitKey(3000)#释放内存  由于OpenCV底层是C++编写的cv.destroyAllWindows()</code></pre><h4 id="图片灰度转换"><a href="#图片灰度转换" class="headerlink" title="图片灰度转换"></a>图片灰度转换</h4><pre><code class="python">import cv2 as cvimg=cv.imread(&#39;lena.jpg&#39;)cv.imshow(&#39;BGR_img&#39;,img)#将图片灰度转换gray_img=cv.cvtColor(img,cv.COLOR_BGR2GRAY)cv.imshow(&#39;gray_img&#39;,gray_img)#保存图片cv.imwrite(&#39;gray_lena.jpg&#39;,gray_img)cv.waitKey(0)cv.destroyAllWindows()</code></pre><h4 id="修改图片尺寸"><a href="#修改图片尺寸" class="headerlink" title="修改图片尺寸"></a>修改图片尺寸</h4><pre><code class="python">import cv2 as cvimg=cv.imread(&#39;lena.jpg&#39;)cv.imshow(&#39;img&#39;,img)print(&#39;原来图片的形状&#39;,img.shape)# 修改图片尺寸resize_img=cv.resize(img,dsize=(600,560))print(&#39;修改后图片的形状：&#39;,resize_img.shape)cv.imshow(&#39;resize_img&#39;,resize_img) #输入q时退出while True:    if ord(&#39;q&#39;)==cv.waitKey(0):        breakcv.destroyAllWindows()</code></pre><h4 id="画图"><a href="#画图" class="headerlink" title="画图"></a>画图</h4><pre><code class="python">import cv2 as cvimg=cv.imread(&#39;lena.jpg&#39;)#绘制矩形，左上角坐标(x,y) 矩形的宽度和高度(w,h)x,y,w,h=100,100,100,100cv.rectangle(img,(x,y,x+w,y+h),color=(0,255,255),thickness=3) #BGR#绘制圆形，圆点的坐标center，半径radiusx,y,r=200,200,100cv.circle(img,center=(x,y),radius=r,color=(0,0,255),thickness=2)#显示图片cv.imshow(&#39;rectangle_img&#39;,img)cv.waitKey(0)cv.destroyAllWindows()</code></pre><h3 id="人脸检测"><a href="#人脸检测" class="headerlink" title="人脸检测"></a>人脸检测</h3><h4 id="Haarcascades"><a href="#Haarcascades" class="headerlink" title="Haarcascades"></a>Haarcascades</h4><ul><li>提取出图像的细节对产生稳定分类结果和跟踪结果很有用，这些提取的结果被称为特征</li><li>虽然任意像素都可以能影响多个特征，但特征应该比像素少得多，两个图像的相似程度可以通过它们对应特征的欧氏距离来度量</li><li>Haar 特征是一种用于实现实时人脸跟踪的特征，每一个 Haar 特征都描述了相邻图像区域的对比模式，如边、顶点和细线都能生成具有判别性的特征</li></ul><h4 id="官方-demo"><a href="#官方-demo" class="headerlink" title="官方 demo"></a>官方 demo</h4><ul><li><p>下载：<a href="https://sourceforge.net/projects/opencvlibrary/files/4.5.3/opencv-4.5.3-vc14_vc15.exe/download">https://sourceforge.net/projects/opencvlibrary/files/4.5.3/opencv-4.5.3-vc14_vc15.exe/download</a></p></li><li><p>build 中是 OpenCV 使用时要用到的一些库文件</p></li><li><p>sources 中是 OpenCV 官方提供的 demo 示例源码</p></li><li><p>sources/data/haarcascades 文件夹包含了所有 OpenCV 的人脸检测的 XML 文件，可用于检测静止图像、视频和摄像头所得到图像中的人脸</p></li></ul><h4 id="静态人脸检测"><a href="#静态人脸检测" class="headerlink" title="静态人脸检测"></a>静态人脸检测</h4><pre><code class="python">import cv2 as cvdef face_detect_demo():    #将图片转换为灰度图片    gray=cv.cvtColor(img,cv.COLOR_BGR2GRAY)    #加载特征数据    face_detector=cv.CascadeClassifier(&#39;opencv/sources/data/haarcascades/haarcascade_frontalface_default.xml&#39;)    faces=face_detector.detectMultiScale(gray)    for x,y,w,h in faces:        cv.rectangle(img,(x,y),(x+w,y+h),color=(0,255,0),thickness=2)    cv.imshow(&#39;result&#39;,img)#加载图片img=cv.imread(&#39;lena.jpg&#39;)face_detect_demo()cv.waitKey(0)cv.destroyAllWindows()</code></pre><h4 id="检测多张人脸"><a href="#检测多张人脸" class="headerlink" title="检测多张人脸"></a>检测多张人脸</h4><pre><code class="python">import cv2 as cvdef face_detect_demo():    #将图片灰度    gray=cv.cvtColor(img,cv.COLOR_BGR2GRAY)    #加载特征数据    face_detector = cv.CascadeClassifier(        &#39;opencv/sources/data/haarcascades/haarcascade_frontalface_default.xml&#39;)    faces = face_detector.detectMultiScale(gray)    for x,y,w,h in faces:        print(x,y,w,h)        cv.rectangle(img,(x,y),(x+w,y+h),color=(0,0,255),thickness=2)        cv.circle(img,center=(x+w//2,y+h//2),radius=w//2,color=(0,255,0),thickness=2)    #显示图片    cv.imshow(&#39;result&#39;,img)#加载图片img=cv.imread(&#39;face3.jpg&#39;)#调用人脸检测方法face_detect_demo()cv.waitKey(0)cv.destroyAllWindows()</code></pre><h4 id="检测视频中的人脸"><a href="#检测视频中的人脸" class="headerlink" title="检测视频中的人脸"></a>检测视频中的人脸</h4><pre><code class="python">import cv2 as cvdef face_detect_demo(img):    #将图片灰度    gray=cv.cvtColor(img,cv.COLOR_BGR2GRAY)    #加载特征数据    face_detector = cv.CascadeClassifier(&#39;opencv/sources/data/haarcascades/haarcascade_frontalface_default.xml&#39;)    faces = face_detector.detectMultiScale(gray)    for x,y,w,h in faces:        cv.rectangle(img,(x,y),(x+w,y+h),color=(0,0,255),thickness=2)        cv.circle(img,center=(x+w//2,y+h//2),radius=(w//2),color=(0,255,0),thickness=2)    cv.imshow(&#39;result&#39;,img)#读取视频cap=cv.VideoCapture(&#39;video.mp4&#39;)while True:    flag,frame=cap.read()    print(&#39;flag:&#39;,flag,&#39;frame.shape:&#39;,frame.shape)    if not flag:        break    face_detect_demo(frame)    if ord(&#39;q&#39;) == cv.waitKey(10):        breakcv.destroyAllWindows()cap.release()</code></pre><h3 id="人脸识别"><a href="#人脸识别" class="headerlink" title="人脸识别"></a>人脸识别</h3><ul><li>用一系列分好类的图像来训练程序，并基于这些图像来进行识别</li><li>每个识别都具有转置信（confidence）评分，因此可在实际应用中通过对其设置阈值来进行筛选</li></ul><h4 id="训练数据"><a href="#训练数据" class="headerlink" title="训练数据"></a>训练数据</h4><ul><li><code>train()</code> 函数中有两个参数：图像数组和标签数组，这些标签表示进行识别时候某人人脸的ID</li><li>需要安装 <code>opencv-contrib-python</code> 模块</li></ul><pre><code class="python">import osimport cv2 as cvimport sysfrom PIL import Imageimport numpy as npdef getImageAndLabels(path):    facesSamples=[]    ids=[]    imagePaths=[os.path.join(path,f) for f in os.listdir(path)]    #检测人脸    face_detector = cv.CascadeClassifier(        &#39;opencv/sources/data/haarcascades/haarcascade_frontalface_default.xml&#39;)    #遍历列表中的图片    for imagePath in imagePaths:        #打开图片        PIL_img=Image.open(imagePath).convert(&#39;L&#39;)        #将图像转换为数组        img_numpy=np.array(PIL_img,&#39;uint8&#39;)        faces = face_detector.detectMultiScale(img_numpy)        #获取每张图片的id        id=int(os.path.split(imagePath)[1].split(&#39;.&#39;)[0])        for x,y,w,h in faces:            facesSamples.append(img_numpy[y:y+h,x:x+w])            ids.append(id)    return facesSamples,idsif __name__ == &#39;__main__&#39;:    #图片路径    path=&#39;./data/jm/&#39;    #获取图像数组和id标签数组    faces,ids = getImageAndLabels(path)    #获取训练对象    recognizer = cv.face.LBPHFaceRecognizer_create()    recognizer.train(faces,np.array(ids))    #保存文件    recognizer.write(&#39;trainer/trainer.yml&#39;)</code></pre><h4 id="基于-LBPH-的人脸识别"><a href="#基于-LBPH-的人脸识别" class="headerlink" title="基于 LBPH 的人脸识别"></a>基于 LBPH 的人脸识别</h4><ul><li>LBPH（Local Binary Pattern Histogram）将检测到的人脸分为小单元，并将其与模型中的对应单元进行比较，对每个区域的匹配值产生一个直方图</li><li>由于这种方法的灵活性，LBPH 是唯一允许模型样本人脸和检测到的人脸在形状、大小上可以不同的人脸识别算法</li><li>调整后的区域中调用 <code>predict()</code>函数，该函数返回两个元素的数组：第一个元素是所识别<br>个体的标签，第二个是置信度评分</li><li>所有的算法都有一个置信度评分阈值，置信度评分用来衡量所识别人脸与原模型的差距，0 表示完全匹配</li><li>可能有时不想保留所有的识别结果，则需要进一步处理，因此可用自己的算法来估算识别的置信度评分</li><li>一个好的 LBPH 识别参考值要低于50，任何高于80的参考值都会被认为是低的置信度评分</li></ul><pre><code class="python">import cv2 as cvimport numpy as npimport os# 加载训练数据集文件recognizer = cv.face.LBPHFaceRecognizer_create()recognizer.read(&#39;trainer/trainer.yml&#39;)# 准备识别的图片faceCascade = cv.CascadeClassifier(    &#39;opencv/sources/data/haarcascades/haarcascade_frontalface_default.xml&#39;)font = cv.FONT_HERSHEY_SIMPLEXid = 0img = cv.imread(&#39;19.pgm&#39;)gray_img=cv.cvtColor(img,cv.COLOR_BGR2GRAY)faces = faceCascade.detectMultiScale(gray_img)for x, y, w, h in faces:    cv.rectangle(img, (x, y), (x + w, y + h), (0, 255, 0), 2)    # 人脸识别    id, confidence = recognizer.predict(gray_img[y:y + h, x:x + w])    print(&#39;标签id:&#39;, id, &#39;置信评分：&#39;, confidence)cv.imshow(&#39;result&#39;, img)cv.waitKey(0)cv.destroyAllWindows()</code></pre><h3 id="摄像头人脸识别"><a href="#摄像头人脸识别" class="headerlink" title="摄像头人脸识别"></a>摄像头人脸识别</h3><h4 id="摄像头调试"><a href="#摄像头调试" class="headerlink" title="摄像头调试"></a>摄像头调试</h4><pre><code class="python">#导入opencv模块import cv2#捕捉帧，笔记本摄像头设置为0即可capture = cv2.VideoCapture(0)#循环显示帧while(True):    ret, frame = capture.read()    #显示窗口第一个参数是窗口名，第二个参数是内容    cv2.imshow(&#39;frame&#39;, frame)    if cv2.waitKey(1) == ord(&#39;q&#39;):      #按q退出        break</code></pre><h4 id="摄像头人脸识别-1"><a href="#摄像头人脸识别-1" class="headerlink" title="摄像头人脸识别"></a>摄像头人脸识别</h4><pre><code class="python">import cv2import numpy as npface_cascade = cv2.CascadeClassifier(    &quot;opencv\sources\data\haarcascades\haarcascade_frontalface_default.xml&quot;)eye_cascade = cv2.CascadeClassifier(&quot;opencv\sources\data\haarcascades\haarcascade_eye.xml&quot;)cap = cv2.VideoCapture(0)while True:    ret, img = cap.read()    gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)    faces = face_cascade.detectMultiScale(gray, 1.1, 5)    if len(faces) &gt; 0:        for faceRect in faces:            x, y, w, h = faceRect            cv2.rectangle(img, (x, y), (x + w, y + h), (255, 0, 0), 2)            roi_gray = gray[y:y + h // 2, x:x + w]            roi_color = img[y:y + h // 2, x:x + w]            eyes = eye_cascade.detectMultiScale(roi_gray, 1.1, 1, cv2.CASCADE_SCALE_IMAGE, (2, 2))            for (ex, ey, ew, eh) in eyes:                cv2.rectangle(roi_color, (ex, ey), (ex + ew, ey + eh), (0, 255, 0), 2)    cv2.imshow(&quot;img&quot;, img)    if cv2.waitKey(1) &amp; 0xFF == ord(&#39;q&#39;):        break</code></pre>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;Open Source Computer Vision Library（OpenCV）是一个跨平台的计算机视觉库，可用于开发实时的图像处理、计算机视觉以及模式识别程序。OpenCV 用 C++ 语言编写，但本次实战项目使用的是 &lt;code&gt;python-opencv&lt;/code&gt; 库实现的，主要是为了初步了解人脸识别的步骤和算法后面的原理。以下为项目笔记，源代码保存在 &lt;a href=&quot;https://github.com/Bezhuang/PracticeMakesPerfect/tree/main/Python-OpenCV&quot;&gt;Github 仓库&lt;/a&gt;中，可供参考。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="编程与开发" scheme="http://blog.zhuangzhihao.top/categories/%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="Python" scheme="http://blog.zhuangzhihao.top/tags/Python/"/>
    
    <category term="OpenCV" scheme="http://blog.zhuangzhihao.top/tags/OpenCV/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络（下）</title>
    <link href="http://blog.zhuangzhihao.top/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E4%B8%8B/"/>
    <id>http://blog.zhuangzhihao.top/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E4%B8%8B/</id>
    <published>2021-08-29T16:00:00.000Z</published>
    <updated>2021-10-25T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>计算机网络是计算机专业必修的重要课程之一，与现实世界结合得相当紧密，也是考研408计算机学科专业基础综合考试中的一门课程。计算机网络学习的核心内容就是网络协议的学习。网络协议是为计算机网络中进行数据交换而建立的规则、标准或者说是约定的集合。我选择的课程是哈工大的<a href="https://www.icourse163.org/learn/HIT-154005">国家精品课</a>和谢希仁版教材，以下为所记课堂笔记下半部分，包含网络层、传输层和应用层的知识点，可供参考。上半部分笔记请访问<a href="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E4%B8%8A">计算机网络（上）</a></p></blockquote><a id="more"></a><h3 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h3><h3 id="未完待续"><a href="#未完待续" class="headerlink" title="未完待续"></a>未完待续</h3>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;计算机网络是计算机专业必修的重要课程之一，与现实世界结合得相当紧密，也是考研408计算机学科专业基础综合考试中的一门课程。计算机网络学习的核心内容就是网络协议的学习。网络协议是为计算机网络中进行数据交换而建立的规则、标准或者说是约定的集合。我选择的课程是哈工大的&lt;a href=&quot;https://www.icourse163.org/learn/HIT-154005&quot;&gt;国家精品课&lt;/a&gt;和谢希仁版教材，以下为所记课堂笔记下半部分，包含网络层、传输层和应用层的知识点，可供参考。上半部分笔记请访问&lt;a href=&quot;/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E4%B8%8A&quot;&gt;计算机网络（上）&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="计算机专业" scheme="http://blog.zhuangzhihao.top/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%93%E4%B8%9A/"/>
    
    
    <category term="computer networking" scheme="http://blog.zhuangzhihao.top/tags/computer-networking/"/>
    
  </entry>
  
  <entry>
    <title>数据结构（中）</title>
    <link href="http://blog.zhuangzhihao.top/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%B8%AD/"/>
    <id>http://blog.zhuangzhihao.top/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%B8%AD/</id>
    <published>2021-08-16T16:00:00.000Z</published>
    <updated>2021-09-25T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>数据结构是指数据的存储结构，是带有结构特性的数据元素的集合。精心选择的数据结构可以带来更好的运行或者存储效率。数据结构是计算机科学与技术专业、软件工程专业甚至于其它电气信息类专业的重要专业基础课程，在408计算机学科专业基础综合考试中占有45分。我选择的课程是浙江大学数据结构<a href="https://www.icourse163.org/course/ZJU-93001">国家精品课</a>，以下为所记课堂笔记第二部分，包含树和图的知识总结以及所需记忆的代码，另外我在开源仓库中还保持了浙大慕课版本的<a href="https://github.com/Bezhuang/LearnCS/tree/main/%E5%90%8D%E6%A0%A1%E5%85%AC%E5%BC%80%E8%AF%BE/%E6%B5%99%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84">代码</a>，可供参考。其他部分笔记详见<a href="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%B8%8A">数据结构（上）</a>和<a href="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%B8%8B">数据结构（下）</a></p></blockquote><a id="more"></a><h3 id="矩阵与广义表"><a href="#矩阵与广义表" class="headerlink" title="矩阵与广义表"></a>矩阵与广义表</h3><h4 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵"></a>矩阵</h4><ul><li><p>矩阵的转置</p><pre><code class="cpp">void trsmat(int A[][maxSize],int B[][maxSize],int m, int n)&#123;    for (int i = 0;i &lt; m;++i)        for (int j = 0;j &lt; n;++j)            B[j][i] = A[i][j];&#125;</code></pre></li><li><p>矩阵相加</p><pre><code class="cpp">void addmat(int C[][maxSize],int A[][maxSize],int B[][maxSize],int m, int n)&#123;    for (int i = 0;i &lt; m;++i)        for (int j = 0;j &lt; n;++j)            C[i][j] = A[i][j] + B[i][j];&#125;</code></pre></li><li><p>矩阵相乘</p><pre><code class="cpp">void amutmat(int C[][maxSize],int A[][maxSize],int B[][maxSize],int m, int n,int k)&#123;    for (int i = 0;i &lt; m;++i)        for (int j = 0;j &lt; k;++j)        &#123;            C[i][j] = 0;            for int(h = 0;h &lt; n;++h)                C[i][j] += A[i][j] * B[i][j];        &#125;&#125;</code></pre></li><li><p>相同的元素或者零元素在矩阵中分布存在一定规律的矩阵称为特殊矩阵，反之称为稀疏矩阵</p><ul><li>对称矩阵、三角阵、对角矩阵</li></ul></li></ul><h4 id="广义表"><a href="#广义表" class="headerlink" title="广义表"></a>广义表</h4><ul><li>表元素可以是原子或者广义表的一种线性表的扩展结构</li><li>广义表可以是递归定义的，长度为表最上层元素的个数，深度为表中括号的最大的层数</li><li>当广义表非空时，第一个元素为广义表的表头，其余元素组成的表是广义表的表尾</li><li>原子结点有两个域：标志域和数据域</li><li>广义表结点有三个域：标志域，头指针域与尾指针域</li></ul><h3 id="树"><a href="#树" class="headerlink" title="树"></a>树</h3><h4 id="树的基本概念"><a href="#树的基本概念" class="headerlink" title="树的基本概念"></a>树的基本概念</h4><ul><li>树是一种非线性的数据结构，是若干个结点的集合，由唯一的根和若干个互不相交的子树组成<ul><li>结点不仅包含数据元素，并且包含指向子树的分支</li><li>结点的度是结点拥有的子树个数或者分支个数，树的度是树中各结点度的最大值</li><li>树的高度是树中结点的最大层次，根结点的高度为树的高度</li></ul></li><li>树的双亲存储结构：<code>int tree[maxSize]</code></li><li>树的链式存储结构<ul><li>邻接表：孩子存储结构</li><li>孩子兄弟存储结构</li></ul></li></ul><h4 id="二叉树的概念和性质"><a href="#二叉树的概念和性质" class="headerlink" title="二叉树的概念和性质"></a>二叉树的概念和性质</h4><ul><li><p>二叉树的定义</p><ul><li>每个结点最多只有两颗子树，即二叉树中的结点的度只能为0、1、2</li><li>子树有左右顺序之分，不能颠倒</li></ul></li><li><p>满二叉树：在一颗二叉树中，如果所有的分支节点都有左、右孩子节点，并且叶子节点都集中在二叉树的最下一层</p></li><li><p>完全二叉树由满二叉树从右至左、从上之下挨个删除结点得到的</p></li><li><p>二叉树的主要性质</p><ol><li><p>非空二叉树上叶子结点数等于双分支结点数加1，$n_0=n_2+1$</p></li><li><p>在二叉树的第 $i$ 层上最多有 $2^{i-1}$个节点，$(i&gt;=1)$</p></li><li><p>二叉树中如果深度为 $k$，那么最多有 $2^{k-1}$ 个节点，$(k&gt;=1)$</p></li><li><p>若对含 n 个结点的完全二叉树从上到下且从左至右进行 1 至 n 的编号，则对完全二叉树中任意一个编号为 i 的结点：</p><ul><li>若 i=1，则该结点是二叉树的根，无双亲，否则编号为 $\lfloor i/2\rfloor$ 的结点为其双亲结点（向下取整）</li><li>若 2i&gt;n，则该结点无左孩子，否则，编号为 2i 的结点为其左孩子结点</li><li>若 2i+1&gt;n，则该结点无右孩子，否则，编号为2i+1 的结点为其右孩子结点</li></ul></li><li><p>Catalan()：给定 n 个结点，能够成 $h\left( n\right) =\dfrac{C_{2n}^{n}}{n+1}$  棵不同的二叉树</p></li><li><p>在完全二叉树中，具有n个节点的完全二叉树的深度为 $\lfloor log2n\rfloor+1$</p></li></ol></li><li><p>二叉树的顺序存储结构最适用于完全二叉树</p></li><li><p>二叉树的链式存储结构</p><pre><code class="cpp">typedef struct BTNode&#123;    char  data;    //数据域    struct BTNoode* lchild;    struct BTNode* rchild;&#125; BTNode;</code></pre></li></ul><h4 id="二叉树的遍历算法"><a href="#二叉树的遍历算法" class="headerlink" title="二叉树的遍历算法"></a>二叉树的遍历算法</h4><ul><li><p>先序遍历</p><pre><code class="cpp">/*二叉树的非递归先序遍历*/void PreTraverseTree2(BitNode * root)&#123;    StackNode* S;   //定义一个栈指针    BitNode* p;   //工作指针    S = NULL;    p = root;    S = InitStack(S);   //初始化栈    if (NULL == p)    &#123;        printf(&quot;树为空！\n&quot;);        return;    &#125;     //end if    while (p || !StackEmpty(S))    &#123;     //如果树不空或者栈不空        if (p)        &#123;            StackPush(S, p);    //p 所指节点入栈            printf(&quot;%c &quot;, p-&gt;data);     //相当于 visit（p）            p = p-&gt;lchild ;     //指向 p 的左孩子         &#125;//end if        else        &#123;     //p 所指节点为空，则出栈赋给 p，遍历右子树            StackPop(S, p);            p = p-&gt;rchild;     //若右孩子有左子树则继续 while 将左孩子入栈        &#125;    //end else    &#125;    //end while    free(S);&#125;    //end PreTraverseTree2/*二叉树的递归先序遍历*/void preOrder(BiTNode *root)&#123;    if (root)    &#123;        printf(&quot;%d &quot;, root-&gt;data);        preOrder(root-&gt;lchild);        preOrder(root-&gt;rchild);    &#125;&#125;</code></pre></li><li><p>中序遍历</p><pre><code class="cpp">/*二叉树的非递归中序遍历*/void InOrderTraverseTree2(BitNode* root)&#123;    StackNode* S; //定义一个栈指针    BitNode* p; //工作指针    S = NULL;    p = root;    S = InitStack(S); //初始化栈    if (NULL == p) &#123; //如果是空树        printf(&quot;树为空！\n&quot;) ;        return;    &#125;//end if    while (p || !StackEmpty(S)) &#123; //如果树不空或者栈不空        if (p)        &#123;            StackPush(S, p); //将节点入栈            p = p-&gt;lchild; //指针一直向左孩子移动直到无左孩子        &#125;//end if        else        &#123;            StackPop(S, p); //p 左子树为空则出栈            printf(&quot;%c &quot;, p-&gt;data); //访问 p 节点            p = p-&gt;rchild; //向右子树移动        &#125;//end else    &#125;//end while    free(S);&#125;//end InOrderTraverseTree2/*二叉树的递归中序遍历*/void inOrder(BiTNode* root)&#123;    if (root)    &#123;        inOrder(root-&gt;lchild);        printf(&quot;%d &quot;, root-&gt;data);        inOrder(root-&gt;rchild);    &#125;&#125;</code></pre></li><li><p>后序遍历</p><pre><code class="CPP">/*二叉树非递归后序遍历*/void LastTraverseTree2(BiTNode* root)&#123;    StackNode* S; BiTNode* cur, * pre;//定义一个栈指针    S = NULL; S = InitStack(S); //cur 为当前节点指针，pre 保存上一节点    if (NULL == root)    &#123;        printf(&quot;树为空！\n&quot;);        return;    &#125;//end if    pre = NULL; cur = NULL;    StackPush(S, T); //根节点入栈    while (!StackEmpty(S))    &#123; //若栈非空        cur = NULL;        StackGetTop(S, cur); //将栈顶节点赋给 cur/*要保证根节点在左孩子和右孩子访问之后才能访问，因此对于任一节点 P，先将其入 栈。如果 P 不存在左孩子和右孩子，则可以直接访问它；或者 P 存在左孩子或者右孩子，但是其左孩子和右孩子都已被访问过了，则同样可以直接访问该节点。*/        if ((cur-&gt;lchild == NULL &amp;&amp; cur-&gt;rchild == NULL) ||            (pre != NULL &amp;&amp; (pre == cur-&gt;lchild || pre == cur-&gt;rchild)))        &#123;            printf(&quot;%c &quot;, cur-&gt;data);            pre = cur;            StackPop(S, cur);        &#125;//end if//若非上述两种情况，则将 P 的右孩子和左孩子依次入栈，这样就保证了每次取栈顶元素//的时候，左孩子在右孩子前面被访问，左孩子和右孩子都在根节点前面被访问。        else        &#123;            if (cur-&gt;rchild != NULL)                StackPush(S, cur-&gt;rchild);            if (cur-&gt;lchild != NULL)                StackPush(S, cur-&gt;lchild);        &#125;//end else    &#125;//end while    free(S);&#125;//end LastTraverseTree2/*二叉树递归后序遍历*/void postOrder(BiTNode* root)&#123;    if (root)    &#123;        postOrder(root-&gt;lchild);        postOrder(root-&gt;rchild);        printf(&quot;%d &quot;, root-&gt;data);    &#125; &#125;</code></pre></li><li><p>层次遍历：自上而下，自左向右</p><ul><li>首先，将二叉树的祖先节点入队列</li><li>然后循环执行以下步骤，直到队列为空：节点出队列进行相应操作，该节点如果有左孩子节点，左孩子节点入队列，该节点如果有右孩子节点，右孩子节点入队</li></ul><pre><code class="cpp">void LayerOrder(BiTreeNode* head)&#123;    LQueue Q;    Initiate_Queue(&amp;Q);    BiTreeNode* p;    if (head != NULL) AppendQueue(&amp;Q, head);    while (QueueNotEmpty(&amp;Q)) &#123;        p = QueueDelete(&amp;Q);        cout &lt;&lt; p-&gt;data &lt;&lt; &quot; &quot;;        if (p-&gt;LChild != NULL) AppendQueue(&amp;Q, p-&gt;LChild);        if (p-&gt;RChild != NULL) AppendQueue(&amp;Q, p-&gt;RChild);    &#125;&#125; </code></pre></li></ul><h4 id="哈夫曼树和哈夫曼编码"><a href="#哈夫曼树和哈夫曼编码" class="headerlink" title="哈夫曼树和哈夫曼编码"></a>哈夫曼树和哈夫曼编码</h4><ul><li><p>哈夫曼树又叫做最优二叉树，它的特点是带权路径最短</p><ul><li>树的路径长度是指从根到每个节点的路径长度之和</li><li>带权路径长度是从该节点到根节之间的路径长度乘以结点的权值</li><li>树的带权路径长度（WPL）是指树中所有叶子节点的带权路径长度之和</li></ul></li><li><p>求哈夫曼树的带权路径长度：WPL = 第 i 个节点的权值+ 第i个节点的长度</p><pre><code class="cpp">ElemType WeightPathLength(struct BTreeNode* FBT, int len)//len初始为0  &#123;      if (FBT == NULL) //空树返回0          return 0;      else      &#123;          if (FBT-&gt;left == NULL &amp;&amp; FBT-&gt;right == NULL)//访问到叶子结点              return FBT-&gt;data * len;          else //访问到非叶子结点，进行递归调用，返回左右子树的带权路径长度之和，len递增              return WeightPathLength(FBT-&gt;left,len+1)+WeightPathLength(FBT-&gt;right,len+1);      &#125;  &#125;  </code></pre></li><li><p>哈夫曼树的构造方法：根据数组 a 中 n 个权值建立一棵哈夫曼树，返回树根指针  </p><pre><code class="cpp">struct BTreeNode* CreateHuffman(ElemType a[], int n)  &#123;      int i, j;      struct BTreeNode **b, *q;      b = malloc(n*sizeof(struct BTreeNode));      for (i = 0; i &lt; n; i++) //初始化b指针数组，使每个指针元素指向a数组中对应的元素结点      &#123;          b[i] = malloc(sizeof(struct BTreeNode));          b[i]-&gt;data = a[i];          b[i]-&gt;left = b[i]-&gt;right = NULL;      &#125;      for (i = 1; i &lt; n; i++)//进行 n-1 次循环建立哈夫曼树      &#123;          //k1表示森林中具有最小权值的树根结点的下标，k2为次最小的下标          int k1 = -1, k2;          for (j = 0; j &lt; n; j++)//让k1初始指向森林中第一棵树，k2指向第二棵          &#123;              if (b[j] != NULL &amp;&amp; k1 == -1)              &#123;                  k1 = j;                  continue;              &#125;              if (b[j] != NULL)              &#123;                  k2 = j;                  break;              &#125;          &#125;          for (j = k2; j &lt; n; j++)//从当前森林中求出最小权值树和次最小          &#123;              if (b[j] != NULL)              &#123;                  if (b[j]-&gt;data &lt; b[k1]-&gt;data)                  &#123;                      k2 = k1;                      k1 = j;                  &#125;                  else if (b[j]-&gt;data &lt; b[k2]-&gt;data)                      k2 = j;              &#125;          &#125;          //由最小权值树和次最小权值树建立一棵新树，q指向树根结点          q = malloc(sizeof(struct BTreeNode));          q-&gt;data = b[k1]-&gt;data + b[k2]-&gt;data;          q-&gt;left = b[k1];          q-&gt;right = b[k2];          b[k1] = q;//将指向新树的指针赋给b指针数组中k1位置          b[k2] = NULL;//k2位置为空      &#125;      free(b); //删除动态建立的数组b      return q; //返回整个哈夫曼树的树根指针  &#125;  </code></pre></li><li><p>哈夫曼编码</p><ul><li>每个字符对应一个二进制编码，采用不等长编码方式，构造哈夫曼树</li><li>将每个字符的出现频率作为字符结点的权值赋予叶子结点，每个分支结点的左右分支分别用0和1编码</li><li>从树根结点到每个叶子结点的路径上所经分支的0、1编码序列等于该叶子结点的二进制编码</li><li>哈夫曼编码产生的是最短前缀码</li></ul><pre><code class="cpp">void HuffManCoding(struct BTreeNode* FBT, int len)//len初始值为0  &#123;      static int a[10];  //定义静态数组a，保存每个叶子的编码，数组长度至少是树深度减一      if (FBT != NULL)  //访问到叶子结点时输出其保存在数组a中的0和1序列编码      &#123;          if (FBT-&gt;left == NULL &amp;&amp; FBT-&gt;right == NULL)          &#123;              int i;              printf(&quot;结点权值为%d的编码：&quot;, FBT-&gt;data);              for (i = 0; i &lt; len; i++)                  printf(&quot;%d&quot;, a[i]);              printf(&quot;\n&quot;);          &#125;          else    //访问到非叶子结点时分别向左右子树递归调用，并把分支上的0、1编码保存到数组a          &#123;   //的对应元素中，向下深入一层时len值增1              a[len] = 0;              HuffManCoding(FBT-&gt;left, len + 1);              a[len] = 1;              HuffManCoding(FBT-&gt;right, len + 1);          &#125;      &#125;  &#125;  </code></pre></li></ul><h3 id="图"><a href="#图" class="headerlink" title="图"></a>图</h3><h4 id="图的基本概念"><a href="#图的基本概念" class="headerlink" title="图的基本概念"></a>图的基本概念</h4><ul><li>图由结点的有穷集合的 V 和边的集合  E 组成（<code>G(V,E)</code>）</li><li>图是按照无方向和有方向分为无向图和有向图，无向边用 $(v_i,v_j)$ 表示，有向边用 $&lt;v_i,v_j&gt;$ 表示</li><li>路径长度：路径上边或者弧的数目</li><li>顶点的度：顶点关联边的数目<ul><li>有向图中：方向指向顶点的边为入度；方向背向顶点的边为出度</li><li>在有向图中，顶点的度就是两者之和</li><li>在无向图中，任意两个顶点是相通的就是连通图，它的极大连通子图为连通分量</li><li>在向图中，任意两个顶点间互相都存在路径的就是强连通图，它的极大强连通子图为强连通分量</li></ul></li></ul><h4 id="图的存储结构"><a href="#图的存储结构" class="headerlink" title="图的存储结构"></a>图的存储结构</h4><ul><li><p>邻接矩阵</p><ul><li>图的顺序存储结构</li><li>用两个数组保存数据：一个一维数组存储图中顶点信息，一个二维数组存储图中边或弧的信息</li><li>无向图中邻接矩阵是个对称矩阵</li><li>0表示无边，1表示有边</li><li>顶点的度是行内数组之和，有向图中各行之和是出度，各列之和是入度 </li><li>邻接矩阵对于边数相对顶点较少的图，就是对存储空间极大的浪费</li></ul><pre><code class="cpp">typedef struct&#123;  int no;  char info;&#125; VertexType;typedef struct&#123;  int edges[maxSize][maxSize];    //有权图中int改为float  int n,e;    //顶点数和边数  VertexType vex[maxSize];    //存放结点信息&#125; MGragh;</code></pre></li><li><p>邻接表</p><ul><li>数组和链表相结合的存储方法，图的链式存储结构</li><li>图中顶点用一个一维数组存储</li><li>图中每个顶点 $V_i$ 的所有邻接点构成一个线性表</li><li>顶点表的各个结点由 data 和 Firstedge 两个域表示<ul><li>data 是数据域，存储顶点信息</li><li>firstedge 是指针域，指向边表的第一个结点，即顶点的第一个邻接点</li></ul></li><li>边表结点由 adjvex 和 next 两个域组成<ul><li>adjvex 是邻接点域，存储某顶点的邻接点在顶点表中坐标</li><li>next 存储边表中下一个结点指针</li></ul></li><li>有向图也可以用邻接表，出度表叫邻接表，入度表尾逆邻接表</li></ul><pre><code class="cpp">typedef struct ArcNode&#123;    int adnex;    //该边所指向的结点的位置    struct ArcNode * nextarc;    //指向下一条边的指针    int info;    //该边的相关信息(如权值)&#125; ArcNode;typedef struct&#123;    char data;    //顶点信息    ArcNode* firstarc;    //指向第一条边的指针&#125;VNode;typedef struct&#123;    VNode adjlist[maxSize];    //邻接表    int n, e;    //顶点数和边数&#125; AGraph;    //图的邻接表类型</code></pre></li><li><p>十字链表</p><ul><li>在邻接表中针对有向图，分为邻接表和逆邻接表，导致无法从一个表中获取图的入读和出度的情况，有人提出了十字链表</li><li>定点表<ul><li>firstin：入边表头指针，指向顶点入边表的第一个结点</li><li>firstout：出边表头指针，指向顶点出边表第一个结点</li></ul></li><li>边表<ul><li>tailvex 是指弧起点在顶点表的下标，headvex 弧终点在顶点表的下标</li><li>headlink 入边表指针域，指向终点相同的下一条边</li><li>taillink 是指边表指针域，指向起点相同的下一条边</li></ul></li></ul></li><li><p>邻接多重表</p><ul><li>ivex 和 jvex 是与某条边依附的两个顶点在顶点表中的下标</li><li>ilink 指向依附项点 ivex 的下一条边</li><li>jlink 指向依附顶点 jvex 的下一条边</li></ul></li></ul><h4 id="图的遍历算法"><a href="#图的遍历算法" class="headerlink" title="图的遍历算法"></a>图的遍历算法</h4><ul><li><p>深度优先遍历（DFS，Depth First Search） </p><ul><li>首先从图中某个顶点 $v_0$ 出发，访问此顶点，然后依次从 $v_0$ 相邻的顶点出发 深度优先遍历，直至图中所有与 $v_0$ 路径相通的顶点都被访问了</li><li>若此时尚有顶点未被访问， 则从中选一个顶点作为起始点，重复上述过程，直到所有的顶点都被访问</li><li>深度优先遍历是一个递归的过程，这种遍历过程类似树的先序遍历，均是先访问节点，再从该节点出发继续向下遍历</li></ul><pre><code class="cpp">bool visited[Max_Vex];    //定义访问标记数组，为了防止重复访问void DFSTraverse(Graph G)&#123;    for (v = 0;v &lt; G.vexnum;++v)        visited[v] = false;    //初始化标记数组    for (v = 0;v &lt; G.vexnum;++v)        if (!visited[v])    //如果 v 未被访问，那么从 v 起，开始做深度优先遍历            DFS(G, v);&#125;void DFS(Graph G, int v)&#123;    visit(v);    visited[v] = true; //定义为已访问    for (w = FirstNeighbor(G, v);w &gt;= 0;w = NextNeighbor(G, v, w))        if (!visited[w])            DFS(G, w);&#125;</code></pre></li><li><p>广度优先遍历（BFS，Breadth First Search）</p><ul><li>首先从图的某个顶点 $v_0$ 出发，访问了 $v_0$ 之后，依次访问与 $v_0$ 相邻的未被访 问的顶点</li><li>然后分别从这些顶点出发，广度优先遍历，直至所有的顶点都被访问完</li><li>BFS 遍历的方式类似于树的层次遍历</li></ul><pre><code class="cpp">bool visited[Max_Vex];    //定义访问标记数组void BFSTraverse(Graph G)&#123;    for (i = 0;i &lt; G.vexnum;++i)        visited[v] = false;    //初始化标记数组    InitQueue(Q);    for (v = 0;v &lt; G.vexnum;++v)        if (!visited[v])    //如果 v 未被访问，那么从 v 起，开始做广度优先遍历            BFS(G, v);&#125;void BFS(Graph G, int v)&#123;    visit(v);    visited[v] = true;    //定义为已访问    while (!isEmpty(Q))    &#123;        DeQueue(Q, v);        for (w = FirstNeighbor(G, v);w &gt;= 0;w = NextNeighbor(G, v, w))            if (!visited[w])            &#123;                visit(w);                visited[w] = true;                EnQueue(Q, w)            &#125;    //if    &#125;    //while&#125;</code></pre></li></ul><h4 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h4><ul><li><p>Prim 算法</p><ul><li>从图中仼意取出一个顶点，把它当成一棵树，然后从与这棵树相接的边中选取一条最短（权值最小）的边，并将这条边及其所连接的顶点也并入这棵树中，此时得到了一棵有两个顶点的树</li><li>然后从与这棵树相接的边中选取一条最短的边，并将这条边及其所连顶点并入当前树中，得到一棵有3个顶点的树</li><li>以此类推，直到图中所有顶点都被并入树中为止，此时得到的生成树就是最小生成树</li></ul><pre><code class="cpp">void prim (G,T)&#123;    T = ∅;    U = &#123;w&#125;;    while ((V - U) != ∅  )    &#123; //若图中不含全部顶点        设  (u，v) 是使 u∈U 与 v∈ (V-U)，且权值最小的边;        T = T∪ (u，v); //边归入树        U = U∪ &#123;v&#125;;     //顶点归入树    &#125;&#125;</code></pre></li><li><p>Kruskal 算法</p><ul><li>将图中边按照权值从小到大排序，然后从最小边开始扫描各边，并检测当前边是否为候选边，即是否该边的并入会构成回路，如不构成回路，则将该边并入当前生成树中，直到所有边都被检测完为止</li><li>Kruskal 算法的时间复杂度主要由选取的排序算法决定，排序算法所处理数据的规模由图的边数e 决定，与顶点数无关，因此克鲁斯卡尔算法适用于稀疏图</li><li>普里姆算法和克鲁斯卡尔算法都是针对于无向图的</li><li>判断是否产生回路要用到并查集，并查集中保存了一棵或者几棵树<ul><li>通过树中一个结点，可以找到其双亲结点，进而找到根结点（可以快速地将两个含有很多元素的集合并为一个，两个集合就是并査集中的两棵树，只需找到其中一棵树的根，然后将其作为另一棵树中任何个结点的孩子结点即可，可以方便地判断两个元素是否属于同一个集合</li><li>通过这两个元素所在的结点找到它们的根结点，如果它们有相同的根，则说明它们属于同一个集合，否则属于不同集合</li></ul></li></ul><pre><code class="cpp">void kruskal（V，T）&#123;    T = V;    //初始化树，仅含顶点    numS = n;    //不连分量的数目    while (numS &gt; 1)    &#123;        从 E 中取出权值最小的边（v,u）;        if（v 和 u 属于 T 中不同的连通分量）        &#123;            T = T∪（u，v）;//将此边加入到生成树中；            numS--; //不连通的分量减少 1        &#125;    &#125;&#125;</code></pre></li></ul><h4 id="最短路径"><a href="#最短路径" class="headerlink" title="最短路径"></a>最短路径</h4><ul><li><p>Dijkstra 算法</p><ul><li>通常用于求图中某一顶点到其余各顶点的最短路径</li><li>设  G=(V,E) 是一个带权有向图，把图中顶点集合 V 分成两组</li><li>第一组为已求出最短路径的顶点集合（用 S 表示，初始时 S 中只有一个源点，,以后每求得一条最短路径就将求得的顶点加入到集合 S 中，直到全部顶点都加入到 S 中）</li><li>第二组为其余未确定最短路径的顶点集合（用 U 表示），按最短路径长度的递增次序依次把第二组的顶点加入 S 中，在加入的过程中，总保持从源点 V 到 S 中各顶点的最短路径长度不大于从源点 V 到 U 中任何顶点的最短路径长度</li></ul></li><li><p>Dijkstra 算法步骤</p><ol><li>初始时，S 只包含源点，即 S＝{v}，v 的距离为 0，U 包含除 v 外的其他顶点，即:U={其 余顶点}，若 v 与 U 中顶点 u 有边，则正常有权值，若 u 不是 v 的出边邻接点，则 权值为 $∞$</li><li>从 U 中选取一个距离 v 最小的顶点 k，把 k 加入 S 中（该选定的距离就是 v 到 k 的最短路 径长度）</li><li>以 k 为新考虑的中间点，修改 U 中各顶点的距离值：若从源点 v 到顶点 u 的距离（经过顶点 k）比原来距离（不经过顶点 k）短，则修改顶点 u 的距离值，修改后的距离值为 v 到 k 的距离加上 k 到 u 的距离</li><li>重复步骤 b 和 c 直到所有顶点都包含在 S 中</li></ol><pre><code class="cpp">void Dijkstra(int v0)&#123;  　　bool S[MAXNUM];                                  // 判断是否已存入该点到S集合中      int n=MAXNUM;  　　for(int i=1; i&lt;=n; ++i) 　　 &#123;      　　dist[i] = A[v0][i];      　　S[i] = false;                                // 初始都未用过该点      　　if(dist[i] == MAXINT)                　　prev[i] = -1; 　　     else             　　prev[i] = v0;   　　&#125;   　 dist[v0] = 0;   　 S[v0] = true; 　　 　　 for(int i=2; i&lt;=n; i++) 　　 &#123;       　　int mindist = MAXINT;       　　int u = v0; 　　                            // 找出当前未使用的点j的dist[j]最小值      　　 for(int j=1; j&lt;=n; ++j)      　　    if((!S[j]) &amp;&amp; dist[j]&lt;mindist)      　　    &#123;         　　       u = j;                             // u保存当前邻接点中距离最小的点的号码          　 　      mindist = dist[j];       　　   &#125;       　　S[u] = true;        　　for(int j=1; j&lt;=n; j++)       　　    if((!S[j]) &amp;&amp; A[u][j]&lt;MAXINT)       　　    &#123;           　    　if(dist[u] + A[u][j] &lt; dist[j])     //在通过新加入的u点路径找到离v0点更短的路径             　    　&#123;                   　　dist[j] = dist[u] + A[u][j];    //更新dist                    　　prev[j] = u;                    //记录前驱顶点             　　    &#125;        　    　&#125;   　　&#125;&#125;</code></pre></li><li><p>Floyd 算法</p><ul><li>Floyd-Warshall算法（Floyd-Warshall algorithm）是解决任意两点间的最短路径的一种算法，可以正确处理有向图或负权的最短路径问题，同时也被用于计算有向图的传递闭包</li><li>Floyd-Warshall 算法的时间复杂度为  $O(N^3)$，空间复杂度为  $O(N^2)$</li><li>Floyd 算法是一个经典的动态规划算法，目标是寻找从点 i 到点 j 的最短路径，假设 Dis(i,j) 为节点 u 到节点 v 的最短路径的距离</li><li>对于每一个节点 k，检查 Dis(i,k) + Dis(k,j) &lt; Dis(i,j) 是否成立，如果成立，证明从 i 到 k 再到 j 的路径比 i 直接到j的路径短，便设置 Dis(i,j) = Dis(i,k) + Dis(k,j)，这样当遍历完所有节点 k，Dis(i,j) 中记录的便是 i 到 j 的最短路径的距离</li></ul></li><li><p>Floyd 算法步骤</p><ul><li>从任意一条单边路径开始，所有两点之间的距离是边的权，如果两点之间没有边相连，则权为无穷大　　</li><li>对于每一对顶点 u 和 v，看看是否存在一个顶点 w 使得从 u 到 w 再到 v 比己知的路径更短，如果是更新它</li></ul><pre><code class="cpp">for (k = 1;k &lt;= n;k++)    for (i = 1;i &lt;= n;i++)        for (j = 1;j &lt;= n;j++)            if (a[i][j] &gt; a[i][k] + a[k][j])                a[i][j] = a[i][k] + a[k][j];</code></pre></li></ul><h4 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h4><ul><li><p>对一个有向无环图 G 进行拓扑排序，是将 G 中所有顶点排成一个线性序列，使得图中任意一对顶点 u 和 v，若存在由 u 到 v 的路径，则在拓扑排序序列中一定是 u 出现在 v 的前边</p><ol><li>从 DAG 图中选择一个没有前驱的节点并输出</li><li>从图中删除该节点和所有以它为起点的有向边</li><li>重复上两步直到当前的 DAG 图为空或不存在无前驱的顶点为止</li></ol><pre><code class="cpp">bool topologicalSort(Graph GL)&#123;    EdgeNode* e;    int top = 0; //用于栈指针下标     int count = 0; // 用于统计输出顶点的个数     int* stack; // 建栈将入度为 0 的顶点入栈     stack = (int*)malloc(GL-&gt;numVertexes * sizeof(int));    for (i = 0; i &lt; GL-&gt;numVertexes; i++)        if (0 == GL-&gt;adjList[i].in) //将入度为 0 的顶点入栈             stack[++top] = i;    while (top != 0)    &#123;        gettop = stack[top--];        printf(&quot;%d -&gt; &quot;, GL-&gt;adjList[gettop].data);        count++; //输出 i 号顶点，并计数         for (e = GL-&gt;adjList[gettop].firstedge; e; e = e-&gt;next) &#123;            k = e-&gt;adjvex;            if (!(--GL-&gt;adjList[k].in))                //将 i 顶点的邻接点入度减 1，如果减 1 后为 0，则入栈                 stack[++top] = k;        &#125;    &#125;    if (count &lt; GL-&gt;numVertexes) return false;    else return true;&#125;</code></pre></li></ul>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;数据结构是指数据的存储结构，是带有结构特性的数据元素的集合。精心选择的数据结构可以带来更好的运行或者存储效率。数据结构是计算机科学与技术专业、软件工程专业甚至于其它电气信息类专业的重要专业基础课程，在408计算机学科专业基础综合考试中占有45分。我选择的课程是浙江大学数据结构&lt;a href=&quot;https://www.icourse163.org/course/ZJU-93001&quot;&gt;国家精品课&lt;/a&gt;，以下为所记课堂笔记第二部分，包含树和图的知识总结以及所需记忆的代码，另外我在开源仓库中还保持了浙大慕课版本的&lt;a href=&quot;https://github.com/Bezhuang/LearnCS/tree/main/%E5%90%8D%E6%A0%A1%E5%85%AC%E5%BC%80%E8%AF%BE/%E6%B5%99%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84&quot;&gt;代码&lt;/a&gt;，可供参考。其他部分笔记详见&lt;a href=&quot;/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%B8%8A&quot;&gt;数据结构（上）&lt;/a&gt;和&lt;a href=&quot;/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%B8%8B&quot;&gt;数据结构（下）&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="计算机专业" scheme="http://blog.zhuangzhihao.top/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%93%E4%B8%9A/"/>
    
    
    <category term="Data Structure" scheme="http://blog.zhuangzhihao.top/tags/Data-Structure/"/>
    
  </entry>
  
  <entry>
    <title>考研政治小抄</title>
    <link href="http://blog.zhuangzhihao.top/%E8%80%83%E7%A0%94%E6%94%BF%E6%B2%BB%E5%B0%8F%E6%8A%84/"/>
    <id>http://blog.zhuangzhihao.top/%E8%80%83%E7%A0%94%E6%94%BF%E6%B2%BB%E5%B0%8F%E6%8A%84/</id>
    <published>2021-07-31T16:00:00.000Z</published>
    <updated>2021-09-20T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>“思想政治理论”是研究生招生考试必考科目之一（为什么！┗|｀O′|┛），分为马原、毛中特、史纲、思修和时政5个大类。政治内容众多且杂，如果对基础概念和知识进行具体总结，篇幅非常长，本篇笔记只是以一个“Cheat-sheet”的形式尽可能包含所有考试重点，至于系统的归纳梳理则以肖精讲精练为准。</p></blockquote><a id="more"></a><h3 id="马克思主义基本原理概论"><a href="#马克思主义基本原理概论" class="headerlink" title="马克思主义基本原理概论"></a>马克思主义基本原理概论</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><ul><li>马克思主义哲学（科学方法）<ul><li>哲学的基本问题哲学的基本问题，不同的哲学流派</li><li>马哲</li><li>唯物论——世界的本源是什么</li><li>辩证法——世界是怎样的</li><li>认识论——如何认知世界</li><li>唯物史观——人类历史发展规律</li></ul></li><li>马克思主义政治经济学（主体）<ul><li>简单商品经济时期（资本主义以前的商品经济就叫简单经济时期）</li><li>发达商品经济时期</li><li>自由竞争资本主义（考试重点）</li><li>垄断竞争资本主义</li></ul></li><li>科学社会主义理论（目的和归宿）<ul><li>社会主义：从空想到实</li><li>共产主义：社会的终极形态</li></ul></li><li>恩格斯的《反杜林论》把马原分为哲学、政经、科社</li></ul><h4 id="唯物论"><a href="#唯物论" class="headerlink" title="唯物论"></a>唯物论</h4><ul><li>世界的本原<ul><li>主观唯心：世界的本原在我心里（王阳明心学）</li><li>客观唯心：世界的本原是脱离物质世界、不依赖于个人意识而独立存在的精神（佛教中的“缘”、道教中的“道”）</li><li>马克思主义哲学认为世界的本原是一切客观实在</li><li>客观实在：不以人的意志为转移</li></ul></li><li>物质决定意识，物质派生出意识</li></ul><h4 id="辩证法"><a href="#辩证法" class="headerlink" title="辩证法"></a>辩证法</h4><ul><li>物质世界是联系和发展的</li><li>辩证法的两大总特征：联系、发展<ul><li>联系：世界上的万事万物都与其他事物发生某种关联、产生某种联系，这个世界是联系的统一体，不存在完全孤立的事物</li><li>发展：任何事物都有它的过去、现在与将来，要立足于过去，展望将来</li></ul></li><li>事物是一对一对联系的<ul><li>一个事物与另一个事物发生联系，而另一个事物又与另一个事物发生联系，如此循环往复</li><li>世界就是靠一对一对相互交织的联系，构建出一张普遍交织的大网，这就是联系的普遍性</li></ul></li><li>辩证法的三大规律：对立统一、量变质变、否定之否定<ul><li>对立统一：是世间万事万物发展的原因和动力</li><li>量变质变：不断地进行星的积累，最终实现质的突破，不断地积累与突破</li><li>否定之否定：波浪式地上升、螺旋式的前进，是事物发展的方向与归宿</li></ul></li></ul><h4 id="认识论"><a href="#认识论" class="headerlink" title="认识论"></a>认识论</h4><ul><li>认识的本质是人类头脑对外部世界的能动反映</li><li>实践是认识的来源</li><li>没有人类的实践，就不会有人类的认识<ul><li>感性认识（浅显）：外部世界直接作用于感官而形成的认识</li><li>理性认识（深刻）：基于感性素材，对其概括、抽象、提炼、加工、思考，获得理性认识</li></ul></li><li>真理：脑子里面的东西与外部世界相致</li><li>谬误：脑子里面的东西与外部世界不一致</li><li>真理的绝对性与相对性：任何一个真理既是绝对的,又是相对的（从不同角度来看）<ul><li>真理的绝对性（通俗）：我既然是真理，我肯定是对的</li><li>真理的相对性（通俗）：我虽然是对的，但我未来有可能不对</li></ul></li></ul><h4 id="唯物史观"><a href="#唯物史观" class="headerlink" title="唯物史观"></a>唯物史观</h4><ul><li>历史进程中的决定性力量<ul><li>唯心史观:由精神力量所决定</li><li>唯物史观:由物质力量所决定（社会生产劳动及其生产力水平的提高决定历史发展）</li></ul></li><li>历史是什么人创造的<ul><li>唯心史观：历史是由英雄人物创造</li><li>唯物史观：历史是由人民群众创造</li></ul></li><li>历史向前发展是统一性和多样性的统一<ul><li>自然界：不以人的意志为转移的客观规律</li><li>人类社会：历史发展规律（取决定性作用）+ 人的主观能动性（对其选择）</li><li>规律使得人类社会的发展具有统一性，能动使得人类社会的发展具有多样性</li></ul></li></ul><h4 id="马克思主义政治经济学"><a href="#马克思主义政治经济学" class="headerlink" title="马克思主义政治经济学"></a>马克思主义政治经济学</h4><ul><li>商品价值的本质是劳动者通过劳动创造的价值</li><li>商品的价值：隐藏在商品里面、用作交换的、人的劳动</li><li>资本主社会以前：劳动的过程以及劳动的成果都归劳动者本人所有</li><li>资本主义社会以后：劳动的过程以及劳动的成果都归资本家所有</li><li>为什么资本主义社会存在剥削<ul><li>劳动创造价值，其中一部分价值通过工资的形式给了劳动者，多出来的部分（剩余价值）被资本家无偿占有</li></ul></li></ul><h4 id="科学社会主义发展进程"><a href="#科学社会主义发展进程" class="headerlink" title="科学社会主义发展进程"></a>科学社会主义发展进程</h4><ul><li>社会主义的发展进程<ul><li>空想 -&gt; 科学</li><li>理论 -&gt; 实践</li></ul></li><li>共产主义的基本特征<ul><li>物质财富极大丰富（产品）</li><li>精神境界极大提高</li><li>每个人自由而全面的发展</li></ul></li></ul><h3 id="思想道德修养与法律基础"><a href="#思想道德修养与法律基础" class="headerlink" title="思想道德修养与法律基础"></a>思想道德修养与法律基础</h3><h4 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h4><ul><li>思想修养<ul><li>人生观：如何树立正确的人生观</li><li>理想信念：如何树立远大的理想，理想和现实是怎样的关系</li><li>中国精神：什么是中国精神，如何去弘扬中国精神</li><li>社会主义核心价值观：当代中国人的思想标准</li></ul></li><li>道德修养<ul><li>道德的基本问题：概念、本质、特征、功能、历史发展脉络</li><li>两个维度<ul><li>不同时期的道德：古代的道德、近代的道德、今天的道德</li><li>不同领域的道德：社会工作中的道德提倡、职场工作中的道德提倡、自身修养的道德报倡、家庭生活中的道德提倡</li></ul></li></ul></li><li>法律基础：基础常识</li></ul><h4 id="思想修养"><a href="#思想修养" class="headerlink" title="思想修养"></a>思想修养</h4><ul><li>人生价值<ul><li>人生观：指我们对自己的人生的整体看法和整体观点</li><li>人生观属于世界观，世界观包含人生观</li><li>人生目的：在人生观中居于核心地位</li><li>人生目的是人生观的核心，可以决定人生态度和人生价值</li></ul></li><li>理想信念<ul><li>理想通过实践实现现实</li><li>实践是理想变成现实的根本途径</li><li>理想 -&gt; 信念 -&gt; 信仰 -&gt; 科学/非科学的信仰</li><li>信仰一般不会改变,但是不是不能改变</li><li>个人理想服从于社会理想，社会理想为个人理想提供保障</li></ul></li><li>中国精神<ul><li>以爱国主义为核心的民族精神</li><li>以改革创新为核心的时代精神</li></ul></li><li>社会主义核心价值观</li></ul><h4 id="道德修养"><a href="#道德修养" class="headerlink" title="道德修养"></a>道德修养</h4><ul><li>道德是上层建筑，由经济基础决定<ul><li>社会主义国家的经济基础：公有制（集体利益大于个人利益）</li><li>资本主义国家的经济基础：私有制（个人利益至上）</li></ul></li><li>道德的功能<ul><li>行为前：认识功能</li><li>行为中：规范功能</li><li>行为后：调节功能</li></ul></li><li>不同时期的道德<ul><li>古代的道德：传统美德</li><li>近代的道德：革命道德</li><li>现代的的道德：社会主义道德</li></ul></li><li>不同领域的道德<ul><li>社会公德</li><li>职业道德</li><li>家庭美德</li><li>个人品德</li></ul></li></ul><h4 id="法律基础"><a href="#法律基础" class="headerlink" title="法律基础"></a>法律基础</h4><ul><li>法律的基本问题<ul><li>法律的概念、功能、历史发展的脉络</li><li>法律是统治阶级的整体意志的体现，是统治阶级进行阶级统治的工具</li></ul></li><li>法律的运行：立法 -&gt; 执法 -&gt; 司法 -&gt; 守法</li><li>法律体系<ul><li>实体法律部门：宪法、民法等</li><li>程序法律部门：诉讼法、非诉讼法等</li></ul></li><li>法治体系：法律体系、法律实施体系、法律监督体系</li><li>法治思维：坚持法治思维，就要批判人治思维</li><li>法律权威：外在（强制性）和内在（合理性）</li><li>法律权利和义务</li></ul><h3 id="中国近代史纲要"><a href="#中国近代史纲要" class="headerlink" title="中国近代史纲要"></a>中国近代史纲要</h3><h4 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h4><ul><li>不考历史的细节，而考历史背后的政治逻辑</li><li>1840年鸦片战争：中国近代史开端</li><li>1911年辛亥革命：清朝政府结束，北洋政府开始</li><li>1919年五四运动：新旧民主主义革命分界线</li><li>1928年东北易帜：北洋政府结束，国民政府开始</li><li>1949年新中国成立：中国现代史开端</li></ul><h4 id="国情（从实际出发）"><a href="#国情（从实际出发）" class="headerlink" title="国情（从实际出发）"></a>国情（从实际出发）</h4><ul><li>国情是一切历史理论研究的起点</li><li>近代中国的国情：半殖民地半封建社会（1840年—1949年）</li></ul><h4 id="二、矛盾"><a href="#二、矛盾" class="headerlink" title="二、矛盾"></a>二、矛盾</h4><ul><li>近代中国主要矛盾<ul><li>半殖民：帝国主义与中华民族之间的矛盾</li><li>半封建：封建主义与人民大众之间的矛盾</li></ul></li></ul><h4 id="任务和对象"><a href="#任务和对象" class="headerlink" title="任务和对象"></a>任务和对象</h4><ul><li>近中国的任务<ul><li>帝国主义与中华民族之间的矛盾的任务：反帝</li><li>封建主义与人民大众之间的矛盾的任务：反封建</li></ul></li></ul><h4 id="中国革命的性质"><a href="#中国革命的性质" class="headerlink" title="中国革命的性质"></a>中国革命的性质</h4><ul><li>中国的革命是一场以反帝反封建为任务为对象的革命</li><li>革命的性质：资产阶级民族革命</li><li>新民主义革命是由无产阶级领导，但性质却是资产阶级革命<ul><li>决定革命性肤的不是革命的领导者，而是革命的任务和对象</li></ul></li><li>革命：推翻旧制度、确立新制度、确立新的生产关系的行为</li><li>奴隶社会：封建地主推翻奴隶主，奴隶主居于统治地位，奴隶处于被统治地位</li><li>封建社会：资产阶级推翻封建地主，封建地主居于统治地位，农民处于被统治地位</li><li>资本主义社会：无产阶级推翻资产阶级，资本主义居于统治地位，无产阶级处于被统治地位</li><li>因为中国革命的任务是反帝反封建，所以中国革命的性质就是资产阶级革命，无论谁来<br>做</li></ul><h4 id="史纲总结"><a href="#史纲总结" class="headerlink" title="史纲总结"></a>史纲总结</h4><ul><li>近代中国我们要做反帝反封建的任务，这件事情理应由资产阶级去做，是资产阶级的历<br>史使命</li><li>但是因为资产阶级的软弱本身没有实力去完成反帝反封建的历史使命，于是就由中国的无产阶级替资产阶级去完成本该由资产阶级完成的反帝反封建的历史使命</li><li>中国的革命也因此变成了由无产阶级领导的、资产阶级性质的、反帝反封建的、新式的<br>民主主义革命</li></ul><h3 id="毛泽东思想和中国特色社会主义理论体系概论"><a href="#毛泽东思想和中国特色社会主义理论体系概论" class="headerlink" title="毛泽东思想和中国特色社会主义理论体系概论"></a>毛泽东思想和中国特色社会主义理论体系概论</h3><h4 id="毛泽东思想"><a href="#毛泽东思想" class="headerlink" title="毛泽东思想"></a>毛泽东思想</h4><ul><li>理论的形成</li><li>理论内容<ul><li>新民主主义革命理论：1949年之前</li><li>社会主义改造理论：1949—1956年</li><li>社会主义建设道路的初步探索：1956—1976年</li></ul></li></ul><h4 id="中国特色主义理论体系"><a href="#中国特色主义理论体系" class="headerlink" title="中国特色主义理论体系"></a>中国特色主义理论体系</h4><ul><li>社会主义应该具有先进的、发达的生产力</li><li>怎样建设社会主义<ul><li>解放生产力，发展生产力</li><li>消灭剥削，消灭两极分化</li><li>最终达到共同富裕</li></ul></li><li>邓小平理论</li><li>“三个代表”重要思想<ul><li>建设什么样的党？怎样建设党？</li><li>要始终代表先进生产力的发展方向</li><li>要始终代表先进文化的发展方向</li><li>要始终代表广大人民的根本利益</li></ul></li><li>科学发展观<ul><li>实现什么样的发展？怎样发展？</li></ul></li><li>习近平新时代中国特色社会主义思想<ul><li>新时代、新思想</li><li>全面小康社会</li><li>建党一百年全面脱贫</li><li>2035年基本实现社会主义现代化</li><li>21世界中叶，建成社会主义现代化强国，实现中华民族伟大复兴</li><li>总任务：实现社会主义现代化，中华民族伟大复兴</li><li>布局理论：五位一体总体布局、四个全面战略布局</li><li>内外条件：国防军队建设、中国的外交问题、党的建设</li></ul></li></ul><h4 id="马克思主义中国化"><a href="#马克思主义中国化" class="headerlink" title="马克思主义中国化"></a>马克思主义中国化</h4><ul><li>新文化运动：学习西方资产阶级民族思想，来改造中国人的思想文化</li><li>十月革命：给中国送来了马克思列宁主义</li><li>五四运动：马克思列宁主义得到广泛传播</li><li>中共一大：以无产阶级革命推翻资产阶级，应联合资产阶级一起反帝反封建</li><li>六届六中全会：首次提出“马克思主义中国话”的命题</li><li>中共七大：实现了第一次飞跃，成果即为毛泽东思想</li><li>1956年《论十大关系》：第二次马克思主义中国化开始</li><li>改革开放：实现了马克思主义中国化的第二次飞跃，成果即为中国特色社会主义理论体系</li></ul><h4 id="新民主主义理论"><a href="#新民主主义理论" class="headerlink" title="新民主主义理论"></a>新民主主义理论</h4><ul><li>革命路线：无产阶级领导的人民大众的反帝反封建反官资的革命</li><li>革命纲领<ul><li>政治上：各革命阶级联合专政</li><li>经济上：没收地主、官资，保护民资</li><li>文化上：民族的、科学的、大众的</li></ul></li><li>革命道路：农村包围城市，武装夺取政权</li><li>革命经验（三大法宝）：统战线、武装斗争、党的建设</li></ul><h4 id="社会主义建设初步探索理论"><a href="#社会主义建设初步探索理论" class="headerlink" title="社会主义建设初步探索理论"></a>社会主义建设初步探索理论</h4><ul><li>《论十大关系》<ul><li>第二次马克思主义中国化开始</li><li>方针：调动一切积极因素为社会主义建设服务</li><li>指导思想：独立自主的符合中国特点的社会主义建设道路</li></ul></li><li>《关于正确处理人民内部矛盾的问题》<ul><li>基本矛盾：生产力和生产关系、经济基础和上层建筑</li><li>主要矛盾：作为一个落后的农业国与先进的工业国需求之间存在的矛盾、人民日益增长的物质文化需要同当前的发展不满足人民需要状况之间的矛盾</li><li>两类矛盾：敌我矛盾、人民内部矛盾</li></ul></li><li>中国工业化道路：农轻重</li></ul><h3 id="当代世界经济与政治"><a href="#当代世界经济与政治" class="headerlink" title="当代世界经济与政治"></a>当代世界经济与政治</h3><h4 id="当代世界政治与经济"><a href="#当代世界政治与经济" class="headerlink" title="当代世界政治与经济"></a>当代世界政治与经济</h4><ul><li>当今世界形势：百年未有之大变局，机遇与挑战并存</li><li>国际行为体：大国、欧盟</li><li>地区热点问题：朝韩问题，伊朗问题，叙利亚问题等</li><li>中国对外战略：和平发展道路、合作共赢的新型国际关系、人类命运共同体、一带一路</li></ul><h4 id="时事政治"><a href="#时事政治" class="headerlink" title="时事政治"></a>时事政治</h4><ul><li>重大会议：国际、国内（两会）</li><li>重大改革举措：雄安新区、深圳、粤港澳大湾区</li><li>科技创新：神舟、天宫、嫦娥</li><li>中国对外战略：事件、人物、政策</li></ul>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;“思想政治理论”是研究生招生考试必考科目之一（为什么！┗|｀O′|┛），分为马原、毛中特、史纲、思修和时政5个大类。政治内容众多且杂，如果对基础概念和知识进行具体总结，篇幅非常长，本篇笔记只是以一个“Cheat-sheet”的形式尽可能包含所有考试重点，至于系统的归纳梳理则以肖精讲精练为准。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="学习生活" scheme="http://blog.zhuangzhihao.top/categories/%E5%AD%A6%E4%B9%A0%E7%94%9F%E6%B4%BB/"/>
    
    
  </entry>
  
  <entry>
    <title>操作系统（上）</title>
    <link href="http://blog.zhuangzhihao.top/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E4%B8%8A/"/>
    <id>http://blog.zhuangzhihao.top/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E4%B8%8A/</id>
    <published>2021-07-27T16:00:00.000Z</published>
    <updated>2021-09-19T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p> 操作系统（OS）是管理和控制计算机硬件与软件资源，是计算机上直接运行的最基本的系统软件，任何其他软件都必须在操作系统的支持下才能运行。操作系统是用户和计算机的接口，同时也是计算机硬件和其他软件的接口。操作系统的功能包括管理计算机系统的硬件、软件及数据资源，控制程序运行，提供人机交互界面，为其它应用软件提供支持等。我选择的课程是苏州大学的<a href="https://www.icourse163.org/course/SUDA-1001752241">国家精品课</a>和汤子瀛版教材，以下为所记课堂笔记上半部分，包含计算机操作系统概述、处理器管理的知识点，可供参考。下半部分笔记请访问<a href="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E4%B8%8B">操作系统（下）</a></p></blockquote><a id="more"></a><h3 id="操作系统概述"><a href="#操作系统概述" class="headerlink" title="操作系统概述"></a>操作系统概述</h3><h4 id="操作系统基本概念"><a href="#操作系统基本概念" class="headerlink" title="操作系统基本概念"></a>操作系统基本概念</h4><ul><li>冯诺依曼模型：运算器、存储器、控制器、输入设备和输出设备</li><li>引入操作系统的目的：提供一个计算机用户与计算机硬件系统之间的接口、有效的控制和管理计算机系统中的各种硬件和软件资源、合理地组织计算机系统的工作流程</li><li>操作系统是计算机系统的资源管理程序</li><li>操作系统的核心是控制和协调进程的运行，解决进程之间的通信</li><li>操作系统的发展：无操作系统阶段 -&gt; 单道批处理系统 -&gt; 多道批处理系统</li></ul><h4 id="操作系统的特征"><a href="#操作系统的特征" class="headerlink" title="操作系统的特征"></a>操作系统的特征</h4><ul><li>并行性：2个或多个事件在同一时刻发生</li><li>并发性：2个或多个事件在同一时间间隔内发生</li><li>并发和共享是操作系统的2个最基本的特征，二者之间互为存在条件</li><li>资源共享方式：互斥共享、同时访问</li><li>虚拟是指把一个物理上的实体变为若干个逻辑上的对应物</li><li>异步性</li></ul><h4 id="操作系统的功能和服务"><a href="#操作系统的功能和服务" class="headerlink" title="操作系统的功能和服务"></a>操作系统的功能和服务</h4><ul><li>处理器管理：进程控制、进程同步、进程通信、进程调度</li><li>存储器管理：内存分配、内存保护、内存扩充</li><li>设备管理：设备分配、设备传输控制、设备独立性</li><li>文件管理：文件存储空间的管理、目录管理、文件操作管理、文件保护</li><li>用户接口：命令接口、程序接口、图形接口<ul><li>联机命令接口又称交互式命令结构</li><li>脱机命令接口又称批处理命令接口</li></ul></li><li>操作系统3种基本类型：批处理操作系统、分时操作系统、实时操作系统</li><li>其他操作系统：嵌入式操作系统、集群系统、网络操作系统、分布式操作系统</li></ul><h4 id="操作系统的运行环境"><a href="#操作系统的运行环境" class="headerlink" title="操作系统的运行环境"></a>操作系统的运行环境</h4><ul><li>处理器的执行状态分为核心态与用户态<ul><li>核心态是操作系统管理程序执行时机器所处的状态</li><li>用户态是用户程序执行时机器所处的状态</li></ul></li><li>特权指令是只能由操作系统内核部分使用，不允许用户直接使用的指令，如I/O指令、设置中断屏蔽指令、清内存指令、存储保护指令和设置时钟指令</li><li>内核的指令操作工作在核心态<ul><li>时钟管理</li><li>中断机制</li><li>原语</li><li>系统控制的数据结构及处理</li></ul></li><li>异常，也称内中断，是由错误引起的</li><li>通常异常会引起中断，而中断未必是由异常引起的</li><li>系统调用（API）：进程控制、文件系统控制、系统控制、内存管理、网络管理、socket 管控、制用户管理以及进程间通信</li></ul><h4 id="操作系统的体系结构"><a href="#操作系统的体系结构" class="headerlink" title="操作系统的体系结构"></a>操作系统的体系结构</h4><ul><li>操作系统的体系结构主要包括模块组合结构、层次结构和微内核结构</li><li>模块组合结构<ul><li>接口简单直接，系统的效率相对较高</li><li>系统结构不清晰、可扩展性差、可适应性差</li></ul></li><li>层次结构<ul><li>按功能的调用次序排列成若干层</li><li>组织和依赖关系清晰明了，可读性、可适应性及可靠性都得到了增强</li><li>通常要将为进程提供服务的系统调用模块放在系统的内层。</li></ul></li><li>微内核结构<ul><li>客户服务器模式（C/S 模式）</li><li>每个服务进程运行在独立的用户进程中，可靠性好，灵活性好，便于维护</li><li>适合分布式处理的计算环境</li><li>效率不高，尤其是通信频繁的系统</li></ul></li></ul><h3 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h3><h4 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h4><ul><li><p>在计算机操作系统中，进程是资源分配的基本单位，也是独立运行的基本单位</p><ul><li>程序顺序执行时的特征：顺序性，封闭性，可再现性</li><li>程序的并发执行的特征：间断性，失去封闭性，不可再现性</li></ul></li><li><p>程序并发执行且其结果具有可再现性的条件（Bernstein 条件）</p><ul><li>R(p1) ∩ W(p2) = ∅</li><li>R(p2) ∩ W(p1) = ∅</li><li>W(p1) ∩ W(p2) = ∅</li></ul></li><li><p>进程的特征：动态性、并发性、独立性、异步性、结构特征（程序段、数据段和进程控制块）</p></li><li><p>进程和程序的关系</p><ul><li>进程和程序的关系程序是静止的</li><li>进程是暂时的，程序是永久的</li><li>进程的组成包括程序段、数据块和进程控制块（Process Control Block）</li><li>通过多次执行，一个程序可以产生多个不同的进程，通过调用关系，一个进程可以执行多个程序</li><li>进程可创建其他进程，而程序不能形成新的程序</li></ul></li><li><p>由程序段、相关数据段和PCB三部分构成的是进程映像，也叫进程实体</p><ul><li>映像是静态的，进程是动态的，进程是进程实体的运行过程</li></ul></li><li><p>进程和作业的区别</p><ul><li>作业是用户需要计算机完成某项任务而要求计算机所做的工作的集合</li><li>作业提交、作业收容、作业执行、作业完成</li><li>进程是已提交完毕的作业的执行过程，是资源分配的基本单位</li><li>作业是用户向计算机提交任务的任务实体，而进程是完成用户任务的执行实体</li><li>这个作业可由多个进程组成，而必须至少由一个进程组成，但一个进程不能构成多个作业</li></ul></li><li><p>进程的组成</p><ul><li>进程控制块（PCB）：标识进程的存在，刻画执行瞬间特征的数据机构</li><li>其他组成部分：程序段、数据段、进程标识符（PID）、进程当前状态、进程队列指针、程序和数据地址，进程优先级、CPU 现场保护区、通信信息、家族联系、占有资源清单</li></ul></li><li><p>PCB 是进程存在的唯一标志</p><ul><li>PCB 存在是为了保证程序的并发执行</li><li>创建进程实质上是创建进程的 PCB，而撤销进程实质上是撤销进程的 PCB</li><li>系统总是通过 PCB 对进程进行控制的</li></ul></li><li><p>进程的5种基本状态：就续状态、执行状态、阻塞状态、创建状态、结束状态</p><ul><li>执行状态只能由就绪状态转换，而无法由阻塞状态直接转换</li><li>不能从就绪状态变为阻塞状态</li><li>进程状态是唯一的</li></ul></li><li><p>进程的创建</p><ul><li>进程创建是通过创建原语实现的</li><li>申请一个空闲 PCB，并指定唯一的 PID -&gt; 分配必要的资源 -&gt; 将新进程的PCB初始化 -&gt; 插入到就绪队列</li><li>导致进程创建的事件：用户登录、作业调度和请求服务</li></ul></li><li><p>撤销一个进程：撤销原语</p><ul><li>找到被撤销进程的PCB -&gt; 停止该进程的执行 -&gt; 回收被撤销进程所占用的资源 -&gt; 回收PCB</li></ul></li><li><p>进程的阻塞与唤醒：两条低级进程通讯原语</p><ul><li>阻塞原语（P 原语）的功能是将进行进程由执行状态转为阻塞状态</li><li>唤醒原语（V 原语）的功能是将进程由阻塞状态变为就绪状态</li><li>一个进程由执行状态变为阻塞状态，是由这个进程自己调用阻塞原语去完成的</li><li>进程由阻塞状态变为就绪状态，是由另一个发现者进程调用唤醒原语去实现的。一般这个发现者进程与被唤醒进程是合作的并发进程</li></ul></li><li><p>调度是决定将系统资源分配给哪个进程，进程切换是实际分配系统资源</p><ul><li>进程切换一定会产生中断，但处理器模式切换不一定产生进程切换</li></ul></li><li><p>进程的互斥与同步就是一种进程间的通信方式</p><ul><li>高级进程通信方式：共享存储器系、消息传递系统、管道（共享文件）通信系统</li></ul></li></ul><h4 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h4><ul><li>线程是进程内一个相对独立的可调度的执行单元<ul><li>内核级线程依赖于内核，一个内核级线程由于 I/O 操作而阻塞时不会影响其他线程的运行</li><li>用户级线程不依赖于操作系统核心，由于操作系统内核不了解用户线程的存在，当一个线程阻塞时，整个进程必须等待</li></ul></li><li>进程与线程<ul><li>线程谁独立调度的基本单位，进程是拥有资源的基本单位</li><li>线程不拥有资源，但线程可以访问其隶属进程的系统资源</li><li>进程之间可以并发执行，同一进程内的多个线程之间也可以并发执行</li><li>多线程之间的同步与通信非常容易实现</li></ul></li><li>多线程模型：多对一模型，一对一模型，多对多模型（将多个用户级线程映射到多个内核级线程）</li></ul><h4 id="处理器的三级调度"><a href="#处理器的三级调度" class="headerlink" title="处理器的三级调度"></a>处理器的三级调度</h4><ul><li>高级调度（作业调度）：从外存上处于后备状态的作业中选择一个或多个，给他们分配内存等必要资源并建立相应的进程，以便该作业具有获得竞争处理器的权利<ul><li>作业调度每次要接纳多少个作业进入内存取决于多道程序的并发程度</li><li>多道程序的并发程度应根据系统的规模和运算速度来决定</li><li>应将哪些作业从外存调入内存取决于所采取的调度算法</li></ul></li><li>中级调度（交换调度）：按照给定的原则和策略，将处于外存对换区中具备运行条件的进程调入内存，并将其状态修改为就绪状态，挂在就绪队列上等待</li><li>低级调度（进程调度）：按照某种策略和方法，从就绪队列中选取一个进程，将处理器先分配给他<ul><li>进程调度的运行频率很高</li><li>作业调度的结果是为作业创造进程，而进程调度的结果是进程被执行</li></ul></li><li>衡量调度算法的性能： CPU利用率、系统吞吐量、响应时间、周转时间<ul><li>作业的周转时间 = 作业的完成时间 - 作业的提交时间</li><li>平均周转时间：多个作业周转时间的平均值</li><li>带权周转时间是作业周转时间与运行时间的比</li></ul></li></ul><h4 id="进程调度"><a href="#进程调度" class="headerlink" title="进程调度"></a>进程调度</h4><ul><li>处理器分配的任务由进程调度程序完成</li><li>进程调度的功能：记录系统中所有进程的有关情况以及状态特征，选择获得处理器的进程和处理器分配</li><li>引起进程调度的原因<ul><li>当前运行进程运行结束</li><li>当前运行进程因某种原因从运行状态进入阻塞状态</li><li>执行完系统调用等系统程序后返回用户进程</li><li>在采用抢占调度方式的系统中，一个更高优先级的进程要求使用处理器</li><li>在分时系统中分配给该进程的时间片已用完</li></ul></li><li>不能进行进程调度的情况<ul><li>处理中断的过程中</li><li>在操作系统内核程序临界区中</li><li>其他需要完全屏蔽中断的原子操作过程中</li></ul></li><li>进程调度的方式：抢占方式、非抢占方式</li></ul><h4 id="常见调度算法"><a href="#常见调度算法" class="headerlink" title="常见调度算法"></a>常见调度算法</h4><ul><li>先来先服务调度算法（作业调度、进程调度）<ul><li>FCFS：按照进程进入就绪队列的先后次序来分配处理器</li></ul></li><li>短作业优先调度算法（作业调度、进程调度）<ul><li>SJF：把处理器分配给最快完成的作业或进程</li></ul></li><li>优先级调度算法（作业调度、进程调度）<ul><li>静态优先级是在创建进程时确定的，确定之后整个进程运行期间不再改变</li><li>按进程类、作业的资源要求、用户类型和要求确定静态优先级</li><li>动态优先级是指在创建进程时根据进程的特点及相关情况确定一个优先级</li><li>根据进程占有CPU时间的长短和就绪进程等待CPU时间的长短确定动态优先级</li><li>基于优先级的调度算法还可按调度方式的不同，分为非抢占优先级调度算法和抢占优先级调度算法</li><li>在优先级相同的情况下，通常按照先来先服务或者短作业优先的顺序执行</li></ul></li><li>时间片轮转调度算法（进程调度）<ul><li>分时系统必须满足系统对响应时间的要求</li><li>就绪队列中的进程数与时间片的大小成反比</li><li>系统的处理能力决定时间片的大小</li></ul></li><li>高响应比优先调度算法（作业调度）<ul><li>响应比 = 作业响应时间 / 估计运行时间</li><li>作业响应时间 = 作业等待时间 + 估计运行时间</li></ul></li><li>多级反馈队列调度算法（作业调度）<ul><li>时间片轮转调度算法和优先级调度算法的综合与发展</li></ul></li></ul><h4 id="同步与互斥"><a href="#同步与互斥" class="headerlink" title="同步与互斥"></a>同步与互斥</h4><ul><li><p>互斥是间接相互制约关系，而同步是直接相互制约关系</p></li><li><p>只要是同类进程即为互斥关系，不同类进程即为同步关系</p></li><li><p>临界资源：同时仅允许一个进程使用的资源</p><ul><li>进入区、临界区、退出区、剩余区</li><li>临界区：进程中用于访问临界资源的代码，又称临界段</li><li>临界资源是必须互斥访问的资源，这种资源同时只能被一个进程所使用，但需要这种资源的进程不止一个，因此需要对使用临界资源的进程进行管理</li><li>每个进程的临界区代码可以不相同</li></ul></li><li><p>互斥的要求：空闲让进，忙则等待，有限等待，让权等待</p></li><li><p>互斥实现方法</p><ul><li>软件实现方法</li><li>互斥实现的硬件方法：中断屏蔽、硬件指令</li><li>硬件方法适用范围广，支持多个临界区，但不能实现让权等待</li></ul></li></ul><h4 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h4><ul><li>信号量 <code>(s,q)</code> 及同步原语<ul><li>整型变量 s 表示系统中某类资源的数目，q 是一个初始状态为空的队列</li><li>信号量的值仅能由 P 操作（wait）操作和 V 操作（signal）操作改变，操作系统利用它的状态对进程和资源进行管理</li><li> P 操作相当于申请资源，V 操作相当于释放资源</li></ul></li><li>信号量分为整型信号量和记录型信号量（资源信号量）<ul><li>记录型信号量添加了链表结构用于链接所有等待该资源的进程，解决忙等的问题</li></ul></li><li>信号量可以用来实现进程互斥和描述前趋关系</li></ul><h4 id="经典同步问题"><a href="#经典同步问题" class="headerlink" title="经典同步问题"></a>经典同步问题</h4><ul><li>生产者-消费者问题<ul><li>P(full) / P(empty) 与 P(mutex) 的顺序不可倒，必须先对资源信号量进行 P 操作，再对互斥信号量进行 P 操作。否则会导致死锁</li><li>互斥信号量就是给同类进程准备的</li></ul></li><li>读者写者问题（许多进程共享数据区）<ul><li>读者不互斥，写者必须互斥</li><li>读者优先，公平情况和写者优先三种不同算法</li></ul></li><li>哲学家进餐问题<ul><li>最多允许4个哲学家同时进餐</li><li>仅当一个哲学家左右两边的筷子同时可用时，他才可以拿起筷子</li><li>将哲学家编号要求奇数号的哲学家先拿左边筷子，偶数号的哲学家先拿右边筷子</li></ul></li><li>理发师问题</li><li>信号量机制问题的解题步骤分析<ul><li>关系分析</li><li>确定临界资源</li><li>整理思路</li></ul></li><li>实现同步互斥的 P、V 操作必须成对出现，先进行 P 操作进入临界区，后进行 V 操作退出临界区</li><li> P、V操作要分别紧靠临界区的头尾部</li><li>通常用于互斥的信号量初值设为 1</li></ul><h4 id="管程"><a href="#管程" class="headerlink" title="管程"></a>管程</h4><ul><li>管程定义了一个数据结构和能为并发进程所执行的一组操作<ul><li>局部于管程的数据只能被局部于管程内的过程所访问</li><li>一个进程只有通过调用管程内的过程才能进入管程访问共享数据</li><li>每次仅允许一个进程在管程内执行某个内部过程，即进程互斥地通过调用内部过程进入管程</li></ul></li><li>管程的互斥访问完全由编译程序在编译时自动添加</li><li>为实现进程间的同步，管程还必须包含若干用于同步的设施<ul><li>局限于管程并仅能从管程内进行访问的若干变量，用于区别各种不同的等待原因</li><li>在条件变量上进行操作的两个函数过程，wait 和 signal</li></ul></li></ul><h4 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h4><ul><li>死锁的概念<ul><li>参死锁的进程至少有两个</li><li>每个参与死锁的进程均等待资源</li><li>参与死锁的进程中至少有两个进程占有资源</li><li>死锁进程是系统中当前进程集合的一个子集</li></ul></li><li>死锁产生的原因是竞争资源<ul><li>一个资源是否属于可剥夺资源，完全取决于资源本身的性质</li></ul></li><li>死锁产生的必要条件<ul><li>互斥条件</li><li>不剥夺条件</li><li>请求于保持条件：可采用预先静态分配方法</li><li>环路等待条件：可采用有序资源分配法</li></ul></li><li>处理死锁的方法：鸵鸟算法、预防死锁、避免死锁、检测及解除死锁（被动）<ul><li>死锁预防对系统加的限制条件通常很严格，对系统的并发性会产生很大的副作用</li><li>死锁避免往往在资源被分配出去之前，要计算分配之后系统是否安全</li></ul></li><li>死锁的避免<ul><li>系统在进行资源分配之前，先计算资源分配的安全性（安全序列）</li><li>并非所有不安全状态都是死锁状态，死锁是不安全状态的真子集</li><li>银行家算法</li></ul></li><li>死锁的检测和解除<ul><li>系统资源分配图（system resource allocation graph）可定义为一个二元组</li><li><code>SRAG = (V,E)</code></li><li>死锁定理：不同简化顺序将得到相同的不可简化图。系统状态 S 为死锁状态的条件是当且仅当 S 状态的资源分配图是不可完全简化的</li><li>死锁检测算法：available、allocation、request、临时变量（work与finish）</li><li>死锁解除：剥夺资源，撤销进程，进程回退</li></ul></li><li>进程与饿死<ul><li>当等待时间给进程推进和响应带来明显影响时，发生进程饥饿</li><li>当饥饿到一定程度，进程所赋予的任务即使完成也不再具有实际意义时，进程被饿死</li><li>活锁：在忙时等待条件下发生的饥饿</li><li>饥饿和饿死与资源分配策略有关，因而可从公平性方面考虑防止饥饿与饿死</li></ul></li></ul>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt; 操作系统（OS）是管理和控制计算机硬件与软件资源，是计算机上直接运行的最基本的系统软件，任何其他软件都必须在操作系统的支持下才能运行。操作系统是用户和计算机的接口，同时也是计算机硬件和其他软件的接口。操作系统的功能包括管理计算机系统的硬件、软件及数据资源，控制程序运行，提供人机交互界面，为其它应用软件提供支持等。我选择的课程是苏州大学的&lt;a href=&quot;https://www.icourse163.org/course/SUDA-1001752241&quot;&gt;国家精品课&lt;/a&gt;和汤子瀛版教材，以下为所记课堂笔记上半部分，包含计算机操作系统概述、处理器管理的知识点，可供参考。下半部分笔记请访问&lt;a href=&quot;/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E4%B8%8B&quot;&gt;操作系统（下）&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="计算机专业" scheme="http://blog.zhuangzhihao.top/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%93%E4%B8%9A/"/>
    
    
    <category term="Operating System" scheme="http://blog.zhuangzhihao.top/tags/Operating-System/"/>
    
  </entry>
  
  <entry>
    <title>计算机组成原理（上）</title>
    <link href="http://blog.zhuangzhihao.top/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E4%B8%8A/"/>
    <id>http://blog.zhuangzhihao.top/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E4%B8%8A/</id>
    <published>2021-07-13T16:00:00.000Z</published>
    <updated>2021-08-14T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>计算机组成原理是计算机专业本科教学中的重要课程，它可以帮助我们系统地理解计算机硬件系统的组织结构和工作原理、掌握计算机硬件系统的基本分析与设计方法以及建立计算机系统的整体概念，为进一步学习计算机设计实践课程、培养系统开发、调试以及设计创新能力奠定良好的基础。计组是考研的最重最难点，在408计算机学科专业基础综合考试中占有45分。我选择的课程是哈工大的<a href="https://www.icourse163.org/course/hit-309001">国家精品课</a>，配合天勤高分笔记，以下为所记课堂笔记上半部分，包含计算机系统概论、数据的表示和运算、存储器和指令系统的知识点，可供参考。下半部分笔记请访问<a href="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E4%B8%8B">计算机组成原理（下）</a></p></blockquote><a id="more"></a><h3 id="计算机系统概论"><a href="#计算机系统概论" class="headerlink" title="计算机系统概论"></a>计算机系统概论</h3><h4 id="计算机的发展历程"><a href="#计算机的发展历程" class="headerlink" title="计算机的发展历程"></a>计算机的发展历程</h4><ul><li>电子管时代 -&gt; 晶体管时代 -&gt; 中小规模集成电路时代 -&gt; 超大规模集成电路时代 -&gt; 智能计算机 -&gt; 生物计算机/量子计算机</li><li>冯·诺依曼计算机（SISD）<ol><li>由运算器、存储器、控制器、输入设备和输出设备组成</li><li>指令和数据用二进制表示，以同等地位存于存储器，可按地址寻访</li><li>指令由操作码和地址码组成</li><li>存储程序，且以运算器为中心</li></ol></li></ul><h4 id="计算机的基本组成"><a href="#计算机的基本组成" class="headerlink" title="计算机的基本组成"></a>计算机的基本组成</h4><ul><li>计算机系统由硬件和软件组成，软件分为系统软件和应用软件</li><li>软硬件在逻辑上是等效的</li><li>计算机硬件主要由存储器、运算器、控制器、输入设备和输出设备组成<ul><li>运算器 ALU + 控制器 CU = CPU</li><li>主存 + 辅存 = 存储器</li><li>CPU + 主存储器 = 主机</li><li>现代计算机为以存储器为中心，指令和数据都是保存在存储器中的</li></ul></li><li>存储器的基本组成：存储体 -&gt; 存储单元 -&gt; 存储元<ul><li>存储单元：存放一串二进制代码，每个存储单元赋予一个地址号</li><li>存储字：存储单元中二进制代码的组合</li><li>存储字长：存储字的位数</li><li>地址寄存器 MAR：存放访存地址，N 位长的 MAR 可映射到 $2^N$ 个地址</li><li>数据寄存器 MDR：暂存从主存中读写的信息，MDR 长度等于存储字长</li><li>按字节寻址和数据线无关，只和地址线有关</li><li>按字寻址，数据线个数等于存储字长位数</li><li>字地址是连续存储单元地址中的最小值</li></ul></li><li>运算器的核心是算术逻辑单元 ALU<table><thead><tr><th></th><th>ACC 累加器</th><th>MQ 乘商寄存器</th><th>X 操作数寄存器</th></tr></thead><tbody><tr><td>加法</td><td>被加数、和</td><td></td><td>加数</td></tr><tr><td>减法</td><td>被减数、差</td><td></td><td>减数</td></tr><tr><td>乘法</td><td>乘积高位</td><td>乘数、乘积地位</td><td>被乘数</td></tr><tr><td>除法</td><td>被除数、余数</td><td>商</td><td>除数</td></tr></tbody></table></li><li>控制器的功能：解释指令、保证指令的按序执行<ul><li>取指令 -&gt; 分析指令 -&gt; 执行指令</li><li>程序计数器 PC：存放当前欲执行指令的地址，具有计数功能（PC）+1 -&gt; PC</li><li>指令寄存器 IR：存放当前欲执行的指令，IR 的内容来自主存的 MDR</li><li>控制单元 CU</li></ul></li><li>主机完成一条指令的过程：<ul><li>输入程序 -&gt; 程序首地址 -&gt; PC -&gt; 启动程序运行</li><li>取指令：PC -&gt; MAR -&gt; M -&gt; MDR -&gt;IR</li><li>分析指令：OP（IR）-&gt; CU</li><li>执行指令：Ad（IR）-&gt; MAR -&gt; M -&gt; MDR -&gt; ACC</li></ul></li><li>计算机系统的层次结构：高级语言 -&gt; 汇编语言 -&gt; 操作系统 -&gt; 机器语言 -&gt; 微指令系统</li></ul><h4 id="计算机硬件的主要技术指标"><a href="#计算机硬件的主要技术指标" class="headerlink" title="计算机硬件的主要技术指标"></a>计算机硬件的主要技术指标</h4><ul><li>机器字长：CPU一次能处理数据的位数，与CPU中的寄存器位数有关</li><li>运算速度：主频、核数及每个核支持的线程数<ul><li>吉普森法：$T_{M}=\sum ^{n}<em>{i=1}f</em>{i}t_{i}$</li><li>CPI：执行一条指令所需时钟周期数</li><li>MIPS：每秒执行百万条指令</li><li>FLOPS：每秒浮点运算次数</li><li>在指令数和时钟周期一定的前提下，CPI越大，执行时间越长</li></ul></li><li>存储容量：存放二进制信息的总位数<ul><li>主存容量：存储单元个数 × 存储字长，字节数</li><li>辅存容量：字节数</li></ul></li></ul><h3 id="数据的表示和运算"><a href="#数据的表示和运算" class="headerlink" title="数据的表示和运算"></a>数据的表示和运算</h3><h4 id="数制与编码"><a href="#数制与编码" class="headerlink" title="数制与编码"></a>数制与编码</h4><ul><li>十进制换二进制：整数除二取余，由下而上；小数乘二取整，由上而下 </li><li>二进制基本符号少，易于用稳态电路实现，编码、计数、逻辑运算规则简单</li><li>八进制 Q，十六进制 H</li><li>真值换机器数：0正1负</li><li>有权BCD码（8421）：逢1001进位，4位一数，C正D负放队尾，偶数位数高位补零</li><li>余3码：8421码的基础上加十进制3（0011）</li><li>ASCII：”0”：48；”A”：65；”a”：97</li><li>国标码 = (区位码)H + 2020H</li><li>汉字内码 = (国标码)H + 8080H</li><li>奇偶校验码：添加一位校验码后使整个码字里1的个数为奇数/偶数</li><li>循环冗余校验码 CRC：检错编码</li><li>海明码：纠错编码</li></ul><h4 id="定点数"><a href="#定点数" class="headerlink" title="定点数"></a>定点数</h4><p>- </p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;计算机组成原理是计算机专业本科教学中的重要课程，它可以帮助我们系统地理解计算机硬件系统的组织结构和工作原理、掌握计算机硬件系统的基本分析与设计方法以及建立计算机系统的整体概念，为进一步学习计算机设计实践课程、培养系统开发、调试以及设计创新能力奠定良好的基础。计组是考研的最重最难点，在408计算机学科专业基础综合考试中占有45分。我选择的课程是哈工大的&lt;a href=&quot;https://www.icourse163.org/course/hit-309001&quot;&gt;国家精品课&lt;/a&gt;，配合天勤高分笔记，以下为所记课堂笔记上半部分，包含计算机系统概论、数据的表示和运算、存储器和指令系统的知识点，可供参考。下半部分笔记请访问&lt;a href=&quot;/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E4%B8%8B&quot;&gt;计算机组成原理（下）&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="计算机专业" scheme="http://blog.zhuangzhihao.top/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%93%E4%B8%9A/"/>
    
    
    <category term="Computer Organization" scheme="http://blog.zhuangzhihao.top/tags/Computer-Organization/"/>
    
  </entry>
  
  <entry>
    <title>数据结构（上）</title>
    <link href="http://blog.zhuangzhihao.top/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%B8%8A/"/>
    <id>http://blog.zhuangzhihao.top/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%B8%8A/</id>
    <published>2021-06-27T16:00:00.000Z</published>
    <updated>2021-08-25T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>数据结构是指数据的存储结构，是带有结构特性的数据元素的集合。精心选择的数据结构可以带来更好的运行或者存储效率。数据结构是计算机科学与技术专业、软件工程专业甚至于其它电气信息类专业的重要专业基础课程，在408计算机学科专业基础综合考试中占有45分。我选择的课程是浙江大学数据结构<a href="https://www.icourse163.org/course/ZJU-93001">国家精品课</a>，以下为所记课堂笔记第一部分，包含C/C++语言基础、线性表、栈和队列的知识总结以及所需记忆的代码，另外我在开源仓库中还保持了浙大慕课版本的<a href="https://github.com/Bezhuang/LearnCS/tree/main/%E5%90%8D%E6%A0%A1%E5%85%AC%E5%BC%80%E8%AF%BE/%E6%B5%99%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84">代码</a>，可供参考。其他部分笔记详见<a href="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%B8%AD">数据结构（中）</a>和<a href="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%B8%8B">数据结构（下）</a></p></blockquote><a id="more"></a><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><h4 id="C-C-语言基础"><a href="#C-C-语言基础" class="headerlink" title="C/C++语言基础"></a>C/C++语言基础</h4><ul><li>数据类型<ul><li>结构型 <code>int a[maxSize];</code></li><li>指针型 <code>int *a;</code></li><li>链表结点<pre><code class="C">typedef struct Node&#123;  int data;  struct Node *next;&#125;Node;</code></pre></li><li>二叉树结点<pre><code class="C">typedef struct BTNode&#123;  int data;  struct BTNode *lchild;  struct BTNode *rchild;&#125;BTNode;</code></pre></li><li>动态申请数组空间<pre><code class="C">int *p;p=(int *)malloc(n * sizeof(int));</code></pre></li></ul></li><li>函数<ul><li>函数参数的引用型定义<pre><code class="cpp">int a=0;void f(int &amp;x)&#123;  ++x;&#125;f(a);</code></pre></li><li>数组作参数的引用型定义<pre><code class="cpp">void f(int x[][maxSize], int n)&#123;···;&#125;</code></pre></li></ul></li></ul><h4 id="算法的时间复杂度和空间复杂度"><a href="#算法的时间复杂度和空间复杂度" class="headerlink" title="算法的时间复杂度和空间复杂度"></a>算法的时间复杂度和空间复杂度</h4><ul><li>时间复杂度 <ul><li>$T(n)=O(f(n)中增长最快的项的系数)$</li><li>将最坏的情况作为算法时间复杂度的度量</li><li>$O(1)≤O(\log_{2}\left(n\right)≤O(n)≤O(n\log_{2}\left(n\right)≤O(n^2)≤O(2^n)$（常对幂指阶）</li><li>取最深层循环内的语句所描述的操作为基本操作，由循环基本执行的次数为规模n，计算函数 $f(n)$</li></ul></li><li>空间复杂度：算法在运行时所需存储空间的度量，主要考虑在算法运行过程中临时占用的存储空间大小<ul><li>空间复杂度 = 函数递归调用的深度</li></ul></li></ul><h4 id="数据结构基本概念"><a href="#数据结构基本概念" class="headerlink" title="数据结构基本概念"></a>数据结构基本概念</h4><ul><li>数据是对客观事物的符号表示</li><li>数据元素是数据的基本单位</li><li>数据对象是性质相同的数据元素的集合</li><li>数据结构是相互之间存在一种或多种特定关系的数据元素的集合<ul><li>数据的逻辑结构是对数据之间关系的描述，分为线性结构（一个数据元素的次序集合）和非线性结构（树、图）</li><li>数据的存储（物理）结构是数据的逻辑结构在计算机中的表示（映像），包括数据元素的表示和关系的表示</li></ul></li><li>数据元素之间的关系：顺序映像和非顺序映像</li><li>数据结构中常用储存方法：顺序存储（数组）、链式存储（指针）、索引存储 <code>&lt;关键字, 地址&gt;</code>、散列存储（根据结点的关键字通过散列函数直接计算出该结点的存储地址）</li></ul><h4 id="算法的基本概念"><a href="#算法的基本概念" class="headerlink" title="算法的基本概念"></a>算法的基本概念</h4><ul><li>算法的特性：有穷性、确定性、输入、输出、可行性</li><li>算法的设计目标：正确性、可读性、健壮性、高效率和低存储量需求</li></ul><h3 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h3><h4 id="线性表的基本概念"><a href="#线性表的基本概念" class="headerlink" title="线性表的基本概念"></a>线性表的基本概念</h4><ul><li>线性表是具有相同特性数据元素的一个有限序列，长度 $n≥0$</li><li>线性表只有一个表头元素，一个表尾元素，除表头表尾元素外其他元素只有一个直接前驱和一个直接后继（有序性）</li><li>顺序表：随机访问特性、要求占用连续的存储空间、做插入操作要移动多个元素</li><li>链表：不支持随机访问、结点的存储空间利用率稍低、支持存储空间的动态分配</li><li>头指针指向链表的第一个结点、头结点指向带头结点链表的第一个结点</li><li>单链表、双链表、循环单链表、循环双链表、静态链表（数据元素分量+指针分量）</li></ul><h4 id="线性表的结构体定义"><a href="#线性表的结构体定义" class="headerlink" title="线性表的结构体定义"></a>线性表的结构体定义</h4><ul><li>顺序表<pre><code class="cpp">typedef struct&#123;  int data[maxSize];   //考试写这两行  int length;         //&#125;Sqlist;</code></pre></li><li>单链表<pre><code class="cpp">typedef struct LNode&#123;  int data;  struct LNode *next;&#125;LNode//构造LNode型结点LNode *A = (LNode*)malloc(sizeof(LNode));</code></pre></li><li>双链表<pre><code class="cpp">typedef struct DLNode&#123;  int data;  struct DLNode *prior;  struct DLNode *next;&#125;DLNode;</code></pre></li></ul><h4 id="顺序表的操作"><a href="#顺序表的操作" class="headerlink" title="顺序表的操作"></a>顺序表的操作</h4><ul><li><p>插入元素</p><ul><li>1 ≤ i ≤ ListLength(L）</li></ul><pre><code class="cpp">int ListInsert(SeqList *L,int i,ElemType *e)&#123;  int k；  if(L-&gt;length==MAXSIZE)/*顺序线性表已经满*/    return ERROR;  if（i&lt;1 || i&gt;L-&gt;length+1)/*当 i 不在范围内时*/    return ERROR;  if(i&lt;=L-&gt;length)  &#123;            /*若插入数据位置不在表尾*/    for(k=L-&gt;length-1；k&gt;=i-1；k--)    /*将要插入位置后的数据元素向后移动一位*/      L-&gt;data[k+1]=L-&gt;data[k];  &#125;  L-&gt;data[i-1]=e;/*将新元素插入*/  L-&gt;length++;  return OK;&#125;</code></pre></li><li><p>删除元素</p><pre><code class="cpp">int ListDelete(SqList *L,int i,ElemType *e)&#123;  int k;  if (L-&gt;length==0)/*线性表为空*/    return ERROR;  if(i&lt;1|| i&gt;L-&gt;length)/*删除位置不正确*/    return ERROR;  *e=L-&gt;data[i-1];  if(i&lt;L-&gt;1ength)  &#123;    /*如果删除不是最后位置*/    for（k=i；k&lt;L-&gt;length;k++)/*将删除位置后继元素前移*/    L-&gt;data[k-1]=L-&gt;data[k];  &#125;  L-&gt;length--；  return OK;&#125;</code></pre></li><li><p>查找元素</p><pre><code class="cpp">int findElem (Sqlist L, int e)&#123;  int i;  for (i=0; i&lt;L.length; ++i)    if (e==L.data[i])      return i;  return -1;&#125;</code></pre></li><li><p>求指定位置元素</p><pre><code class="cpp">int getElem(Sqlist L, int p, int &amp;e)  if(p&lt;0||p&gt;L.length-1)    return 0;  e=L.data[p];  return 1;</code></pre></li></ul><h4 id="单链表的操作"><a href="#单链表的操作" class="headerlink" title="单链表的操作"></a>单链表的操作</h4><ul><li><p>尾插法建立链表C</p><pre><code class="cpp">void createlistR(LNode *&amp;C, int a[], int n)&#123;  LNode *s, *r;  //s指向新申请结点，r指向C的终端结点  int i;  C=(LNode *)malloc(sizeof(LNode));  //申请C的头结点空间  C-&gt;next=NULL;  r=C;  for (i=0; i&lt;n; ++i)  &#123;    s=(LNode *)malloc(sizeof(LNode));    s-&gt;data=a[i];    r-&gt;next=s;    r=r-&gt;next;  &#125;  r-&gt;next=NULL;&#125;</code></pre></li><li><p>归并成递减的单链表</p><pre><code class="cpp">void merge (LNode *A, LNode *B, LNode *C)&#123;  LNode *p=A-&gt;next;  LNode *q=B-&gt;next;  LNode *s;  C=A;  C-&gt;next=NULL;  free(B);  while(p!=NULL&amp;&amp;q!=NULL)  &#123;    /*下面的if else体现了头插法*/    if(p-&gt;data&lt;=q-&gt;data)    &#123;      s=p;p-&gt;next;      s-&gt;next=C-&gt;next;      C-next=s;    &#125;    else    &#123;      s=q;q=q-&gt;next;      s-&gt;next=C-&gt;next;      C-&gt;next=s;    &#125;  &#125;  while(p!=NULL)  &#123;    s=p;    p=p-&gt;next;    s-&gt;next=C-&gt;next;    C-&gt;next=s;  &#125;  while(q!=NULL)  &#123;    s=q;    q=q-&gt;next;    s-&gt;next=C-&gt;next;    C-&gt;next=s;  &#125;&#125;</code></pre></li><li><p>单链表获取元素</p><ul><li>用 e 返回表中第 i 个数据元素的值</li></ul><pre><code class="cpp">int GetElem(LinkList L,int i,ElemType *e)&#123;  int j=1;    /*j 为计数器*/  LinkList p;    /*声明一节点 p*/  p=L-&gt;next;    /*p 指向链表 L 的第一个节点*/  while(p &amp;&amp; j&lt;i)   &#123;     /*当 p 不为空并且计数器不等于 i 时，循环继续*/    p=p-&gt;next； /*p 指向下一个节点*/    ++j;  &#125;  if(!p || j &gt; i)    return ERROR;  *e = p-&gt;data;  return OK;&#125;</code></pre></li><li><p>单链表插入元素</p><pre><code class="cpp">int ListInsert(LinkList *L,int i,ElemType e)&#123;  int j=1；    LinkList p,s;    p=*L；    while (p &amp;&amp; j&lt;i)     /*寻找第 i 个节点*/    &#123;        p=p-&gt;next;        ++j；    &#125;  if (!p || j&gt;i)  return ERROR;     /*第 i 个元素不存在*/  s=(LinkList *) malloc (sizeof(Node));    /*生成新节点（C 标准函数）*/  s-&gt;data=e;  s-&gt;next=p-&gt;next;    //将 p 的后继节点赋值给 s 的后继*）  p-&gt;next=s;       //将 s 赋值给 p 的后继  return OK;&#125;</code></pre></li></ul><h4 id="双链表的操作"><a href="#双链表的操作" class="headerlink" title="双链表的操作"></a>双链表的操作</h4><ul><li><p>尾插法建立双链表</p><pre><code class="cpp">void createDlistR(DLNode *&amp;L, int a[], int n)&#123;  DLNode *s, *r;  //s指向新申请结点，r指向C的终端结点  int i;  L=(DLNode *)malloc(sizeof(DLNode));  L-&gt;prior=NULL;  L-&gt;next=NULL;  r=L;    //和单链表一样，r始终指向终端节点，开始头节点也是尾节点  for (i=0; i&lt;n; ++i)  &#123;    s=(DLNode *)malloc(sizeof(DLNode));    s-&gt;data=a[i];    r-&gt;next=s;    s-&gt;prior=r;    r=s;  &#125;  r-&gt;next=NULL;&#125;</code></pre></li><li><p>双链表寻找结点</p><pre><code class="cpp">DLNoded* findNode(DLNode *C, int x)&#123;  DLNode *p=C-&gt;next;  while(p!=NULL)  &#123;    if(p-&gt;data==x)        break;    p=p-&gt;next;  &#125;  return p;  //如果找到，则P中内容是结点地址，如果没找到，则P中内容是NULL&#125;</code></pre></li><li><p>双链表插入结点</p><pre><code class="cpp">s-&gt;prior = p; s-&gt;next = p-&gt;next; p-&gt;next-&gt;prior = s; p-&gt;next = s; </code></pre></li><li><p>双链表删除结点</p><pre><code class="cpp">p-&gt;prior-&gt;next = p-&gt;next; p-&gt;next-&gt;prior = p-&gt;prior; free(p)     //释放空间，不要漏掉</code></pre></li><li><p>链表的逆置</p><pre><code class="cpp">ListNode* reverseList(ListNode head)&#123;  if(head == NULL || head-&gt;next == NULL)      return head;      ListNode* newhead = reverseList(head-&gt;next);   //递归到链尾      head-&gt;next-&gt;next = head;    //反转链表      head-&gt;next = NULL;    //将指针置NULL      return newhead;    //newhead始终指向新链表的头&#125;</code></pre></li></ul><h4 id="循环链表的操作"><a href="#循环链表的操作" class="headerlink" title="循环链表的操作"></a>循环链表的操作</h4><ul><li><p>逆置循环链表</p><ul><li>只交换节点中的数据成员 data，其他的前后指针不变</li></ul><pre><code class="cpp">void Reverse () &#123;   LinkList * begin = _head;   LinkList * end = _tail;   while (begin != end &amp;&amp; begin-&gt;_prev != end)   &#123;      swap(begin-&gt;_data, end-&gt;_data);      begin = begin-&gt;_next;      end = end-&gt;_prev;   &#125; &#125; </code></pre></li><li><p>删除顺序表中值在 min 和 max 之间的数</p><ul><li>对顺序表进行遍历查找介于 min 与 max 之间的数然后进行删除</li></ul><pre><code class="cpp">void Delete(Seqlist *L,int min,int max)&#123;  int i=0,n=0;  while(i&lt;L-&gt;length)   &#123;        if(L-&gt;elem[i]&gt;=min &amp;&amp; L-&gt;elem[i]&lt;=max)            n++;         else            L-&gt;elem[i-n]=L-&gt;elem[i];        i++;    &#125;  L-&gt;length -= n;   if(L-&gt;length==0)  printf(&quot;the sqlist ie empty/n&quot;); &#125; </code></pre></li></ul><h3 id="栈和队列"><a href="#栈和队列" class="headerlink" title="栈和队列"></a>栈和队列</h3><h4 id="栈和队列的基本概念"><a href="#栈和队列的基本概念" class="headerlink" title="栈和队列的基本概念"></a>栈和队列的基本概念</h4><ul><li>栈是一种只能在一端进行插入或删除操作的线性表（FILO）<ul><li>栈顶（Top）动态变化，栈底固定不变</li></ul></li><li>队列为仅允许在表的一端进行插入，在表的另一端进行删除的线性表（FIFO）<ul><li>队头（Front）可进行删除，队尾（Rear）可进行插入</li></ul></li></ul><h4 id="栈和队列的结构体定义"><a href="#栈和队列的结构体定义" class="headerlink" title="栈和队列的结构体定义"></a>栈和队列的结构体定义</h4><ul><li><p>顺序栈的定义</p><pre><code class="cpp">typedef struct&#123;  int data[maxSize];  int top;&#125; SqStack;</code></pre></li><li><p>链栈结点的定义</p><pre><code class="cpp">typedef struct LNode&#123;  int data;  struct LNode *next;&#125;  LNode;</code></pre></li><li><p>顺序队列的定义</p><pre><code class="cpp">typedef struct&#123;  int data[maxSize];  int front;  int rear;&#125; SqQueue;</code></pre></li><li><p>链队结点的定义</p><pre><code class="cpp">typedef struct QNode&#123;  int data;  struct QNode *next;&#125; QNode;</code></pre></li><li><p>链队类型的定义</p><pre><code class="cpp">typedef struct&#123;  QNode *front;  QNode *rear;&#125; LiQueue;</code></pre></li></ul><h4 id="顺序栈"><a href="#顺序栈" class="headerlink" title="顺序栈"></a>顺序栈</h4><ul><li><p>栈空状态：<code>st.top==-1</code></p></li><li><p>栈满状态：<code>st.top==maxSize-1</code></p></li><li><p>非法状态：栈满后继续入站上溢，栈空继续出栈下溢</p></li><li><p>定义一个栈并初始化：<code>int stack[maxSize]; int top==-1</code></p></li><li><p>进栈：先移动指针再进栈</p><ul><li><code>stack[++top]=x</code>;</li></ul><pre><code class="cpp">int push(SqStack &amp;st,int x)&#123;  if(st.top==maxSize-1)    return 0;  ++(st.top);  st.data[st.top]=x;  return 1;&#125;</code></pre></li><li><p>出栈：先取出元素，再移动指针</p><ul><li><code>x=stack[top--];</code></li></ul><pre><code class="cpp">int pop(SqStack &amp;st,int &amp;x)&#123;  if(st.stop==-1)    return 0;    //栈空不能出栈  x = st.data[st.top];  --(st.top);  return 1;&#125;</code></pre></li></ul><h4 id="链栈"><a href="#链栈" class="headerlink" title="链栈"></a>链栈</h4><ul><li>栈空状态：<code>lst-&gt;next==NULL</code></li><li>不存在栈满状态</li><li>进栈：头插法建立链表中的插入操作<ul><li><code>p-&gt;next=lst-&gt;next; lst-&gt;next=p;</code></li></ul></li><li>出栈：单链表的删除操作，出栈元素保存在 x 中<ul><li><code>p-lst-&gt;next; x=p-&gt;data; lst-&gt;next=p-&gt;next; free(p);</code></li></ul></li></ul><h4 id="循环队列"><a href="#循环队列" class="headerlink" title="循环队列"></a>循环队列</h4><ul><li><p>解决假溢出：<code>front=(front+1)%maxSize</code></p></li><li><p>队空状态：<code>qu.rear==qu.front</code></p></li><li><p>队满状态：<code>(qu.rear+1)%maxSize==qu.front</code></p></li><li><p>初始化队列：队首和队尾指针重合，并且指向0</p><ul><li><code>qu.front=qu.rear=0;</code></li></ul></li><li><p>进队算法</p><pre><code class="cpp">int enQueue(SqQueue qu)&#123;  if((qu.rear+1)%maxSize==qu.front)    return 0  qu.rear=(qu.rear+1)%maxSize;    //先移动指针  qu.data[qu.rear]=x;    //再存入元素  return 1;&#125;</code></pre></li><li><p>出队算法</p><pre><code class="cpp">int denQueue(SqQueue &amp;qu, int &amp;x)&#123;  if(qu.rear==qu.front)    return 0;  qu.front=((qu.front+1)%maxSize)    //先移动指针  x=qu.data[qu.front];  return 1;&#125;</code></pre></li></ul><h4 id="链队（尽量避免使用）"><a href="#链队（尽量避免使用）" class="headerlink" title="链队（尽量避免使用）"></a>链队（尽量避免使用）</h4><ul><li><p>队空状态：<code>lqu-&gt;rear==NULL</code> 或者 <code>lqu-&gt;front==NULL</code></p></li><li><p>不存在队满状态</p></li><li><p>初始化链队</p><pre><code class="cpp">void initQueue(LiQueue *&amp;lqu)&#123;  lqu=(LiQueue*)malloc(sizeof(LiQueue));  lqu-&gt;front=lqu-&gt;rear=NULL;&#125;</code></pre></li><li><p>进队操作：<code>lqu-&gt;rear-&gt;next=p;  lqu-&gt;rear=p;</code></p></li><li><p>出队操作：<code>p=lqu-&gt;front; lqu-&gt;front=p-&gt;next; x=p-&gt;data; free(p);</code></p></li></ul><h4 id="用队列实现栈"><a href="#用队列实现栈" class="headerlink" title="用队列实现栈"></a>用队列实现栈</h4><ul><li><p>入栈：push(x)，除栈顶元素：pop() – 移，获取栈顶元素：top() ，返回栈是否为空：empty()</p><pre><code class="cpp">// Push element x onto stack.void push(int x)&#123;  q1.push(x);&#125;// Removes the element on top of the stack and returns thatint pop()&#123;  int length1 =  q1size();  for(int i-0; i&lt; length1- 1; i++)  &#123;    q2.push(q1.front());    q1. pop();  &#125;  data= q1.front()    int length2= q2size():  for(int j=0;j&lt; length2; j++)  &#123;    q1.push(q2.front());    q2.pop();  &#125;  return data;&#125;// Get the top element. *int top()    int length1 = q1.size();    int data;    for (int i=0; i&lt; length1- 1; i++)  &#123;    q2.push(q1.front());    q1.pop();  &#125;    data= q1.front();    return data;&#125;// Returns whether the stack isemptybool empty()&#123;  if(q1.empty()&amp;&amp;q2.empty())    return true;  else        return false;&#125;</code></pre></li></ul><h3 id="串"><a href="#串" class="headerlink" title="串"></a>串</h3><h4 id="串数据类型的定义"><a href="#串数据类型的定义" class="headerlink" title="串数据类型的定义"></a>串数据类型的定义</h4><ul><li><p>串是限定了元素为字符的线性表，<code>char str[]=&quot;abcdef&quot;;</code></p></li><li><p>空格串不是空串</p></li><li><p>串赋值：对数组中的每个元素进行逐一赋值操作</p><ul><li><code>strassign(str,&quot;cur input&quot;);</code></li></ul></li><li><p>取串长度</p><ul><li><code>return str.length;</code></li></ul></li><li><p>串比较操作</p><pre><code class="cpp">int strcompare(Str s1, Str s2)&#123;  for(int i=0;i&lt;s1.length&amp;&amp;i&lt;s2.length;++i)      if(s1.ch[i]!=s2.ch[i])      return s1.ch[i]-s2.ch[i];  return s1.length - s2.length;&#125;</code></pre></li></ul><h4 id="串的模式匹配算法"><a href="#串的模式匹配算法" class="headerlink" title="串的模式匹配算法"></a>串的模式匹配算法</h4><ul><li><p>KMP 算法</p><pre><code class="cpp">void getnext(str substr, int next[])&#123;  int i=1, j=0;    next[1]=0;    while (i&lt;substr.length)  &#123;    if (j==0||substr.ch[i]==substr.ch[j])    &#123;      ++i, ++j;      next[i]=j;    &#125;    else      j=next[j];  &#125;&#125;int KMP (Str str, Str substr, int next[])&#123;   int i=j=1;  while(i&lt;=str.length&amp;&amp;j&lt;=substr.length)  &#123;     if (j==0||str.ch[i]==substr.ch[j])      ++i, ++j;    else      j=next[ j];    if (j&gt;substr.length)       return i-substr.length;    else      return 0;  &#125;&#125;</code></pre></li></ul>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;数据结构是指数据的存储结构，是带有结构特性的数据元素的集合。精心选择的数据结构可以带来更好的运行或者存储效率。数据结构是计算机科学与技术专业、软件工程专业甚至于其它电气信息类专业的重要专业基础课程，在408计算机学科专业基础综合考试中占有45分。我选择的课程是浙江大学数据结构&lt;a href=&quot;https://www.icourse163.org/course/ZJU-93001&quot;&gt;国家精品课&lt;/a&gt;，以下为所记课堂笔记第一部分，包含C/C++语言基础、线性表、栈和队列的知识总结以及所需记忆的代码，另外我在开源仓库中还保持了浙大慕课版本的&lt;a href=&quot;https://github.com/Bezhuang/LearnCS/tree/main/%E5%90%8D%E6%A0%A1%E5%85%AC%E5%BC%80%E8%AF%BE/%E6%B5%99%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84&quot;&gt;代码&lt;/a&gt;，可供参考。其他部分笔记详见&lt;a href=&quot;/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%B8%AD&quot;&gt;数据结构（中）&lt;/a&gt;和&lt;a href=&quot;/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%B8%8B&quot;&gt;数据结构（下）&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="计算机专业" scheme="http://blog.zhuangzhihao.top/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%93%E4%B8%9A/"/>
    
    
    <category term="Data Structure" scheme="http://blog.zhuangzhihao.top/tags/Data-Structure/"/>
    
  </entry>
  
  <entry>
    <title>Java基础编程总结</title>
    <link href="http://blog.zhuangzhihao.top/Java%E5%9F%BA%E7%A1%80/"/>
    <id>http://blog.zhuangzhihao.top/Java%E5%9F%BA%E7%A1%80/</id>
    <published>2021-06-19T16:00:00.000Z</published>
    <updated>2021-09-29T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Java 语言是 SUN(Stanford University Network) 公司于1995年推出的一门高级编程语言，舍弃了 C 语言中容易引起错误的指针（以引用取代）、运算符重载（operator overloading）、多重继承 （以接口取代）等特性，增加了垃圾回收器等功能，具有面向对象、健壮性、跨平台性等特性。我选择的 Java课程为<a href="https://www.bilibili.com/video/BV1Kb411W75N">尚学堂 Java 零基础入门教程</a>，但由于我个人不是零基础入门，所以这篇笔记不含编程入门和语言概述，仅包含 Java 基础编程知识的总结。</p></blockquote><a id="more"></a><h3 id="运行机制"><a href="#运行机制" class="headerlink" title="运行机制"></a>运行机制</h3><h4 id="Java-虚拟机"><a href="#Java-虚拟机" class="headerlink" title="Java 虚拟机"></a>Java 虚拟机</h4><ul><li>JVM 是一个虚拟的计算机，具有指令集并使用不同的存储区域，负责执行指令，管理数据、内存、寄存器</li><li>对于不同的平台，有不同的虚拟机，只有某平台提供了对应的 Java 虚拟机，Java 程序才可在此平台运行</li><li>Java 虚拟机机制屏蔽了底层运行平台的差别，实现了“一次编译，到处运行”</li></ul><h4 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h4><ul><li>Java 语言消除了程序员回收无用内存空间的责任：提供一种系统级线程跟踪存储空间的分配情况，并在 JVM 空闲时，检查并释放那些可被释放的存储空间</li><li>垃圾回收在 Java 程序运行过程中自动进行，程序员无法精确控制和干预</li></ul><h4 id="JRE-与-JDK"><a href="#JRE-与-JDK" class="headerlink" title="JRE 与 JDK"></a>JRE 与 JDK</h4><ul><li>Java Development Kit 是提供给 Java 开发人员使用的 Java 开发工具包，其中包含了 Java 的开发工具，也包括了 JRE</li><li>Java Runtime Environment 包括 Java 虚拟机（Java Virtual Machine）和 Java 程序所需的核心类库等，如果想要运行一个开发好的 Java 程序，计算机中只需要安装 JRE 即可</li><li>JDK = JRE + 开发工具集（例如 Javac 编译工具等），JRE = JVM + Java SE 标准类库</li></ul><h4 id="通过-javac-命令编译-Java-文件"><a href="#通过-javac-命令编译-Java-文件" class="headerlink" title="通过 javac 命令编译 Java 文件"></a>通过 javac 命令编译 Java 文件</h4><ul><li><p>通过编译器将 Java 源文件编译成 JVM 可以识别的字节码文件</p><pre><code class="java">javac Test.java  //此时有了可执行的 java 程序</code></pre></li><li><p>通过 java 命令运行生成的 class 文件</p><pre><code class="java">java Test  //通过运行工具 java.exe 对字节码文件进行执行</code></pre></li><li><p>一个源文件可以声明多个 class，但最多只能有一个 public 类，而且 public 类名必须与文件名相同</p></li></ul><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><ul><li><p>被注释的文字不会被 JVM 解释执行，多行注释里面不允许有多行注释嵌套</p><pre><code class="java">//单行注释/* 多行注释/*</code></pre></li><li><p>文档注释</p><pre><code class="java">/** * @author  java程序的作者** * @version  源文件的版本** */</code></pre></li><li><p>注释内容可以被 JDK 提供的 javadoc 所解析，生成该程序的说明文档</p></li></ul><h3 id="命名规范"><a href="#命名规范" class="headerlink" title="命名规范"></a>命名规范</h3><ul><li>标识符（Identifier）不可以数字开头，不能包含空格，严格区分大小写，长度无限制</li><li>包名：所有字母都小写</li><li>类名、接口名：所有单词的首字母大写</li><li>变量名、方法名：第一个单词首字母小写，第二个单词开始每个单词首字母大写</li><li>常量名：所有字母都大写，每个单词用下划线连接</li></ul><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><ul><li>变量是程序中最基本的存储单元，包含变量类型、变量名和存储的值</li><li>先声明，后使用：<code>&lt;数据类型&gt; &lt;变量名称&gt;</code></li><li>赋值：<code>&lt;变量名称&gt; = &lt;值&gt;</code>，<code>&lt;数据类型&gt;&lt;变量名&gt;= &lt;初始化值&gt;</code></li><li>成员变量：在类体内，方法体外声明的变量<ul><li>以 static 修饰的是类变量，不以 static 修饰的是实例变量</li></ul></li><li>局部变量：在方法体内部声明的变量<ul><li>方法、构造器中定义的变量成为实参</li><li>局部变量除形参外，都需显式初始化</li></ul></li><li>基本数据类型<ul><li>整型：byte \ short \ int \ long（整型常量默认为 int 型，声明 long 型常量须后加 l 或 L）</li><li>浮点型：float \ double（浮点型常量默认为双精度，声明 float 型常量须后加 f 或 F）</li><li>字符型：char（使用 Unicode 编码，<code>‘\uXXXX’</code>）</li><li>布尔型：boolean（true 用1表示，false 用0表示）</li></ul></li><li>引用数据类型<ul><li>类：class</li><li>接口：interface</li><li>字符串：String（<code>“aaaa”</code>）</li><li>数组：array</li></ul></li><li>数据类型转换<ul><li>byte、short、char之间不会相互转换，在计算时首先转换为 int 类型</li><li>boolean 类型不能与其它数据类型运算，不可以转换为其它的数据类型</li><li>任何基本数据类型的值和 String 进行连接运算时，基本数据类型的值将自动转化为 String 类型</li><li>强制转换符：<code>(byte)(a+b)</code></li><li>通过基本类型对应的包装类则可以实现把字符串转换成基本类型：<code>String a = “43”; inti= Integer.parseInt(a);</code></li></ul></li></ul><h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><ul><li>算术运算符</li><li>赋值运算符<ul><li>当 <code>=</code> 两侧数据类型不一致时，可以使用自动类型转换或使用强制类型转换原则进行处理</li><li>支持连续赋值</li><li>扩展赋值运算符：<code>+=, -=, *=, /=, %=</code></li></ul></li><li>比较运算符（关系运算符）<ul><li>比较运算符的结果都是 boolean 型</li></ul></li><li>逻辑运算符<ul><li><code>&amp;</code>：逻辑与，<code>|</code>：逻辑或，<code>！</code>：逻辑非</li><li><code>&amp;&amp;</code> ：短路与，<code>||</code>：短路或，<code>^</code> ：逻辑异或</li><li>单<code>&amp;</code>时，左边无论真假右边都进行运算；双<code>&amp;</code>时，如果左边为假，那么右边不参与运算</li><li><code>||</code>时：当左边为真，右边不参与运算</li></ul></li><li>位运算符<ul><li>位运算符操作的都是整型的数据变量</li><li><code>&lt;&lt;</code> : 在一定范围内，每向左移一位，相当于 <code>\* 2</code></li><li> <code>&gt;&gt;</code> : 在一定范围内，每向右移一位，相当于 <code>/ 2</code></li><li><code>&gt;&gt;&gt;</code>：无符号右移</li><li><code>&amp;</code>：与运算，<code>|</code>：或运算，<code>^</code> ：异或运算，<code>~</code>：取反运算</li></ul></li><li>三元运算符<ul><li><code>(条件)？a : b</code></li><li>条件表达式的结果为 boolean 类型</li><li>三元运算符是可以嵌套的</li></ul></li><li>只有单目运算符、三元运算符、赋值运算符是从右向左运算的</li></ul><h3 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h3><h4 id="分支结构"><a href="#分支结构" class="headerlink" title="分支结构"></a>分支结构</h4><ul><li><p><code>if-else</code> 条件表达式</p><ul><li>必须是布尔表达式（关系表达式或逻辑表达式）、布尔变量</li></ul><pre><code class="java">if(条件表达式)&#123;执行表达式1&#125;else if&#123;执行表达式2&#125;else if(条件表达式)&#123;执行表达式3&#125;...else&#123;执行表达式n&#125;</code></pre></li><li><p>输入语句</p><ol><li>导包：<code>import java.util.Scanner;</code> </li><li>Scanner 的实例化</li><li>调用 Scanner 类的相关方法来获取指定的变量</li></ol><pre><code class="java">import java.util.Scanner;class ScannerTest&#123;    public static void main(String[] args)&#123;        Scanner scan = new Scanner(System.in);        //声明一个Scanner        int num = scan.nextInt();      //获取变量        System.out.println(num);    &#125;&#125;</code></pre></li><li><p><code>switch-case</code> 结构</p><ul><li>switch 结构中的表达式只能是如下的六种数据类型：<code>byte</code>、<code>short</code>、<code>char</code>、<code>int</code>、<code>枚举类型</code> （JDK5.0）、<code>String类型</code>（JDK7.0）</li><li>case 之后只能声明常量，不能声明范围</li></ul><pre><code class="java">switch(表达式)&#123;case 常量1:    执行语句1;    //break;     //break关键字是可选的case 常量2:    执行语句2;...default:    执行语句n:&#125;</code></pre></li></ul><h4 id="循环结构"><a href="#循环结构" class="headerlink" title="循环结构"></a>循环结构</h4><ul><li><p>for 循环</p><ul><li>初始化部分可以声明多个变量，但必须是同一个类型，用逗号分隔</li><li>可以有多个变量更新，用逗号分隔</li></ul><pre><code class="java">for(初始化; 循环条件; 迭代)｛    循环体;｝</code></pre></li><li><p>while 循环</p><ul><li>for 循环和 while 循环可以相互转换</li></ul><pre><code class="java">初始化while(循环条件)｛    循环体;    迭代;&#125;</code></pre></li><li><p>do-while 循环</p><ul><li>至少执行一次循环体</li></ul><pre><code class="java">初始化do&#123;    循环体;    迭代;&#125;while(循环条件);</code></pre></li><li><p><code>for</code>、<code>while</code>、<code>do…while</code> 均可以作为外层循环或内层循环</p></li><li><p><code>break</code> 用于终止某个语句块的执行，<code>continue</code> 用于跳过其所在循环语句块的一次执行，继续下一次循环</p><ul><li><code>break</code> 只能用于 <code>switch</code> 语句和循环语句中，<code>continue</code> 只能用于循环语句中</li><li><code>continue</code> 出现在多层嵌套的循环语句体中时，可以通过标签指明要跳过的是哪一层循环</li></ul></li><li><p>与 <code>break</code> 和 <code>continue</code> 不同的是，<code>return</code> 直接结束整个方法</p></li></ul><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><ul><li><p>数组属于引用类型的变量，数组的元素既可以是基本数据类型，也可以是引用数据类型</p></li><li><p>创建数组对象会在内存中开辟一整块连续的空间，数组的长度一旦确定就不能修改</p></li><li><p>数组是有序排列的</p><pre><code class="java">//静态初始化：数组的初始化和数组元素的赋值操作同时进行ids = new int[]&#123;1001,1002,1003,1004&#125;;    //动态初始化：数组的初始化和数组元素的赋值操作分开进行String[] names = new String[5]; //通过角标的方式调用数组指定位置的元素names[0] = &quot;张学良&quot;;    //如果数组超过角标会通过编译，运行失败//获取数组的长度Syst遍历数组em.out.println(names.length);//遍历数组for(int i = 0;i &lt; names.length;i++)&#123;            System.out.println(names[i]);        &#125;</code></pre></li></ul><h4 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h4><ul><li><p>从数组底层的运行机制来看，其实没有多维数组，可以看作 array1 作为 array2 的元素而存在</p><pre><code class="java">//静态初始化int[][] arr1 = new int[][]&#123;&#123;1,2,3&#125;,&#123;4,5,6&#125;,&#123;7,8,9&#125;&#125;;//动态初始化String[][] arr2 = new String[3][];//调用数组的指定位置的元素System.out.println(arr1[0][1]);//获取数组的长度System.out.println(arr4.length);System.out.println(arr4[0].length);//遍历二维数组for(int i = 0;i &lt; arr4.length;i++)&#123;  for(int j = 0;j &lt; arr4[i].length;j++)&#123;    System.out.print(arr4[i][j] + &quot; &quot;);  &#125;  System.out.println();&#125;</code></pre></li></ul><h3 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h3><h4 id="类与对象的创建"><a href="#类与对象的创建" class="headerlink" title="类与对象的创建"></a>类与对象的创建</h4><ul><li><p>属性：类中的成员变量，行为：类中的成员方法</p></li><li><p>Field = 属性 = 成员变量 = 域、字段，Method = 成员方法 = 函数</p></li><li><p>创建类 = 类的实例化 = 实例化类</p></li><li><p>如果创建类一个类的多个对象，则每个对象都独立的拥有一套非 static 的类的属性</p></li><li><p>所有的对象实例以及数组都要在堆（Heap）上分配：此内存区域的唯一目的就是存放对象实例</p></li><li><p>虚拟机栈（Stack）用于存储局部变量：局部变量表存放了编译期可知长度的各种基本数据类型（boolean、byte、char、short、int、float、long、double）、对象引用（reference 类型，它不等同于对象本身，是对象在堆内存的首地址），方法执行完，自动释放</p></li><li><p>方法区（MethodArea）用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据</p><pre><code class="java">//类的正文要用&#123; &#125;括起来修饰符 class 类名&#123;        //修饰符为 public：类可以被任意访问         属性声明;         方法()声明;&#125;        //调用属性对象.属性;//调用方法对象.方法();</code></pre></li></ul><h4 id="类中属性的使用"><a href="#类中属性的使用" class="headerlink" title="类中属性的使用"></a>类中属性的使用</h4><ul><li>属性（成员变量）和局部变量<ul><li>属性直接定义在类的一对 <code>&#123;&#125;</code> 内 。局部变量声明在方法内、方法形参、构造器形参、构造器内部</li><li>在声明属性时可以使用权限修饰符指明其权限（private、public、缺省、protected），局部变量不可以使用权限修饰符</li><li>类的属性都有默认初始化值，局部变量没有默认初始化值，在调用局部变量之前，一定要显式赋值（形参在调用时，赋值即可）</li><li>属性加载到堆空间中（非 static），局部变量加载到栈空间</li></ul></li></ul><h4 id="类中方法的使用"><a href="#类中方法的使用" class="headerlink" title="类中方法的使用"></a>类中方法的使用</h4><ul><li><p>Math类：<code>sqrt()、random()</code></p></li><li><p>Scanner类：<code>nextXxx()</code></p></li><li><p>Arrays类：<code>sort()、binarySearch()、toString()、equals()</code></p><pre><code class="java">//方法的声明权限修饰符 返回值类型 方法名(形参列表)&#123;    方法体&#125;</code></pre></li><li><p>如果方法有返回值，则必须在方法声明时指定返回值的类型，在方法中使用 return 关键字来返回指定类型的变量或常量</p></li></ul><h4 id="匿名对象的使用"><a href="#匿名对象的使用" class="headerlink" title="匿名对象的使用"></a>匿名对象的使用</h4><ul><li>创建对象时，没有显式的赋值给一个变量名，即为匿名对象</li><li>匿名对象只能调用一次，换行直接销毁匿名对象</li></ul><h4 id="方法重载（overload）"><a href="#方法重载（overload）" class="headerlink" title="方法重载（overload）"></a>方法重载（overload）</h4><ul><li><p>在同一个类中，允许存在一个以上的同名方法，只要它们的参数个数或者参数类型不同即可</p></li><li><p>判断是否重载与方法的返回值类型、权限修饰符、形参变量名、方法体都无关</p><pre><code class="java">//与 void show(int a,char b,double c)&#123;&#125; 构成重载int show(int a,double c,char b)&#123;&#125;void show(int a,double c,char b)&#123;&#125;//void show(int a,double c,char b)&#123;&#125; 不与上方构成重载，因为参数类型相同</code></pre></li></ul><h4 id="可变个数的形参"><a href="#可变个数的形参" class="headerlink" title="可变个数的形参"></a>可变个数的形参</h4><ul><li><p>JavaSE 5.0 中提供了 Varargs (variable number of arguments) 机制，允许直接定义能和多个实参相匹配的形参，从而可以用一种更简单的方式来传递个数可变的实参</p></li><li><p>可变个数形参的格式：<code>数据类型 ... 变量名</code></p></li><li><p>可变个数形参的方法与本类中方法名相同，形参不同的方法之间构成重载。</p></li><li><p>可变个数形参的方法与本类中方法名相同，形参类型也相同的数组之间不构成重载（二者不可共存）</p></li><li><p>可变个数形参在方法中的形参中，必须声明在末尾</p></li><li><p>可变个数形参在方法中的形参中，最多只能声明一个可变形参</p><pre><code class="java">public void show(String... strs) &#123;    for (int i = 0; i &lt; strs.length; i++) &#123;        System.out.println(strs[i]);    &#125;&#125;//public void show(String[] strs)&#123;&#125; 与上一方法不可共存</code></pre></li></ul><h4 id="方法参数的值传递机制"><a href="#方法参数的值传递机制" class="headerlink" title="方法参数的值传递机制"></a>方法参数的值传递机制</h4><ul><li><p>如果变量是基本数据类型，此时实参赋值给形参的是实参真是存储的数据值</p></li><li><p>如果变量是引用数据类型，此时实参赋值给形参的是实参存储数据的地址值</p><pre><code class="java">public class ArrayPrint &#123;    public static void main(String[] args) &#123;        int[] arr = new int[]&#123;1,2,3&#125;;  //传进去的是一个Object的对象        System.out.println(arr);    //地址值                char[] arr1 = new char[]&#123;&#39;a&#39;,&#39;b&#39;,&#39;c&#39;&#125;;  //传进去的是一个数组，里面遍历数据了       System.out.println(arr1);    //abc    &#125;&#125;</code></pre></li></ul><h4 id="递归（recursion）方法"><a href="#递归（recursion）方法" class="headerlink" title="递归（recursion）方法"></a>递归（recursion）方法</h4><ul><li><p>一个方法体内调用它自身</p></li><li><p>方法递归包含了一种隐式的循环，它会重复执行某段代码，但这种重复执行无须循环控制</p></li><li><p>递归一定要向已知方向递归，否则这种递归就变成了无穷递归，类似于死循环</p></li></ul><h4 id="属性赋值的过程"><a href="#属性赋值的过程" class="headerlink" title="属性赋值的过程"></a>属性赋值的过程</h4><ol><li>默认初始化值</li><li>显式初始化</li><li>构造器中赋值</li><li>通过 <code>对象.方法</code> 或 <code>对象.属性</code> 的方式赋值</li></ol><h3 id="封装与隐藏"><a href="#封装与隐藏" class="headerlink" title="封装与隐藏"></a>封装与隐藏</h3><ul><li><p>高内聚：类的内部数据操作细节自己完成，不允许外部干涉</p></li><li><p>低耦合：仅对外暴露少量的方法用于使用</p></li><li><p>将类的属性私有化（private），同时提供 public 方法来 get 和 set</p><pre><code class="java">public class AnimalTest &#123;    public static void main(String[] args) &#123;        Animal a = new Animal();        a.name = &quot;大黄&quot;;        a.show();        a.setLegs(-6);        a.show();        System.out.println(a.name);        System.out.println(a.getLegs());    &#125;&#125;//类的设置class Animal&#123;    String name;    private int age;    private int legs;//对于属性的设置public void setLegs(int l)&#123;  if(l &gt;= 0 &amp;&amp; l % 2 == 0)&#123;    legs = l;  &#125;else&#123;    legs = 0;  &#125;&#125;//对于属性的获取public int getLegs()&#123;  return legs;&#125;    public void eat()&#123;    System.out.println(&quot;动物进食&quot;);&#125;    public void show()&#123;    System.out.println(&quot;name = &quot; + name + &quot;,age = &quot; + age + &quot;,legs = &quot; + legs);&#125;    //提供关于属性 age 的 get 和 set 方法public int getAge()&#123;    return age;&#125;public void setAge(int a)&#123;    age = a;    &#125;&#125;</code></pre></li><li><p>权限修饰符 <code>public、protected、default（缺省）、private</code>  置于类的成员定义前，用来限定对象对该类成员的访问权限</p><ul><li>对于 class 的权限修饰只可以用 public 和 default</li><li>public 类可以在任意地方被访问，default 类只可以被同一个包内部的类访问</li></ul></li></ul><h3 id="构造器（constructor）"><a href="#构造器（constructor）" class="headerlink" title="构造器（constructor）"></a>构造器（constructor）</h3><ul><li><p>构造器的作用：创建对象、初始化对象的属性</p></li><li><p>如果没有显示的定义类的构造器的话，则系统默认提供一个空参的构造器</p></li><li><p>一个类中至少会有一个构造器，一个类中若定义多个构造器，则彼此构成重载</p><pre><code class="java">权限修饰符  类名(形参列表) &#123; &#125;//创建类的对象：new + 构造器</code></pre></li></ul><h4 id="JavaBean-的使用"><a href="#JavaBean-的使用" class="headerlink" title="JavaBean 的使用"></a>JavaBean 的使用</h4><ul><li><p>JavaBean 是一种 Java 语言写成的可重用组件</p></li><li><p>JavaBean 符合如下标准：类是公共的、有一个无参的公共的构造器 、有属性，且有对应的 get、set 方法</p><pre><code class="java">public class Customer &#123;        private int id;    private String name;    public Customer()&#123;            &#125;        public void setId(int i)&#123;        id = i;    &#125;        public int getId()&#123;        return id;    &#125;        public void setName(String n)&#123;        name = n;    &#125;        public String getName()&#123;        return name;    &#125;&#125;</code></pre></li></ul><h4 id="UML-类图"><a href="#UML-类图" class="headerlink" title="UML 类图"></a>UML 类图</h4><p><img src="https://cdn.jsdelivr.net/gh/Bezhuang/Imgbed/blogimg/UML%E7%B1%BB%E5%9B%BE.png"></p><ul><li><code>+</code> 表示 public 类型，<code>-</code> 表示 private 类型，<code>#</code> 表示 protected 类型</li></ul><h3 id="this-关键字"><a href="#this-关键字" class="headerlink" title="this 关键字"></a>this 关键字</h3><ul><li>this 用来修饰和调用属性、方法、构造器</li><li>在类的方法中，可以使用 <code>this.属性</code> 或 <code>this.方法</code> 调用当前对象属性和方法（通常情况下选择省略），特殊情况下，如果方法的形参和类的属性同名必须显式使用 <code>this.变量</code> ，表明此变量是属性而非形参</li><li>在类的构造器中，可以使用 <code>this.属性</code> 或 <code>this.方法</code> 调用当前对象属性和方法（通常情况下选择省略），特殊情况下，如果构造器的形参和类的属性同名必须显式使用 <code>this.变量</code> ，表明此变量是属性而非形参</li><li>this 调用构造器<ul><li>可以在类的构造器中，显式使用 <code>this(形参列表)</code> 调用本类中重载的其他的构造器</li><li>   构造器中不能通过 <code>this(形参列表)</code> 的方式调用自己。</li><li>   如果一个类中声明了 n 个构造器，则最多有 n -1 个构造器中使用了<code>this(形参列表)</code></li><li>   <code>this(形参列表)</code> 必须声明在类的构造器的首行</li><li>   在类的一个构造器中，最多只能声明一个 <code>this(形参列表)&quot;</code></li></ul></li></ul><h3 id="package-关键字"><a href="#package-关键字" class="headerlink" title="package 关键字"></a>package 关键字</h3><ul><li><p>为了更好的实现项目中类的管理，提供包的概念</p></li><li><p>使用 package 声明类或接口所属的包，声明在源文件的首行</p></li><li><p>每 <code>“.”</code> 一次就代表一层文件目录。</p></li><li><p>同一个包下，不能命名同名接口或同名类；不同包下，可以命名同名的接口、类</p><pre><code class="java">java.lang  //包含一些 Java 语言的核心类，如 String、Math、Integer、System 和 Thread，提供常用功能java.net  //包含执行与网络相关的操作的类和接口java.io  //包含能提供多种输入/输出功能的类java.util  //包含一些实用工具类，如定义系统特性、接口的集合框架类、使用与日期日历相关的函数java.text  //包含了一些 java 格式化相关的类java.sql  //包含了 java 进行 JDBC 数据库编程的相关类/接口java.awt  //包含了构成抽象窗口工具集（abstractwindowtoolkits）的多个类，这些类被用来构建和管理应用程序的图形用户界面(GUI)。B/S  C/S</code></pre></li></ul><h4 id="MVC-设计模式"><a href="#MVC-设计模式" class="headerlink" title="MVC 设计模式"></a>MVC 设计模式</h4><ul><li><p>MVC 是常用的设计模式之一，将整个程序分为三个层次：视图模型层，控制器层，数据模型层</p></li><li><p>这种将程序输入输出、数据处理以及数据的展示分离开来的设计模式使程序结构变的灵活而且清晰，同时也描述了程序各个对象间的通信方式，降低了程序的耦合性</p></li><li><p>模型层 model 主要处理数据</p><ul><li>数据对象封装 model bean/domain</li><li>数据库操作类 model.dao</li><li>数据库 model. db</li></ul></li><li><p>控制层 controller 处理业务逻辑</p><ul><li>应用界面相关 controller.activity</li><li>存放 fragment/controller.fragment</li><li>显示列表的适配器 controller.adapter</li><li>服务相关的 controller.service</li><li>抽取的基类 controller.base</li></ul></li><li><p>视图层 vieW 显示数据</p><ul><li>相关工具类 view.utils</li><li>自定义 vIew/view.ul</li></ul></li></ul><h4 id="import-关键字"><a href="#import-关键字" class="headerlink" title="import 关键字"></a>import 关键字</h4><ul><li>在源文件中显式的使用 import 结构导入指定包下的类、接口，声明在包的声明和类的声明之间</li><li>如果导入的类或接口是 <code>java.lang</code> 包下的，或者是当前包下的，则可以省略此 import 语句</li><li>如果在代码中使用不同包下的同名的类，需要使用类的全类名的方式指明调用的是哪个类</li><li>已经导入 <code>java.a</code> 包下的类时，如果需要使用 a 包的子包下的类的话，仍然需要导</li><li>import static：调用指定类或接口下的静态的属性或方法</li></ul><h3 id="继承性"><a href="#继承性" class="headerlink" title="继承性"></a>继承性</h3><ul><li><p>一旦子类 A 继承父类以后，子类 A 中就获取了父类 B 中声明的结构（属性、方法）</p></li><li><p>如果父类中声明为 private 的属性或方法，子类继承父类以后，仍然认为获取了父类中私有的结构，只有因为封装性的影响，使得子类不能直接调用父类的结构而已</p></li><li><p>子类继承父类以后，还可以声明自己特有的属性或方法，实现功能的拓展</p></li><li><p>子类和父类的关系不同于子集与集合的关系</p><pre><code class="java">class A extends B&#123;&#125;//A：子类、派生类、subclass//B：父类、超类、基类、superclass</code></pre></li><li><p>Java 中关于继承性的规定</p><ul><li>一个类可以被多个类继承</li><li>类的单继承性：一个类只能有一个父类</li><li>子父类是相对的概念。</li><li>子类直接继承的父类，称为直接父类。间接继承的父类，称为间接父类。</li><li>子类继承父类后，就获取了直接父类以及所有间接父类中声明的属性和方法</li><li>如果没有显式的声明一个类的父类的话，则此类继承于 <code>java.lang.Object</code> 类</li><li>所有的 java 类具有 <code>java.lang.Object</code> 类声明的功能（直接或间接继承）</li></ul></li></ul><h3 id="方法的重写（override-overwrite）"><a href="#方法的重写（override-overwrite）" class="headerlink" title="方法的重写（override/overwrite）"></a>方法的重写（override/overwrite）</h3><ul><li><p>重写：子类继承父类以后，可以对父类中的方法进行覆盖操作</p></li><li><p>重写以后，当创建子类对象以后，通过子类对象去调用子父类中同名同参数方法时，执行的是子类重写父类的方法（即在程序执行时，子类的方法将覆盖父类的方法）</p><pre><code class="java">权限修饰符 返回值类型 方法名(形参列表)&#123;        //方法体&#125;</code></pre></li><li><p>类重写的方法的方法名和形参列表必须和父类被重写的方法的方法名、形参列表相同</p></li><li><p>子类重写的方法使用的访问权限不能小于父类被重写的方法的访问权限</p></li><li><p>子类不能重写父类中声明为 private 权限的方法</p></li><li><p>子类方法抛出的异常不能大于父类被重写的方法抛出的异常</p></li><li><p>子类与父类中同名同参数的方法必须同时声明为非 static 的（即为重写），或者同时声明为 static 的（不是重写），因为 static 方法是属于类的，子类无法覆盖父类的方法</p></li><li><p>方法的重载与重写</p><ul><li>   方法的重写 Overriding 和重载 Overloading 是 Java 多态性的不同表现</li><li>   重写 Overriding 是父类与子类之间多态性的一种表现，重载 Overloading 是一个类中多态性的一种表现</li><li>   如果在子类中定义某方法与其父类有相同的名称和参数，该方法被重写 Overriding</li><li>   子类的对象使用这个方法时，将调用子类中的定义，对它而言父类中的定义被屏蔽了</li><li>   如果在一个类中定义了多个同名的方法，它们或有不同的参数个数或有不同的参数类型，则称为方法的重载 Overloading</li></ul></li><li><p>返回值类型</p></li><li><p>   父类被重写的方法的返回值类型是 void，则子类重写的方法的返回值类型只能是 void</p></li><li><p>   父类被重写的方法的返回值类型是 A 类型，则子类重写的方法的返回值类型可以是 A 类或 A 类的子类</p></li><li><p>   父类被重写的方法的返回值类型如果是基本数据类型，则子类重写的方法的返回值类型必须是相同的基本数据类型</p></li></ul><h3 id="super-关键字"><a href="#super-关键字" class="headerlink" title="super 关键字"></a>super 关键字</h3><ul><li>super：父类的，可以用来调用属性、方法、构造器 </li><li>可以在子类的方法或构造器中，通过 <code>super.属性</code> 或 <code>super.方法</code> 显式的调用父类中声明的属性或方法（通常情况下省略这个）</li><li>当子类和父类中定义了同名的属性时，要想在子类中调用父类中声明的属性，则必须显式的使用 <code>super.属性</code>  表明调用的是父类中声明的属性</li><li>当子类重写了父类中的方法后，想在子类的方法中调用父类中被重写的方法时，必须显式的使用 <code>super.方法</code>  表明调用的是父类中被重写的方法</li><li>super 调用构造器<ul><li>可以在子类的构造器中显式的使用 <code>super(形参列表)</code> 调用父类中声明的指定的构造器</li><li><code>super(形参列表)</code> 的使用必须声明在子类构造器的首行</li><li>在类的构造器中，针对于 <code>this(形参列表)</code> 或 <code>super(形参列表)</code> 只能二选一，不能同时出现</li><li>在构造器的首行，既没有显式的声明 <code>this(形参列表)</code> 或 <code>super(形参列表)</code> 则默认的调用的是父类中的空参构造器 <code>super()</code></li><li>在类的多个构造器中，至少有一个类的构造器使用了 <code>super(形参列表)</code> 调用父类中的构造器</li></ul></li></ul><h3 id="子类对象实例化过程"><a href="#子类对象实例化过程" class="headerlink" title="子类对象实例化过程"></a>子类对象实例化过程</h3><ul><li>从结果上看<ul><li>   子类继承父类以后，就获取了父类中声明的属性或方法</li><li>   创建子类的对象中，在堆空间中，就会加载所有父类中声明的属性</li></ul></li><li>从过程上看</li><li>   通过子类的构造器创建子类对象时，一定会直接或间接的调用其父类构造器， 直到调用了 <code>java.lang.Object</code> 类中空参的构造器为止</li><li>正因为加载过所有的父类结构，所以才可以看到内存中有父类中的结构，子类对象可以考虑进行调用</li><li>   虽然创建子类对象时调用了父类的构造器，但自始至终就创建过一个对象，即为 <code>new</code> 的子类对象</li></ul><h3 id="多态性"><a href="#多态性" class="headerlink" title="多态性"></a>多态性</h3><ul><li>父类的引用指向子类的对象（或子类的对象赋值给父类的引用）</li><li>多态的使用：当调用子父类同名同参数方法时，实际调用的是子类重写父类的方法（虚拟方法调用）</li><li>有了对象多态性以后，在编译期，只能调用父类声明的方法，但在执行期实际执行的是子类重写父类的方法<ul><li>编译时，看左边，看的是父类的引用（父类中不具备子类特有的方法）</li><li>运行时，看右边，看的是子类的对象（实际运行的是子类重写父类的方法）</li></ul></li><li>多态性的使用前提：类的继承关系、方法的重写<ul><li>对象的多态性只适用于方法，不适用于属性（编译和运行都看左边）</li></ul></li><li>多态是运行时行为</li></ul><h4 id="虚拟方法"><a href="#虚拟方法" class="headerlink" title="虚拟方法"></a>虚拟方法</h4><ul><li><p>重载是指允许存在多个同名方法，而这些方法的参数不同，编译器根据方法不同的参数表，对同名方法的名称做修饰</p></li><li><p>对于编译器而言，这些同名方法就成了不同的方法，它们的调用地址在编译期就绑定了</p></li><li><p>Java的重载是可以包括父类和子类的，即子类可以重载父类的同名不同参数的方法。所以对于重载而言，在方法调用之前，编译器就已经确定了所要调用的方法，这称为早绑定或静态绑定</p></li><li><p>而对于多态，只有等到方法调用的那一刻，解释运行器才会确定所要调用的具体方法，这称为晚绑定或动态绑定</p><blockquote><p>不要犯傻，如果它不是晚绑定，它就不是多态。—— Bruce Eckel</p></blockquote></li></ul><h4 id="向下转型"><a href="#向下转型" class="headerlink" title="向下转型"></a>向下转型</h4><ul><li><p>使用强制类型转换符调用子类所特有的属性和方法</p></li><li><p>可能出现 ClassCastException 异常</p></li><li><p>进行向下转型之前，先进行 <code>instanceof</code> 的判断，返回 true 就进行向下转型，返回 false 不进行向下转型</p><pre><code class="java">if (p2 instanceof Man) &#123;    Man m2 = (Man) p2;    m2.earnMoney();    System.out.println(&quot;Man&quot;);&#125;</code></pre></li></ul><h3 id="Object-类的使用"><a href="#Object-类的使用" class="headerlink" title="Object 类的使用"></a>Object 类的使用</h3><ul><li><p>Object 类是所有 Java 类的根父类</p></li><li><p>如果在类的声明中未使用 extends 关键字指明其父类，则默认父类为 <code>java.lang.Object</code>  类</p></li><li><p>Object 类中的功能（属性、方法）具有通用性</p><ul><li>方法：<code>equals()、toString()、getClass()、hashCode()、clone()、finalize()、wait() 、notify()、notifyAll()</code></li></ul></li><li><p>Object类只声明了一个空参的构造器</p></li></ul><h4 id="final、finally、finalize的区别"><a href="#final、finally、finalize的区别" class="headerlink" title="final、finally、finalize的区别"></a>final、finally、finalize的区别</h4><ul><li>被 final 修饰符（关键字）修饰的类，不能再派生出新的子类，不能作为父类而被子类继承<ul><li>一个类不能既被 abstract 声明，又被 final 声明</li><li>将变量或方法声明为 final，可以保证他们在使用的过程中不被修改</li><li>被声明为 final 的变量必须在声明时给出变量的初始值，而在以后的引用中只能读取</li><li>被 final 声明的方法也同样只能使用，即不能被子类重写</li><li>final 修饰局部变量（尤其是使用 final 修饰形参）时，表明此形参是一个常量，当我们调用此方法时，给常量形参赋一个实参，一旦赋值以后，就只能在方法体内使用此形参，但不能进行重新赋值</li><li>static final 用来修饰全局常量</li></ul></li><li>finally 是在异常处理时提供 finally 块来执行任何清除操作，不管有没有异常被抛出、捕获，finally块都会被执行<ul><li>try 块中的内容是在无异常时执行到结束</li><li>catch 块中的内容是在 try 块内容发生 catch 所声明的异常时跳转到 catch 块中执行</li><li>finally 块则是无论异常是否发生都会执行 finally 块的内容，所以在代码逻辑中有需要无论发生什么都必须执行的代码，就可以放在 finally 块中</li></ul></li><li>Java技术允许使用 <code>finalize()</code> 方法在垃圾收集器将对象从内存中清除出去之前做必要的清理工作<ul><li>这个方法是由垃圾收集器在确定这个对象没有被引用时对这个对象调用的</li><li>它是在 object 类中定义的，因此所有的类都继承了它，子类覆盖 <code>finalize()</code> 方法以整理系统资源或者被执行其他清理工作</li><li><code>finalize()</code> 方法是在垃圾收集器删除对象之前对这个对象调用的</li></ul></li></ul><h4 id="操作符与-equals-方法"><a href="#操作符与-equals-方法" class="headerlink" title="== 操作符与 equals 方法"></a>== 操作符与 equals 方法</h4><ul><li><p>== 运算符可以使用在基本数据类型变量和引用数据类型变量中</p><ul><li>如果比较的是基本数据类型变量：比较两个变量保存的数据是否相等（类型不一定要相同）</li><li>如果比较的是引用数据类型变量：比较两个对象的地址值是否相同（两个引用是否指向同一个对象实体）</li></ul></li><li><p><code>equals()</code> 是一个方法，而非运算符，只能适用于引用数据类型</p><pre><code class="java">public boolean equals(Object obj)&#123;  return (this == obj);&#125;        //Object 类中 equals() 的定义，和 == 的作用相同</code></pre></li><li><p>重写 equals() 方法</p><ul><li>对称性、自反性、传递性、一致性</li></ul><pre><code class="java">@Override    public boolean equals(Object obj) &#123;        if (this == obj)            return true;        if (obj == null)            return false;        if (getClass() != obj.getClass())            return false;        Customer other = (Customer) obj;        if (age != other.age)            return false;        if (name == null) &#123;            if (other.name != null)                return false;        &#125; else if (!name.equals(other.name))            return false;        return true;    &#125;        //重写原则，比较两个对象的实体内容（name和age）是否相同</code></pre></li></ul><h4 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="toString()"></a>toString()</h4><ul><li><p>输出一个引用对象时，实际上就是调用当前对象的 <code>toString()</code></p></li><li><p>自定义类如果重写 <code>toString()</code> 方法：当调用此方法时，返回对象的实体内容</p><pre><code class="java">public String toString() &#123;    return getClass().getName() + &quot;@&quot; + Integer.toHexString(hashCode());&#125;</code></pre></li></ul><h3 id="包装类（Wrapper）"><a href="#包装类（Wrapper）" class="headerlink" title="包装类（Wrapper）"></a>包装类（Wrapper）</h3><h4 id="JUnit-单元测试"><a href="#JUnit-单元测试" class="headerlink" title="JUnit 单元测试"></a>JUnit 单元测试</h4><ul><li>选中当前项目工程 -&gt; 右键 build path-&gt; add libraries-&gt;  JUnit 4</li><li>创建一个 Java 类进行单元测试。</li><li>此时的Java类要求：此类是公共的、此类提供一个公共的无参构造器、此类中声明单元测试方法</li><li>此时的单元测试方法：方法的权限是 public，没有返回值，没有形参</li><li>此单元测试方法上需要声明注解：<code>@Test</code> 并在单元测试类中调用：<code>import org.junit.Test;</code></li><li>声明好单元测试方法以后，就可以在方法体内测试代码</li><li>写好代码后 -&gt; 双击单元测试方法名 -&gt; 右键 run as -&gt; JUnit Test</li><li>如果执行结果无错误，则显示是一个绿色进度条，反之，错误即为红色进度条</li></ul><h4 id="包装类的使用"><a href="#包装类的使用" class="headerlink" title="包装类的使用"></a>包装类的使用</h4><ul><li>Java提供了8种基本数据类型对应的包装类，使得基本数据类型的变量具有类的特征</li><li>byte -&gt; Byte，short -&gt; Short，int -&gt; Integer，long -&gt; Long，float -&gt; Float，double -&gt; Double，boolean -&gt; Boolean，char -&gt; Character</li><li>其中 Byte、Short、Integer、Long、Float、Double 的父类是 Number</li></ul><h4 id="包装类与基本数据类型相互转换"><a href="#包装类与基本数据类型相互转换" class="headerlink" title="包装类与基本数据类型相互转换"></a>包装类与基本数据类型相互转换</h4><ul><li>基本数据类型 -&gt; 包装类（装箱）<ul><li>通过构造器：<code>Integer t = new Integer(11);</code></li><li>通过字符串参数：<code>Float f = new float(&quot;32.1F&quot;);</code></li><li>自动装箱</li></ul></li><li>包装类 -&gt; 基本数据类型（拆箱）<ul><li>调用包装类的方法：<code>xxxValue()</code></li><li>自动拆箱</li></ul></li><li>String 类 -&gt; 基本数据类型<ul><li>调用相应的包装类的 <code>parseXxx(String)</code> 静态方法</li><li>通过包装类构造器: <code>boolean b = new Boolean (&quot;true&quot;);</code></li></ul></li><li>基本数据类型 -&gt; String 类<ul><li>String 类的 <code>valueof (3.4f)</code> 方法 2.23.4+””</li></ul></li><li>包装类 -&gt; String 类<ul><li>包装类对象的 <code>toString()</code> 方法</li><li>调用包装类的 <code>toString(形参)</code> 方法</li></ul></li><li>String 类 -&gt; 包装类：装箱</li></ul><h3 id="Static-关键字"><a href="#Static-关键字" class="headerlink" title="Static 关键字"></a>Static 关键字</h3><h4 id="static-的使用"><a href="#static-的使用" class="headerlink" title="static 的使用"></a>static 的使用</h4><ul><li><p>使用 static 修饰属性：静态变量（类变量）</p><ul><li>实例变量：创建类的多个对象，每个对象都独立的拥有了一套类中的非静态属性，当修改其中一个非静态属性时，不会导致其他对象中同样的属性值的修饰</li><li>静态变量：创建类的多个对象，多个对象共享同一个静态变量，当通过静态变量去修改某一个变量时，会导致其他对象调用此静态变量时，是修改过的</li></ul></li><li><p>静态变量随着类的加载而加载，可以通过 <code>类.静态变量</code> 的方式进行调用</p></li><li><p>静态变量的加载要早于对象的创建，由于类只会加载一次，则静态变量在内存中也只会存在一次，存在方法区的静态域中</p><pre><code class="java">System.out.Math.PI;</code></pre></li></ul><h4 id="static-修饰方法"><a href="#static-修饰方法" class="headerlink" title="static 修饰方法"></a>static 修饰方法</h4><ul><li>使用 static 修饰方法：静态方法</li><li>静态方法中，只能调用静态的方法或属性，非静态的方法中，可以调用所有的方法或属性</li><li>在静态的方法内，不能使用 this 关键字、super 关键字</li><li>操作静态属性的方法，通常设置为 static ，工具类中的方法，习惯上声明为 static （Math、Arrays、Collections）</li></ul><h4 id="单例（Singleton）设计模式"><a href="#单例（Singleton）设计模式" class="headerlink" title="单例（Singleton）设计模式"></a>单例（Singleton）设计模式</h4><ul><li>取一定的方法保证在整个的软件系统中，对某个类只能存在一个对象实例</li><li>饿汉式：对象加载时间过长，但线程安全的</li><li>懒汉式：延迟对象的创建</li><li>由于单例模式只生成一个实例，减少了系统性能开销，当一个对象的产生需要比较多的资源时，如读取配置、产生其他依赖对象时，则可以通过在应用启动时直接产生一个单例对象，然后永久驻留内存的方式来解决</li><li>Singleton 设计模式的应用场景<ul><li>网站的计数器</li><li>应用程序的日志应用，这一般是由于共享的日志文件一直处于打开状态，因为只能有一个实例去操作，否则内容不好追加</li><li>数据库连接池，因为数据库连接是一种数据库资源。</li><li>项目中读取配置文件的类，一般也只有一个对象，没有必要每次使用配置文件数据，都生成一个对象去读取</li><li>Application、Windows 的 Task Manager、Recycle Bin</li></ul></li></ul><h3 id="代码块（初始化块）"><a href="#代码块（初始化块）" class="headerlink" title="代码块（初始化块）"></a>代码块（初始化块）</h3><ul><li>用来初始化类、对象</li><li>代码块如果有修饰的话，只能使用 static</li><li>静态代码块：初始化类的信息<ul><li>内部可以有输出语句</li><li>随着类的加载而执行，而且只执行一次</li><li>如果一个类中，定义了多个静态代码块，则按照声明的先后顺序执行</li><li>静态代码块的执行，优先于非静态代码块的执行</li><li>静态代码块内只能调用静态的属性、静态的方法，不能调用非静态的结构</li></ul></li><li>非静态代码块：可以在创建对象时，对对象的属性等进行初始化<ul><li>内部可以有输出语句</li><li>随着对象的创建而执行</li><li>每创建一个对象，就执行一次非静态代码块</li><li>如果一个类中，定义了多个非静态代码块，则按照声明的先后顺序执行</li><li>非静态代码块内可以调用静态的属性、静态的方法，或非静态的属性、非静态的方法</li></ul></li><li>对属性可以赋值的位置<ul><li>默认初始化、显式初始化、构造器中初始化</li><li>有了对象以后，可以通过 <code>对象.属性</code> 或 <code>对象.方法</code> 的方式进行赋值</li><li> 在代码块中赋值</li></ul></li></ul><h3 id="抽象类与抽象方法"><a href="#抽象类与抽象方法" class="headerlink" title="抽象类与抽象方法"></a>抽象类与抽象方法</h3><ul><li>Java 允许类设计者指定超类声明一个方法但不提供实现，该方法的实现由子类提供</li><li>这样的方法称为抽象方法，有一个或更多抽象方法的类称为抽象类</li></ul><h4 id="abstract-关键字的使用"><a href="#abstract-关键字的使用" class="headerlink" title="abstract 关键字的使用"></a>abstract 关键字的使用</h4><ul><li>abstract 修饰抽象类<ul><li>此类不能实例化</li><li>抽象类中一定有构造器，便于子类实例化时调用</li><li>开发中都会提供抽象类的子类，让子类对象实例化，实现相关的操作</li></ul></li><li>abstract 修饰抽象方法<ul><li>抽象方法：只有方法的声明，没有方法体</li><li>包含抽象方法的类，一定是一个抽象类，但抽象类中可以没有抽象方法</li></ul></li><li>abstract 不能用来修饰变量、代码块、构造器</li><li>abstract 不能用来修饰私有方法、静态方法、final 的方法、final 的类</li></ul><h4 id="模板方法设计模式（TemplateMethod）"><a href="#模板方法设计模式（TemplateMethod）" class="headerlink" title="模板方法设计模式（TemplateMethod）"></a>模板方法设计模式（TemplateMethod）</h4><ul><li>抽象类体现的就是一种模板模式的设计，抽象类作为多个子类的通用模板，子类在抽象类的基础上进行扩展、改造，但子类总体上会保留抽象类的行为方式</li><li>模板模式：在软件开发中实现一个算法时，整体步骤很固定、通用，这些步骤已经在父类中写好了，但是某些部分易变，易变部分可以抽象出来，供不同子类实现</li><li>常见的模板方法设计模式<ul><li>数据库访问的封装</li><li>Junit 单元测试</li><li>JavaWeb 的 Servlet 中关于 doGet/doPost 方法调用</li><li>Hibernate 中模板程序</li><li>Spring 中 JDBCTemlate、HibernateTemplate 等</li></ul></li></ul><h3 id="接口（interface）"><a href="#接口（interface）" class="headerlink" title="接口（interface）"></a>接口（interface）</h3><ul><li>接口是抽象方法和常量值定义的集合，用 interface 来定义</li><li>接口中的所有成员变量都默认是由 <code>public static final</code> 修饰的，接口中的所有抽象方法都默认是由 <code>public abstract</code> 修饰的</li><li>接口中没有构造器，意味着接口不可以实例化</li><li>JDK8 后除了全局常量和抽象方法之外，还可以定义静态方法、默认方法</li><li>接口和类是并列的两个结构</li><li>接口通过让类去实现 implements 使用，如果实现类覆盖了接口中的所有方法，则此实现类就可以实例化，如果实现类没有覆盖接口中所有的抽象方法，则此实现类仍为一个抽象类</li><li>Java 类可以实现多个接口 ，弥补了 Java 单继承性的局限性，接口与接口之间是继承,而且可以多继承</li><li>接口的具体使用，体现多态性 ，主要用途就是被实现类实现，实际可以看作是一种规范</li></ul><h4 id="代理模式（Proxy）"><a href="#代理模式（Proxy）" class="headerlink" title="代理模式（Proxy）"></a>代理模式（Proxy）</h4><ul><li>代理设计就是为其他对象提供一种代理以控制对这个对象的访问</li><li>分类<ul><li>静态代理（静态定义代理类）</li><li>动态代理（动态生成代理类）：JDK 自带的动态代理</li></ul></li><li>应用场景<ul><li>安全代理：屏蔽对真实角色的直接访问。</li><li>远程代理：通过代理类处理远程方法调用（RMI）</li><li>延迟加载：先加载轻量级的代理对象，真正需要再加载真实对象</li></ul></li></ul><h4 id="接口和抽象类之间的对比"><a href="#接口和抽象类之间的对比" class="headerlink" title="接口和抽象类之间的对比"></a>接口和抽象类之间的对比</h4><table><thead><tr><th>区别点</th><th>抽象类</th><th>接口</th></tr></thead><tbody><tr><td>定义</td><td>包含抽象方法的类</td><td>主要是抽象方法和全局常量的集合</td></tr><tr><td>组成</td><td>构造方法、抽象方法、普通方法、常量、变量</td><td>常量、抽象方法、默认方法、静态方法</td></tr><tr><td>使用</td><td>子类继承抽象类（extends）</td><td>子类实现接口（implements）</td></tr><tr><td>关系</td><td>抽象类可以实现多个接口</td><td>接口不能继承抽象类，但允许继承多个接口</td></tr><tr><td>常见设计模式</td><td>模板方法</td><td>简单工厂、工厂方法、代理模式</td></tr><tr><td>对象</td><td>都通过对象的多态性产生实例化对象</td><td></td></tr><tr><td>局限</td><td>抽象类有单继承的局限</td><td>接口没有此局限</td></tr><tr><td>实际</td><td>作为一个模板</td><td>是作为一个标准或是表示一种能力</td></tr><tr><td>选择</td><td>如果抽象类和接口都可以使用的话，优先使用接口，因为避免单继承的局限</td><td></td></tr></tbody></table><h4 id="Java-8-中关于接口的改进"><a href="#Java-8-中关于接口的改进" class="headerlink" title="Java 8 中关于接口的改进"></a>Java 8 中关于接口的改进</h4><ul><li>静态方法<ul><li>使用 static 关键字修饰，可以通过接口直接调用静态方法，并执行其方法体</li><li>经常在相互一起使用的类中使用静态方法，可以在标准库中找到像 Collection/Collections 或者 Path/Paths 这样成对的接口和类</li></ul></li><li>默认方法<ul><li>默认方法使用 default 关键字修饰，可以通过实现类对象来调用</li><li>在已有的接口中提供新方法的同时，还保持了与旧版本代码的兼容性，如：java 8 API 中对 Collection、List、Comparator 等接口提供了丰富的默认方法</li></ul></li></ul><h3 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h3><ul><li>Java 中允许将一个类 A 声明在另一个类 B 中，则类 A 就是内部类，类 B 就是外部类</li><li>成员内部类<ul><li><pre><code>作为外部类的成员，调用外部类的结构，可以被static修饰，可以被4种不同的权限修饰</code></pre></li><li><pre><code>作为一个类，类内可以定义属性、方法、构造器等，可以被 final 修饰，表示此类不能被继承。言外之意，不使用 final，就可以被继承，可以 abstract 修饰</code></pre></li></ul></li></ul><h4 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h4><ul><li><p>匿名内部类不能定义任何静态成员、方法和类，只能创建匿名内部类的一个实例</p></li><li><p>一个匿名内部类一定是在 new 的后面，用其隐含实现一个接口或实现一个类</p></li><li><p>匿名内部类必须继承父类或实现接口 ，=只能有一个对象，匿名内部类对象只能使用多态形式引用</p><pre><code class="java">new 父类构造器（实参列表）|实现接口()&#123;         //匿名内部类的类体部分&#125;</code></pre></li></ul><h4 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h4><ul><li>方法内、代码块内、构造器内</li><li>局部内部类的方法中（如：show）如果调用局部内部类所声明的方法（如：method）中的局部变量（如：num）的话，要求此局部变量声明为 final 的</li><li>jdk 8及之后的版本可以省略 final 的声明</li></ul><h3 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h3><ul><li>将程序执行中发生的不正常情况称为异常，开发过程中的语法错误和逻辑错误不是异常</li><li>Error：Java 虚拟机无法解决的严重问题，如：JVM系统内部错误、资源耗尽等严重情况<ul><li>StackOverflowError 和 OutOfMemoryError：一般不编写针对性的代码进行处理</li></ul></li><li>Exception：其它因编程错误或偶然的外在因素导致的一般性问题，可以使用针对性的代码进行处理<ul><li>空指针访问、试图读取不存在的文件、网络连接中断、数组角标越界</li></ul></li><li>解决方法：遇到错误就终止程序的运行，或在编写程序时，就考虑到错误的检测、错误消息的提示，以及错误的处理</li><li>捕获错误最理想的是在编译期间，但有的错误只有在运行时才会发生，如：除数为0，数组下标越界等</li></ul><h4 id="异常分类"><a href="#异常分类" class="headerlink" title="异常分类"></a>异常分类</h4><ul><li>运行时异常<ul><li>编译器不要求强制处置的异常，一般是指编程时的逻辑错误，是程序员应该积极避免其出现的异常</li><li><code>java.lang.RuntimeException</code> 类及它的子类都是运行时异常</li><li>对于这类异常，可以不作处理，因为这类异常很普遍，若全处理可能会对程序的可读性和运行效率产生影响</li></ul></li><li>编译时异常<ul><li>编译器要求必须处置的异常，即程序在运行时由于外界因素造成的一般性异常</li><li>编译器要求 Java 程序必须捕获或声明所有编译时异常</li><li>对于这类异常，如果程序不处理，可能会带来意想不到的后果</li></ul></li></ul><h4 id="try-catch-finally"><a href="#try-catch-finally" class="headerlink" title="try-catch-finally"></a>try-catch-finally</h4><ul><li><p>try</p><ul><li>用 try{…} 语句块选定捕获异常的范围，将可能出现异常的代码放在 try 语句块中</li></ul></li><li><p>catch(Exceptiontypee)</p><ul><li>在 catch 语句块中是对异常对象进行处理的代码，每个 try 语句块可以伴随一个或多个 catch 语句，用于处理可能产生的不同类型的异常对象</li><li>捕获异常的有关信息与其它对象一样，可以访问一个异常对象的成员变量或调用它的方法</li><li>getMessage() 获取异常信息，返回字符串</li><li>printStackTrace() 获取异常类名和异常信息，以及异常出现在程序中的位置，返回值 void</li></ul></li><li><p>finally</p><ul><li>通过 finally 语句为异常处理提供一个统一的出口，使得在控制流转到程序的其它部分以前，能够对程序的状态作统一的管理</li><li>不论在 try 代码块中是否发生了异常事件、catch 语句是否执行、catch语 句是否有异常、catch 语句中是否有 return，finally 块中的语句都会被执行</li><li>像数据库连接、输入输出流、网络编程 Socket 等资源，JVM 是不能自动的回收的，我们需要自己手动的进行资源的释放，此时的资源释放，就需要声明在 finally 中</li><li>finally 语句和 catch 语句是任选的</li></ul><pre><code class="java"> try&#123;         //可能出现异常的代码 &#125;catch(异常类型1 变量名1)&#123;         //处理异常的方式1 &#125;catch(异常类型2 变量名2)&#123;      //处理异常的方式2 &#125; ... finally&#123;         //一定会执行的代码 &#125;</code></pre></li></ul><h4 id="throws"><a href="#throws" class="headerlink" title="throws"></a>throws</h4><ul><li>声明抛出异常是 Java 中处理异常的第二种方式<ul><li>如果一个方法中的语句执行时可能生成某种异常，但是并不能确定如何处理这种异常，则此方法应显示地声明抛出异常，表明该方法将不对这些异常进行处理，而由该方法的调用者负责处理</li><li>在方法声明中用 throws 语句可以声明抛出异常的列表，throws 后面的异常类型可以是方法中产生的异常类型，也可以是它的父类</li></ul></li><li><code>throws + 异常类型</code> 写在方法的声明处，指明此方法执行时，可能会抛出的异常类型</li></ul><h4 id="用户自定义异常类"><a href="#用户自定义异常类" class="headerlink" title="用户自定义异常类"></a>用户自定义异常类</h4><ul><li>一般用户自定义异常类都是 <code>RuntimeException</code> 的子类</li><li>自定义异常类通常需要编写几个重载的构造器，需要提供 serialVersionUID</li><li>自定义的异常通过throw抛出</li><li>如何自定义异常类<ol><li>继承于现有的异常结构：RuntimeException 、Exception</li><li>提供全局常量：serialVersionUID</li><li>提供重载的构造器</li></ol></li></ul><h3 id="课程代码"><a href="#课程代码" class="headerlink" title="课程代码"></a>课程代码</h3><ul><li>课程代码已上传 <a href="https://github.com/Bezhuang/LearnCS/tree/main/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/Java%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B">Github 仓库</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;Java 语言是 SUN(Stanford University Network) 公司于1995年推出的一门高级编程语言，舍弃了 C 语言中容易引起错误的指针（以引用取代）、运算符重载（operator overloading）、多重继承 （以接口取代）等特性，增加了垃圾回收器等功能，具有面向对象、健壮性、跨平台性等特性。我选择的 Java课程为&lt;a href=&quot;https://www.bilibili.com/video/BV1Kb411W75N&quot;&gt;尚学堂 Java 零基础入门教程&lt;/a&gt;，但由于我个人不是零基础入门，所以这篇笔记不含编程入门和语言概述，仅包含 Java 基础编程知识的总结。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="编程与开发" scheme="http://blog.zhuangzhihao.top/categories/%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="Java" scheme="http://blog.zhuangzhihao.top/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络（上）</title>
    <link href="http://blog.zhuangzhihao.top/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E4%B8%8A/"/>
    <id>http://blog.zhuangzhihao.top/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E4%B8%8A/</id>
    <published>2021-06-09T16:00:00.000Z</published>
    <updated>2021-08-05T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>计算机网络是计算机专业必修的重要课程之一，与现实世界结合得相当紧密，也是考研408计算机学科专业基础综合考试中的一门课程。计算机网络学习的核心内容就是网络协议的学习。网络协议是为计算机网络中进行数据交换而建立的规则、标准或者说是约定的集合。我选择的课程是哈工大的<a href="https://www.icourse163.org/learn/HIT-154005">国家精品课</a>和谢希仁版教材，以下为所记课堂笔记上半部分，包含计算机网络体系结构、物理层和数据链路层的知识点，可供参考。下半部分笔记请访问<a href="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E4%B8%8B">计算机网络（下）</a></p></blockquote><a id="more"></a><h3 id="计算机网络体系结构"><a href="#计算机网络体系结构" class="headerlink" title="计算机网络体系结构"></a>计算机网络体系结构</h3><h4 id="计算机网络概述"><a href="#计算机网络概述" class="headerlink" title="计算机网络概述"></a>计算机网络概述</h4><ul><li>计算机网络就是一些互联的、自治的计算机系统的集合。</li><li>自治计算机就是能够进行自我管理、配置和维护的计算机。</li><li>计算机网络包括硬件、软件、协议三大部分。<ul><li>硬件由主机、通信处理机、通信线路和交换设备组成。</li></ul></li><li>从工作方式上看，计算机网络可分为边缘部分和核心部分。</li><li>从功能组成上看，计算机网络由通信子网和资源子网两部分构成。<ul><li>通信子网包括物理层、数据链路层和网络层。</li></ul></li><li>数据通信是计算机网络最基本和最重要的功能。</li><li>资源共享包括数据资源、软件资源以及硬件资源。</li></ul><h4 id="计算机网络体系结构与参考模型"><a href="#计算机网络体系结构与参考模型" class="headerlink" title="计算机网络体系结构与参考模型"></a>计算机网络体系结构与参考模型</h4><ul><li>实体是任何可发送或接收信息的硬件或软件进程。</li><li>对等层是不同机器上的同一层，对等实体是同一层上的实体。</li><li>协议是控制2个对等实体进行通信的规则。</li><li>接口又称服务访问点，没有接口就不能提供服务。从物理层开始，每一层都向上层提供服务访问点。</li><li>服务数据单元 SDU，协议控制信息 PCI，接口控制信息 ICI。</li><li>协议数据单元 PDU，表示的是同等层对等实体间传送的数据单元。<code>n-SDU</code>+<code>n-PCI</code>=<code>n-PDU</code>，<code>n-PDU</code>=<code>(n-1)-SDU</code></li><li>接口数据单元 IDU，表示的是在相邻层接口间传送的数据单元。<code>n-SDU</code>+<code>n-ICI</code>=<code>n-IDU</code></li><li>服务至下层为相邻上层提供的功能调用。只有那些能够被高一层实体看得见的功能才成为服务。</li><li>面向连接的服务（TCP），面向无连接的服务（IP和UDP）。</li><li>第n层的实体使用第n-1层的服务，向第n+1层提供本层的服务。该服务是第n层及其下各层所提供的服务的总和。</li><li>最高层向用户提供服务，下一层提供服务的实现细节对上一层透明。</li><li>OSI参考模型具有7层结构，而TCP/IP模型仅有4层结构。<ul><li>应用层（用户对用户），提供系统与用户的接口。文件传输、访问和管理、电子邮件服务。FTP，smtp，pop3，HTTP。</li><li>传输层（应用对应用，进程对进程），负责主机中2个进程之间的通信。为端到端连接提供可靠的运输服务、流量控制、差错控制、服务质量管理。TCP、udp、ARQ。</li><li>网络层（主机对主机），为传输层提供服务、组包和拆包、路由选择、拥塞控制。ICMP、Arp、RARP、IP、IGMP。</li><li>网络接口层 = 数据链路层 + 物理层</li><li>数据链路层，将网络层传下来的IP数据报组装成帧数。PPP、HDLC。</li><li>物理层，为数据端设备提供传送数据通路，传输比特流。 </li><li>应用层 = 应用层 + 表示层 + 会话层</li><li>会话层的主要功能是在2个节点间建立维护和释放面向用户的连接，并对会话进行管理和控制，保证会话数据可靠传送。</li><li>表示层负责处理在2个内部数据表示结构不同的通信系统间交换信息的表示格式，数据压缩及解压。</li><li>TCP/IP模型没有明确区分服务、接口、协议，且网络层仅有无连接。OSI参考模型网络层有连接和无连接，但传输层仅面向连接。</li></ul></li></ul><h4 id="计算机网络性能指标"><a href="#计算机网络性能指标" class="headerlink" title="计算机网络性能指标"></a>计算机网络性能指标</h4><ul><li>总时延 = 发送时延 + 传播时延 + 处理时延 + 排队时延</li><li>数据传输率是由总时延决定的，而带宽仅决定了发送时延。</li><li>发送时延 = 数据帧长度（bit）/ 发送速率（bit/s）</li><li>传播时延 = 信道长度（m）/ 电磁波在信道上的传播速度（m/s）</li><li>时延带宽积 = 传播时延 × 带宽</li><li>利用率包括信道利用率和网络利用率（全网络的信道利用率的加权平均值）。</li><li>1 MB/s = 8 Mbit/s</li></ul><h3 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h3><h4 id="通信基础"><a href="#通信基础" class="headerlink" title="通信基础"></a>通信基础</h4><ul><li>数据是传送信息的实体。而信号是数据的电气或电磁的表现。</li><li>基带对应数字信号，宽带对应模拟信号。</li><li>数据传输方式分为串行传输和并行传输。通信方式分为同步通信和异步通信。通信模式分为单向通信、双向交替通信、双向同时通信。</li><li>波特率（码元传输速率）表示单位时间内数字通信系统所传输的码元个数，单位波特（Baud）。</li><li>比特率（信息传输速率）表示单位时间内通信数字系统所传输的二进制码元个数，单位比特数（bit/s）。</li><li>每比特只能表示两种信号变化，可看成二进制。</li><li>带宽表示在单位时间内从网络中的某一点到另一点所能通过的最高数据率（网络的通信线路所能传送数据的能力）。单位比特每秒（bit/s）。</li><li>在通信领域，带宽是指信号最高频率与最低频率之差（Hz）。因此将模拟信号转换成数字信号时，采样频率必须大于等于最大频率f的2倍。</li><li>奈奎斯特定理给出了在无噪声情况下码元的最大传输速率。f表示理想低通信道的带宽。N表示每个码元的离散电平的数目。<ul><li>$C_{\max }=f_1<em>\log _{2}N=2f</em>\log _{2}N$</li></ul></li><li>信噪比是信号的平均功率和噪声的平均功率之比。S/N（dB）‘</li><li>香农公式给出了信号传输速率的极限。W为信道的带宽。<ul><li>$C_{\max }=W*\log _{2}\left( 1+\dfrac{S}{N}\right)$</li></ul></li><li>要使信息的极限传输速率提高，就必须提高信道的带宽或信道中的信噪比。实际信道的传输速率要比极限速率低不少。</li><li>模拟数据和数字数据都可以转化成模拟信号（调制）或数字信号（编码）。</li><li>数据传输方式包括电路交换、报文交换和分组交换。<ul><li>电路交换一定面向连接。通信时延小、实时性强、有序传输，但信道利用率低、缺乏统一标准、灵活性差。</li><li>报文交换，报文携带有目的地址、源地址。无需建立连接、动态分配线路，但报文大小没限制，要求网络节点需要有较大的存储缓存空间。</li><li>分组交换仍采用存储转发传输方式。将一个长报文分割成若干个较短的分组。加速传输、简化存储管理、减少出错概率和重发数据量，但存在传输时延、可能出现失序、丢失或重复分组现象。</li><li>TCP可以向应用层提供面向连接的服务，而UDP在传输层是无连接的。</li><li>分组交换可分为面向连接的虚电路方式和面向无连接的数据报方式，二者都由网络层提供。</li><li>数据报无需建立连接、提高吞吐量、对故障适应力强，每个分组包含完整的源地址和目的地址，可靠通信由用户主机来保证。</li><li>虚电路时延小、按序到达，每个分组包含一个虚电路号，可靠通信由网络来保证。</li></ul></li></ul><h4 id="传输介质"><a href="#传输介质" class="headerlink" title="传输介质"></a>传输介质</h4><ul><li>传输介质分为导向性传输介质和非导向性传输介质。<ul><li>导向性传输介质包含双绞线、同轴电缆和光纤。</li><li>双绞线分为无屏蔽双绞线和屏蔽双绞线。</li><li>同轴电缆分为基带同轴电缆（50Ω）和宽带同轴电缆（75Ω）。</li><li>光纤分为单模光纤（远距离）和多模光纤（近距离）。</li><li>非导向性传输介质有短波、微波、红外线与可见光等。</li></ul></li><li>传输介质并不是物理层，在传输介质中传输的是信号。物理层主要的功能就是确定与传输介质的接口有关的一些特性，即物理层接口的特性，如机械特性、电气特性、功能特性、规程特性。</li><li>物理层设备主要包含中继器和集线器。放大器放大的是模拟信号，中继器放大的是数字信号。</li><li>集线器实际就是一个多端口的中继器（Hub）。集线器在一个时钟周期内只能传输一组信息。集线器不能隔离冲突域。</li><li>通过中继器或集线器连接起来的几个网段仍然是一个局域网。使用集线器的以太网在逻辑上仍是一个总线网，各工作站使用CSMA/CD协议，共享逻辑上的总线。</li></ul><h3 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h3><h4 id="数据链路层的功能"><a href="#数据链路层的功能" class="headerlink" title="数据链路层的功能"></a>数据链路层的功能</h4><ul><li>数据链路层在物理层所提供的服务的基础上向网络层提供服务，分为无确认的无连接服务、有确认的无连接服务和有确认的有连接服务。</li><li>数据链路层的主要功能分为链路管理、帧同步、差错控制、透明传输。</li><li>当2个主机互相传送信息时，网络层的分组。必须封装成帧，并以帧的格式进行传送。即将一段数据的前后分别添加首部和尾部形成帧，首部和尾部中有很多控制信息，如帧定界。</li></ul><h4 id="组帧"><a href="#组帧" class="headerlink" title="组帧"></a>组帧</h4><ul><li>组帧方法分为字符计数法、字节填充的首尾界符法、比特填充的首尾标志法、物理编码违例法。</li><li>在网络中以帧为最小单位进行传输，所以组帧既要有首部又要加尾部，确定接收端清楚该帧在一串比特流中从哪里开始、到哪里结束。</li><li>字符计数法用一个特殊的字符表示一帧的开始，用一个计数字段表明该帧包含的字节数，计数字段提供的字节数包含自身所占的一个字节。</li><li>首尾界符法选定2个字符（SOH/EOT）作为每一个帧的开始和结束。字符填充的首尾界符法是将数据中可能出现的控制字符<code>SOH</code>和<code>EOT</code>在接收端不解释为控制字符。</li><li>比特填充的首尾标志法使用<code>01111110</code>作为帧的开始和结束标志。零比特填充法每有5个连续的<code>1</code>马上在其后插入<code>0</code>，接收方每收到5个连续的<code>1</code>自动删除后面紧跟的<code>0</code>恢复原始数据。</li><li>物理编码违例法利用物理介质上的编码的违法标志来区分帧的开始和结束，例如在曼彻斯特编码中高-高和低-低电平的编码方式是无效的，用来作为帧的起始和结束标志。</li></ul><h4 id="差错控制"><a href="#差错控制" class="headerlink" title="差错控制"></a>差错控制</h4><ul><li>检错编码分为奇偶校验码和循环冗余码。<ul><li>奇偶校验码是在信息码后面加1位校验码，分为奇校验和偶校验。奇校验是添加1位校验码后使得整个码字里面<code>1</code>的个数是奇数。</li><li>循环冗余码（CRC）是在发送端产生一个冗余码，附加在信息位后面一起发送到接收端，接收端收到的信息按发送端形成循冗余码同样的算法进行校验，如果发现错误则通知发送端重发。</li><li>CRC的本质是模-2除法的余数，采用的除数不同，CRC的类型也就不一样。</li><li>循环冗余码具有r检测位的多项式能够检测出所有小于或等于r的突发错误，长度大于r+1的错误逃脱的概率是 $\dfrac{1}{2^{r}}$。</li></ul></li><li>常见的纠错编码是海明码，在 k 位信息字段中插入若干位数据用于监督码字里的哪一位数据发生变化，具有一位纠错能力。<ul><li>确认校验码的位数 r：$2^{r}-1\geq k+r$</li><li>校验码$P_i$在编码中的位置为$2^{i-1}$</li><li>出错位$e_n$等于所有有关位$M_n$互为异或，求出$P_i$，按序写出海明码</li><li>校验海明码：出错位$e_n$等于所有有关位$M_n$互为异或，求出$e_n$</li><li>出错位$e_n$对应的十进制数就是出错的位数</li></ul></li></ul><h4 id="流量控制与可靠传输机制"><a href="#流量控制与可靠传输机制" class="headerlink" title="流量控制与可靠传输机制"></a>流量控制与可靠传输机制</h4><ul><li>流量控制就是要控制发送方发送数据的速率使接收方来得及接收，分为停止-等待流量控制和滑动窗口流量控制。<ul><li>停止-等待流量控制就是发送方发出一帧，等接收方收到一帧后返回应答信号，再发送下一帧。</li><li>滑动窗口流量控制允许一次发送多个帧。在任意时刻发送方都维持一组连续的允许发送的帧的序号，称为发送窗口。同时接收方也维持一组连续的允许接收帧的序号，称为接收窗口。发送端每收到一个帧的确认，发送窗口就向前移动1个帧的位置。</li><li>只有在接收窗口向前滑动时，发送窗口才有可能向前滑动。</li><li>只要当接收窗口大小为1时，则可保证帧按序接受。</li></ul></li><li>端到端的可靠传输就是在传输层使用面向连接的TCP，而不是数据链路层。</li><li>可靠传输一般使用确认和超时重传两种机制共同完成（ARQ自动请求重发）。</li><li>可靠传输机制包括停止-等待协议、后退N帧协议和选择重传协议。<ul><li>停止等待协议就是发送窗口和接收窗口大小均为1。帧一般分为数据帧和确认帧。</li><li>后退N帧协议：发送方连续发送若干个数据帧，如果收到接收方的确认帧接着发送数据，如果某个帧出错，接收方只能简单丢弃该帧及后续所有帧。增加吞吐量，但造成一定浪费。</li><li>后退N帧协议接收窗口大小=1，$1&lt;发送窗口大小W_{T}\leq 2^{n}-1$。n为对帧编号的比特数。</li><li>选择重传（SR）协议：当一帧出错时，后续帧先存入接收方的缓冲区中,同时要求发送方重传出错帧。提高信道利用率但增加缓冲空间。</li><li>选择重传协议的接收窗口尺寸和发送窗口尺寸都大于1，以便能一次性接受多个帧。发送窗口的最大尺寸也不能超过序列号范围的一半。当发送窗口等于接收窗口=$2^{n}-1$时达到最大效率。</li><li>按序到达的且没有被交付给主机的帧被放在接收缓存里。不按序到达的数据且没有错误的帧放在接收窗口里。不直接给主机，等缺少的帧收到后再一起放到接收缓存。</li></ul></li></ul><h4 id="介质访问控制"><a href="#介质访问控制" class="headerlink" title="介质访问控制"></a>介质访问控制</h4><ul><li>静态分配信道的方法是信道划分介质访问控制。动态分配信道的方法分为随机访问介质访问控制和轮询访问介质访问控制。</li><li>多路复用技术是在一条介质上同时携带多个传输信号，使多个计算机或终端设备共享信道资源，提高信道的利用率。实现信道划分介质访问控制。</li><li>信道划分介质访问控制分为频分多路复用、时分多路复用、波分多路复用和码分多路复用。<ul><li>频分多路复用时如果复用数增加，那么信号的频率带宽增加。</li><li>统计时分复用是一种动态的时间分配。</li><li>波分多路复用就是光的频分多路复用。</li><li>码分多路复用，又称为码分多址（CDMA），既共享信道的频率又共享时间，主要用于无线通信系统。</li><li>任意2个站点的码片向量的规格化内积一定为1。任意站点的码片向量与该码片向量自身的规格化内积一定为1。任何站点的码片向量和该码片的反码向量的规格化内积一定为负1。</li></ul></li><li>动态划分信道分为随机接入（争用性协议）和受控接入。<ul><li>ALOHA协议：不检测发送数据，一段时间没收到确认即为发送冲突，发生冲突的节点等待一段随机事件后再发送数据。</li><li>时分ALOHA：所有节点的时间被划分为间隔相同的时隙，并规定每个节点就会等到下一个时隙到来时才可发送数据。</li><li>载波侦听多路访问（CSMA）协议：每个节点发送数据之前，都使用载波侦听技术来判定通信信道是否空闲，在局域网中被广泛的应用。</li><li>1-坚持CSMA：监听到信道空闲时，立即发送数据，否则继续监听。</li><li>p-坚持CSMA：监听到信道空闲时，以概率P发送数据，以概率(1-P)延迟一段时间并重新监听。</li><li>非坚持CSMA。监听到信道空闲时，立即发送数据，否则延迟一段随机的时间再重新监听。</li><li>CSMA/CD协议（带冲突检测的载波侦听多路访问协议）：检测超过发送站点本身发送的载波信号的幅度，由此判断出冲突的存在，并向总线上发一串阻塞信号。</li><li>CSMA/CD工作流程：先听后发，边听边发，冲突停发，随机重发。</li><li>CSMACD用于信道使用半双工的网络环境，而对于使用全双工的网络环境，则无需采用这种介质访问控制技术。</li><li>争用期（$2\tau$）：以太网端到端的往返时延，又称冲突窗口或碰撞窗口。只有经过争用期还没有检测到冲突，才能肯定这次发送不会发生冲突。</li><li>以太网规定最短帧长为64B，凡长度小于64B的都是由于冲突而异常停止的无效帧。以太网端到端的单程时延实际上小于争用期的一半（25.6μs）。</li><li>最短有效帧长和最远2个站的距离及传输速率成正比。</li><li>截断二进制指数类型退避算法：发生碰撞的站在停止发送数据后要推迟一个随机时间才能发送数据，基本退避时间一般取争用期（$2\tau$），重传需要推迟的平均时间随重传次数的增大而增大。</li><li>CSMA/CA协议主要用在无线局域网中，在CSMA的基础上增加了冲突避免的功能。</li><li>CSMA/CA协议要对正确接收到的数据帧进行确认。</li></ul></li><li>轮询访问介质访问控制主要用于在令牌环局域网中。典型的轮询访问介质访问控制协议就是令牌传递协议。</li></ul><h4 id="局域网"><a href="#局域网" class="headerlink" title="局域网"></a>局域网</h4><ul><li>局域网（local area network，LAN）是指一个较小范围内的多台计算机或其他通信设备通过双绞线、同轴电缆等连接介质互联起来，以达到资源和信息共享目的的互联网络。<ul><li>局域网有较高的数据率、较低的时延和较小的误码率，具有广播功能，便于系统的扩展和演变。</li><li>局域网的主要技术要素包括网络拓扑结构传输介质与介质访问控制方法。局域网的主要拓扑结构包括星型网环形网总线型网和树型网（星型网和总线型网的结合）。双绞线为局域网的主流传输介质。</li><li>局域网的主要介质访问控制方法包括CSMA/CD、令牌总线和令牌环。前两种作用于总线型网，令牌环作用于环形网。</li><li>局域网对应OSI参考模型中的数据链路层和物理层，并将数据链路层拆分为2个子层，逻辑链路控制（LLC）子层和媒体接入控制（MAC）子层。</li></ul></li><li>以太网采用总线拓扑结构。所有计算机都共享一条总线信息，以广播方式发送，使用CSMACD技术对总线进行访问控制。<ul><li>以太网采用无连接的工作方式，不对发送的数据帧进行编号，也不要求对发送方发送确认。以太网提供的服务是不可靠服务，所以有重传机制，且差错纠正由传输层的TCP完成。</li><li>数据传输速率达到或超过100Mbit/s的以太网称为高速以太网。100base-T以太网称为快速以太网。吉比特以太网成为千兆以太网,允许在全双工和半双工两种方式工作。在半双工方式下工作时必须使用CSMA/CD协议进行冲突检测。</li></ul></li><li>无线局域网分为有固定基础设施和无固定基础设施两类。IEEE802.11规定有固定基础设施的无线局域网的最小构建为基本服务集（BSS），BSS中的基站称为接入点（AP）。<ul><li>基本服务集可以是孤立的，也可以通过接入点连接到一个主干分配系统（DS）构成扩展的服务器（ESS），ESS还可通过门桥（portal）设备为无线用户提供到非IEEE802.11无线局域网的接入。</li><li>IEEE802.11标准中的物理层有跳频扩频（FHSS）、直接序列扩频（DSS）、红外线（IR）3种实现方法。</li><li>IEEE802.11标准中的MAC层在物理层上，包括2个子层，从下往上依次为分布协调功能（DCF）子层和点协调功能（PCF）子层。在带有碰撞避免功能的CSMA/CA协议的基础上增加确认机制。</li></ul></li><li>广域网是覆盖范围很广的长距离网络，由一些节点交换机以及连接这些交换机的链路组成。节点交换机完成分组存储转发的功能。<ul><li>广域网是通过交换机连接多个局域网组成，因特网是由广域网和局域网共同通过路由器相连。</li><li>局域网使用的协议主要在数据链路层，而广域网使用的协议主要在网络层。</li><li>广域网的路由选择协议负责搜索分组从某个节点到目的节点的最佳传输路由，以便构成路由表，从路由表再构造出转发分组的转发表，分组是通过转发表进行转发的。</li></ul></li><li>点对点协议（PPP）由一个将IP数据报封装到串行链路的方法、一个用于建立配置和测试数据链路连接的链路控制协议（LCP）和一套用来建立和配置不同的网络层协议的网络控制协议（NCP），其中每个协议支持不同的网络层协议。<ul><li>PPP是一个面向字节的协议，不需要纠错（只负责检错）、流量控制（由TCP负责）、序号（不可靠的传输协议）、多点线路，只支持全双工链路。</li></ul></li><li>高级数据链路控制（HDLC）协议是ISO制定的面向比特的数据链路控制协议，可适用于链路的非平衡配置（一个主站控制整个链路的工作）和平衡配置（链路两端2个站都是复合站）。<ul><li>PPP帧比HDLC协议帧多一个2字节的协议字段，当协议字段值为Ox0021时表示信息字段是IP数据报。</li><li>PPP不使用序号和确认机制，只保证无差错接收（通过硬件进行循环冗余码校验），HDLC协议的信息帧使用了编号和确认机制。</li></ul></li></ul><h4 id="数据链路层设备"><a href="#数据链路层设备" class="headerlink" title="数据链路层设备"></a>数据链路层设备</h4><ul><li>在物理层拓展局域网使用中继器和集线器扩大冲突域，但总吞吐量未提高，且不能互联使用不同以太网技术的局域网。</li><li>在数据链路层扩展局域网使用网桥，具有过滤帧的功能。网桥至少有2个端口，每一个端口与一个网段相连。<ul><li>网桥从一个端口接收一个帧，先暂存到缓存中，若未出现差错，且发往目的站MAC地址属于另一网段，则通过查找转发表将该帧从对应端口发出。</li><li>网桥过滤通信量、扩大物理范围、提高可靠性、可互连不同物理层、不同MAC子层和不同速率的以太网，但存储转发增加时延，且在MAC层并没有流量控制功能，用户过多会因传播过多的广播信息而产生网络拥塞（广播风暴）。</li><li>网桥包括透明网桥（选择的不是最佳路由）和源选径网桥（选择的是最佳路由）。最佳路由并不一定是经过路由器最少的路由，也可以是发送帧往返时间最短的路由（实现负载平衡）。</li></ul></li><li>局域网交换机实质上是工作在数据链路层的多端口网桥。局域网交换机的每个端口都直接与主机或集线器相连，并且一般都工作在全双工方式。<ul><li>交换机总容量 = 端口数×每个端口带宽（半双工）or 端口数×每个端口带宽×2（全双工）</li><li>交换机分为直通式交换和存储转发式交换，工作原理与网桥类似。</li><li>网桥的端口一般连接到局域网的网段，而以太网交换机的每个端口一般都直接与主机相连，也可连接到Hub。</li></ul></li><li>一块网卡发出一个广播，能收到这个广播的所有网卡集合为一个广播域。通常情况下，一个网段就是一个冲突域，一个局域网就是一个广播域。</li></ul>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;计算机网络是计算机专业必修的重要课程之一，与现实世界结合得相当紧密，也是考研408计算机学科专业基础综合考试中的一门课程。计算机网络学习的核心内容就是网络协议的学习。网络协议是为计算机网络中进行数据交换而建立的规则、标准或者说是约定的集合。我选择的课程是哈工大的&lt;a href=&quot;https://www.icourse163.org/learn/HIT-154005&quot;&gt;国家精品课&lt;/a&gt;和谢希仁版教材，以下为所记课堂笔记上半部分，包含计算机网络体系结构、物理层和数据链路层的知识点，可供参考。下半部分笔记请访问&lt;a href=&quot;/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E4%B8%8B&quot;&gt;计算机网络（下）&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="计算机专业" scheme="http://blog.zhuangzhihao.top/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%93%E4%B8%9A/"/>
    
    
    <category term="Computer Networking" scheme="http://blog.zhuangzhihao.top/tags/Computer-Networking/"/>
    
  </entry>
  
  <entry>
    <title>使用Python程序画画</title>
    <link href="http://blog.zhuangzhihao.top/Python%E7%94%BB%E7%94%BB/"/>
    <id>http://blog.zhuangzhihao.top/Python%E7%94%BB%E7%94%BB/</id>
    <published>2021-05-31T16:00:00.000Z</published>
    <updated>2021-05-31T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>turtle 库是 Python 的标准库之一，属于入门级的图形绘制函数库，其原理是让一只海龟在画布上游走，走过的轨迹形成了绘制的图形，海龟由程序控制，可以自由改变颜色、方向宽度等。我们也可以依赖这个库完成一些简单的画画，以下为一些经典图像的代码实现笔记，可供参考。</p></blockquote><a id="more"></a><h3 id="turtle-简介"><a href="#turtle-简介" class="headerlink" title="turtle 简介"></a>turtle 简介</h3><pre><code class="python">import turtle# 设置窗体大小turtle.setup(width,height,startx,starty)    #后两个参数非必选参数#turtle的移动turtle.goto(x,y)#画圆turtle.circle(r,angle)#当前距离后退turtle.bk(d)#当前距离前进turtle.fd(d)    #turtle.forward(d)#改变海龟行进方向，angle为绝对角度turtle.seth(angle)    #只改变呢方向不行进#向左右前进turtle.right(angle)turtle.left(angle)#抬起画笔turtle.pu()    #turtle.penup()#画笔落下turtle.pd()    #turtle.pendown()#画笔宽度turtle.width(width)    #turtle.pensize(width)#画笔颜色turtle.pencolor(color):color</code></pre><h3 id="画笑脸"><a href="#画笑脸" class="headerlink" title="画笑脸"></a>画笑脸</h3><pre><code class="python">import turtle as fucksisudef eye(col, rad):    fucksisu.down()    fucksisu.fillcolor(col)    fucksisu.begin_fill()    fucksisu.circle(rad)    fucksisu.end_fill()    fucksisu.up()fucksisu.fillcolor(&#39;yellow&#39;)fucksisu.begin_fill()fucksisu.circle(100)fucksisu.end_fill()fucksisu.up()fucksisu.goto(-40, 120)eye(&#39;white&#39;, 15)fucksisu.goto(-37, 125)eye(&#39;black&#39;, 5)fucksisu.goto(40, 120)eye(&#39;white&#39;, 15)fucksisu.goto(40, 125)eye(&#39;black&#39;, 5)fucksisu.goto(0, 75)eye(&#39;black&#39;, 8)fucksisu.goto(-40, 85)fucksisu.down()fucksisu.right(90)fucksisu.circle(40, 180)fucksisu.up()fucksisu.goto(-10, 45)fucksisu.down()fucksisu.right(180)fucksisu.fillcolor(&#39;red&#39;)fucksisu.begin_fill()fucksisu.circle(10, 180)fucksisu.end_fill()fucksisu.hideturtle()</code></pre><h3 id="画柱状图"><a href="#画柱状图" class="headerlink" title="画柱状图"></a>画柱状图</h3><pre><code class="python">import turtleturtle.title(&quot;柱状图名称&quot;)heights = [834, 620,460,260,105]def main():    t = turtle.Turtle()    t.hideturtle()    for i in range(5):        drawFilledRectangle(t,-200+(76*i),0,76,heights[i]/4,&quot;black&quot;,&quot;light blue&quot;)    displayText(t)def drawFilledRectangle(t,x,y,w,h,colorP=&quot;black&quot;,colorF=&quot;white&quot;):    t.pencolor(colorP)    t.fillcolor(colorF)    t.up()    t.goto(x,y)    t.down()    t.begin_fill()    t.goto(x+w,y)    t.goto(x+w,y+h)    t.goto(x,y+h)    t.goto(x,y)    t.end_fill()def displayText(t):    languages = [&quot;柱状图1&quot;, &quot;柱状图2&quot;, &quot;柱状图3&quot;, &quot;柱状图4&quot;, &quot;柱状图5&quot;]    t.pencolor(&quot;blue&quot;)    t.up()    for i in range(5):        t.goto((-162+76*i),heights[i] / 4)        t.write(str(heights[i]),align=&quot;center&quot;,font=(&quot;Arial&quot;,10,&quot;normal&quot;))        t.goto((-162+76*i),10)        t.write(languages[i],align=&quot;center&quot;,font=(&quot;Arial&quot;,10,&quot;normal&quot;))        t.goto(-200,-25)        t.write(&quot;柱状图1名称&quot;,font=(&quot;Arial&quot;,10,&quot;normal&quot;))        t.goto(-200,-45)        t.write(&#39;(柱状图1注解)&#39;,font=(&quot;Arial&quot;,10,&quot;normal&quot;))main()</code></pre><h3 id="画皮卡丘"><a href="#画皮卡丘" class="headerlink" title="画皮卡丘"></a>画皮卡丘</h3><pre><code class="python">import turtledef sisuisrubbishl(x, y):    turtle.setx(x)    turtle.sety(y)    print(x, y)class Cartoon:    def __init__(self):        self.t = turtle.Turtle()        t = self.t        t.pensize(3)        t.speed(9)        t.ondrag(sisuisrubbishl)    def meme(self, x, y):        self.t.penup()        self.t.goto(x, y)        self.t.pendown()    def ihatesisu1(self, x, y):        self.meme(x, y)        t = self.t        t.seth(0)        t.fillcolor(&#39;#333333&#39;)        t.begin_fill()        t.circle(22)        t.end_fill()        self.meme(x, y + 10)        t.fillcolor(&#39;#000000&#39;)        t.begin_fill()        t.circle(10)        t.end_fill()        self.meme(x + 6, y + 22)        t.fillcolor(&#39;#ffffff&#39;)        t.begin_fill()        t.circle(10)        t.end_fill()    def ihatesisu2(self, x, y):        self.meme(x, y)        t = self.t        t.seth(0)        t.fillcolor(&#39;#333333&#39;)        t.begin_fill()        t.circle(22)        t.end_fill()        self.meme(x, y + 10)        t.fillcolor(&#39;#000000&#39;)        t.begin_fill()        t.circle(10)        t.end_fill()        self.meme(x - 6, y + 22)        t.fillcolor(&#39;#ffffff&#39;)        t.begin_fill()        t.circle(10)        t.end_fill()    def fucksisu(self, x, y):        self.meme(x, y)        t = self.t        t.fillcolor(&#39;#88141D&#39;)        t.begin_fill()        l1 = []        l2 = []        t.seth(190)        a = 0.7        for i in range(28):            a += 0.1            t.right(3)            t.fd(a)            l1.append(t.position())        self.meme(x, y)        t.seth(10)        a = 0.7        for i in range(28):            a += 0.1            t.left(3)            t.fd(a)            l2.append(t.position())        t.seth(10)        t.circle(50, 15)        t.left(180)        t.circle(-50, 15)        t.circle(-50, 40)        t.seth(233)        t.circle(-50, 55)        t.left(180)        t.circle(50, 12.1)        t.end_fill()        self.meme(17, 54)        t.fillcolor(&#39;#DD716F&#39;)        t.begin_fill()        t.seth(145)        t.circle(40, 86)        t.penup()        for pos in reversed(l1[:20]):            t.goto(pos[0], pos[1] + 1.5)        for pos in l2[:20]:            t.goto(pos[0], pos[1] + 1.5)        t.pendown()        t.end_fill()        self.meme(-17, 94)        t.seth(8)        t.fd(4)        t.back(8)    def fucksisu4(self, x, y):        turtle.tracer(False)        t = self.t        self.meme(x, y)        t.seth(300)        t.fillcolor(&#39;#DD4D28&#39;)        t.begin_fill()        a = 2.3        for i in range(120):            if 0 &lt;= i &lt; 30 or 60 &lt;= i &lt; 90:                a -= 0.05                t.lt(3)                t.fd(a)            else:                a += 0.05                t.lt(3)                t.fd(a)        t.end_fill()        turtle.tracer(True)    def fucksisu5(self, x, y):        t = self.t        turtle.tracer(False)        self.meme(x, y)        t.seth(60)        t.fillcolor(&#39;#DD4D28&#39;)        t.begin_fill()        a = 2.3        for i in range(120):            if 0 &lt;= i &lt; 30 or 60 &lt;= i &lt; 90:                a -= 0.05                t.lt(3)                t.fd(a)            else:                a += 0.05                t.lt(3)                t.fd(a)        t.end_fill()        turtle.tracer(True)    def fucksisu6(self, x, y):        t = self.t        self.meme(x, y)        t.fillcolor(&#39;#000000&#39;)        t.begin_fill()        t.seth(330)        t.circle(100, 35)        t.seth(219)        t.circle(-300, 19)        t.seth(110)        t.circle(-30, 50)        t.circle(-300, 10)        t.end_fill()    def fucksisu7(self, x, y):        t = self.t        self.meme(x, y)        t.fillcolor(&#39;#000000&#39;)        t.begin_fill()        t.seth(300)        t.circle(-100, 30)        t.seth(35)        t.circle(300, 15)        t.circle(30, 50)        t.seth(190)        t.circle(300, 17)        t.end_fill()    def fucksisu8(self):        t = self.t        t.fillcolor(&#39;#F6D02F&#39;)        t.begin_fill()        t.penup()        t.circle(130, 40)        t.pendown()        t.circle(100, 105)        t.left(180)        t.circle(-100, 5)        t.seth(20)        t.circle(300, 30)        t.circle(30, 50)        t.seth(190)        t.circle(300, 36)        t.seth(150)        t.circle(150, 70)        t.seth(200)        t.circle(300, 40)        t.circle(30, 50)        t.seth(20)        t.circle(300, 35)         t.seth(240)        t.circle(105, 95)        t.left(180)        t.circle(-105, 5)        t.seth(210)        t.circle(500, 18)        t.seth(200)        t.fd(10)        t.seth(280)        t.fd(7)        t.seth(210)        t.fd(10)        t.seth(300)        t.circle(10, 80)        t.seth(220)        t.fd(10)        t.seth(300)        t.circle(10, 80)        t.seth(240)        t.fd(12)        t.seth(0)        t.fd(13)        t.seth(240)        t.circle(10, 70)        t.seth(10)        t.circle(10, 70)        t.seth(10)        t.circle(300, 18)        t.seth(75)        t.circle(500, 8)        t.left(180)        t.circle(-500, 15)        t.seth(250)        t.circle(100, 65)        t.seth(320)        t.circle(100, 5)        t.left(180)        t.circle(-100, 5)        t.seth(220)        t.circle(200, 20)        t.circle(20, 70)        t.seth(60)        t.circle(-100, 20)        t.left(180)        t.circle(100, 20)        t.seth(300)        t.circle(10, 70)        t.seth(60)        t.circle(-100, 20)        t.left(180)        t.circle(100, 20)        t.seth(10)        t.circle(100, 60)        t.seth(180)        t.circle(-100, 10)        t.left(180)        t.circle(100, 10)        t.seth(5)        t.circle(100, 10)        t.circle(-100, 40)        t.circle(100, 35)        t.left(180)        t.circle(-100, 10)        t.seth(290)        t.circle(100, 55)        t.circle(10, 50)        t.seth(120)        t.circle(100, 20)        t.left(180)        t.circle(-100, 20)        t.seth(0)        t.circle(10, 50)        t.seth(110)        t.circle(100, 20)        t.left(180)        t.circle(-100, 20)        t.seth(30)        t.circle(20, 50)        t.seth(100)        t.circle(100, 40)        t.seth(200)        t.circle(-100, 5)        t.left(180)        t.circle(100, 5)        t.left(30)        t.circle(100, 75)        t.right(15)        t.circle(-300, 21)        t.left(180)        t.circle(300, 3)        t.seth(43)        t.circle(200, 60)        t.right(10)        t.fd(10)        t.circle(5, 160)        t.seth(90)        t.circle(5, 160)        t.seth(90)        t.fd(10)        t.seth(90)        t.circle(5, 180)        t.fd(10)        t.left(180)        t.left(20)        t.fd(10)        t.circle(5, 170)        t.fd(10)        t.seth(240)        t.circle(50, 30)        t.end_fill()        self.meme(130, 125)        t.seth(-20)        t.fd(5)        t.circle(-5, 160)        t.fd(5)        self.meme(166, 130)        t.seth(-90)        t.fd(3)        t.circle(-4, 180)        t.fd(3)        t.seth(-90)        t.fd(3)        t.circle(-4, 180)        t.fd(3)        self.meme(168, 134)        t.fillcolor(&#39;#F6D02F&#39;)        t.begin_fill()        t.seth(40)        t.fd(200)        t.seth(-80)        t.fd(150)        t.seth(210)        t.fd(150)        t.left(90)        t.fd(100)        t.right(95)        t.fd(100)        t.left(110)        t.fd(70)        t.right(110)        t.fd(80)        t.left(110)        t.fd(30)        t.right(110)        t.fd(32)        t.right(106)        t.circle(100, 25)        t.right(15)        t.circle(-300, 2)        ##############         t.seth(30)        t.fd(40)        t.left(100)        t.fd(70)        t.right(100)        t.fd(80)        t.left(100)        t.fd(46)        t.seth(66)        t.circle(200, 38)        t.right(10)        t.fd(10)        t.end_fill()        t.fillcolor(&#39;#923E24&#39;)        self.meme(126.82, -156.84)        t.begin_fill()        t.seth(30)        t.fd(40)        t.left(100)        t.fd(40)        t.pencolor(&#39;#923e24&#39;)        t.seth(-30)        t.fd(30)        t.left(140)        t.fd(20)        t.right(150)        t.fd(20)        t.left(150)        t.fd(20)        t.right(150)        t.fd(20)        t.left(130)        t.fd(18)        t.pencolor(&#39;#000000&#39;)        t.seth(-45)        t.fd(67)        t.right(110)        t.fd(80)        t.left(110)        t.fd(30)        t.right(110)        t.fd(32)        t.right(106)        t.circle(100, 25)        t.right(15)        t.circle(-300, 2)        t.end_fill()        self.fucksisu9(-134.07, 147.81)        self.fucksisu(-5, 25)        self.fucksisu4(-126, 32)        self.fucksisu5(107, 63)        self.fucksisu6(-250, 100)        self.fucksisu7(140, 270)        self.ihatesisu1(-85, 90)        self.ihatesisu2(50, 110)        t.hideturtle()    def fucksisu9(self, x, y):        self.meme(x, y)        t = self.t        t.fillcolor(&#39;#CD0000&#39;)        t.begin_fill()        t.seth(200)        t.circle(400, 7)        t.left(180)        t.circle(-400, 30)        t.circle(30, 60)        t.fd(50)        t.circle(30, 45)        t.fd(60)        t.left(5)        t.circle(30, 70)        t.right(20)        t.circle(200, 70)        t.circle(30, 60)        t.fd(70)         t.right(35)        t.fd(50)        t.circle(8, 100)        t.end_fill()        self.meme(-168.47, 185.52)        t.seth(36)        t.circle(-270, 54)        t.left(180)        t.circle(270, 27)        t.circle(-80, 98)        t.fillcolor(&#39;#444444&#39;)        t.begin_fill()        t.left(180)        t.circle(80, 197)        t.left(58)        t.circle(200, 45)        t.end_fill()        self.meme(-58, 270)        t.pencolor(&#39;#228B22&#39;)        t.dot(35)        self.meme(-30, 280)        t.fillcolor(&#39;#228B22&#39;)        t.begin_fill()        t.seth(100)        t.circle(30, 180)        t.seth(190)        t.fd(15)        t.seth(100)        t.circle(-45, 180)        t.right(90)        t.fd(15)        t.end_fill()        t.pencolor(&#39;#000000&#39;)    def start(self):        self.fucksisu8()def main():    turtle.screensize(800, 600)    turtle.title(&#39;皮卡丘&#39;)    cartoon = Cartoon()    cartoon.start()    turtle.mainloop()if __name__ == &#39;__main__&#39;:    main()</code></pre><h3 id="画哆啦A梦"><a href="#画哆啦A梦" class="headerlink" title="画哆啦A梦"></a>画哆啦A梦</h3><pre><code class="python">import turtlefrom turtle import *turtle.title(&quot;哆啦A梦&quot;)def fucksisu1(x, y):    penup()    goto(x, y)    pendown()def fucksisu2():    fillcolor(&quot;#ffffff&quot;)    begin_fill()    tracer(False)    a = 2.5    for i in range(120):        if 0 &lt;= i &lt; 30 or 60 &lt;= i &lt; 90:            a -= 0.05            lt(3)            fd(a)        else:            a += 0.05            lt(3)            fd(a)    tracer(True)    end_fill()def fucksisu3():    fucksisu1(-32, 135)    seth(165)    fd(60)    fucksisu1(-32, 125)    seth(180)    fd(60)    fucksisu1(-32, 115)    seth(193)    fd(60)    fucksisu1(37, 135)    seth(15)    fd(60)    fucksisu1(37, 125)    seth(0)    fd(60)    fucksisu1(37, 115)    seth(-13)    fd(60)def fucksisu4():    fucksisu1(5, 148)    seth(270)    fd(100)    seth(0)    circle(120, 50)    seth(230)    circle(-120, 100)def fucksisu5():    fillcolor(&#39;#e70010&#39;)    begin_fill()    seth(0)    fd(200)    circle(-5, 90)    fd(10)    circle(-5, 90)    fd(207)    circle(-5, 90)    fd(10)    circle(-5, 90)    end_fill()def fucksisu6():    fucksisu1(-10, 158)    seth(315)    fillcolor(&#39;#e70010&#39;)    begin_fill()    circle(20)    end_fill()def black_fucksisu2():    seth(0)    fucksisu1(-20, 195)    fillcolor(&#39;#000000&#39;)    begin_fill()    circle(13)    end_fill()    pensize(6)    fucksisu1(20, 205)    seth(75)    circle(-10, 150)    pensize(3)    fucksisu1(-17, 200)    seth(0)    fillcolor(&#39;#ffffff&#39;)    begin_fill()    circle(5)    end_fill()    fucksisu1(0, 0)def face():    fd(183)    lt(45)    fillcolor(&#39;#ffffff&#39;)    begin_fill()    circle(120, 100)    seth(180)    fd(121)    pendown()    seth(215)    circle(120, 100)    end_fill()    fucksisu1(63.56, 218.24)    seth(90)    fucksisu2()    seth(180)    penup()    fd(60)    pendown()    seth(90)    fucksisu2()    penup()    seth(180)    fd(64)def fucksisu7():    penup()    circle(150, 40)    pendown()    fillcolor(&#39;#00a0de&#39;)    begin_fill()    circle(150, 280)    end_fill()def fucksisu8():    fucksisu7()    fucksisu5()    face()    fucksisu6()    fucksisu4()    fucksisu3()    fucksisu1(0, 0)    seth(0)    penup()    circle(150, 50)    pendown()    seth(30)    fd(40)    seth(70)    circle(-30, 270)    fillcolor(&#39;#00a0de&#39;)    begin_fill()    seth(230)    fd(80)    seth(90)    circle(1000, 1)    seth(-89)    circle(-1000, 10)    seth(180)    fd(70)    seth(90)    circle(30, 180)    seth(180)    fd(70)    seth(100)    circle(-1000, 9)    seth(-86)    circle(1000, 2)    seth(230)    fd(40)    circle(-30, 230)    seth(45)    fd(81)    seth(0)    fd(203)    circle(5, 90)    fd(10)    circle(5, 90)    fd(7)    seth(40)    circle(150, 10)    seth(30)    fd(40)    end_fill()    seth(70)    fillcolor(&#39;#ffffff&#39;)    begin_fill()    circle(-30)    end_fill()    fucksisu1(103.74, -182.59)    seth(0)    fillcolor(&#39;#ffffff&#39;)    begin_fill()    fd(15)    circle(-15, 180)    fd(90)    circle(-15, 180)    fd(10)    end_fill()    fucksisu1(-96.26, -182.59)    seth(180)    fillcolor(&#39;#ffffff&#39;)    begin_fill()    fd(15)    circle(15, 180)    fd(90)    circle(15, 180)    fd(10)    end_fill()    fucksisu1(-133.97, -91.81)    seth(50)    fillcolor(&#39;#ffffff&#39;)    begin_fill()    circle(30)    end_fill()    fucksisu1(-103.42, 15.09)    seth(0)    fd(38)    seth(230)    begin_fill()    circle(90, 260)    end_fill()    fucksisu1(5, -40)    seth(0)    fd(70)    seth(-90)    circle(-70, 180)    seth(0)    fd(70)    fucksisu1(-103.42, 15.09)    fd(90)    seth(70)    fillcolor(&#39;#ffd200&#39;)    begin_fill()    circle(-20)    end_fill()    seth(170)    fillcolor(&#39;#ffd200&#39;)    begin_fill()    circle(-2, 180)    seth(10)    circle(-100, 22)    circle(-2, 180)    seth(180 - 10)    circle(100, 22)    end_fill()    goto(-13.42, 15.09)    seth(250)    circle(20, 110)    seth(90)    fd(15)    dot(10)    fucksisu1(0, -150)    black_fucksisu2()if __name__ == &#39;__main__&#39;:    screensize(800, 600, &quot;#f0f0f0&quot;)    pensize(3)    speed(9)    fucksisu8()    mainloop()</code></pre><h3 id="钢铁侠"><a href="#钢铁侠" class="headerlink" title="钢铁侠"></a>钢铁侠</h3><pre><code class="python">import turtlefucksisu1 = [[(-40, 120), (-70, 260), (-130, 230), (-170, 200), (-170, 100), (-160, 40), (-170, 10), (-150, -10), (-140, 10),           (-40, -20), (0, -20)],          [(0, -20), (40, -20), (140, 10), (150, -10), (170, 10), (160, 40), (170, 100), (170, 200), (130, 230), (70, 260),           (40, 120), (0, 120)]]fucksisu2 = [[(-40, -30), (-50, -40), (-100, -46), (-130, -40), (-176, 0), (-186, -30), (-186, -40), (-120, -170), (-110, -210),           (-80, -230), (-64, -210), (0, -210)],          [(0, -210), (64, -210), (80, -230), (110, -210), (120, -170), (186, -40), (186, -30), (176, 0), (130, -40),           (100, -46), (50, -40), (40, -30), (0, -30)]]fucksisu3 = [[(-60, -220), (-80, -240), (-110, -220), (-120, -250), (-90, -280), (-60, -260), (-30, -260), (-20, -250),           (0, -250)],          [(0, -250), (20, -250), (30, -260), (60, -260), (90, -280), (120, -250), (110, -220), (80, -240), (60, -220),           (0, -220)]]turtle.hideturtle()turtle.bgcolor(&#39;#ba161e&#39;)  # Dark Redturtle.setup(500, 600)turtle.title(&quot;钢铁侠&quot;)fucksisu1Goto = (0, 120)fucksisu2Goto = (0, -30)fucksisu3Goto = (0, -220)turtle.speed(2)def logo(a, b):    turtle.penup()    turtle.goto(b)    turtle.pendown()    turtle.color(&#39;#fab104&#39;)  # Light Yellow    turtle.begin_fill()    for i in range(len(a[0])):        x, y = a[0][i]        turtle.goto(x, y)    for i in range(len(a[1])):        x, y = a[1][i]        turtle.goto(x, y)    turtle.end_fill()logo(fucksisu1, fucksisu1Goto)logo(fucksisu2, fucksisu2Goto)logo(fucksisu3, fucksisu3Goto)turtle.hideturtle()turtle.done()</code></pre><h3 id="蝙蝠侠"><a href="#蝙蝠侠" class="headerlink" title="蝙蝠侠"></a>蝙蝠侠</h3><pre><code class="python">import turtleimport mathturtle.title(&quot;蝙蝠侠&quot;)fucksisu1 = turtle.Turtle()fucksisu1.speed(500)window = turtle.Screen()window.bgcolor(&quot;#000000&quot;)fucksisu1.color(&quot;yellow&quot;)fucksisu2 = 20fucksisu1.left(90)fucksisu1.penup()fucksisu1.goto(-7 * fucksisu2, 0)fucksisu1.pendown()for a in range(-7 * fucksisu2, -3 * fucksisu2, 1):    x = a / fucksisu2    rel = math.fabs(x)    y = 1.5 * math.sqrt((-math.fabs(rel - 1)) * math.fabs(3 - rel) / ((rel - 1) * (3 - rel))) * (                1 + math.fabs(rel - 3) / (rel - 3)) * math.sqrt(1 - (x / 7) ** 2) + (                    4.5 + 0.75 * (math.fabs(x - 0.5) + math.fabs(x + 0.5)) - 2.75 * (                        math.fabs(x - 0.75) + math.fabs(x + 0.75))) * (1 + math.fabs(1 - rel) / (1 - rel))    fucksisu1.goto(a, y * fucksisu2)for a in range(-3 * fucksisu2, -1 * fucksisu2 - 1, 1):    x = a / fucksisu2    rel = math.fabs(x)    y = (2.71052 + 1.5 - 0.5 * rel - 1.35526 * math.sqrt(4 - (rel - 1) ** 2)) * math.sqrt(        math.fabs(rel - 1) / (rel - 1))    fucksisu1.goto(a, y * fucksisu2)fucksisu1.goto(-1 * fucksisu2, 3 * fucksisu2)fucksisu1.goto(int(-0.5 * fucksisu2), int(2.2 * fucksisu2))fucksisu1.goto(int(0.5 * fucksisu2), int(2.2 * fucksisu2))fucksisu1.goto(1 * fucksisu2, 3 * fucksisu2)for a in range(1 * fucksisu2 + 1, 3 * fucksisu2 + 1, 1):    x = a / fucksisu2    rel = math.fabs(x)    y = (2.71052 + 1.5 - 0.5 * rel - 1.35526 * math.sqrt(4 - (rel - 1) ** 2)) * math.sqrt(        math.fabs(rel - 1) / (rel - 1))    fucksisu1.goto(a, y * fucksisu2)for a in range(3 * fucksisu2 + 1, 7 * fucksisu2 + 1, 1):    x = a / fucksisu2    rel = math.fabs(x)    y = 1.5 * math.sqrt((-math.fabs(rel - 1)) * math.fabs(3 - rel) / ((rel - 1) * (3 - rel))) * (                1 + math.fabs(rel - 3) / (rel - 3)) * math.sqrt(1 - (x / 7) ** 2) + (                    4.5 + 0.75 * (math.fabs(x - 0.5) + math.fabs(x + 0.5)) - 2.75 * (                        math.fabs(x - 0.75) + math.fabs(x + 0.75))) * (1 + math.fabs(1 - rel) / (1 - rel))    fucksisu1.goto(a, y * fucksisu2)for a in range(7 * fucksisu2, 4 * fucksisu2, -1):    x = a / fucksisu2    rel = math.fabs(x)    y = (-3) * math.sqrt(1 - (x / 7) ** 2) * math.sqrt(math.fabs(rel - 4) / (rel - 4))    fucksisu1.goto(a, y * fucksisu2)for a in range(4 * fucksisu2, -4 * fucksisu2, -1):    x = a / fucksisu2    rel = math.fabs(x)    y = math.fabs(x / 2) - 0.0913722 * x ** 2 - 3 + math.sqrt(1 - (math.fabs(rel - 2) - 1) ** 2)    fucksisu1.goto(a, y * fucksisu2)for a in range(-4 * fucksisu2 - 1, -7 * fucksisu2 - 1, -1):    x = a / fucksisu2    rel = math.fabs(x)    y = (-3) * math.sqrt(1 - (x / 7) ** 2) * math.sqrt(math.fabs(rel - 4) / (rel - 4))    fucksisu1.goto(a, y * fucksisu2)fucksisu1.penup()fucksisu1.goto(300, 300)turtle.done()</code></pre>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;turtle 库是 Python 的标准库之一，属于入门级的图形绘制函数库，其原理是让一只海龟在画布上游走，走过的轨迹形成了绘制的图形，海龟由程序控制，可以自由改变颜色、方向宽度等。我们也可以依赖这个库完成一些简单的画画，以下为一些经典图像的代码实现笔记，可供参考。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="编程与开发" scheme="http://blog.zhuangzhihao.top/categories/%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="Python" scheme="http://blog.zhuangzhihao.top/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>IntelliJ IDEA的配置与使用总结</title>
    <link href="http://blog.zhuangzhihao.top/IDEA%E9%85%8D%E7%BD%AE/"/>
    <id>http://blog.zhuangzhihao.top/IDEA%E9%85%8D%E7%BD%AE/</id>
    <published>2021-05-19T16:00:00.000Z</published>
    <updated>2021-08-31T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>IntelliJ IDEA 被公认为是最好的 Java 开发工具之一，尤其在智能代码助手、代码自动提示、重构、J2EE 支持、Ant、JUnit、CVS 整合、代码审查、创新的GUI 设计等方面的功能可以说是超常的。相较于 Eclipse 而言，IDEA 增加了强大的整合能力、好用的快捷键和代码模板以及精准搜索，一些新的特性非常有必要学习熟悉。我目前使用的是 IDEA Ultimate 2021.2 版本，本篇笔记也是对最新版 IDEA 项目的创建、模板的使用、断点调试、数据库的关联、插件的下载、Maven及版本控制工具的配置等内容的一些总结。</p></blockquote><a id="more"></a><h3 id="安装目录"><a href="#安装目录" class="headerlink" title="安装目录"></a>安装目录</h3><ul><li><code>bin</code>：容器，执行文件和启动参数等<ul><li><code>idea.exe.vmoptions</code>：VM 配置文件</li><li><code>idea.properties</code>：IDEA 属性配置文件</li></ul></li><li><code>help</code>：快捷键文档和其他帮助文档</li><li><code>jre64</code>：64 位 java 运行环境 </li><li><code>lib</code>：IDEA 依赖的类库 </li><li><code>license</code>：各个插件许可 </li><li><code>plugin</code>：插件</li></ul><h3 id="设置目录"><a href="#设置目录" class="headerlink" title="设置目录"></a>设置目录</h3><h4 id="config-目录"><a href="#config-目录" class="headerlink" title="config 目录"></a>config 目录</h4><ul><li>IDE 主要配置功能、自定义的代码模板、自定义的文件模板、自定义的快捷键、Project 的 tasks 记录等个性化配置</li></ul><h4 id="system-目录"><a href="#system-目录" class="headerlink" title="system 目录"></a>system 目录</h4><ul><li>缓存、索引、容器文件输出等</li></ul><h3 id="Project"><a href="#Project" class="headerlink" title="Project"></a>Project</h3><ul><li>IntelliJ IDEA 没有类似 Eclipse 的工作空间的概念（ Workspaces），最大单元就是 Project</li><li>Eclipse 中 Workspace 相当于 IDEA 中的 Project</li><li>Project 下的 <code>src</code> 类似于 Eclipse 下的 <code>src</code> 目录，用于存放代码</li><li>Project 下的 <code>.idea</code> 和 <code>projectname.iml</code> 文件都是 IDEA 工程特有的，类似于 Eclipse 工程下的 <code>.settings</code>、<code>.classpath</code>、<code>.project</code> 等</li></ul><h3 id="Module"><a href="#Module" class="headerlink" title="Module"></a>Module</h3><ul><li>Eclipse 中 Project 相当于 IDEA 中的 Module</li><li>在 IntelliJ IDEA 中 Project 是最顶级的级别，次级别是 Module</li><li>一个 Project 可以有多个 Module。目前主流的大型项目都是分布式部署的， 结构都是类似这种多 Module 结构</li></ul><h3 id="常用配置"><a href="#常用配置" class="headerlink" title="常用配置"></a>常用配置</h3><ul><li><p>Editor -&gt; General</p><ul><li>Change font size with <code>Ctrl</code> + Mouse Wheel</li></ul></li><li><p>Editor -&gt; General -&gt; Auto Import</p><ul><li><p>Add unambiguous imports on the fly</p></li><li><p>Optimize imports on the fly</p></li></ul></li><li><p>Editor -&gt; General -&gt; Appearance</p><ul><li>Show line numbers</li><li>Show method separators</li></ul></li><li><p>Editor -&gt; General -&gt; Code Completion</p><ul><li>取消 Match Case</li></ul></li><li><p>Editor -&gt; General -&gt; Editor Tabs</p><ul><li>取消 Show tabs in one row </li></ul></li><li><p>Editor -&gt; File and Code Templates -&gt; Includes</p><pre><code class="java">/** @author Bezhuang@create $&#123;YEAR&#125;-$&#123;MONTH&#125;-$&#123;DAY&#125; $&#123;TIME&#125; */ </code></pre></li><li><p>Editor -&gt; File Encodings</p><ul><li>Global / Project / Default encoding: <code>UTF-8</code></li><li>Transparent native-to-ascii conversion</li></ul></li><li><p>Build, Execution, Deployment -&gt; Compiler</p><ul><li>Build project automatically（如果电脑带不动取消）</li><li>Compile independent modules in parallel</li></ul></li></ul><h3 id="Keymap"><a href="#Keymap" class="headerlink" title="Keymap"></a>Keymap</h3><table><thead><tr><th>快捷键</th><th>实现效果</th></tr></thead><tbody><tr><td>Ctrl + X</td><td>删除当前行</td></tr><tr><td>Ctrl +D</td><td>复制当前行</td></tr><tr><td>Alt+Insert（右键Generate）</td><td>get、set方法，构造函数等</td></tr><tr><td>Ctrl+Alt+T</td><td><code>try catch</code>（Alt+enter选择）</td></tr><tr><td>CTRL+ALT+T</td><td>把选中的代码放在 <code>TRY&#123;&#125;</code> <code>IF&#123;&#125;</code> <code>ELSE&#123;&#125;</code> 里</td></tr><tr><td>Ctr+shift+U</td><td>大小写之间转化</td></tr><tr><td>ALT+回车</td><td>导入包，自动修正</td></tr><tr><td>CTRL+ALT+L</td><td>格式化代码</td></tr><tr><td>CTRL+ALT+I</td><td>自动缩进</td></tr><tr><td>CTRL+E</td><td>最近更改的代码</td></tr><tr><td>Alt + 左右键</td><td>多窗口</td></tr><tr><td>Ctrl + 鼠标点击</td><td>快速找到成员变量的出处</td></tr><tr><td>Shift+F6</td><td>重构/重命名 (包、类、方法、变量、甚至注释等)</td></tr><tr><td>CTRL+Q</td><td>查看当前方法的声明</td></tr><tr><td>Ctrl+Alt+V</td><td><code>new 对象();</code>（自动创建变量）</td></tr><tr><td>Ctrl+O</td><td>重写方法</td></tr><tr><td>Ctrl+I</td><td>实现方法</td></tr><tr><td>ALT+/</td><td>代码提示</td></tr><tr><td>Ctrl+Shift+R</td><td>在当前项目中替换指定内容</td></tr><tr><td>Ctrl+E</td><td>最近编辑的文件列表</td></tr><tr><td>Ctrl+P</td><td>显示方法参数信息</td></tr><tr><td>Ctrl+Shift+Insert</td><td>查看历史复制记录</td></tr></tbody></table><h3 id="Templates"><a href="#Templates" class="headerlink" title="Templates"></a>Templates</h3><ul><li><p>Live Templates 可以自定义，而 Postfix Completion 不可以</p></li><li><p>psvm -&gt; <code>public static void main(String[] args)</code></p></li><li><p>sout -&gt; <code>System.out.println()</code> </p><ul><li>soutp -&gt; <code>System.out.println(&quot;方法形参名 = &quot; + 形参名);</code></li><li>soutv -&gt; <code>System.out.println(&quot;变量名 = &quot; + 变量);</code></li><li>soutm -&gt; <code>System.out.println(&quot;当前类名.当前方法&quot;);</code></li><li>“abc”.sout -&gt; <code>System.out.println(&quot;abc&quot;);</code></li></ul></li><li><p>fori -&gt; for 循环</p><ul><li>iter -&gt; 增强 for 循环</li><li>itar -&gt; 普通 for 循环</li></ul></li><li><p>list -&gt; <code>List&lt;String&gt; list = new ArrayList&lt;String&gt;();</code></p><ul><li>list.for -&gt; <code>for(String s:list)&#123;&#125;</code></li></ul></li></ul><ul><li><p>list.fori -&gt; 正序遍历</p></li><li><p>list.forr -&gt; 倒序遍历</p></li><li><p>ifn -&gt; <code>if(xxx = null)</code></p><ul><li>inn -&gt; <code>if(xxx != null)</code></li><li>xxx.nn</li><li>xxx.null</li></ul></li><li><p>prsf -&gt; <code>private static final</code></p><ul><li>psf -&gt; <code>public static final</code></li><li>psfi -&gt; <code>public static final int</code></li><li>psfs -&gt; <code>public static final String</code></li></ul></li></ul><h3 id="创建-Java-Web"><a href="#创建-Java-Web" class="headerlink" title="创建 Java Web"></a>创建 Java Web</h3><ul><li>Module 右键 -&gt; add Framework Support</li><li>配置本地 Tomcat 环境变量<ul><li>系统环境变量中新建 <code>CATALINA_HOME</code> 环境变量</li><li>修改 <code>Path</code> ： <code>%CATALINA_HOME%\lib</code>、<code>%CATALINA_HOME%\bin</code>、<code>%CATALINA_HOME%\lib\servlet-api.jar</code></li><li>Tomcat 文件夹下打开 Terminal：<code>catalina run</code> 启动 Tomcat</li></ul></li></ul><h3 id="关联数据库"><a href="#关联数据库" class="headerlink" title="关联数据库"></a>关联数据库</h3><ul><li>IDEA 的 Database 对于常使用的 ORM 框架，如 Hibernate、 Mybatis有很好的支持，比如配置好了 Database 之后，IDEA 会自动识别 domain 对象与数据表的关系，也可以通过 Database 的数据表直接生成 domain 对象等</li></ul><h3 id="版本控制"><a href="#版本控制" class="headerlink" title="版本控制"></a>版本控制</h3><ul><li>IntelliJ IDEA 对版本控制的支持是以插件化的方式来实现的</li><li>IntelliJ IDEA 自带了 Github 插件，方便 Checkout 和管理 Github 项目</li><li>File -&gt; Setting -&gt; VCS (version control system)</li><li>VCS -&gt; Get from Version Control</li></ul><h3 id="断点调试"><a href="#断点调试" class="headerlink" title="断点调试"></a>断点调试</h3><h4 id="Debug-的设置"><a href="#Debug-的设置" class="headerlink" title="Debug 的设置"></a>Debug 的设置</h4><ul><li>File -&gt; Settings -&gt; Build, Execution, Deployment -&gt; Debugger<ul><li>Java -&gt; Transport: Shared memory</li></ul></li></ul><h4 id="断点调试快捷键"><a href="#断点调试快捷键" class="headerlink" title="断点调试快捷键"></a>断点调试快捷键</h4><ul><li>step over：进入下一步，如果当前行断点是一个方法，则不进入当前方法体内</li><li>step into：进入下一步，如果当前行断点是一个方法，则进入当前方法体内</li><li>force step into：进入下一步，如果当前行断点是一个方法，则进入当前方法体内</li><li>step out：跳出</li><li>resume program：恢复程序运行，但如果该断点下面代码还有断点则停在下一个断点上</li><li>stop：停止</li><li>mute breakpoints：点中，使得所有的断点失效</li><li>view breakpoints：查看所有断点</li></ul><h4 id="条件断点"><a href="#条件断点" class="headerlink" title="条件断点"></a>条件断点</h4><ul><li>调试的时候，在循环里增加条件判断，可以极大的提高效率</li><li>在断点处右击调出条件断点，可以在满足某个条件下，实施断点</li><li>选择行后 CTRL + u，可以在查看框中输入编写代码时的其他方法</li></ul><h3 id="配置-Maven"><a href="#配置-Maven" class="headerlink" title="配置 Maven"></a>配置 Maven</h3><ul><li>自动化构建工具：Make -&gt; Ant -&gt; Maven -&gt; Gradle </li><li>Maven 使用了一个标准的目录结构和一个默认的构建生命周期，用于自动化构建和依赖管理</li><li>构建环节<ul><li>清理：表示在编译代码前将之前生成的内容删除</li><li>编译：将源代码编译为字节码</li><li>测试：运行单元测试用例程序</li><li>报告：测试程序的结果</li><li>打包：将 java 项目打成 jar 包，或将 Web 项目打成 war 包</li><li>安装：将 jar 或 war 生成到 Maven 仓库中</li><li>部署：将 jar 或 war 从 Maven 仓库中部署到 Web 服务器上运行</li></ul></li><li>File -&gt; Settings -&gt; Maven：选择自己Maven 的目录和 settings 文件，然后配置自己的本地仓库 repository</li><li>Maven 目录下有对应的生命周期，其中常用的是：clean、compile、package、install</li></ul><h3 id="其他设置"><a href="#其他设置" class="headerlink" title="其他设置"></a>其他设置</h3><ul><li>生成 javadoc<ul><li>Tools -&gt; Generate JavaDoc</li><li>Locale（输入语言类型）：zh_CN </li><li>Other command line arguments: <code>-encoding UTF-8 -charset UTF-8</code></li></ul></li><li>缓存和索引的清理<ul><li>IntelliJ IDEA 首次加载项目的时候，都会创建索引，而创建索引的时间跟项目的文件多少成正比</li><li>IntelliJ IDEA 的缓存和索引主要是用来加快文件查询，从而加快各种查找、代码提示等操作的速度</li><li>某些特殊条件下，IntelliJ IDEA 的缓存和索引文件也是会损坏的，可以清理缓存和索引</li><li>File -&gt; Invalidate Caches / Restart</li></ul></li><li>插件<ul><li>File -&gt; Settings -&gt; Plugins</li><li><a href="https://plugins.jetbrains.com/">https://plugins.jetbrains.com/</a> </li></ul></li></ul>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;IntelliJ IDEA 被公认为是最好的 Java 开发工具之一，尤其在智能代码助手、代码自动提示、重构、J2EE 支持、Ant、JUnit、CVS 整合、代码审查、创新的GUI 设计等方面的功能可以说是超常的。相较于 Eclipse 而言，IDEA 增加了强大的整合能力、好用的快捷键和代码模板以及精准搜索，一些新的特性非常有必要学习熟悉。我目前使用的是 IDEA Ultimate 2021.2 版本，本篇笔记也是对最新版 IDEA 项目的创建、模板的使用、断点调试、数据库的关联、插件的下载、Maven及版本控制工具的配置等内容的一些总结。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="编程与开发" scheme="http://blog.zhuangzhihao.top/categories/%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="Java" scheme="http://blog.zhuangzhihao.top/tags/Java/"/>
    
    <category term="IDEA" scheme="http://blog.zhuangzhihao.top/tags/IDEA/"/>
    
  </entry>
  
  <entry>
    <title>云上搭建基于Anaconda的Jupyter数据科学环境</title>
    <link href="http://blog.zhuangzhihao.top/%E4%BA%91%E4%B8%8A%E6%90%AD%E5%BB%BAJupyter%20Notebook/"/>
    <id>http://blog.zhuangzhihao.top/%E4%BA%91%E4%B8%8A%E6%90%AD%E5%BB%BAJupyter%20Notebook/</id>
    <published>2021-05-08T16:00:00.000Z</published>
    <updated>2021-06-11T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Jupyter Notebook是基于浏览器网页的用于交互计算的应用程序，支持Python、R、Julia和Scala等多种语言，在数据科学相关领域有着非常大的用途。JupyterLab是基于web的集成开发环境，包含了Jupyter Notebook所有功能的同时还支持操作终端、编辑markdown文本、打开交互模式、查看csv文件及图片等功能，最近在学习的IBM数据科学专项课程也都是基于Jupyter Lab的，在阿里云主机上部署Jupyter环境也能使研究和学习更加方便。本篇笔记是在多次踩坑后总结的适用于CentOS7.6系统的过程记录。</p></blockquote><a id="more"></a><h3 id="安装Anaconda"><a href="#安装Anaconda" class="headerlink" title="安装Anaconda"></a>安装Anaconda</h3><ul><li><p>通过清华源安装最新版本Anaconda</p><pre><code class="bash">wget http://mirrors.tuna.tsinghua.edu.cn/anaconda/archive/Anaconda3-2020.11-Linux-x86_64.shbash Anaconda3-2020.11-Linux-x86_64.sh# 狂按Enter&gt;&gt;yes&gt;&gt;继续狂按Enter安装</code></pre></li><li><p>Anaconda默认安装在<code>/root/anaconda3</code>目录下</p></li><li><p>配置环境变量</p><pre><code class="bash">vim ~/.bashrc# 添加下面两行内容#added by Anaconda3 4.4.0 installerexport PATH=&quot;/root/anaconda3/bin:$PATH&quot;</code></pre></li><li><p>激活Anaconda环境并测试</p><pre><code class="bash">source ~/.bashrcconda --version</code></pre></li><li><p>添加清华镜像源，并搜索时显示通道地址</p><pre><code class="bash">conda config --add channels &#39;https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/&#39;conda config --set show_channel_urls yes</code></pre></li><li><p>创建jupyter notebook运行环境</p><pre><code class="bash">conda create -n jupyter_notebook python=3# source activate jupyter_notebook 激活环境# source deactivate 退出环境</code></pre></li></ul><h3 id="安装配置Jupyter"><a href="#安装配置Jupyter" class="headerlink" title="安装配置Jupyter"></a>安装配置Jupyter</h3><ul><li><p>通过Anaconda安装Jupyter Notebook</p><pre><code class="bash">conda install jupyter notebook# 输入jupyter notebook --ip=127.0.0.1 --allow-root 可运行则为安装成功</code></pre></li><li><p>生成Jupyter Notebook配置文件</p><pre><code class="bash">jupyter notebook --generate-config</code></pre></li><li><p>设置Jupyter Notebook密码</p><pre><code class="bash">ipythonIn [1]: from notebook.auth import passwdIn [2]: passwd()Enter password: Verify password: Out[2]: &#39;加密字符串&#39;</code></pre></li><li><p>修改配置文件</p><pre><code class="bash">vim /root/.jupyter/jupyter_notebook_config.py#修改如下行c.NotebookApp.ip = &#39;*&#39;c.NotebookApp.password = &#39;加密字符串&#39;c.NotebookApp.open_browser = Falsec.NotebookApp.allow_root = True</code></pre></li><li><p>启动Jupyter Notebook</p><pre><code class="bash">jupyter notebook</code></pre></li><li><p>访问<a href="http://106.15.200.147:8888/">云服务器公网ip地址:8888</a></p></li><li><p>启动Jupyter Lab</p><pre><code class="bash">jupyter lab</code></pre></li><li><p>访问<a href="http://106.15.200.147:8888/">云服务器公网ip地址:8888</a></p></li></ul><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li>Jupyter Notebook只适用于单用户登录，如果想搭建多用户的Jupyter的话，要使用JupyterHub进行搭建</li><li>阿里云默认不打卡8888端口，需要在服务器管理控制台中设置开放端口</li></ul><h3 id="添加JAVA环境支持"><a href="#添加JAVA环境支持" class="headerlink" title="添加JAVA环境支持"></a>添加JAVA环境支持</h3><ul><li><p>安装JDK（过程略）</p></li><li><p>下载 java 内核压缩包<code>ijava</code>，<a href="https://github.com/SpencerPark/IJava/releases">下载地址</a></p></li><li><p>上传到服务器，使用<code>unzip</code>命令解压</p></li><li><p>安装Java内核</p><pre><code class="bash">python install.py --sys-prefix</code></pre></li><li><p>查看Jupyter内核支持</p><pre><code class="python">jupyter kernelspec list&#39;&#39;&#39;Available kernels:  java       /root/anaconda3/share/jupyter/kernels/java  python3    /root/anaconda3/share/jupyter/kernels/python3&#39;&#39;&#39;</code></pre></li></ul>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;Jupyter Notebook是基于浏览器网页的用于交互计算的应用程序，支持Python、R、Julia和Scala等多种语言，在数据科学相关领域有着非常大的用途。JupyterLab是基于web的集成开发环境，包含了Jupyter Notebook所有功能的同时还支持操作终端、编辑markdown文本、打开交互模式、查看csv文件及图片等功能，最近在学习的IBM数据科学专项课程也都是基于Jupyter Lab的，在阿里云主机上部署Jupyter环境也能使研究和学习更加方便。本篇笔记是在多次踩坑后总结的适用于CentOS7.6系统的过程记录。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="云计算与应用开发" scheme="http://blog.zhuangzhihao.top/categories/%E4%BA%91%E8%AE%A1%E7%AE%97%E4%B8%8E%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="Data Science" scheme="http://blog.zhuangzhihao.top/tags/Data-Science/"/>
    
    <category term="云服务器" scheme="http://blog.zhuangzhihao.top/tags/%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
  </entry>
  
</feed>
