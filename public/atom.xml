<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Bezhuang&#39;s Blog</title>
  
  
  <link href="http://blog.zhuangzhihao.top/atom.xml" rel="self"/>
  
  <link href="http://blog.zhuangzhihao.top/"/>
  <updated>2022-01-16T16:00:00.000Z</updated>
  <id>http://blog.zhuangzhihao.top/</id>
  
  <author>
    <name>Bezhuang</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>JPMorgan Chase Software Engineering Virtual Experience Program</title>
    <link href="http://blog.zhuangzhihao.top/JP-Morgan-Banking-Technology-Virtual-Program/"/>
    <id>http://blog.zhuangzhihao.top/JP-Morgan-Banking-Technology-Virtual-Program/</id>
    <published>2022-01-09T16:00:00.000Z</published>
    <updated>2022-01-16T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="ef7e1baf9e59fdebd3ce0eb3893109b1d660e1d537be5e186170a2e37981a412">cec776f7fc63ae327c1b8b56b82bb8d06ddf381de1ed6a9d4eceaf4f70557eaee91ec675d0c9aff3b6390370b5842b290eaae3060bb80cabaab32d5ff77709a1a0efeeecdabff823e4e6cb2fac19e0d658a71b1a71d80a3b92c57258d448746d6b731552e0959ddafcb7a8c89134c273ef5698fd5f304d6bdfcf8ba507da29e8e036776372ec7a7ffe186677e53557abf71cf3142951c400dbf1bc3254e3bad55e8fbe0e5616338876ad873a016b3b6c5078f88676438ff8695a46373ededd6c8eb304d1219b66b5c92e09a9f20a091f57571a13cfc8975813dc33f67b6c2cc4102490f65a9ddf7cbb1b6940676e8bd01589d08400f1479625840dec241aae1c197ae9b34485ba2b8f61838bd37475d10361e36e0aba7a6bfa6ca668933537b75a3743328bf7b83d098f9aaff5452bb1dcb43043bfc486a26a41ef00812cf47b0f336c86e4830e3dd6aa5fbe3c1f7808f6e98178e649d01a2898a45be0dad6bbbb3680f2ed9f937e273b27d5028090fb6c69ee255612b29b0bbc881ef4bfd348f7536902763d22233cc8e6ce226d74de1ae0f588f36215dd7049b28a21cb5ead505fffcbe4742be22469dbd8363629e45fbf2abf5316ecf8fbf34bd8dcb100ad172662828430006789c09b9ef70b082337e77b5e0631c711429c1d429a2e00ac66e98a281022b93bf9613a59603cf8d1c5ec7162b326fc5b6f5ef52ca205540462485e3c6cb0965966d1df22a120ffadbe7f4e7616e35436bc2cbd11688518c0d57205daa616e865d00301d8df3f27e036216527a2cb5a6a6c6d85bfabe598fb4f1b2227e3951c9022d5ac3e52701ccfbc6e099665e6349c044ca04318edbd647922ef82f4bc8a18346fb27a13eeb54bb8f3c27756904faa750179c3e5a1d2e2ff5ca343e2f68425b33b4a6e5291620a8ceabb7db258605188095526920970186a011081f73e990d36820dc0ac09e0dbb7ef56f7e3604a71c8db7c59f2c33299b9e70f4da9464788126c7354b91c883e131cc17b5f8cb662fc208eee081f6fc34d44ad1bd32968d11babe3ea28d7f666a02e4029d4ddc40cf7d29469c3faf496a56a23acc206a0934befef14bcf2d104e8cd8066d62cebee72590fa25ea43a436d3b1a466045362860f8e8d328733c55becafd3aa3f889c753246ea41bf03138ae2096c69e43c0bf344f91f186072125c36c448462ab2e76bca501cb1584ed5766ea17ddf4b1d2a96c9aaa08f49593e9660f90c083f0126a063ca2a13e12285e8930c2d47c055b839e1ee5f047f2fd3aaf0e5c13517554e97bce8d45f387f0336c6908611085b5226aeee53e49a38c928c57e04802acba23c3468f4711023cd48036ae7a1a54b7e2a947ecad0882f9a6645da0bb224a0e63b7368f141ba6f348490d1e13a0f9855b45395a57339514787410af4f3d2445315c0aafbf390bfeb135157fa975c19d28982b1b629a900488c898f6dd2221e85cbbb8a87302375f3ab5f1af24e8937b8afc9177755cccc4878dcfeebc426623ec5910a9bacbd14c4c68848c059745567bb16694c1e9c672cf7872653ee6803973d549b1829cc3bc0a6e896da94c80249d1bf82b4a20e2bc3331b257e08b5d352a64593d1776e731a1e721cb9f5d06e257101d9e662fc2bc95415696018092b02fc4e17fc52c090b2fa4053099130e71844e8e320110ef91860a3e7dce09e4f69c5e2e70878191a8d795d0b7cd511fb737872e9b2ccb507fc5095ee6101b247ffaea708de69ba116e20cf483aa3c968c8c0827e2476cb83c0b155b378dc36209c8d4769e747e2eb3fbc5bc0b1881fc3145772135d4703874da0ed539bbc354f426a00a7fa41340eb578e5aef75fa2c671858760af7951f082f6ad5c4d2a7a3b6f9a2b306f6ddf86d4b36605dec0f01268091241ed9ef21d39c95c012f5e280d62d9327da1cc0cfbd7f18c27cdd68d5caa0b172204f722194f8542e7dd3746b8f6666b7b1ac77e3b52e63686c6188b0737f6da9dfa8ff59d8afcc99312aad7c336a17d761a0341efe18b9338eebb4bb38cd3a4ba9f9930e8f8aa94874078157a9e00e9069f351e393e70f22ce6e80c874f7bc10080a13c9e5bca6f336ad07e91f2bb0c304ba1248c5a03dec127ebd32e866132dcd664f319c54ec4568f07b37a397e4be7854615558ecf2edb9733300824d90b7a8ae2ba58ad4c12a49daa45cc67d5bdc358b0d208242bf8b302695fbbc2249b5a1151ea9d9278cb747f01289a39f8f82974065791a4530a1fa3226f8ea1e65396e04d4cf74e2453f38fe6c6e60a05288bd85a992cea4c6b460085440cd25da313f74a2d48be83ef5994544208140b64b3ab76d0c1000bf0f3f0dd968ffaf31bf3b7960c24a45fdc75e0cc1c80719d1c096f80a0df9e55eacef9d42420afb63d62ea0097ec1655f71f37ca36468a6bced7a8505f58aa52364ac33574423397234f070bbfb8a13a2361dec67a70cf5a617354053774da60ce3330b8039611f3b139be3cbf7dcaade88edf49e54dce13bf2ae6f7e0228eb48863a499dd8baa7d519118d76ffdd9e7e0945860bfe785f3e0e1e7c9536a81acbec5388010aac316e7f81a90ee78b512978d4c4248648ee9dafcbfe7f40b4b1b622b6c4e12971731ab96ff5093d49eb506b6b6a323f8d539f050fed25e997c65af49ee4e2dc95f6afb95fac2dfa26b4fb1b77175c7b0b80da933a6accb35dddc9f5fe572f4dd997f31bd87cb21ad56c5a63855c20ee49b456e477ec7b585230a429735f3b3e4e73b8cbb772100699f2e27d33d2d59376983d0da0cbc5280c4636b9b1a9ccb633b1acbda175cc80ea2cbb52395c869f45ede5dcd4cabb64044d8e727e9e1856e56298e36ba0050f6e9d1fa449916c523971189107706cdb5387238da509ec393ec34c6342c0c39dcce911f7dd74002e7f75bc28c0e268c573064e75421ed40ba76b8112850f8c34fa9762a367147a08ddc1ecc53ab6a3d6ff923c85c8e88e93d95f6cb3513e8b8cc858ac286914b47b9e4f12e0d3b595efb9241047a512030590815e5dab4bc68e9a118877e89ef3933118c2365fcfe96d39f4d1b4e08475aed4a1a291c1cebeeb7a8cb9a5cca4e3355bf9dd8b93643036f53668fb4187ed9bacc854c1f0ac7104c460e2d646517eb9d33d1d5d2d88ad31d6983e84a3d5f9c7c8df6427ac198754520ac83af00aa1049de0ffe78c61f2037129556de956924356d994afb1a4f8d6f87e93ec6050205f65729415d102ef946b4d2ba3d429ecfa3b2db72dc2240e19091abf69b56c4c768ef21f802bc86020cf8a8b9b5514e65e64f577120b795905b56f23d255e19e8ea6632334ca0eb11de8ea2dcf25b47eaa5b7535b26cb0a04dec4d54e89306b2735ba0034e989b4e8599fb9ad406cddad1a0caa19cee60565db649f26afd41af39b6bb48f8bb572934017d20ddebb46b4f6e91e430c6bf96c858d9a38f569b1298c92feb5bfef44817adea08d7cf616c5d30b82000d5da0b10a1d8932ac740aaa125e34d60f69dd797520716b643eb6b4d436cffa42ef2196ebb74b57114cd2d3e4f648d3231ae75e5024b1b98808c188236f7e19ede9157f83fa3f4e3b5199c03497fb667b40144f621fea14438eb5e04ba59ccdd4bb06a0bc87c8365ce15efc8fdacd6db6dd32301af281051507bf2707e99c92ade8d8b11d25ed1d8bcd7b8e70f19add0fa3b64170348bc561d25716ed14f66b7d16b2404305a484e2974e5d735521e6ce9428961e189dab3fc910a6e57a74763233e87f20d6c1113a391c62c3bfe7a489fcb22c000e3408d730565e6aa6f527c14575fa9c121aba21f0b5a284a65d56fd89e6f67c92eafc4fe64025c6a2bde9c64904f26384c7717ea1a282dc193e26fa45f37758c29bd32094f96233995c10d6e5b3d36457d7c038ba367d11fef91f78e8c8df51f2d23a7658d904cddbaf67d9dd7b89f8337c6c75abc15d6c16ab7c5b1ecf375ffa744e8a7c63d2eb437d14aa851887ad87061b8be1b71ff1aad6e97582b3da55c1494ee35121c50640d25936b87ae15f6dd5cf14c796a4409898415928644e3e50d45b87a796c105dee812c4b0f4c95262e23e6383824cdb1a1ffdc31bd41853a44bbaeb122767c8d982b1898c93ff6d9a5898ad228ccd1867a2b6374f029baaa7029100ecd3fae075f6b13c38a263e4f14</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <summary type="html">Here&#39;s something encrypted, password is required to continue reading.</summary>
    
    
    
    <category term="程序人生" scheme="http://blog.zhuangzhihao.top/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/"/>
    
    
    <category term="Python" scheme="http://blog.zhuangzhihao.top/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Accenture Coding Virtual Experience Program</title>
    <link href="http://blog.zhuangzhihao.top/Accenture-Coding-Virtual-Experience/"/>
    <id>http://blog.zhuangzhihao.top/Accenture-Coding-Virtual-Experience/</id>
    <published>2021-12-31T16:00:00.000Z</published>
    <updated>2022-01-16T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>The Accenture Know-the-Code Virtual Experience Program covers the fundamentals of software development, including object-oriented programming, code refactoring, and agile delivery. It empowers me to explore what a career in software development could look like at Accenture while practicing my coding skills. The following are the notes I took during this virtual experience.</p></blockquote><a id="more"></a><div class="row">    <embed src="/pdf/Accenture-Coding-Virtual-Experience.pdf" width="100%" height="550" type="application/pdf"></div><h3 id="Task-1-Object-Oriented-Programming"><a href="#Task-1-Object-Oriented-Programming" class="headerlink" title="Task 1: Object Oriented Programming"></a>Task 1: Object Oriented Programming</h3><h4 id="Background-Information"><a href="#Background-Information" class="headerlink" title="Background Information"></a>Background Information</h4><ul><li>Recently, a company has brought on Accenture to help with the development of its e-commerce website written in Java using the Spring Boot framework. The first task they need help with is searching for products</li><li>One of the UX designers at Accenture has already implemented the new search capability in the UI</li><li>My responsibility is to implement the search capability in our backend Java app</li></ul><h4 id="Requirements"><a href="#Requirements" class="headerlink" title="Requirements"></a>Requirements</h4><ul><li>Expose an HTTP GET request on the path <code>/api/products/search</code></li><li>The request should take a single parameter named “<code>query</code>” which will be the text that was entered in the search bar</li><li>The request will return a Collection of <code>ProductItem</code> which are the matching products for the search</li></ul><h4 id="Implement-a-new-controller-to-handle-searching"><a href="#Implement-a-new-controller-to-handle-searching" class="headerlink" title="Implement a new controller to handle searching"></a>Implement a new controller to handle searching</h4><ol><li>Download and unzip the mock-company-webapp codebase</li><li>Open the application in IDEA with Gradle support</li><li>Follow the README.md instructions for setting up the development environment</li><li>Implement the “<code>search</code>” method of the class <code>SearchController</code>, the relevant code is outlined with a TODO comment</li><li>The controller should use the “<code>productItemRepository</code>” to interface with the product database</li><li>Review the tests and implement the controller to the spec</li></ol><h4 id="Practical-skills-gained"><a href="#Practical-skills-gained" class="headerlink" title="Practical skills gained"></a>Practical skills gained</h4><ul><li>Object Oriented Programming</li><li>Java</li><li>Spring</li></ul><h3 id="Task-2-Code-Refactoring"><a href="#Task-2-Code-Refactoring" class="headerlink" title="Task 2: Code Refactoring"></a>Task 2: Code Refactoring</h3><h4 id="Background-Information-1"><a href="#Background-Information-1" class="headerlink" title="Background Information"></a>Background Information</h4><ul><li>Now we’ve identified some code in the <code>ReportController</code> class that seems to be doing similar product searching</li><li>I need to refactor the <code>SearchController</code> logic into a new <code>SearchService</code> class that can be used in the <code>SearchController</code> as well as in the <code>ReportController</code></li></ul><h4 id="Requirements-1"><a href="#Requirements-1" class="headerlink" title="Requirements"></a>Requirements</h4><ul><li>Logic moved from <code>SearchController</code> to <code>SearchService</code></li><li><code>SearchController</code> and <code>ReportController</code> both updated to use the <code>SearchService</code></li><li>All unit tests pass</li></ul><h4 id="Refactor-controllers-to-a-shared-service"><a href="#Refactor-controllers-to-a-shared-service" class="headerlink" title="Refactor controllers to a shared service"></a>Refactor controllers to a shared service</h4><ol><li>Follow the README.md instructions for setting up the development environment</li><li>Create the new <code>SearchService</code> class in the “<code>services</code>” package. All of the search logic from the <code>SearchController</code> should be moved into a function in this class for reusability. The relevant code is outlined with a TODO comment</li><li>Using <code>@Autowired</code>, inject the <code>SearchService</code> into the <code>SearchController</code> and <code>ReportController</code></li><li>Refactor both controller classes to use the service by rewriting their functions to use the new service</li><li>Ensure unit tests all pass</li></ol><h4 id="Practical-skills-gained-1"><a href="#Practical-skills-gained-1" class="headerlink" title="Practical skills gained"></a>Practical skills gained</h4><ul><li>Java</li><li>Spring</li></ul><h3 id="Task-3-Continuous-Integration"><a href="#Task-3-Continuous-Integration" class="headerlink" title="Task 3: Continuous Integration"></a>Task 3: Continuous Integration</h3><h4 id="Background-Information-2"><a href="#Background-Information-2" class="headerlink" title="Background Information"></a>Background Information</h4><ul><li>Continuous Integration is the practice of automating the integration of code changes from multiple contributors into a single software project</li><li>It’s a primary DevOps best practice, allowing developers to frequently merge code changes into a central repository where building and test runs can occur</li><li>Use the most popular Continuous Integration tool, Jenkins</li><li>Creating a <code>Jenkinsfile</code> that will build and test the application on all branches of the repository</li></ul><h4 id="Requirements-2"><a href="#Requirements-2" class="headerlink" title="Requirements"></a>Requirements</h4><ul><li>GitHub account created, Git CLI setup, mock-company-webapp repository forked and cloned</li><li><code>Jenkinsfile</code> defined with stages setting it up to run on commit to any branch in the repository</li><li>Continuous Integration server runs <code>build/test</code> and succeeds</li><li>Change made to code that breaks test</li><li>Continuous Integration server runs <code>build/test</code> and fails</li></ul><h4 id="Simulating-Jenkins-using-the-Jenkinsfile-Runner-Action-in-a-GitHub-Workflow"><a href="#Simulating-Jenkins-using-the-Jenkinsfile-Runner-Action-in-a-GitHub-Workflow" class="headerlink" title="Simulating Jenkins using the Jenkinsfile Runner Action in a GitHub Workflow"></a>Simulating Jenkins using the <code>Jenkinsfile</code> Runner Action in a GitHub Workflow</h4><ol><li>Create an account with GitHub and fork the mock-company-webapp repository</li><li>Setup the Git CLI on workstation and “<code>clone</code>” the repository you forked to workstation</li><li>Install the Pipelines application from the GitHub marketplace to use Jenkins directly</li><li>use the Simulated Jenkins for GitHub link to add a <code>.github/workflows/workflow.yml</code> to the repository.</li><li>Add the following stages to the <code>Jenkinsfile</code>, the relevant code is outlined with a TODO comment.<ul><li>Build: <code>./gradlew assemble</code></li><li>Test: <code>./gradlew test</code></li></ul></li><li>Continue to tweak the <code>Jenkinsfile</code> until the build is successful</li><li>Change the <code>SearchService</code> to always return <code>Collections.emptyList()</code> in order to break the tests.</li><li>Commit the change and validate the Continuous Integration build fails which proves that we’ve properly set up Continuous Integration guard rails, that will catch failing tests each time a commit is made by a developer</li></ol><h4 id="Practical-skills-gained-2"><a href="#Practical-skills-gained-2" class="headerlink" title="Practical skills gained"></a>Practical skills gained</h4><ul><li>Continuous Integration</li><li>Jenkins</li><li>DevOps</li></ul><h3 id="Task-4-Agile-Planning"><a href="#Task-4-Agile-Planning" class="headerlink" title="Task 4: Agile Planning"></a>Task 4: Agile Planning</h3><h4 id="Background-Information-3"><a href="#Background-Information-3" class="headerlink" title="Background Information"></a>Background Information</h4><ul><li>In an Agile planning session, developers are given a set of large software features that they then must break up into smaller units of work, called stories, that can be completed within a one to three week period, called a sprint</li><li>A story is an informal, general explanation of a software feature written from the perspective of the end user or customer and is made up of the following components:<ul><li>Who the feature is for</li><li>What they need</li><li>Why they need it</li><li>What shows it’s done</li></ul></li></ul><h4 id="Requirements-3"><a href="#Requirements-3" class="headerlink" title="Requirements"></a>Requirements</h4><ul><li>Stories are written in the following format: As a <code>&lt;who the feature is for&gt;</code>, I need to be able to <code>&lt;what they need&gt;</code> so I can <code>&lt;why they need it&gt;</code></li><li>The “<code>what shows it’s done</code>”, called acceptance criteria, must be provided with the story as well</li><li>Stories are then pointed or sized which means to assign some kind of value indicating the difficulty of implementing the story</li><li>Use a T-Shirt size strategy assigning a value of small/medium/large to each story</li><li>It’s very important that stories are broken down as small as they can be so try and keep them either small or medium</li><li>This allows for better concurrency throughout the sprint and easier completion within a single sprint</li></ul><h4 id="planning-a-sprint-to-implement-the-checkout-feature-of-the-site"><a href="#planning-a-sprint-to-implement-the-checkout-feature-of-the-site" class="headerlink" title="planning a sprint to implement the checkout feature of the site"></a>planning a sprint to implement the checkout feature of the site</h4><ul><li>Create a document that defines around 10 to 20 stories around the checkout feature</li><li>Pull in a subset of these stories based on our capacity to work on in the next sprint</li><li>Make sure the stories are broken up as small as possible, and the acceptance criteria is testable</li></ul><h4 id="Practical-skills-gained-3"><a href="#Practical-skills-gained-3" class="headerlink" title="Practical skills gained"></a>Practical skills gained</h4><ul><li>Agile Methodology</li><li>Software Development Lifecycle (SDLC)</li></ul>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;The Accenture Know-the-Code Virtual Experience Program covers the fundamentals of software development, including object-oriented programming, code refactoring, and agile delivery. It empowers me to explore what a career in software development could look like at Accenture while practicing my coding skills. The following are the notes I took during this virtual experience.&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="程序人生" scheme="http://blog.zhuangzhihao.top/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/"/>
    
    
    <category term="Java" scheme="http://blog.zhuangzhihao.top/tags/Java/"/>
    
    <category term="Spring" scheme="http://blog.zhuangzhihao.top/tags/Spring/"/>
    
    <category term="Spring Boot" scheme="http://blog.zhuangzhihao.top/tags/Spring-Boot/"/>
    
    <category term="Gradle" scheme="http://blog.zhuangzhihao.top/tags/Gradle/"/>
    
    <category term="Jenkins" scheme="http://blog.zhuangzhihao.top/tags/Jenkins/"/>
    
  </entry>
  
  <entry>
    <title>SSM 基础框架总结</title>
    <link href="http://blog.zhuangzhihao.top/SSM%E6%A1%86%E6%9E%B6/"/>
    <id>http://blog.zhuangzhihao.top/SSM%E6%A1%86%E6%9E%B6/</id>
    <published>2021-12-26T16:00:00.000Z</published>
    <updated>2022-01-19T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="b71f94ea79908093f69bbd91d8c7423d79e04c8119b491805204c1841e1d4a0f">cec776f7fc63ae327c1b8b56b82bb8d06ddf381de1ed6a9d4eceaf4f70557eaee35511ffaee18a3a31e7316c06d74d2e8e13ddb713686c241f2dc7f0c5250021041b482e0262285ebdf3b16b82b8afd0e55cdce8d1f7808a5813b593d1ba692932b4d276ed229fdcc11bfd7e8c3c81da34c94e9524de0dc6abe39a7fb2c5e2fd020a5ef603938816b5c4e0238c1385aa0e80a9a16f2f060e9af0651dd40a4914d697bebb77e91bbe1dfcb3f7ccfaf30ae1c91a06358d7cbeb7ef4e933d5891ced141c3f5759fc9aa9208088d7f86f3977f28123ffd4b8293f7358aff303039fb0178d5d1c336527c47fa11b0dd8ba5777a7507556076f71767ef8a8c8ad545ef2d761e8ff6e33b6ec1bf8316d2c433c44581857d04abde5b57303c78d8fe1364bb2fe9606adee7dfdb32e1475d592dc15e0052a1cadfad911f07930daeaadf86d14de7d9e877a6cb3a32bfa0e0926a30e12dbbd881f3734abf56154cb3d197887fb97652d7370560f19746b19b5cfbaf4978f3263bf6338163ecd5822be2097f7598b6cfc5f7c98b14c1e9e9776bc2c4a383a28287399ac85971cdc796d2185176c7cfade2f4a7efd55292838ab2af77ce121b5b6a688bd7ebd54c33db567eabf19cdcfd04837f96a1ce4ad12e348e6df56d7c41397cc73b1daf96f189830f1a22a9cb76484fe6c0fb2cce18bf0e8be02c1a698fa981030da8a15358dc35270a071db083b7d241e407c3ca13bbe3f77ee04a620c7d3c01d4fb1b345ca9d890d848cdb9034a238b52b7b477de1928e96a04dfbabf39650d04e42849b33d0062279f6c31227862d0e285a9f6da132f5587e6730f895bca8743aa2b86c9ea4e6f9a5f7cca63f9d3754c7e16695706f03e1990d86dfe4bb4af2d28ad9ae343f0bbe24257eec66ff3037b2de2637b0c4b8fa878b2f8ba9ffe2aca650d4dd980b329423d88c7182fad06bface7418759f67058f7ae378e6d0222708fabcac14bc83c7c490694e72e15aaac457662d52c76022904963b5738d3a8b8e69f6a24b63099337b5b45b89a1cfda4d24e74a682a259116fc290727adf1f45c1efaffbd8051369c10bc58e7c2c5dbb73b4a2b65599d55c36ed6104a32ea9f328c19f18631d68821b672c26e33a63f919b7f0f28e3968a8699bd0dfb9ac6c69a40c760c88774959cc60035d185960754fcab092ff608183d30e626ef2f186d0134ec4b5f8302f27e5b0fd7a2850d96f7a630335a20d3d4debfcdbe74b058d98ca34c06d96dd4d39aae8d1e54e646fd1689b7907292c330c7f7287350cdbb67220314df3811a201cd2ccde573822e8f91526cd2b5bce3c787cadd16c1b9da7368b2d536281c561d32f90b3523a032be821b23da1b93a9249cdea63a2d7ee0f78b5fa092da1a6e3d3a124d04e6a983c4f3f825da85f2989e1c8b21f438b6f7ec6f803717d5d275c2708deda34a868cb0e1922a1b6c3fc65b084d6f052b7a158a6c737962270e1fe2bb3d043ad637ac0209784ab1ca4470853f4d1c3c4c1242a154091a0c54de9a2e2ca8385a4f35eea3fd9ee02e6ef4fe7cbbe48582a71ff2c5ff2fce974bb406a808fbd8b0b6d5d9346706c4783839425e75c6fd59db0eb2b0a92a2e58b74c66ca0b0a5cc7f9a7ab755376d961c1b6d6363a77ae2483e23303c4bba7e391c5525202e836d6c1496e739dc36d334d10f8369d173a447d93dddcaf42ea4686800fc42d860a440792047591383c0d6a8ff4b4f255e3a7555d4d3df227f96e9e57c17d2d32a20306c948f81cec23637fff39ba6bb62158db83c28b178ddc7d573697792f577c7cdf7acaeb15864f48593285bcc36965db7f1367ed77d80114e6cb81bb7a516ce083d0374e201d73ea606e4beb086a42c8a53527cd98d5c5497fd22b7748640afb14bb593de5f49890d079465ebd5ed791714b4a1e51f58e27fda3c82a20e4a682a7457ec71aba9260bcd1eaa0ddb11572d603d295e7f9d0bb1055538059efdeb3cb0524ecae0f303956fb6a4d61679fd01cc1da2ef3049b85748491a13338b13c291450545ca2f83a228f47fbeba9fc5a8ab7ad1446393a399396c2e287c8f5b913fcb524496061f2df07a5c7652bf5965ffa3476d778a6f911edadb5e037f8c14a2197cba6d26095d8b16762580a428437a4ea462e3f2b81d4e6bf32d1f742d5f09a345712119a042322e7a9770aafc54b580f90e43616fb7fd4cf11a2e7b26b761ad08d5fdf00f1dc70cb47792875393c320d60f0c7cfeda520004152b31c6f29a80e531956622d01ccac8235ab5393dc799692e37c61f4f328de4122bdb96173310eecdce7b25456b2637903d1565b5ac318a94ebcc01dae74242e3fdf01fd9023398b34d0bbbabe37d31ac69212b48611dfde7e37bf6c1ec30cfb08dbd510aee5f55dc1c907d1502521f4c205c18f66d20bf646ec1ff62ade84902f0f1d2e684cbd1044bf6bf7561c024fde4774f7993a393a6094a30a4ac189f72a1db2dae3ca89649db8f2505612ef22406dc2cc65ed608f2a533aa3e2cf3ed3ecb92dbeef9aa753ae00e4e361e61160ccfda6d16ad2658bd62a3026d972b1ca567b4134ef349c43a1ebc129840e94fd7f0484818f797f8229c7c3637d238b00a6a0345d997f457c3538b905483dd821be1a3c59d2bd90d527bbebba93280f835292a3a3b33e89e92aa8a4d3f90a72a168fb84456bca2a4ea36e8352c1fb6b87aee3feed466a522064a94b10c31373f384b8a8955eb54df2e69ab6f1325aaf595b632ede1200e86c294c189e04f1f0dc1190bfe752a615f8dfc6692e555a8910600b97313791cb9ab817f8aaefbba9a54368ba7526d38fa9e91f43466e2fb42f5a2b31693c9e51bdab294cbbaf61073b001dc476517593daf69384891c7170ad410cc0d4ae2c4fcb07b2a30ad2ab90a87d4f332b29f9882cdd64e269ef7d92f5a519edb62e3feaeee6a8beeac975d24aa3f5963947747650124dab936d916c44ca3552fe0410b530d5ffcf31c3567a114e4702bd103338206d7c7ffd980f48960df7e5e674c8a33c6f27d96cd9c4cb55198abf3d40d95334b98c9589d17fbea4e81dbd48aff8cc7c25828ba8ea144fd462c67ae6c89ef2ea532ae56526ec405f1d348af3e80b5d3dbac81dfe7ba0d33ab3cf5ff2cbdb8e55d13fd0dc0986ea91936174e3a549f9c35cbf829c49e1d3cf193fd302188666c1a12a907546386852cf889c0d860cd1611c3739fd75701ca888574821deb1fce64b8755fe706f4308e33053c02bbf729a2b1b2fe5c6f24c13ea1f211085b738bb7016210cf89b095de7a65d41b2142cf03da2fdf240d74407fef0f9010c6da7e9851cd64a29cb3a68f13e30ae1793ec08730865049491db924437288e7126fff584da5c9c357988f7db883fc86d39246ed8aa7895c72c3a48076138f171fafb78e9699b639fb57b7f1d8b5f7c7c551690d77bf42eed8382c481f3f299612084d9aa187383a9fd2a6b80e2636c18d67a0ec2d4802566e9d14592f77b945226f24088a7ae291a17c706da2e1a68b979e21cf25e84dd9192978493e5a2cf14fc3c3ef2a09eb60d01f05f5092bfbb2517cd82cfc3e3a0b674f09eb5321a30b8f3ae83772f318263d4361f5661c1574ee6d4bbc837f9c2bdd4a891206001e0bff9cab346a726887ea52ab6981edc0a341b6f815452e3ee086413add2f6ab6c7c60394d5a6fc83418f16d0ec18d16284343363faaed4c1754b7f389bd88490e6c836c5ce67b43176a5089092dcee6a9d3d0f4d38b2782bc694e88347b427a7a5cf26763c1ca5a439c329d25c6ed685990a34196190e4a3a8a679de367f7880355d268389780535810e3786c217e88129bb8ece0053b1b48bf62cc6765bb27483a36a41b700f12a74d0e5534e7e7e55aa1776ed9f84dc278f1a00463721f3c177b79f2ddf67e6ab5a24d78a14cc637555a207e1ca01c22472a6f091f2488fe424d2788e79ba32e2e885a37a4bb3764f022e16668557a047e57355366373a2c0999c8ce09ad41e574e236048650f2be7f836d31108753be0ffffafb92381e9e8f873a7b5dd7ea726f03fe07160762cba1bb9a707db740c72f3aa9ee87c77f5d064b9d8910a3c347412f8d5a6519757c424e05fc98a318fac650f21df81ae56d9ba5ee5081dbff8c6d00ece7712dd46c3206203814a42afee085f80f0e981df30cc0bd4fdf7b8cf3513e6ec7be8696055f8bb11af960b1964cde01f282c3b4671258b96e80f1f7790908d6386f2aab50b14d2b48cd2dbfc7de4f806e8061cdc7b04b6ff846c400d57c64f45ba84c0a23a26004464fab308455f326bac32f8ee55d49ebcef32a570e6835d614d99dec936e0f9bdeb57b2666254357116d7aaacc61c05f4ff78a36c56e492090afdab3f05bf95c0aca8a9e377383e97de9961f37a8f4e9b1bf883e645de77ab7dc9067ce23b4ee295b03d2d236978226e1a10b9020cfcd31bfaf658883154dc76d25067d1663b42ae619e5b006f5b6cd866d047f3a457c4e27ddd8202ce83cac53f7080b9bd0e80b681f9598cc2e14e153b442dcdefd58e08d37b1243a106d065f0f90c0c4a9b0552c3c9b575de551d5c66cebe8d5a4be8aed90b628bae2e8513edf7a0e20d0e6df35037fd2e84eb999abbfc37b636c6a61b431edc4670d9f5e497a0907a75ad914ce25e1fc9dce6604e3b7bb2dcf092b8eab59e5e48e60b4d14dbd9a3e1c1144176d6fe7cd476e09e3fcf57090992ace7b09a3495399966e04971a82becfa07ac6c65a1801f53533b5eea4b3726b85ee41d2928b0247af3d7bcb1c813c9fc002433914f80aa1185d8e502b66c1fecde76fc4a53274cbcefae525275c0e14e18ec4ffe5f5d255e4589a29524f9e805e8e983cf6ee7be3da0320886956dc3942972a9e0ee2b1fcf901e3c2209d95f165eb4c39d50c2ea8148b39a485ecc56229fb5c78ebb6c9d007cedcf061e742a9137bf0bb01db5b4a2c8948a0f39b8f9966dff578d444da4d805be32f680f815a74566bccecc4a9a893e34b97e5a861d2e2a8fc0c3ad5e146cd4f53dce73555284e1251e7d4974d24d4857c4d492e28287e22f294b7e3727bdea3392537aa10497c9ed998ad43b5b57eea0a8f16e4be7c01c605f499d6f1fb3b6fda048c2ffba10e96ad4b18037c4639933649c55b488f7b43d1c9fd2a2ac5b0df75bb93ecad2cad8de3ff5b2ed84ba2b281b609b6e7b631a5e85651af0cc3bde009a2cb0838804f87cacfed86b69fa63266f340118a80cf7177c395666f1790a64af79ba3ffd689b91d5fb802f160f7245d73a97158b03657bc1755a7e68b5b937eb914c32de11e671714e6aa1cd77f369e653cff6185b27fe4595585d2e232dd0d6ee5e2cb7e10483b9e3d5122c286b37900ecb6bd545e8f657cd179e594764901c636873152361cb8a1984fabe73d7de70a96b499f8d818ee6f7d678a81271adbc3cfecd1daff9691a3769034871b50fabd7b210ffb16d16855839603675e2ee6bb77c3b722371d889edb339f8ef9611cba77bd4135e520b72d2e6a28573841f62b2110f3181f297317e8ca246e587cd68f9f9e90847e8925b77025912235f626d40e46b06337e09082110ce3e35cc6576e479a33d4dc9641b221360b7a6e38eac7482950ef9b300315958987827594c844f1ae178632b9ad984092d7130cb4a3bf4</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <summary type="html">Here&#39;s something encrypted, password is required to continue reading.</summary>
    
    
    
    <category term="编程与开发" scheme="http://blog.zhuangzhihao.top/categories/%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="Java" scheme="http://blog.zhuangzhihao.top/tags/Java/"/>
    
    <category term="Spring" scheme="http://blog.zhuangzhihao.top/tags/Spring/"/>
    
    <category term="SpringMVC" scheme="http://blog.zhuangzhihao.top/tags/SpringMVC/"/>
    
    <category term="MyBatis" scheme="http://blog.zhuangzhihao.top/tags/MyBatis/"/>
    
  </entry>
  
  <entry>
    <title>JavaWeb 基础总结（下）</title>
    <link href="http://blog.zhuangzhihao.top/JavaWeb%E5%9F%BA%E7%A1%80-%E4%B8%8B/"/>
    <id>http://blog.zhuangzhihao.top/JavaWeb%E5%9F%BA%E7%A1%80-%E4%B8%8B/</id>
    <published>2021-11-30T16:00:00.000Z</published>
    <updated>2022-01-19T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="0772bf31ced2d193cff864afa415f21689db572eed1eb4b3d174fbe4f5468798">cec776f7fc63ae327c1b8b56b82bb8d06ddf381de1ed6a9d4eceaf4f70557eaeb12ff3733ad3c5a8b05478819db47fb33b4e93179fdb096f20bab26b530e4253e787232249761aa19fd66789ebb15528688e216a7dbcba41cc5a5175d3031ef1ecf605ac801673c1801023d961bc45e39f9d380128fc9585cc2a0963220b8c1bc108328d7fdf9168de255c1a376941bd4ddac7393bd9e97123c1016340cb2eafd85dcd6ffed4bdc1217bb7fa37bb10544672e09fea09378b1be33f2d02082c44ee66c34f2889eacd608796fcc7aa0f1393fa0b86849284062460dc1ca33f13b167743fde259f4d31f9ae278b1e36a1e25b6c6dd231b26af7577a517c38b7c29c5fa1c91b577d64e90b60d4b349588ecfdb5ba22009affaeceb26ae9856d0128f4420824ad4a5953c01244b19e4891c3c9f69be7e6f06d1801ed3e6d5d59b6048086e224ba8811d5bf14afb3956175bf2a83b382662441fb8e4df29587ca93b8edd367f160196cea34bbbb86ed99264b72bd2238106b5fc8d24ef7229ff3c550799f8beb8993717657594f19e38389fa6f5cca5e25951c5372188eb6cad510844bb086170f80899e7551463c4b34e8aad07f144f9036300e00548de7c44a1926629a3d8e96c2125427798b109efa847bb0cf93f7a7bdbae786da7fab78a63d157f04821a5b856039115f8993ed1813673c30e4491b4fc66aa07b7c22bb66f41a976590eaed3fea1d7b0ae89727da893d968d9675b83138c31b56aa135ca263d6ed41406714fe5e0ebecd683b080ff713f67c6a570c0a4a4d7951d6aa29a8b8ca214e802c7bf3ce5608d9b41b80117d25677fd5a249f5f7ef184a7e694dcd4979073ef52d450ed6866e8bc0a8f1aecf832c764e73eaf8c540150a67d28788839a1d5e467e93b3a3bbe2216230a879732889cb42aa859c21c62b7c7bb9b064e5c1dbb87588b0dd4be9bedd013f4785c6f38014360bc3a78e16210c3ba7abd2dfe06ce788c7e05d74cc6bb4ef9094c62bd7d89368250f0cfdcae6ec395a40a3372de22503e0f1aa8968ae002a9a2a600091637491ce5cbedd237b15e848802b0ac8d</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <summary type="html">Here&#39;s something encrypted, password is required to continue reading.</summary>
    
    
    
    <category term="编程与开发" scheme="http://blog.zhuangzhihao.top/categories/%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="Java" scheme="http://blog.zhuangzhihao.top/tags/Java/"/>
    
    <category term="JavaWeb" scheme="http://blog.zhuangzhihao.top/tags/JavaWeb/"/>
    
  </entry>
  
  <entry>
    <title>JavaWeb 基础总结（中）</title>
    <link href="http://blog.zhuangzhihao.top/JavaWeb%E5%9F%BA%E7%A1%80-%E4%B8%AD/"/>
    <id>http://blog.zhuangzhihao.top/JavaWeb%E5%9F%BA%E7%A1%80-%E4%B8%AD/</id>
    <published>2021-11-10T16:00:00.000Z</published>
    <updated>2022-01-19T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="020be9db67a2a38eee459535e29a3c37a82874a5da5c53788fa0aed2fa24d0cd">cec776f7fc63ae327c1b8b56b82bb8d06ddf381de1ed6a9d4eceaf4f70557eaeb12ff3733ad3c5a8b05478819db47fb33b4e93179fdb096f20bab26b530e4253e787232249761aa19fd66789ebb15528688e216a7dbcba41cc5a5175d3031ef1ecf605ac801673c1801023d961bc45e39f9d380128fc9585cc2a0963220b8c1bc108328d7fdf9168de255c1a376941bd4ddac7393bd9e97123c1016340cb2eafd85dcd6ffed4bdc1217bb7fa37bb10544672e09fea09378b1be33f2d02082c44ee66c34f2889eacd608796fcc7aa0f1393fa0b86849284062460dc1ca33f13b167743fde259f4d31f9ae278b1e36a1e25b6c6dd231b26af7577a517c38b7c29c5fa1c91b577d64e90b60d4b349588ecfdb5ba22009affaeceb26ae9856d0128f4420824ad4a5953c01244b19e4891c3c9f69be7e6f06d1801ed3e6d5d59b6048086e224ba8811d5bf14afb3956175bf2a83b382662441fb8e4df29587ca93b8e0ae7dcefb9e588ce55f5538a3bd6b35d72e831c51721b5b0b39769573fce1db76fd02dff1526409aed0f5bf00400c866b3de819730e09541ba79f87df29d837cdbb8b2cbf420d646a83427583b6244b9b2b422acfb7b2b64ac9df4267234a48396c66d60a74fed911e6961ce8c7198a3bba8709724f58c60424a2c204045278c8d78bb9938c436dbce1fc8a69089548e0b2b3f109a738bf53edca6c513a7df9b0f2d58e1bb923b80a4c58868801135390e6cba8353aa33773f5298ed52db5ecc8ecd99c1a9c321d2fa6c820802da4a3bd14c538be57432aafa9623c19c315af602ab690e0282538f3d5ae81de1a564e9dc8c3d17a8eebda51f54a2a73f53a2ffff8ad3cdcb53a9c282ef0cfd708405621ca3a318229256812699c7386c28415a7c871f5f5f7eb5d7c24f486782686d4bce4848a792a90fc97b80a74996ed2de87c70cbd891351119caa00945d392f0ee3a376222ce24e8b63d15168ab0cfc189a54fff1339c03af5dfd01f707ec6e5ffdd4dbf019088deaadef97dfaf82361cb7cbbac5829f261d3a99454ec2bc775a4774d0682d5b013b208211093d93c2301</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <summary type="html">Here&#39;s something encrypted, password is required to continue reading.</summary>
    
    
    
    <category term="编程与开发" scheme="http://blog.zhuangzhihao.top/categories/%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="Java" scheme="http://blog.zhuangzhihao.top/tags/Java/"/>
    
    <category term="JavaWeb" scheme="http://blog.zhuangzhihao.top/tags/JavaWeb/"/>
    
  </entry>
  
  <entry>
    <title>JavaWeb 基础总结（上）</title>
    <link href="http://blog.zhuangzhihao.top/JavaWeb%E5%9F%BA%E7%A1%80-%E4%B8%8A/"/>
    <id>http://blog.zhuangzhihao.top/JavaWeb%E5%9F%BA%E7%A1%80-%E4%B8%8A/</id>
    <published>2021-10-31T16:00:00.000Z</published>
    <updated>2022-01-19T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="e3043655bfacfe681c1499d2bb5f3177c67aeef9ad0189889a09c343167fc060">cec776f7fc63ae327c1b8b56b82bb8d06ddf381de1ed6a9d4eceaf4f70557eaeb12ff3733ad3c5a8b05478819db47fb33b4e93179fdb096f20bab26b530e4253e787232249761aa19fd66789ebb15528688e216a7dbcba41cc5a5175d3031ef1ecf605ac801673c1801023d961bc45e39f9d380128fc9585cc2a0963220b8c1bc108328d7fdf9168de255c1a376941bd4ddac7393bd9e97123c1016340cb2eafd85dcd6ffed4bdc1217bb7fa37bb10544672e09fea09378b1be33f2d02082c44ee66c34f2889eacd608796fcc7aa0f1393fa0b86849284062460dc1ca33f13b167743fde259f4d31f9ae278b1e36a1e25b6c6dd231b26af7577a517c38b7c29c5fa1c91b577d64e90b60d4b349588ecfdb5ba22009affaeceb26ae9856d0128f4420824ad4a5953c01244b19e4891c3c9f69be7e6f06d1801ed3e6d5d59b6048086e224ba8811d5bf14afb3956175bf2a83b382662441fb8e4df29587ca93b8e4748074460fc92b520e1867af9eb225d43dbe9190b3372c3a8b60c4d3bce58cf8410e4d41847642282a2eb1ced400ee0cadf04dffbbd14866dfad58430f39818b982a86b3613bd4e43ae1e3d9cd5a134341c20777aeda99815624030792f4f5c96719703fe7a8be797cc44982ce0bdfbbef587123b89a0c658cc87007bb17595e0a62570b7a89feb7fb3b0b7ff2b506e751268e64a2487162c3dca3e074a8fdce93b3f89baf179c83b02c611ab2e2ed51237453273abbcd4b1e622b1d166f668a490c7aa8a66dd0f0bcd49df1393df9870f9b8cd6134e7bd87e0591eabfbcd1ff5ced1f56a7ebec8d7ac8713077644e36512e9917f8bd65124b82c2a0e0bfa4c7c885a86a3c1969bc2ca470aef52cd2f71de6a3e61adaeaf53b97b353ad0b7978c7b053dc7bef5e871dc61c62800c3577923983dc675fd8e44e2bf6e51d90b637ff12a47ac6a3113fd62360cb7b51b9d81ca43366e645c53e635873b86deb9a29189b98e6e60680845094bd34c83ca4310a17141b165a021bf6a3e11d034b7bc301f7e2988bb1c864eb3779f18a3ce3c9395f60089ff81c0d4a475a23a8d7a9f0818a481885288dada92b79796ebb05b0cc769955b7e48c2ac3721fc05e2b6e03638480f2e2caaa243554ff93ee1654385cbff6a7b253b633148a6fa5f1a5641c6522003cc116d309feaf623bd606d694c4786759bcf5fddfea3457a6379ae7002ed5ec80b0fb0563ff135b6c88348b16daa83f69dc99f392e39d00a8e9a26ca561b988d62dcf4734d614df45cf463b015a40e2b635b58326918c7cf07c71d077490e7fe90393e08f0d19149382a141ef1c89b36e32c8b98c85a3532d4572b23024aa6ec62fec9db4a45a4d0cb2ac8e652132b33b3c594e4c57548e55a057d72a645ed045b504708a3a7f2c54ebe45f01e4fe7b9f19b314a8011c42527cd301ab43f4ee97e5a7a720e18b5b8c0ec4eb16d492a444afb1f66cd1c6160eb77b02bd080c8bac88a3a83e5ce563eb30b144778e8effeedfb149176ce226c9927d04c3e91f5c87331d01b5545cd8902b77e7c431de0a15fab8fb9dd1a4853a9a166aac08380286a7ee743a19ff4dba118b8f9e56a437ee10f808653fa422da739b7fcc7e318fc1f0275b46bb617c103cf2c4677ea2cbd230b3ffc01879d3d1545bf43ec897c52d6bdd01fc169db8919ad0412163110019377469b238cebe278079b41f202548fe735578859c9d8b9ae476056ceb09ebe845b920ea693cfac6fa01514be1fd1fd51ceb74a80dc3290e43b407f5d256d38af4d6e97fceee2e73a6c1b7388927dbacd80e87b5d6d208d4ee8148f48a86dc899b0fc249496e1980fdc96ea2f401140e4716ebb03cebe40117c16d12470a28a931e2d4180f71d69086e07f843b3dd42a083fef375f68db9c79138edb3ac66d836b671760e66a1231dfadabe7b9dc302ccab8681538a2ccd8bcbb987c8fb7d408f7050096e724618812340ae83747f15fd198fb3d1783d0f08e7618f1383bd7ee06101f3dec81314031e0256154dac7bf9ba75cc0594bbcab66bc50d11dbca99d7275f5d501d46dcba3a87ca80ea8790a2b6248b120eb419f08ef5bfedee85b3880f48cd7516576ad4f19b60643e74ce928ae6e48a84304da4261556b8352f2fd22545880359e4f666ab2bbad90893ee2d5f836be7e9284938191959d40d74c90c9ca8d9ec455d524d4976414520943dcab2c3d15ff056f8ce05b489782fa3ab0bc9d74f71eefecf4c73c2d96f41a5aa7cae5ce28e8101c5b72c74cc86f87d699f04575267091ae3dde4aee9d91f3d2f1de29f61d08e0c371b8a3227611e5e49d22bedf02b5cad2b5172d9de1cedc6a281894c7d452201a97f57a6b6b248d9153596a4b6ad5b80b06405c133e9b17ffd4b1159efc2559f67826e318e287b273ea6c172ba8a6170d88d38bab43cc1305066f728c58a9d9e62a5168a330fc099b6d5289fa4f462dabb0953685b7dd9df7fb795e783b47f46d7a0818eda212b4f4996927e1da005f0141934f004895028f34a4bcab6ac866cb468fd2d1741e885f624c42db3b68981352a31cb62c64f7ebcb51b263043ff246bf787c12593a2b3ccccce65ff29c023597f85b6aa469e943c3b790bf5b654d84473441fa5d252abb7eeb4c42a5682f430ba5712da91b8b46a48fe73c63ab98d76baf21d539065b6a678d2fd8c6708c6ac9596270b3f6caedb1272825c12f7ea2fcb92dfc3f817a47448e54f1e163b7df229f50d20793dffb3d49b904e70f7773467c7f7975c01971e8d96e3c484945c6b8125c450d8c0294488bc787ed266999b0850b7cadde5e0b40f46e58a0830ca67e50fe95ea3013887f375836d2d11641507d407a61162cb724b189e663f02af15ba287652eabd5609b1ad1042df5b0dc890e3e413026755283721fe37a9697f7ba064ad6f36e8369de84c6e247bf61302fd95114d1af07ed38e4e3bf9caa7176b11bc3849d5a09c7a6483610c567844b94e6fdba5b2296594b9352d9f5b7ea74f3d0113fad365cf430e0064242de87c940b911c75879110a123cfbe48c14bbbb21aa6f940474f18afbedeeaead8f711c0c4c8c36f538d1d35076ad03edb617b860c14069690ab351dc61898d0a23bc831342454b416247acc6930bdfe0a51526157059f8364f45bdebcf97a418114721261c958a04a71e6d876b305e393bb7ce165bcde04c56250314441e11c94893c605412d1ecf70d5665af402922846eee7e029501ce68a5f32e7b8f8a6be7656fad4ab17988525f31d8399ccf19716181a03a02cf1e8fa88d5e96f0d764fa1031df10673c3c2f16099fca47c5ea4f442b4dd927df27f6249499e74d08b6c9ca3072af601ff599c14e24793b7b68447f88a3041e7892406585c350d486d51091b558d9c27c640863675e4dd795ed479a7028ba968c87a39accc5c43f301bbc9bdc48252fdbefcd189e33d4293a993d1c3ade64df9e323020cf49fb958e84ae9d80d0c5b872b9a8ab1be9836bd8a27a8e0ff563919d5fe0dc792ada4dfcee18c7b215914aedbae80870aa98ad853a2514913c2bac4400210588bca56b18e9ddf5dd7e161f744973aa39f4e3bcf24674ff40657cf917a3fe264a97141b03766c0117b4e865baa1e0c72ffa60094583c9da44df29ed9ca2153c734a0e4e0bd1420ab578bac128a04956317a6604d8e0e753b21a84aae4044228899c3da364cad5a47ba2190ca0841600a047c16ca5945f2cd08c56840c5cc8bae03b1983f05770da12593073928189860e30225f0fec48c13b750ecf6a86b098ab1aaf7ffca9c04b075b9046dd9511cbac31d5838a6b2680cc63e287934af62c638912f0aeee7b76a5901d2aff08c3a935fcc584a8f154e1a61229728e5818d980e9108a86eab7d9554fb2811c180c296cd52e2b06e21378630d125922cdb9e1f48e2eabff63c4c8e98053e8226e4dd75fbb8c4e75b11e10325a023b34048c358ab80b8fe0d6dd3a9e487358246f4c56c8163a4f6212cbe3281cd5d14ef7fcadfcbdf5d24935f9e0364b57584403c162f73347e4293c337593fec466b08d66b710f0aa8d2d8589a4a97e1d95b5f1ab86392befcd4d39a5c7190b7a233ae7a5834809124e9b1e306872142d9387dd19db0c45000e2f3341651f59e6a2fc3afd531b4a0e6cb8640dc3b5c634c7ef938f51ef469b0e5979d604b5dbe37d6cfce151393422a48efd5c89ebb3a85eb6ebb3d805cef2536e77bc45d2463debb0ff0d0e459bc3cdf011cbd6df7e28e497d1f375fdeb5cec7b69c024e2c96d6168be1d0a3dd43fb6aef4030fa8cffd52d194f90fb5c32006fbd5b5441d7463f9ef690f2d3b80a02e4fff8130207abe816633e5105d518fe9cdeb675b722e421356d5bee36d2a3325291d1ad1313baeeb754f30b71a956c4e8b895be491e74a509ca2dfb09cffaaad96276d5b3d6eae593da47f671f496e2529d0cba57d6d58423f7efa34f1148cbb39075c24e9d7b46f6c5af5557e2275e3da66b28ffea0f316f24198703780d09a85328534159f8171b25d3913e443e650d1bc1e24435cd38167f2140a1937d69d794aa9eb35d0b8bb58435ece9d2beb857b174ab2b639d0df74a058e7b897978de2f197d015ff23593e71ab130b4af3da14f0185e924fd0ca35af09713199ec9558d411edea96d929063e15838190834888aa09d262c8adb2170ca40f631248c8779a20c89c9ea8bb17fdecc24a20ed2c730c252b29d81ac379143321626a31f12c5805b7e66fe11bd6f30c9bf805f7f3087c289706a4edb20937fbb2977a80c1bc7bc131a158ed5044531c7aaf59b292669ff97b4d0e004df53e1ac2c05e546e872243147faf2ee465da3aab70644f032ff34bd33ef63096aa0fb1281546c11dc8da65ceeb69ffdb3d01d32b655167edfff9a277d77658d7ad8fd5960da3a2d3166e067500d5e9b24409edcc57a9e63987d28826a9cc605f6710ee5082d0a8e62d3a52840f3c9170e349093d8f57f41690c002d051703e267305cb68a8b48bc82858cfb4848acaedecd78c853732395fbd84b60ff85a885cc9f43dcebab9f9a95a714dd11a496754531d59853ed30c09c0adbb40ebf40e400dcaeecacb58c9b388d7a723d253a8a585be4d21d4a5f30fc7e3e936fce985fdf8ca15232314888bc888249b6b0e60fb05ac3ffc60977aaa3c5fca1a7a78cfb2378185f71ebf3663ba74ac5d55174ec784a175267a16d9ffbbcccb000f92306595d3f949b5bf4687d56092504bdaa28ca807232067bafb0fd418df420b0d1f061782aaf706ee34451dee288c5d84aef183111b503fd4465e4290ef29334cc3d578b0eaf085b7a351476af8e850dd056cbfd7414a5550416949a6e86ae4867aa113b29056ec17d0729a5ce5f754144397290d6c6f3ba0c1a64a5b285f83c5d7aab402834f61c9ec2f5f4102d4977045ed793c8d3b7aecbf94497c08c26618e8220608440750cbd3a1e808abcb2130abf0a178a21a97d6d68e3d60c8108bc6dc612754ed8235735fc1a110bc9dc09d597b52f53c7eb663f2e83b60a121ca225ad98395df357b539a7de0a95e0a3c4b369a897c349f0571bd3a20124253ea83bacced62de3073c2c48e876efdb34cd5f932bd28429366676ad0f65954dd6c907c2a197925f8536374c11f478cf5d4c845f6bb413ddc8e2efccdabe6ae800fcf78ab0fc0bf858697b89fcb1e71ffd037f6e59ccbcdfa67352861f5168fa149e2c2b7e0bc65a674489752f61d267725fc13538a3447f70683f2c68e73a438494294794c8b9856b7117806f037f990fced7407b9979208bc2f22c07c1917b1ce5e29acec0c316a1f2d5a95e399eb652182e82e9285ee50f87dad664dcd6a85cdce6074998d23db0b743002521692484b54f431d0cca32a8cf96ac1314cf7be0ba66aff5ec5142fb80d7cf3315612b36c87f7b30228c08359f4d60cf810efd2204928e47150899c11ac7f7a69504edd3dbada664162ca2f4011b971ad3b9b83ba0235a7c323d16f09ff9592e98cb80df3a926838081a15668df0d30caae401cbf9ab4dee4278844280992d65442d9d6571592a489a22e202b54a59982b23dbfbbbc536773d54749bef678f71ad93e01a0b0a2e245467796a91451dd298905fa7aadf8ff13a88ee6ba1232e582e6d87de71d85b57a837b4c348193a99e119b8d77b12b29e39b8a99fe7e85de1c4691dd80ea5de79072e189e4bbfb35dcd259a479899569036eae7c3d592ad9a02de3a9bd367915c6e7a779dbb1c5b25a091b3d4689ed66d7abd916b188515caa509eceea1a57db717b1de7dc6c8775f9d4ddcc75ec5351f9498585282714468ba7485fc88c1244f8f60cd375406e778312231028a06128e6d81a39d50d486bb5217da862230cf79efad07f6c5a298565712c8f35cc71d443416d856d8ae2ae715c761241b22cde133599223e5deafdfdabe8e2a1d6eebbc70fc68d97f8e1169f54020c782b4a8091bbf27ce7a78061278bc850fb5023a2809de8d93e0d24fa90dfea29def7882a1b4ff6538c7ada358c9e6c3d0202c7fd30f3188b4b1d8c9826d5056595bf05a114339f5ef71d2414263d6e16c7a901cfc49fbf39be62be97d05010e81b2e43015bcc03f956c0d79de981fd415813d52e4b21d510b800873eed27d15fc47000966a5fbc242c0dafeac04e8387a7c41761693cdec892d4c5de29a1d9b53aed527c29bd3f938373cdd8f19b5aaeafa404c03a3611d3c4c72d62ba42cd74e39c72a5d3d9b87d4de71f2b4e1442a5ff3fba362722570f24b9f9022672972a40507e649551d00bcf1c80ef2cc20047e190774943d0b59592a86f3c728898e0476e12f24d8c77933e04c743b2572acb68bd6e8ff97380b02ca506bddd8a8749f410dde5e2e73e48c09e08ad6c532c492cf2f6f3a85d8ef8ce14f77fa4d0b3eeefa368937f5234f29e5a165d7642b9ec3171bed79e6758de5eb5381902ed4a85520fcd1b6c98bb5c58156934b9ad61264f7fa391283aee89a54cd10c55ecced8c58c4277dcd509b09600d571a438ceb9302ac6f0792f00721bfc2218c4ef94b559984fb26809de9344326b40c85ad56fd39ff862d7f88fac4ea0f5e3031fe3c38dd095438179d6c0c98ff6b089e563a039198c0b5ab82ac1adb444c448048192b9ef223fd755a8f0dfb02c396f46a2855e99233f2d6853671269eba07780ffbc1ec3b6db7a1a36b98fba64d1ea4c4445ad2d2aaeb47efff07a21e4b7635f97feef21e7eb20ebc73c46850ae55f194d7e0b08c6f37b848f96e011e8dd9cc610365be0d4958d22cbc69e1c0b5b3812176d2181d83701bac4b414ba20a6db77ad271e84526240ae567a79aa06cab81d6c632b9188c92447d6d03756aa76a5a11d37bb3d7d5def722eb8033b44b96042bc0b252b098835e6638b666bc711355a5981431bb973654d1f5e6926c333e42f544c20e75f653918a555b511e59da93a0e962d470841ec7362ca851063a1bb2cfdb2f61b1f626472414dd5a4e9d8c961cf1ec1b38d7d0bfeec75c50d4338257137a7566564588e75f704b59bca3382a20f2b9f8d805d88d537a8cd8470bde0669cd2f38eed0f59f83e14faa539b01c025ae93af38b418983d86b194e637ce6688a4ef619f87e2fa8ce765c22e00e42aa934c43a00fdd3c1f9d852541f9f04e9011019ece1e2cc89991cb236b69efb2c79a20ec60a6001bd75e0b6e8fd3ad41e4d8ba3cec34aa044afc866d985de0749ee662b1fbcb43771c86cc78169a0fedc71a261d2f6be2ea6af89203b8b8c671698608abc635ac39d715ede565e77a4dc58da9b63af6b23e3a7f14efafb4fc52ee3c18bdffd3d8fe03d443393bd159a171ccdd9c0d2857de7d8b4d3f8de1cb323b66d3264fab5367ea0a5fea1e02d550fb9f7a7fe8c34cededeb6d806f9477d93881067af563ec6927ca4a6de7516f3e279cb57c164ece3452ffbfa90188e4c11819a58d2f323568caa83d985b215cd2c6c7d4e80ab803bbb6adfb5b47def90f495ff2d8a6461f58cfd95a6bd6bcd1bed4bfc6ed4030aaed694d5961898d6c23a538b859e69c7712a0899e4dcb80196ebb14a950374c0be9fca1e68efd2a99b0c9f53b8ec30bb9780efd72b5e149a3cd2dc5cadfcd26fb53fb34d68d855f48d2473531ff1d2ab9d529d0fa6a6af1712317586e51b319b17649ab487d6eba77a6f243e897e33a42255199f25a11852467741bb2811a97396a603b5fded300860bd613b26532b9b0def4e1dfd8bcc33cee3825531dcb212cbb2b409639f12627cd70e3c97014a9a83afbd351e9b085c2833516a975a17144b1f6a7e66783a3de27de8de309330f91e0d5b00efa320112f6c7fba051f35513fc0b7ec1d6d6731282db1fd9ded869697122b59612cf1a3453090abc80e401b728e61ffea44a518a7f662d1d98d578613e3f7c8cc0acd90dd6035595b4a9eb327a7379d680c8c56c154452abf661f09a5be5e92f2f256d4c92162a17f4c806db1143c149975cba45dfc9b62026e00b8ebb8573fbbcfd4d61c6f5bf0d1432b666c6052c1cd2a28d6a853227898695d3697f433736c68b7436af051306584f23b62a002fe64dbd0fabae084035164b9defa6db4592dff8dabee256910fe93e89a7520849ecb35941283bab24593ea6d4237a0c3a42cb27736fcffea49f6c54e6af60485242807c341e998e1bb0ea819abadab58839932d90ee4dff0ac4001ddfa29ee802a214fe7be631c4e37702502f4d3f5d012e2d9d6a0d57e967b059ef2862fa08ca7378c3bcaa7b1102896c0a884200da4c62e139ca365a25ce735049215e3a0ad0eb6368b4a6559a34757ff35014601f9f29731e3cff2a5448fc21a7ecdfff627aae25bd17e594e15c1d429951bcfa0bf293f9f4578bb255f5e0a0cb4fe798e6f6f4fd1712ea49f53caac4c5c78192580d93b5414d3dcc6532e6ccd37e92583e6fceb223c8d4da2b6d5bcfdd2af08ae4870e11992bcb3d8c08f441fc50d22cfeff11a04c047f1031bd387bc29b52d9bf2bd24250c674d515fec36eabe518b4de61bb4e0c05674d4518985be81727908ced61f9e363e1710e0cc898c42e98197966e9673fcb8c0794aed17e0ff9089f359ad30ce0609329450d402db78ea59ca5b1c922a38ac8700ec6deedef03159517e8f4eec1e2700df9ea543e635d80c0ef4b4ca3886a0cb5dc341c58c95baf8e2828017a1731a72582433115686e7cd67d739c840c44c2bffb17a40ee010893ccf2d813dc9fd1ee8058cc26e79a8b263d34373c348c03f1eaa38505304b6cfcfbd6cd06be1dd6ab7e488c79d370daa702d3547c6bed67b8aade3f157860a785e577a8e4ad9ca94302e76e7cea6bea8dce529f80cdf7f90b333b95a1401ea014629a084fc7f6fda0b6150204607495a8810d1236d3a556d0398e10904dff43baf7b48c36b3972e67c294a09a8635f55a5a9216aa8ebb16dac8d9967242236d7f186eef64e8f2d154c84a2c0bda6edc1bb8198cf81d4841ac6390868454ef3ce9bdef5402183402e668fea09a63061d0ed3269e32565573b3626cc10f3316c23635fd0b73725e83ded52d1ea241aa16eb756414fb6f791f41e256619f28a8d63ca4a2f8099244ebb04dff78ceafd218f915732c337cd38c2720ec6b2ade29ce4fb1dece1c3d4ebd95e1a3142f9e77c2d2a87d1767580ef8c22937918a6b446dc43fadf316a24557dc449856a32953c3d727aa5d79289e07441b5aafc03e97d9ff6c36fc7f29ad5d5251ab0f2489d9105f7532acbaa78bb1d6cb730e4d2a381944543036e870ec31bb8af4dcfa98ee20515c01fada4f7c1657729b7dd10769a2eb39731da3e305f6347c7977128155d994912253ee3fa1ff23aaed57d69c9105e5490337a75e45fe4050ee06f249b2e473806571d05aed51a65a6b26329f8c19cff4947ed51e787ab5367d8f4437312db9956a65366e62ca0bb0e8ce7b51580fa782587301766e080468b499a08ec4314e648ba4553477ac8f555f978898c8c00f88bf3a5518f6fb3b3b153d6060d4c50e123c2cccd9f53ccef9dd830eada565e1d17f4bb6672bbb23b41917bf06855261a28c18c83bc967d80c37fe5c7c5859b3b88c4b176b0b3a4f58557cb6de28f82168dc9b1f3e745210ce0c1e7c9cfa7027ee79365633f502cc1ebb522b22e302ed167afd31dade6c80a3ea9a7b9a9786ea844e80da7c62cf0617f06411c47e61ba0173b5f9534e8d8e7e7b026f3516132befcc2a01bd9ea7682f5d6209984ad9c72dd7d3ffd18344056b978d1ee5d9706e07a69b15de027200c77fd194922287b0756efcd132d3e7e0eb24474dbb6a63087600a18ed2ec761077b43f25020b2e730ea2e88cbd725eeaec1fa84078bb776f8738ee823b42fce6314d4f51945b09637523acfe11ef4d013d110ef49fdca95be3d1a1f7dd2ebd9d439223c6309fb78c83ff6afb14fb229f715063ed88e1e928e126abc5ef59d7c9b3fc0cc038cf371d3a625881c7ccf2779125f3891fec6843f5bace7d0eae23bc5664357036811b18d92d6d12365dd7c1e9051578b5154bb9f65e2bbdf27101e95109bba79b7dd4ad0f3c19ce8e477c11b244ca40b8fdfdaca12c2791388eb1b443c77a165e79d428971d7047fc3945ebdbe1d11c2e55743449105a4ec0f06a5c863248cfbddab2f0e86a04a07d4aa8d32436b6e4870007fe531ac72b35d0cb3a126b7ac93c52996c94350b329f4a0e7e4d5065766066c45a85e6f52830f2ca71cc498061d7effb6fd78747b6ea79f27e5ca7d7d3000a6a644b27c9b9d9ae25d4084ff87511cf21fa6c3c3cff3fb35311b05a9a95422020a3d0b16eb2c98bcad8efc99f06848a0bccd36f1cb78fdfdea0dbe4bd437774edaf2e04ed128f7a8693b1dc4fc038184aadfebcf968bda83496d41d77bb134a4f6860d3482517701aa0f784e67348da0755488e03d1b088f8595fa4f41160739b93d72e50e8b602d7d360e597ff7b8aeed8f9faa8fa0cc3bd1efeaa5302478746f69ef8a1d459d852c4a40f5e232d158226c46e5a252b5de308dea4fb4eb390b063b7b4158e3a33704873d3de51d3cbf71ceefc10091959de12c51bd7400ff43d4ee3b2e40a44f96419ea98fe320481420b6db6dbfdc03b42bc1fed813c669f8a2142e3afd985e34f3b89dd908b2818aabda554db3ffeeb199cbc83cbba44454def1fd5ddba71de681a1a97b63caa8bbcb71b2fb3b3a10adc6f4ea11222e5f8a2ef708eba40c8f730f40cfb5c608f1424a855eec3073cc2f814f376d0962de7a752e991cb540b4f3f7570e431f0b992d35062851b6213f7e0bc4b89df2f77842c8ad4d9ada08f4628f71f70fdf2482e8460b2139c2edbc71af6516863d6dc1129d9bbe13680a8a6a2c52c7f4375871d0ada90f4e21bc0cb72f0b85db66e2cfec7b561d1d9362077203d4610bf330c4ae82e9dc514fdf1cbca8a5ae3eda813b4e70cec557d91d70ad02126a343d97a70cb81e20a4e5abe9d555baef4d554eb6bc8f7429a9df398a79957c382c77d6fac3b923827171470e755a5841a2a7014e4ee1e7f618366c77a925b7b0fa8baf0213c15f8cd185c7560db7213cdf251c63972d346325101fbe47adecca391b28328b6afa46b8219bbab69f4aa2070c729229b3965458cabad6b2ce5477cea3b18e6fdb200e2ba44f279302fa7367730fb0ce627a123f4fd098c2c70c4e8879e21a8666d38b3650d3f1c0baf060c517e086716369607e637417cda97b3e3509391a3c9b47992ac5d37eb4401034f81e48968ed7372e69b2db6fed0b5e992c6c50aa075f30404e7fb6a9e80969e2b0a6ca83b3595acec6267534e6d1502704763a0b4fbfd0fa15de9a652b4e225121d940b3b5096fe4ca21e177173586512bb434b8be492b4543d50f408ba5672cb97fc259022bbdaa57757ec4124a516688302c0b22a608ca40b79f4bea11070057fded3097d0fc33071e716bd7a63b1b4f64504e9e68adabc2dc464a8d663d0b3ddfda001eb789b272d8a3d367e97d73fcd4e9629f53876a7e2c28261825d74b5070510e078b8f83450b668fe06dff88201772983c087624ad7d613c8e90ebd5f849ef361d65ee74f0501e625555a9b40bd64b27c57ecc3378472578d537fc1e9514cf1fb6f9d358a58bf6346e94091e9cbece410601f90572134b53ba46327c055fc8f43bdceef6f978ae1a01b67ded046ccbdc91a54c630fa1de0eca73bab4579daa9287143a1312cc1f173bd6f89e245083c829d8b59b45c2bfd7ae236cc78808fbf49ee113f54da614a7b691b6725ed1e9efe8a129c2d8b6c3eec72f9ff73c3883388aebe338515dcfbb9ac063a0670c718ec277d6165df24e6bb9b0fe3a5ae22bc2f347b296653c0f8624ecef4f656370341cb72547099850d0bea505b8c9fa7965ab9710b8d6906b706150a3ae3a1c721c0e2b420dd02129898397c5c2d5e837d787386714b9c0af74f48fab62aea73df2ccdccebbb41a077edb21bb67f3e43dd978cce52a44c646eaae471efbfe3ed99c5c0044b9244543d1259a64d2b530a13853a0f49c9c6a551abef0213c64d845b5ab6096c108a576fa5308b396e50955c51d70ebeb7e6caacf541bbfc49951490d4ef357fbdf5d401d14db62e06e3988cc5c104c2512401d5671658b931dc072f0b7c9761d8426c9ec642f0d00c848f6f8c629dda259b3b0f0c957663930378d9d3305339ab7d2f9c7cbd8b429d63d4d0ed3e7dcfcee63de2c15e36711b22683e43d75bed901f9d9e94e1d5a1494cadc2212538c05de369b2b511f52a1c2d7219d6574239392c05019b0c7d5977d63e41d5d6f0a23af9ede57863720ba3d2ccd9dab2d28588db6d41265e2e8ac9ab5228f2ce1c40ea05a2fa1c5a8b595861a1b8247e0ff1f2a38276514e4a140b0db0f4999a65b831afd02b6db5c0c2b98677e31fcbde54076e150191c0a047ef804ddbc434394ee0f494bc5ead68675e748a3fc2d34d7ec91af172e6cb1dda98c48d6e4ba5160b080de036a85eacb7b84201a06360c7d35f44aa7b6ebf83e4fe2e2e277ba65a564ee0c7a9f09e7ce808199e1a9917432748a6983d65ceaf51d9b6eb4ff3c3409ed99ce34f2a5369acb03f6081d27dbea94913d3ea869b13d9153e92dad6f687dc7374a7a94014a65a4a0eb75da555b130fcb403bcdbd60f4b3b14c23fa812250142cb2b4426ed9eb418d8830f7614164fd54a1e14fd7b5eae52e761729aace466cb270ec78ea4aa3ecd5d88688dce6e8da392b31e645997356fbf3a4adbbd7300b3f8f2a8e3bb353540fb935cc34067a50319b9fc2f1a95d4765ab5645dc3dc15ff09cca26124b2991fdbd727a3a497f4195f5fcd9057c3ac11997db5de8dabf375c9538acce918145e8ee2cbbcf84d74b7ac160cae25c5b7c283d500b5b94ad152e34425f9c39a265adbf58f82a9231a3484967366653270d5885650c61957d414708c44f7ed37d9c11e749d821e9f5c92a5145662dfa22e18c1f45664ff1d2c175e88ac67eb0d5e33a21f1550c58de727d4ac3aa433b3906a86082c3d152c33d944fa1ce436ac3231f353d40f6bdeb40a988a2677625f9950bd4dd6fa9de4a8b4d61237bb7e15fe37055b8db1ce8075ad289e31284e09caedbc79b20d43fce4c47243f719077a211d803eef966e261da81f28cf88a7ec81af9e02021e056a276ecba53d1f709a3cf52ca50bccd7ab996dfb0bde4be738af9d630bb57cddec4931cf73b4c751214475b26fe8d3989c7bb47f0b382a179fb0d0dd3341b7e2c38ee116da7464a5610a58ca7e52f83e596338db4a28b2a08881abcc0dc212a2455c495ca14b4b62e5bf296202db9bc4e5aafa8fef1c814ee3d514b5897e7f22fe9dd074ee0ea6221eec1dd5be283590cae4c592c43afc0e43718d7255ca4afa3cb30e1a4c0a6c44043d1da7dcbb109ab2c766e2433a8af7ea96e7f5a559c1ecb84eb4ee8bf1d5ae63b6c3489d2bdb9216dec64fe6293793918a933193f65cdae2c16ffb4736bcf61dd1415f0c2d9ae569b6fac8754c364472039b59ab608d1b7e5e7f0374e79693658e7750c41c44b74c83b6c2baf3d027070e2dd5384d2feae65ca4cdef9df0714c0b79cb149f0936d3b6722d7eb8afa326a0302e1937c489a167aca0c7f1010ef92cdfa86e5d20542e412803a54225ca693ae1c28a63751d6a5099c1760c785f86588fa1ecabeaa93998bec813de2b3414db4ae5b3a8e249649b43ac583cc68c14c6fe88e23d1d5af74c399380dea531235d3187124bad530c2464b7934a78c129779904e49abbf0e334d76b93697d67543e23c9f8023fe4ad7022f8b7e8bef13b8596bbb007cd987dd1c56880180a841e7865a34d793b7e1cb4157d8eeacf04673af5f5d5b6e96e460c6d6ace10ccc9843d766a8a12371dbd3d53ee9fe41ad5b5983c99d2d291bafdeaf9bbbb70101ad906fadceca81ecc84fd4ef75856d3ec45e42ccf88f891f6addeecce00b98ac64c6cfac78072872ddf412ca43e7ac4e4088a97fc5e4620f4f5e38e65c4bfb96158ce29af447c5e573fa49d9c08a1c0d6b432a3738c5d77d0750d62636e0251404cee69ca525758cf0627315383f920c304e920c613e9ceb014f5637b1304fe8c2fc9324120593622360f35e809f941ec71c5e765b7016903ddc240d298c0aa7ddf3b3e03de59e43b48a19c19f0a81f600e30cf3fa08e40de11e3367c664089543abe63bbff80d44fd31a788c525abcea336d992694ab6b637c356b4ebede3336079b1a4a114df012735314428e8816cb2a94464f9eaa6eaea2ca7240a3a32abc87952b6566f24e5b8076f475a8e4524a00fa8ef2d14decf29519396a46a931a7b4494bb7c0f97b745aa01e4f2ae383b1524131082a0dc18a7e19c3fbb6ae54c68355b224238cf70a10477695f1c6ca4b98052a0fa5aff61307529369f583740100478be69947e00cdd76ef8351d4da30543472b3f00502e30c2b757b2de00be5f20d4ee8d0d0da0344553130aaf009b6965d9eb996bbdeff9b3857efa0476ccd9b1707178663531a10999b364f973d3bfb1957178e2f4c84a6cc8ca046b80b13cea16da258aa8842e2389bca90e31f397c09afe707bf702f1ba9e5e81ef97f6f54fdb4f7c446d27da5829fb1a4842ff0a7d055b4a8d67030c1bda22571340219582508fc081384aac63b48da99e1bdc4d056f9b983215fadac102151df481f4c2c785f31ba6912fbe5232fb0c4164a74731857a3f08e6bb99b574cdff4be464edbe78cfae6d0c9201209af26f08274d7faee558dbe3969cc8c4bcadd4cea3c9cd1e9c2251965ae2ddb8360edf36cb73782e343226b1fcbc57e96a53d4d0a8d7ffb3a4171bd966333fef5acd2f32b2e7240c288335009a5f34358a8fe665adbf4db6ec62548e83fdf1c911c4f02cef3c1d43a4545d04c326a491206b139fce532d5f1700e9c9c194613ff5fe56a0d720f1944073342e28e11bbc12ebdf384507593655e96d172676d63299475dc65e3a0036abb223f846d9408873d0b1e040b40e96ce4cd2e3142e45a130a71aeec58d61521dc1e054dd3040b80c671420b26c7a80b689851da5663e61bc54c6d24e5a689855c57935419c72070f823ae104efc75138438094cba7e05ecfe7deb4093380906b5a12b49dfc7b8d8779cbda027d0c40eda987a0cc3c4e513e792ed2ee665e4f8fd18dcf815453b07a1232f93de9bc3edc7a4db30aab8ae63525b76c5eb3c864872bd84169e7186fd7c8d81e7f20edfe606e15d208c9979520b6b248ffe5cdef5f0978f7323bc542e335f670271b433463c834f865735a5cc7372a9e91f1827e6550fe570bfbad14fa3b1f2c141d2dd50fba0e9e7bd4a0f3852c670a86c99dfdca657e08803cfb5e488a34aaa3cdff7037a6172c7e0191fb044a1c276bdb57d6f7e9b21465baf9b85d0b2f7d9acd9cac386aad65a46e950d129b21b5e8903806662a723838216e4f3e2c050cd4ac7b96ec1539d2b74a487c7e5a1e573fb9ab0b53da739d1343ea3071ab40b60331e4b7cbb22ccbe199c5c99667ee13465c6ecceb38c98a83259aa243ba39b1e1907f60bb0ddd711096b3537169aeecfa2a123065f9cc99c7affbfed999bb20e0d82dd56d97444a79aed04049251133c1019efbd2bf173c5e3d78d326b418f9168d39f76617485402b64b52750284fdf755a20be05369f26e7c8dcd6462f333f5940c91c15e434bd3b1840e153aee16b7d6ff97eae7a6f035c9d9a5a0a5fbbc313d1992d2f454dbfda2392e8c23efe5e10c82b7fcbd1f50f3dbbfda7a4c6adbb3a120f3ebe9c37c6c90235316b9e042eae31938aa6402c2251042f25dda7d448bd30511e3c6d71255775f8f0453408bff93bc0b6d06e5d7f1f3fde233343ead1206f335766dce0b455c7df65cb021bfc2e6d87ffec7f06f41f05d3e30e1b47dabac9420f1eb3aa4e9cfa3ea0b57c107b7d6825994b35ead015fe8adc1c9eae66a9ddbc1923ee26c6d55c01e9654b52d40c2f70946e9d9d0f51fb0d7986211a25696123fb81766f2214f737a66303c131e7dff0ccab571dce5fc1555beb93a23524de6520189138b505ea7fdd965ac43148396fd7233e8b084ab751113c56386360830aae7d5daa1a7a9d7cf04a831ca1a9b9a93ae0a6c402077bb2d75236eb86d9aa142d2312f17e62e7dc0b83add10d42ba3965dc75f5f63303181c2cf83cdb8002ed904018fd8b5ebb5a06d12caf165f859944befb0b9029e3e13512b7470e8c7642db5eb410c56b82fa092b148c83809f65cc723896e7202af206694f6f5c948b1bcab1e42aea153ad4ef8b945aec8736f0a5fbb56c90d1d30a48be46b1e9557858634a4fc65cab9148996d2aac8957c284658a5f728dff975801cf5ffcd0899401f0592e03d23cd4239bdc67417dfb7080c5ba08472e07fc9693a12b48e94f1944c8c2d2c8e2e58344f88132c325dc50dda176595ee597ed4acb4e6cb79d9e86ab07e32122f6e15c61ec9681ce631d66d42388262827fc9243847855d016212a3bd1b84f5f644b680433f2d27fbe3f5158dbfccd7bb8463074a23fdfaf6686e5a25c19ef83e20453d3a96eee1df16adffdff4e42207c4a7d0ad051a204804151570c7a6e820f2cf3bc60d4824f795676e0d5e436d17546822ae0e6d2531b36812adb7286a4d9fbc6c602ca47653c9d919ee10ad615cf69f7730266f3eccac0b1db1f48a09f0a358518cb08299d855104bd424ddb4017cefef73ff1c378bd29129cacd46601c6554c0fefc2d8510cc9e222d44f026eb734c96c8597630e3777b81d6baa8f1b8e0cb0deb822fafef2592de5e6f14bbb5f5a642472942c26c20fb7f79f46056297603f339f2c87d2516ec0a4afb52b69d30cb09945242801ea79ddbe91441d33c40b0a7a68f15cc6f367057615f10b94a27a327fd523fd416116be83af86d2c8d1e0560c72ff22c17aa9115c1eb230dd77e963f81793c1b90679cdeba670a790dfd8939c71bd886adb25e9cf11d0d279fae9c5062d49199c139933d05d97d7aa125ed4f9c81883ed62976a7df6bf16b24d7d753c1d2848bbdb5c53c5e8a6d865228c2d90427b143c5e85d80dbd05b0c9f57e71f8bcb48a9ee45e2e8482b6e6e1f0ff003f68741c812214b817dee0416620b48276b2109937ae15a6c2bbfba0c268242f8d9508af3367ddd6797be6430a394e62ca993178318176e19d24b63a18ce0272581348ab55cfc3d4e6c1e4d3468082d83c31f19e5f65c328b91f6eadf4063c102bcf8d498ccf2ae91cc163047a81c824dc54946bf730ad0f88ee219c06c441e4197e70f6b1f44acc7b34b8fbd9a8964a61f0ca6a80d1792fe30c93f67d58ca5232ca76a1e2ea0d87dec76a06a562a489b44aa892627fabdae9920901aa14877c2fd6f7e356d117f395b2abb04d935e876c7f09a25ebdc6e046d8fbc0c3de60a67f505e049155ae416158a405fdf6e4ecd8e1e68161a3e65faf2d5c9a33a40d01a0e2425e6621781ec98da5bcbe812ef1f10dac25c28ea899dbcba7a68a4d4655801f26a2dbc8d92bc34fbf3f0a089740b55f65bc305f9a65eec0a2642559b71572115a489596ac1b730bef9deb83b4bbb02c184e83bcdfe09953af6cf52841dd21d2d55802bad30d9636854eb6722d4933fc6974ac1e1f6015a063781401b5f2cb92bdcc2e9fcdfca5e1d7a21a2dc1678f6691e7bc6287ee7af6a9084e0132c208d37280a249c0293684743fedcc70d9d88930a2a71030d6fb012d1602b4be47b897cb4fe87d843e74c5986f61835e7abf6c3c8334823372bd6450df8e87dcb0df607863a4d4cafbd44ed692a8c43b7774ed15b5504d224b5dbe6a57aff5f32e38a7787e9c0f4c746d76c6651832b2b93966c766959e00c375fe182312832e7a1088be2bb6a233b0ab8341645a74e6c295fa40c9479a2e931a6c3c3d5210d18c3e4e772cf3dc1d1fc91530792f45eaa6f508aa870c599d4b2300190c5acac0fc9815b5000fdb91008eed51fe50c5d689a1337e7ce08cd1ff592f8c11ca76ad028c9f384cccc6c734b4e3f89694489ab762048f25c9c3562604185a40cad0b9a297bdfcbc095794524bf993215a44b03bdd039d050d37d30db213ed97ce303b000bf26e4164d2bfd37667a6322e7d6927faeee43f54caf2d4a5c737024cdbb08230c9715820f56bea085415bf051fbabd96e93a4c18b51fcd1bdda39264efbbf20d25e3c3538feba32e0524fec8903eff6ac10f48538a31b742b431a62c61eb76ae6b4068c5c0ac9c957830a5596cfe323e675628423e6f1fca23d7fc641e2b7d07e40292a531c716d9d24655f7d9f4cc1e130fc9b7b8bad85f5cba5d31b147c10016e82c3e324f9db3955288df921371add9ea31c57849493fc74c1e92f80b6b6e504b505c1da902c82ba970f1c3694eec6e00af7b03e935807286d0c090d3eda2f7ab99afddacd707b2dbb04861b66f37b0e8dea76c12117b303db8ec4692c1bc0def289a75b29fb422ae20c732bf95a10e19bf576956347ece0a96124565631b875ba3d32f90dc78500c8df82ed8349b8203965d95ecc7d1a484e2804b8b8f1bef765ef3d5c2b16e343aeae472e13419aaa1e19d84e1b16aa7cef81af0db3c9a8f2142a825dc6820cfe6bf308e9b6f62ba554f5147465f11e8624a3ba1216dd7c8821bcda10605eea69754f196b7274008a1b3a5fb9249ae9a7edb092419de7d71f93b0f8b1e24ebe4c9ec74d13c88696183e5940413d2ec75c4e791891b65d0716d5b7ebd089f32a0ebe647ab675d5fde61a263bb9545983ad333b7cd4dbcfdd06ce68fcca161bfc60fac409800729c95203f4256ebd4329c8f0eb1e3ed674ee35020f518f707ede6d456b542ec5e75e879c22071147eb8163d400f88dcf3543cf59865dd6be0c7eab1d0cc125af07d89f0a88fb721e788eab9df3cc07787ecd52a491a5e126a768daae69db6f498ca27c25d58af436456d3d0805d83dc73098406882ad7fbadf3aaaa52c4294ee8a22d6b668a6ae76aa068bbba32c24dc9af4a59fd881b8aa6bc087a1dd3644b9268fd225e2bf3514a5e400927328bab8be4467c8de9e55ae3b1955e9d44d09a5bbc19be4f10e59760133250d0d6f5e9e565eb74503d2225de034a6f904aed4a9fba5c37763ce584ffa6f58886e16574c8fbdc423f729da561f58a23dc71b9aabde414195abe777db9fad76fa49664cb95ec2063a20b9cd3342fe177422565946665e1f2d9d2b7e7470ea8b30db174a0b1a66590f7ce957b13779b2aeff6045afcc14275cec29bffbf62624e76e1d9c0de479af0799bfc035f23ddc97714544d802a43b15c647c9e45fcaa6d248097e50f2c19a1b45310e4889da1e5f91d99b109a138b66de36abeb1b1875fa08c0854dd32565f38fffd9028d3da2cfe9c55c467f987807e8fad592c7d77846dd84775d26a49f39f12421e558c55ac7a72514586290a53bf850a40d24a52335ba5cb2992bb4533d85de929aed2cd06b39c8263cd38f24868e4201d741851fe57975fe0c0a7801e53949def04bae18dd8c88fc3c8887c8ba70b9e17c116cf5c1baead35d512f76e9d651c79f391f5e2e22a8b33600d7700f8dcd9a880fdf52671eee1c804a71e2439e5b9da6bcbac487ee333fd67bf5bc1af235566ad999fc501685e872dd1ec8bdbce3613f35a7d22eed661f42ba619a895ea8d01a491b9206f28f06891962f4df7274efe15720d265fd31d04d2833fde1596324620da18fa485879e8564616c1b8c62dd8fe72138a84a5e2c0bcf0cb251869d56590bebb3518ed6ab52aadea6355ca4a9e3def1b18273e6b1651b5e6ac0d3fc1355d7796eb261c713b09a7156a56438302d7087ced32304e8e67f6906dae5a28986ee6053f41c875388d02250158623a84201dbcebd5dedff32f87dddf1b03b561dfbc9bd8a97effc8583ef07d4883746189457fa9503c8c444d4a59f28b91ab4023a9004a99a5816ccb679dd1f68c634bb7cfe0a0818de718b63d80f8c029826a5916f2840e7e19ad687f7c72a5ee5a589837c95c0d15d4e8a4ec4f71e1a9fbe081940f6275a0d95ae906a0ad2e3948258cbdc09a56acd824215aa81a0b08177d15111ae91355625c088dca5a5a73e3a3bd7f666914ee81d64d692eb275e147ccc1bbda5a64f74e15604aa61bb340728f75b5a55b3fa012421e423c6d29af396cc367e77ad8189b077b08ed73b2722efd430eede4ad9617306ae39f80550f90bed690efc00dbadc2c04c9a749e8aebb19ad6d88078258c2750ae8c81568de0185d1a900530be80fb3120d82ab2bfefbbc7e6202a76d9bf433b6542aa7bc1f0717e4e248190518e8da7971396f87feb1550bc007cfd547d04c88090f824cae3c56d910aee210002056207fa07d6af9d65697920c2b9900cb2c00c75a27a6546bd2f11bc49978b0a04a9abe3eaa829cbe43b2cb790857236ac187d38d917f9e59cc9d322b64183e49e6a5327c23a1b577018f4e0731256c33205a0db527456291ecf7204b78eae39c26b0a88d73fa53b5d74310f2db6c2c7b72d98b83afe191729a2dd03b0d2a46654b30f6a6dfd9ad6bd3a847ede729b520752140c24fc9e59ee23a3224b5089a4b24cc5a54eeef9caaa2995d496658103c020a8b14cfab86194bffc6ede2b536f8bc51c1520629ecb11b537eae15b1fd9a72188ccf780a3f78097e369902660014a7cff55ca7117d830037c0158e24906ed1de088a2938c064839563732344c152c78dc349a3d163a95a199bf7db72cbea7fe7cb518e6fb1e3f4e24ee402802199b80cfe7db48cb677555ee9b14904a63150fade79d2a68ade975e2fb39e7d8fad42174fa783d739e3929127f2a67c0c1421237820e3405ac0965e42a1623ebeea2114a75c769f2acaec4dc99cb196e31f18c41ddf96f170821159a7b77416b9a2c5cc28832d94616c7cb41cc97f7aaeab123235932abc81b548b65a8e0050b6559f9d81f4d91c90d809c6488e6b341ed06ec5ad792d1d6cf2f17a7768b88bad6930ee50a24ed443dbe0f3eb3426672cd1dde0ecee1416b2e14cdbb3780a21cdaee941ab0ab523ae5ec71ffbf5bd2ee49ed8884523e791241bf1a9b429d0bedd3a1b561e4708d4153ed5bd5e11878673306b924b1cdaf29cafbb9bdf206505fbb02e8402f234ce8b50d7541fb59a06b2290becf31952f09c71f48b18c3538dcd15c7c4cdbdb3805dcc0e7c2de8474622ec1b8c907b2b1ea531de10be6f49f0f36ea773459c63cdd66a521b61d1ba650cc98e2c946d9f258e4b4355568800411bd16446ec30575a1ef31061a60cb12d49806ea52e0a461f331d5fb154b8da4a312c69d60b8698ad98ccf3ff7a007d492c1ded3dff6a261e4a3146fc4dcd80127cb6c1cce67d572eedf92d880ced8a2025d1f3d34b02eb0cf0a2447183c4fdf67c727e901ea6d251443e11b054231a00aad06972f2a63c40eba6da093227e0fee0f7956dc7f8099437c0f4d10af5339fc4ac0b7e56143a1bffa169da91a40ff9fb09b9628ef94f6b659c2e0c05f8a65df8781121b05760d973e355879881fe5f040e1f3e6ef728b2a5ae910113115fec89e6efde38418de651015dfc3c2a06c7916ec05d9a3351ab01ea9c120e1f9fcfb5fa5123cf7fc4426891b1975456431515a8ce0cee5698c36aa222b925013ea5c1dfdbc1f9b8df8ed0bcddeb7ed000b20c7ee78658e263b83c3fd9d2dabfadec780e1dae539d35cccc0c687b9d80d2b9e61a3716da7688e96264ca1760cd8e4cbd9402752bc3a95245e7ef688e523ff9c7c5da64d0da7cf488ba17d3361a86edb8b82148682e1cdcd57a6109241c9b5781679ad2d3c23195831402f975e944f5620ce33a8c46198fcc84a8b55ef59f8b59e908b57f36e9ba413f9b5bbf4349c743652cf6cf404ddc65d49a683d47987444b2104fec5cdbcf7792e195b0f60523926d6adb44fd52c4de1a17d5b2c778b4082503aa61ecda814be20709c077403850d521ec43f01f06066e9525f8facb25c955d12dcc8b3ab8db241bc86f3001b4c56b309023a4539a3bb0de7a4e4fc7436717e22497d9292bdcf317c021f271a1cc08a283ac13a508e0668be0b12ce07e35a553b5b2dad2ab39d2fac7b227e59abb29acb9385e4164d56834bee1f84824f77d58b6ab3ad4b78b094c8974377fc4ed96db56605b21e1ca10c70cfcb0a24ee80df45ed432ae4bdf1fb7423233758027132af24dc17bf911a8d186eaabdcb623703f46d87a0fbfb79eba0d0ef3b9d8668715ac85af897abc190a7070b48dbb937714fd0a752b06f5ceec0a524618c72f966df4dcd5c426c592c933557e871c2774fcbb576cd4cbb5a083a917411fd451f08a6fee2c12353ca67f6128b50c542d7c2cd143a23a9775e6c8ef70ba5101afc215c3de8116b1fe11dec0c27db7febfad5320aba4abb1346d7a7c93ea5b1914973e6317a073c0079f741c84fa46c537a1962821000e342d9897f5281bcbf1c99a46723aefd3cd18e2c5706616fd51c0435349de10f803a9223d5b4cda881f48da5fa17aa36270e9abd1080a49881d773ad1ce66fa879981bf4962f7d57853c909276c281c86a1ca1b22d68adb3465a1631f14fb963b21b9f2dcf4916c4fc0da8c8d25c4e55c868e2ed90d571d614ee0db700852165799981c69bb8ee06c037745e5b7f01fdeb7b067e650fdeea21aa69e5a451fabe6a701a9af3aac7705adae4cc476ef8c09e99c57ddc49e921ac87f8197531d1c9ada63b3e3b2063bb651e337c40542654166c56575bee47a1dafbbed24336e156ce0cda1fb02e112c0f0f9c03b0a66e0433d275d6c054e6a682cf1c794f36211fabf9af0dc80ac92fe1599c667dbf1c6cacbe6f9a893b156d91eff498d76646613ce6da2299c81b8ff2933f4e3bae82ea1fc4ba794ebe59822e61e9c2f5fda7b209ed8a789e59aa3b2ab7b1e5da0c8867cce68f997ccff9dfa9196b273784858c6f3199e562e47400b89d199bd08c86b9bc9a88e37e209521108e10ccd439919fdcb56d2c1828138493f8ff9fc37e2a293c5527316dd82d946d247154b8bc9eb5ad3ea2dd73bf81942312f2745b0a2b1199629fe4e33da3de61070dc1ac0472f40632be48583434e521dfcced167546aea68baa0e3a22728ad4c8172f3dc918e5f22e30ec4639675101a42ea6f53e4aee98ebd12331933af4571d3886c6ff403a4af2a1130859564969ac9d9770389f74bb31bc2845d52a9271dc88959c3dbdc2d42ce8430e6a2937fac9e4e0de22ce655e9fcb8132888609057845c4e3a997674d66ceadba9017eeb3f235d4fbf7576dc5eea3d90d0f79fd9dded4e91606546a3c2bb85ce6e928ae98fc0b54bd1749f74f197f18e6572327f7f482e556822dde973830ec4929b9fae608aaed3e1db243fad431074c20a54dfe41473a356518093e627aee89c18737ad19c841b2c87e048ff5cb45af9290eb0e1f45ac3b2aa839ae1835028e91c4eb35f49e68b544ca6fde14356e76f76bf4d4aa1ce6c8a734084c6570a080399244357c9f1542aead0276753053fde6939534316b55719d20bd8a1e021c4623ffd74a3e3491039a8afa3b90d0079b3322dfaf9743d11fbd11be4b50c03528d2d4ebc5521bc093382d7bf76020499b4ab91af5e7d1cc32e941233895198f8c6fde2aac896b4a20101f914b40d86672ec66faca54229922d81fb2cb96d2a7f7a7f757a9e214758abb7414083303cf9615c9470259f22fd166eb1961b8a17f0308f8c06a1831655d95232ea201de14aee203301fa350fffed829619f77eab8f5cac4b893172bfd75c933a16c3145af5dcbd9c1b85a4c38fae258593539848378ca3ad0a10f245fd661a9a26e303ac8edcdbe805ef0d4886b0771c7a4946bfab31be8371e9c113eef7483003c4a82e8566980e4c0b36504714c47118a6177f55fe983f3335181d2d8c943eb85d51a7ba2b48869e2598136650edbcdf055a74b2a0cef1a865aa04832d053075a338277f73178ffcd877563e9c9e0a0b7cd8b9c28b6de65d9180d381c1a1563c4f9a1759c5826eda8cddd2c10827a466a36bc38019a227f04cc6a777b8214283cd7cca024df59276ed93a51aa9333dad424cef8258180d25bfaab5fa9914942f728c18554db7f2fd32ab5c84e79b85d790ec7fddd66c32be6742cad316c3b084e226bf39b99804ef2c0d1ccb817fcc9cc80251b622a3a78ff219b86d84c4e5666ea8388e1981e6194e947fc777819593cc9b159587e091def188a40af89d903bf813fad302c8c06c885f4fdda7563ddf2149f065dac09cb4fb81291575f9a543c457b3bee93650452fe224d1c2d0e36f3a1b711cc08863da37c229c0d11bc7333b02f333791aa3fd1837c72511a75ed084166295ae463704a1ceec2ff58fd4371c0ebd7d5279ba08589aa7e62e55c66bcf14fb98727f0afddacff39dd7fa7ee7c90f3a13b6944cc0251d6f4810dbc77e02644faa7eb8f0bdbe63e3067d1b6343ddd564769fa1f9208014ff0bebbe492703a4a7446d33fd9fbc99bb37592403dd08d79e6dac9a8afef261d222189b9e94342cbd33ee7bfb9415a5b2ccb7a4cc292f7c525419c2842f2c0df1e8864efed5fee1091d938a41ab4ae5d7719c828e30297e0b0988a767b265aebf774e6bbe19f46614b47ff8302a4d4c90838c06f822bdc3dd46169c777d96df1bb8de7ac32600982ba56f9f46393a703062386a3756faf7502d3fa03d16930f678a09ad88d098a2e28665c8a55ed1fe9d55cbee8a7d8cc4b989453e90608bc10a8356326d68d98cf24551f6212b17e8e5c01f10bf47cabc60c6f92fc14488e02855b9469e9ffe7d403b8a78f4d7cff23761ad39ee270600fd2f0117c3a8cd3e219e9b9a907d0e8fcf80d789799f685f08cdd2d8f2492f313e8521eed8733e5130834e356340659c5b1c3e9419c85dcae20bb8f9a4901fc9faad8f2af0f02d78ba3c99113a627421bb1eb7d2073f64955e3a69ded8cdbe02c737b9f852a508966f138267c0b802b1b5d98b20ffad988ace750e760c06c1cb84410545a60bafb8e5cf784ea56faa1f87bf78bc57e993327a5cc18230aedbeccc6ffa2d067cf01266db7d1b2f9df80a58ffd58b2746b46559550ab92cf549d2cf85f1f46768e575b7921b9b5f775d077c7d051128aafdf4d92aa5e95ac4df28afe0743e4ca2861a4774d2e2dea9ca25fbb24bf1430ef5c511a1fb96038a38a4d89f367200548cda0f0174566a69710297b712f8693891de666e9ee19c14ad86adcc085e71daaf5199eb7a5104e6b592555da7260c0060db77593e8269e61d7c6948d86fe493326e165871d2107d0df95576b5265896a307207a7aed2d5ecd9ad4b237c6de011787c20a114378aa526ee4cbce4d31e9f0d327c849a9f0a351ce3f385d923738c147092d5e08ab0ed81c837664e1ac0c95be1ba295e063187586266637dcff678bf2c1bb6e67b72b4cc1a272cc08625804c5ccabcf4e975bd128e3e596f9f2c58e17d32f3da985348f71d75919453d1108a89e01e5148ead94dbc055cd795d1434c1a9b821994e4eb7482bcc54655731ccdc166af8511a69ca3b5b4ce4961ac09ae47beae889054446bc5a2ac92fb8e0a8995073bf40387274dba6c9401263d67f27d60aa4189b9ddc4d78aef7262b851010ae640c976a24476a1b632da1586cb57a3950199eaa591f973cd7bd8944cfaa18bbcea10e240f8c1b74e4c2c75bc527e8909d3ed128eb0426dd9a44a466c85e9c315c4e26645b5d1592a78b4c21be683694269553a0f78881db7a8e481cbc23016675c5aa3897111288169301244d13e7358d40ff4e05809b37e753e85fc7221adb3dd77bcee4256e9f83374bd3420a46b586e7ed006f578c50838810914c20de855ab4bf4a0022b57f952e17c6cdc67d45a143f2b6e93c4e9cb062bf078b9fecbc34d9852c9c05923b972a14aae3ce4798b08c99e96c139dffb40272203236c78bf7d11acf0e10098129e8a295643a16adf02bc908dc60c6df44d753c811310090fd00bc4386a47c3a0c1111d7956e68560e30a40253b390118410097ee066d9ad43e18507dc5cdab72bbd6e8e04d777573c323126e4c7ebc8e861fa1eff24388ec074d0553e434fdc54903f7715d0c0be23057a4464c145e1270f3b734a42fffe717eaf60a5dce374f3370f1c22d41bac5842b8f202207c5faecc9f1fdef93dcfd2c3e12aa88f018406b74cff2f15948ce250165d2e73702cab3dc9853582df81fcdb2ac4364c0c1c3a51660a8dd01e639e0736e089f48abe6aa589b6f8b1f805cf2d6a494da475cce3396dbd0d56e3cb012d17cc127c871bc4373a149ab672db23c8223e3b7e7da09c25972596d8cd00f5a8e681568b3a06e8f6c3ee3b67ccab6dd136636add28bad009ba8f8ccad0ff5029fc187217b1e3ce984c1d7d9da7c62b42abe7b5b25e75a2082f5daa1ae1ba93df922dbb103d12be7f8e1e20abec96b72e24a0c7ba0b17437240fd08c67b6eb7086da5ef81edada6b4e16278b31d4b1a00eacf4204435ce537f3193fc5e19d850851d0651ad64c98b2de71d5b7b72286d4ef84028eb31f47716a6c285c838efdcf66fd1732e971406c3dfa2b7f507bcfd8da54fd264463d558ad89d63a5b47451b9f5a38825498f57d0dc541348cf4e2529868e988ad2ba94b2a9a7a8e2d728c12513c8d3b626ad00d2ffa61522d8f501448b5f92800fc26be031b4ddf446ea12f40603ff315f4372be75f29e488754c8fe1054747df4e61d857b744a0193b32fcc6e7651ba8a9a8b759345e54ca98830340a109c443c246313220a760b89c9c723c442c47d63e2042cfe65ffdfc48b51b74cd3f127f83c5520b6b80464142ffd9d3bbd9364f4ff8f63ebec0b2e68d5d3850954cf5a57b455324d513cefa651704be83dff544c9ddab0b2596d02f8366266a909816b15072e04ad1a30c6d4373c8ccf6a9b8cc9a6d61dcf6d6ead708280e81b48a3824eda59fe8cd1b1c6c924c09ca758c7455f015a830f2e76721a33f782714f3b8ddb30aba078f90dc3bbcdca67aafeb6d2f1495d76d2983b4509db75aa666386a81dc07aae9ed1f373e02fc410ff55d0b926448231700eab5694fd69a8c1c661aa0b928be8c92274e05e161aa244dec560c83e70f7b1ee72d6fbf8ede964672349d12326f1989b3ac0b96777d2834741416edb980b1f33bf62837dfb5d3f8e6be5accad63f1165af14dc7ce15ee99dc5bae5d94190e847468a8f92bc02a7357bfea78fcef9060d0c476c98936db02cc12b45e3928dd887281e52a58dc42084686af976826e7beb9645615bb8fe41b6e8de71b1142296c82a2f1789cbfea84279a9dcc710683e6b384ad16a9d16b4ea4d77ddb7c9b3a48088af6b09fc44fdb1ef6a1354220b9a3772ed37ddbb6cfa689015772d2069da3de54e1975b8f1b0d2df086db7f5af3366eed98a0faff4612acb831b48e1179970b95f310ac5d7c13804a0fc27d9591b2914e3e77ec32edd669b666304105ced09be4c16a01fd00f03ff8a0aeea56606adf32cc7d511e4c2ea99b188871c1e2ddb7381861bc08486e3bfe75917ccc94156f4a2f8627ba3888c713fa8b38d2beffe4406510955dc759f47b71cd73d6d10ec696811c71f54c35ebe2158d1d2ecd60a0aed575878ee6c66559d90c76705726978458fb4cf26b0e2978ac3ee8ee20d05293f7db9b2672d6ae4987bae629e5dbc5458a18dba014f26f23229d85cacc9b302beb9bfa7e61ceef30a141fdb7ebc17f3bcc646928b81bf9d19ef3f09c181e6a7d82533bb33f888cea555b73142ecd5c9e299ccc7fdf005ef57b9a61a72588900c98f4b9ba9c8877dd764281f401ce2365c11d9cf8749846857532114e9bcdb7e69acb4fd7af5e4d9a5e2fbd4a5c6cb27ab4c381f345d4d97c9eec097d03a76f2c666f014a16ffc9342a5a53fc44e479dc4fdef73311230231dac18c0d1bd9ec662bb6b391f26454b88610b32d7662b4c6b28f85ddeb64233d2ad0e959dc78b28358d5e2e1c032373338d8dd12b7644fb39d35dde4beba2340d0c597f6b9b470aaa959ab29098378b4c737030d2351f21b03f49409c365cd0ad466e4bf6ecbba33a8a4b0350bf09e0b4e0f5ad2a9f70e58a94b603ece481f7d428f52114eefdbc9e4320908adccffe10b0d926ffbfb05de2ed232dcd30c24fdd7eef9f02e3d7271524318c347e69e632273d29e06cdbcac06ada6f161f18a8a58cf8f6a11698ff7b822b5c7eeb7846a906f6b188e109d4bf0c372d649096120e903447d22368666c798dada8ce39d08a4450d4aea15845d2d67496e23f3c6751a56f11f9d84a99425f2d67bdd1cc0661cf5a047d967b33e0ad01a30b3a988a4621ee6823e99f1ce44ca26b4e7193d5fbb5495f8a3bf177339ab509254282b2a2784b4fb21b7be302a0cc3e719c0ca5e15cb7358dce75a92055069fad68bbabca0be142de30f6658b64a6484d0b6665f5e59f6cd874ba73c4644b0df81b556038d10d7212647cb1cac2ccfcb6eba615a90017428522955265db1720f87907503dd4f4f760eb423e748606515165fecdb2be7febd4fb72fca4607bef8749f4f4222390e15cfb510fd79db5478c162660257915600d263f3e639d99f05d2d0533599aea5f9dfd4cab1afe2b067555818dd28389c5fe8caa1033d081981328f4722e0743223f58bd9d8239a8c83a6f2cdce1b795df1e29a9cae520d78c6643bbd9912e06a5613cfd2c32433b8412022d72d2e78f973cbca9357c6ca2cf9331ab9b0c44aa826e5633ddfa7b6ca8a30f4e0db52f1e328c6462afa931f59f4bcd18d2dac86a9954c409bcaf470963543e38aabdaf3e6c9350ed6b13239f140b2b251bc8126526cc582de719d708f325610894ad1603ff382f29481630e8dfb2f8cbd20228d807ce10c533ce9406b45a087de1519b5b3a890943e9b55829f43889239d8dfa83253ed6e212c7429c81a2dbf158aef3f2fb88c88dbd74353d558afb8ba0f28ead66506a0bea4fd755ce59dee0eb496bdb5ea81c4f29621528d5a4aba55abdfca9088bdd7f1285117552284cf963f827b871c2d41ef465077f1b097facceafeb848475ddbe8e48bd289db7f237d5e928c2a6ca8cd263c77d1df87e9900ea79efe9787a50fbbbee752bf296f569fe6c8c55825f95d1754527c7373d2524c9b035574b5420c8d18b7ba51f6eff8b3b62f9771e690ff81417de8561891641debaade144d548865a77e8fbb01868232e50a55892b93ce4b6a42cb2af82d35d9dc4acf170b616c0eb5dea09e7474c3ddb32c7393881f1e3e1ffefaede983ffb2cf24591d8b71bf6e3254bec501b4c55e291735eba1079cb05025c8a01a73a9c95f392ddba69ca7d40e4e7a9edabd1d7dd02eb8b38683c809b04b2348d4b1f866c13c69533521f29108b8cda7520295333f5d687b1ce691c663d4fffc9cef5c1e2bd7372b506c5f8a44f7f014f5adadfd1cf210c500bc8fae9964c40d4be8d16bda999d55b204f7c2cc3fca74b455d78f12586c2458a31408c268f924afd5fd5ccb9bfe878e1a047e5b8e556a94305a57f2ffe2af7d118184ed1bdce93488dc4bb7830adf57e16dad8e1cabfd7236b5f59e79fd8c3554dc126974fa5e38c4b75b21f7138c949a64c23c765b7a6eb470768d336a17fc49e2217e001996115b5bf1502bfcf5c1ba6e97253ff71466de8cfd31ac48b730e0a60f1d226d19740dbb2f11f4a2fbffb0610ff76e7354fffc6955366e5a133e448a13e555ad348c32cc5791109d455ca485b2998d32e7f738c685e7439c807aab24552048991ee9744e3b3b0b0fe408bc037683eda4989c0ca1fd4a69d28f1f561e1aa4306d6743ed2777266f07116129151f592f6041c99042cdab4a40c48d9acba83380a2ac8ba20b84345c40bb825252b593bbd455ea5e5ef0d456b23d111a0838b6aa32b7c666b24f167451df05fb7c08b30b18ef3b6eec325a3fd6b91eda1169f3f98d2f098dc030b020d743e6b0c627c12089aff17783e495763bd088d54f65f579bcbb77923bb7d92f6a5028437e28c4225e5df040adc9386a18d7f1e9196218d9ab5bbad07cd15f46297e7114e692784c42c4779a88b61307cf05a522b79ceba3df172930f07518f46b8dc90f7a5e9f27ec42eac2186342d30721e6dfd6994e22535924259e88045d4a0c91d70c0151f0ee13450c55de3b05872667174d3a8df9cdcb253b61ccfa0c898ea074bdc7eb87054ef07f4c55e7766f0982cdf7ed3913552a7dbfd0c357625cf0a2e96a0292a211f3c63af027ebc2bf96b25bbc2212f3c61406f50975eb4cd9b2b7887bfda809b7543b1fe940be4c78fc5c4a6f23f520cc563cc5b3a4c5412173fabe7b5e221fb5f2862b6ede63ed679eff6d570e352ed242f735435bc6bff0e09c91b3e39b74a07059d90a1cc128c2d1066fd0258fe9dbcf1c491afab16d584b4d13b5487482b8d7709eaa305663c0db733febd091a9d96d781d518eb0fb96db087431528c78c910ecf15b66507fad9efeaaa4d329da44cbbf1816af9894ab6791abdf63e283bd6c64972c35ded807203a457cbb24772fc13d718388fd819015739984a6851f3c485033d847cbcc5f1e5e8ae0298b12607eaea318c223181f9f6b2b03b2fec0a3f6e1786cc794e5a54e4808e4c66f9d2f93110dca091220fc1fc16442ac46506a386c81fe400efe1c641b99159cf423445478e9c51f18f38710797d287618239bc12dab239027af0cb3945377321cd8edbfa1874eb93ae9ed96a9ed4958e5b6b5e9cd950f5300112a1d81adfae6fd99b8410a5048dd7c7080bb354022f4db0a742c6dc903d3b9dbe8af6644d302edc6839642dc9fbe5e2e29f603a47f08f006ab94bff2e4b31b8273fab43e93a8deb2712d97648ff86ee5ce9d83b11c2be15e9114d99229e3a0aba2afe568d598eb9688ea0faf790de9f1a2d1106718e0976279cc7fa937647af3451d7256e524a416b6493b7086d8d2fb3c38d9ed0b6895a98adf7f267d04920b2cf3e4c7a124114223e368eb5dd4b135035865aa4c3d698e1cc8db405af8723b2c11bb5e4f1ea2f77342964d605ef4bd23f7def13527021da56e6883297f3a02caefcb5a13d50a4c13f3d27ed0515814fcfb2360e623f0191351d8a775e360884372ec878d108e8d382b53086e34ae800466aa2393cbfa11ffa35614ac7b6503781ae7598b44c6c350665001fa65ec5de0210bc77d1d380d32d959fc6b6f6e85c7c76c2e58b6980852940f0dd79f13333780727581340d2dd51b805f2cd494f5fb06928eeb6b3123fdc4b07aa425bbc047083cbe8a9cb7192d585b8d3aaa81f94ef97afc9c134d37fdbd61c04f3699601149ff5ca46de30d45d64d833f5d1d78fef929196f4c5fd4d3072268f71a9c588640d8c30eba137fe4dbb5bb077279ac9a1106e9393c9dfaf3cd548f27729719441187ee22231c14042b97af9a621ec3926112b5451eb70cd7ac6ba5fc1eb1a0318d0c304e87bc022340082cdcc8658697869d4e0652ef394bcecc209942cdf63eead22d3e07f2643c9785260f8899f4723f1ebde62d6ee267f702f0214ec6e5ed7c8d117c3dac70050a4a4e3bf669ba625dd1e888253476a45c2b1c0057e9d3222aaef51fd485007ec3e351e5d58d8245965205e39e8da62950773b42e270a2bc17d916fc8b674b4fb1bc29c4e30dcdad09f61b198cbbe974ad9d0af09928cbc5cf89c241253b64d2ae64b6c54e50fa7967bbe2fb1cfb0b60e33070447c5af64304f41fc4d4549dc3d76d451d4a58ae4b922afc6d60177e118be5b086e5aeb0e4ea57a52821bcd22d8ec93c640d7781dcf8bd2f7fbcdeb950eac8a39f76f12eede45b19e6d24f7363d05e38884d1cc02131cb32ea46717e99e7ccf09f859fdcfdbabfabb3bb269666236e3802e63c7794dd1c8945a447450e8e75828261f1880b2745fe515164e70341cd9ae9a39518a815a56102726edd7dd8d829a938f8f5586f3f764c51f65bb169bcea452a6f3829d656cbc0e71090c0f4aa16363f2edc67f171a381f385cf43a9eba91a27d33f29e36a6ee08a4368c20f45d288fefa7625783678a920b871d0abb6246ba3bdd863a02368770b1f2fbf2e9c66d00be5cb8942abc7646d7c519eaef28bcb92b6864aa8aebe7c69625d49a4bcad4193767d923fb3b88694f19dbe902d97976c82c3b96e7c083e632e9cdc602693d2f5d8f13ee5c0cf51757dddde858ffb28d2a9a2a343377ade13945f46afe47d65ffa55eb463be475344123bc32f7cd617c5f1e729f876539bd53d956d7c63e793b1c39cefc315a4ba73c3741ea91fc3710a81a3ae154cb3abc4783f2037adceaf1a3597d216a39a0345c99089ea545ba08c333622d0ceb193c7b8d68e7b43ac28ceaf85e9ddd23773d832253c9a15f84dd68a6c6ce8c0e7e69b39440cf57933072d2a86d3889b950e449d978ad68d9da8c9600d6de3ac89511265efdde09c4935473bca82cbda837ab5e24f522342e9e844ec9569136f5b750717116f09c777b10e6a07490d7974ed5265bc2da47ac081f64d407fd231397b05b6f2a5a1381837539867279f6a5b7b6f899d7192686e62744c7bfcd4af0a06eafdc04125d28ab3ba5baf72dd4f29b839e7c7d9da8eb704b8a35a62fc6e04375c529c5ee3e317d71a708a17a828b06553b8c8d8ac1f954f7e027dc1f14c8669a3cd61dc4b24bd78369591a5285afbb696ffaaf49bfe99a467d894c769a4d760d7e175b69ceee1b0d02122802d8a5e677fa52ea4213a5359820f71edbe836608a80b0cc73dea896a9aee484b67e5746d3aa09ce552b2862dc8e7474bc2b6d085118000b83d9e6c0df75a41d619fcc174f5e012ff9ed2dd0197db12db9b64507a3849db60c3ecb113c3489ada47d092b4af779959a9b539438392484d171e56f75990e11a1b26916ffdb86e1d43c3ce449300c6abf052ff4abc1a0705b97f941102442c4b92b77d7dbb351ae604ab6954cecab32e4a6f8b4b0380d9b6866123af34dcc91f07659f029c069c2b45c9c45d1931eefc227a666fda9f9fbf5e1563e605428e8f597c89494f3fad83053a2fe0c59220e0170236bc0ab9852d951aefee72713f489a70e04714216efe1ec8ec035ea922e77b07cfe8e249574598952f2fbdf113d00b9ba34ac6576349d3a1482482c86ed8fda3e3c0d6433d55ce6fb1703c38c988d4f65c30469f024c73bdddaae9897b422dc56b2499d4f288e63674d2894c6feed025199e301964dfcde7e5510fa400d6150122e4ff181da74315273a3b61a98ead08c65d160e6fac8212d7cc713d96b30f4013357b46af7fd355e8d451d20e1156d1a1df18dad47ba747abc7a3c268366b6da9882bc2356d3fed3299401f87971fd2cec1a9ba70f3b9d2a715c885bc95ea393144c4f81d0914377de2e60ccb08fa327f33bedf56c72d139be1b99b354efcdcb3caad8d6a3ffd26aa30f903e83eda26677490ec808056230188308e12764cba5d5fbc97ba7ae8d8466d9f156db6145eb74b2b5395e228b14672db4ade9738998f25c91a5347922512415171beb3cbd580bf25666a4be397540ba2f433db8de05c42fb4c158281a7bbb9302f703d3784b8427782523446f4255e2873f1adf7ee208901acd22ec2ccca0e394e08a992b209c96b98aa753e3d67af9f405d0441a2688adf8bcc801c81eaaa54adfe3eee89a729a72f673342204e433c5dd611e88222786df5493b62636ec3977809d775332dce777f5ebe72b298314037f4cad9ab40713b80a1fafc7bb04fd60f76078075e68d76e7458bcecf5e1abf0aa6fec062f91847d56a5fa6fe46284a1b00a71c8dadaf3fdc2f0dd4247242c34f69939f39864fffd2e10618f202bf22324bd8cbe3a831e1908abc1fed6c01345569df3e476c36891e183a82bbbbdfcedf50c3a560b7374698785f43e0a581448b419b269d4f8f4ca8937c23ccf222ff3b592ee68f2c5366f5211d9dc6735a605f13140641f99351578dbbf9b2e4417ed76b01a494a6beb63996147e81c556d064d6d679554281050e1196fccbadc68e8b59c20c5eb444b80961e453ec9a52bdbef5be1764a6f14fc1fe939dbe782112d074d78de50f42350f80d8291843b604363f3df9054392c0ebd3ee44ee509d8cda918615c2361f0ae1a83ba559bfe88990d1e8827ee154550dd72c3784fa7a6bad1917997fb8ddab578dac3fec553be46094a462f1f78122a2278d90343ef3fe01d4e193c4e6cda3dc4d28d66ca9c139cca042a7684f5ed3bc350eccc7b061a93c193ac4a29c306f1a5db111723c6700d914d49225f47128b2beb7932b5c690bec94edfa825180e3b8e3eba530620753831ced32816e0ce231349233409f7f6db72b077f76ab604f14d15e634511334217da217aa45e5703fdaa527c6f56d2130f34dd63964261041b0967a5953feb891744c4a5fde85a9e47c609b5c7732445aa39f63de36acdfa3c26c605c9628d2a8573192a9b8360671356953a3216648920db57c7e95da6ab28d818957cacc990560b94e5c6813e0b84017698a68507726f697bc2298e9f44e1712c21b976f7922bbe55c0065d2bac26ccea65b303a12c9e8e783504643edaca5db193892e05928e59f009d6c19c83749eb741e1f7a04889d3bd14acece920a0167fffb6e8476c372f137de2ba5d2075e581d068d401236bc78f0030d11f788e65f59fbe6ce46954f41a0bbd0f218ed0da86225249a920a56249d209ac6f1871045a40a0119f75dd5c7b8ce18cff819c32103184d188357164732bb291aff243326c2a690e71473af584af8cb6cc6f49274be5aea56dd75378675fd1aac3144450f90bb9bdb7cdb015eaf473056e95a6730f7e4b8a19e31cc2de73298e0bdc9926c4ebbd2976e61b585d99011b4860d05cc9562aa9498ef3e34e899f07111fd791158e639361dd6a0cdecd54049e7ac66ec05fc4ea832931685fa3de10344088e1d1d1c11fd0fe85237e81ea8adec8feef217003c7b2ee4488899c77b4ed0f58eeb9414977b143814b7a34d87c4912c89d3c370e47920e682cc7f7ec55c12ff5b6a233594376ee0adcaf228519e9d2dbbd4205eec6b9c0dd68412952f1ac6b61a2ef196b1719f83272c69c7491e0cf5a3298622fd8f5d79e2b61dcd9482c54dcf865a647227b8ecf90ef5b3aedd34bba82fb63f3751bf0e087d10cea1f23ffade431555f13a24f32829024fea35226ae3574e60de095b74f2c14adc32d24d5dfde7d64e4a188484e43bc999ab98850b1d35a06d1a9eb2f2a7b5f9a46439fd5acd809d47290190442590a295a6555c55fafc78142472019c5b6bfdbe5b6ad0cfc4643cdb335f6d91fd581048e2a7f1bf3bf93f02692debb6506d66b612f90cd9ad195c50db986fc0ae64879cfea5ebfce343cd4dd1bfd711c7a475c15afb47e7340106ed18b3d71209fb72472cdbfe0f56e6de5e5750c256cf33b7642d80dde1b5df8fbc3e4b8af7488804ab5c414a90669036f37538ee0c6c1eb1800e9ee370d0a63a49c166a874774acfe09b8390103466d9430cede3273518fb7497f50366b0531f4a5e5735ae244419c5c3accc61e8d4cafab1ff66dd0212d10f4b45e4adefbf9a79abc421825c3864fda33f1955c05d20975494c4063083990467771e7e35e2f29d276de2fda3909f5f0841171ec5efea7b644af55bd4e0d3dfb9caa276fb17ab6f91dd67bb7dd3f24ab8d85df93efa120a6a841d59a53a4ee51b200a2d44c501d0a73e01265036bcc858cdb4f9f505b2f84526bdb63f31409b5561109062028f2b34daffded8b85abc5bab91b458a310d9060b3fada3f724dc11effc873185a22952e57ae9e224c3af3c0f2a246d7c7b022cb14b0c22b5c4c2f53f32bd368efd652b5f3003da6340345f42c24fe1454b89002bf81d17136cbf07c3bef3de15c7e7b6e712eb07b5b56c2c5d97b858e7dce26b4b7d5c1e48306d6eb4e5cc87078f9ffa2c7903d51e26376b33d6203adaa02378ac9dd35fd42c4eee0aa2037178b3f23c043d82946004cc94d7e0395bb4c8152330c94a4dd12a585e7db842bf7f6137e83b0081b29ae15a726b5feb726afcbcee3b742513b1056c3f5365e75af6518e5dadebf6878b2b2a9c7ab8bc1528c09509c9ee9af73a261d0932187996efbe51b2ee2504308ffd7058ebc7eab51ccfdb30313d465efed4e61450464dbe9ca66e690cafefb56ea7bbeb1414a7aba8845f17c8f104b99cd95d9b41a869764d8ac8013da59d46c59477c1e2c60170eb45f00fb81404ede179c18bf63de03a9f3535ffcce86dd9351157b0bc1140bf091b716f1c29f3b5bff30e036b05a58f6cf5c90e7866edeb761bc99f055625b533f02ab8317b94f34b8ea3aa054323584a1e6283b96fbb67083d2a92e626931c5a1163e1ad3b2fd2686fea29ad48caa8ee44bad63d45e3441d1a8cd5778139317352b920070507190901dab688889385acfaf58e9cd5a8db10e206c54898cd9c699792dfc3938ece7c397d98908e478d7442b0f77ffae3e0b6c3da3c4810afb15655168ba156aa0f4c23bab4c8299b6c1e2135fd825f5f1d6e308665b4a79acb2ac4c0f21330fd64a2fa41f021b346ff17c8ec848a61765012a22b0518d7e7683ffc79c1d1badf45df58438b4e1f504dcbe2805cb0e81fca3f9362c4a0598de99bff7439ffc40105732a2dddedc5680ae339e3b36e4144a501df9ac67e26d4b60619d172f4f1da7e5174460c665c3d7d33a7655d0a6a12fc2237f6901402adc1fa3d6fb22386dad830603b121937cffcc4d257b8571c55598cfbfa1cba075ca12eca2aad8ea797b4e8e8f11bf3848f009d29608bd59ffdcc4a87648cafc579e3928179d675cdedd97e19f559afcd9f3ca4918ed1ca9292caa513c84cd12c1085c8f3c003e87a8347f15f6c9b8d4cba26a950d76c14afd71803c00ffcc13a9901fc2e730e9586d7a4440af3b5aa536cb033e463bacaa0d54c108c6302a3a0254f36dcb9c3aa93c12eb685b91ea49872f66dfd67b02e1702ad8b1204b86e73f7c1dc91ae8240a47b15a40652e6145259e6fc9149c82ee85f11bc242e944ff40b820b739a73e922d347406e0f3010c031a954eea7c60e3dc7bd2658e86a1875b2f6502d6cb5aab928d990b1bc501538cb82d6f0c372aec4be0a23ccb6e1840b3e8f0a2978f8ce9da6db73fc22937f08ff3c3fd441f727d4939528477c4d97881acad703cb632d67e68069683807a928421f094ea04874449eff2e66d7e17dbdc3a6a0b4b5f8bb87e5dedd9ff588c4d06aa6bcdae4aa371088aff45ea1a9653a857b94b9cf31e37f03b84cc1b7a04caf064817388983eb25abc7722cc5467988c9f3ea7f6238ffaf2efcdd8adafb9ae2ec60802f171cc479649d391a37948aeb371a6e312d66edcfcba3455828212c972dee40d68047bab2e752201821f045de7bb805b1b744e3fb4398d3ba919ca5330bf5ec150f24121c3b22e5724a0b44a6ac4118fa38a6e100fe9a1462c4d6332fbf975c010f1623e6b7f616c41a7ef97e6bcf25c8e708b4c9613777c3211dbfbc8eb57ede265a3dda16b2c99887cb84506829835290c635cd6f9fe57f4a307250a47f034d33266e3f9cf5de1f33f2c271101c71197bd9076ad30ccf0159615e45342196abb7996e96e0cf1ef30d87c3297e3d4f9de6cb85f23a12b37867da7a3a352c5082906561d8dbb73615b2b92d29b9a4698a02f4a111fa4e143277f1415db6d883fc3409dbe741cabd15d8628dfca59773d89505e13b611532c4aa80b1324aaf6db9e1cba79ca79a0a0ed30ea03da159d73ba9a392399dc0dd0049b7c56c895d25b69fe559fb25822f95adb6575661f3a06dc383e94df8fb209c53fe8ae5da6945f7bb5975e5ff67448cd92d4ae3769a64c038b4a8e7b41721058ff311283bebe40df50325e8201fc287a8f04311f05a6e210be3d1e97dd3db53e91b794e7fd4c581bca7e9f6c3cfdb4da6e099a0718b5ba845dad787cb39b4cd5eb3f75a438b1be28f0b6fb18dd355854fbad9a2503d0b93115e0c91be57e171bd8b8f90656154f01b53ba52b055d9e5d0382fa67d2c24e239adc66cad19470f423663075e85a3b95beb5d49aa1c8203c15874f2a59572a0a549707f079b70be5000b1bf9f635834b90eb536b4d3cea13bb0c2b2901a5f55e2d6efdf21e5ec2ce6dc25d62bb3d80e385db472497d8a632c4a21fa9a00c2f637b9a6f042a02898ad85bbab4d5961e4b54155f2e24982547b481d322ab2246b00ec2eb62a687470cac105ceec3ba55d594ec7f801d618e9b5f9d019a657516515fb7db903f96266f3e4c06ec2c2237e2c9d6f07c35886435de2ae25249898b5fcbbea023f7e6565617267f99d1429473c04c1750e00a982b5b77f44e3e4ff21f22b81ce30dd28ac5733f093b5f352a4d2f047d789b54867fa85953a598b90e061c2f860180263351e3c0b082fc8c869b5348d6e3fa6efd4d9520e101a2b2c6636af2895257301bd510903b407181920e4effdfc025b24ac600f3b61c893c2f7780386d1e678357a3f3d9dbef4dc2faefe3b3135b1ab0239be96bbdc92fa228d0638d410d96492c450d733c792e75572bbaa80d198092253c7434fc66f77fc2233bf5af86729324772c6f0942835cf5294ce25897ee81d3c05e32fa81e4624663585e08a5ee6284786c1b2cd48f0c0e9e99886ec277b7e68d5d7b994ffc1bc4353dc4632cca744ba19ed9c5bc9d890bea72d68cd864fd9d6cf2695f325c82f3d4379955894c468db52e376f3878345a558849f063491afd309c1985b22257cadaba5ee943fe7607e0b1cc75a324a9bffff48c34b1c20f9c02ebc4cc7ae9e6245c7ba36d8e3d6b33aed40a132d7987042e6d720645b4d056b1191175bdc8f6a436129e6eadd106035529db66dbe6763b56af35f7a6be39daceac00c087319f6a5da194cf23793acddd6ae88f5e72a66e720be64e89dd79a5ce1f5dc75d25dab29389adad524a5b3df34dc9fe562a4c77bc8452a6d51fea8b4c879c44306e7c362a6a77de3895c268efd49006956fd798663baef7d35b27d6999b8e112f76dc127deec171a5789464da65e291db33633b8fb3037ef102fb08a3be4ca318060ec61c2f33bea47db12a606160846d6a1121ed254a24da3a5fde593060a40d902edbc8dee9de7001763d69141f3ab6d64b02e4efff0c27d77bc28912c027c2dc8698ed9c9c4b88d805330dd16712ac7c9db5493a989a249ae1b84022c29110653293db6a423ba2ac135e51b8213ed60cb11a1a4f754db0dd0f034ea228adecf9fbf4cea5dc72079a622b4416b4dcf0d0557e9e67cf255c86da1c6b75242f3bf81b802f5eb9044f1b3052d09347f02d84eecc462479578a6625a44d9a6ae2630116647ea0279d554d72059e4050b6b0ddc73d8e81f727c277f91c767b7a9129957d79533281a75c17ccc1b7eeebaa26cca550d908714bd9f71cdd7e3a55a50322d23bff7125136e2d63897f33bad00c3d207565000aba9953e4f9ff238da40082fc49a5c5f2262c0eeecff6e969772ba8359d14782ae94ca9341627476a83c860993935e69d0a7df8c46eb4c93bdc54d10fb9d539afe593720ff396b2ca2e0c5bd83f0d2cd8a7f7ba7345e52e2c94ed826d0bdccd955136f0b1bac9d3ea85192b1321ba096dd04f2bec5f88fc0cd3b8f5b7cd188e65d05569cc5af183b0ae39e33b7adc31f9aa9075b451ef9057a65ab4b2b7e4c3a3e2efcc0f96d5e7f6e01d5fefc2b5afdb9a8480e57739a268656debd0c46f87d0159064fd86e76ceaed8e1721d1256385a8868273828dadc58b265f6f87b890880dff8a6c5b4388aa6639fa9dfcbb910db70ad7f471962b89892683f956f10e726fa3d490ec0e5d5f088018652128d7ff2de128a81064ff3d8543d5a6119d667044d881c55410bd89153bbfdb3d49566a7c532b071be7f6c29f00ea4d08addf9a7c6e1a3c7874b5197e904464c4ea6264798a0c6a816f94dae752c6d6b8aa9f2d9fd4ac57e6aa599907033c2997264d73639f5ac7d75d9bce5880d2df87204d3131645f35702d0cd677a7dba96a6170dc836152ef42273634bb7dc60aa0f0af8d0cd1f188353a33200824a5685ae44519a74f5b5c5e01bf37a19668dc16d12530585d9ddf3f0aad37ce7403189f4844a91aaba0acec065bae8489ab694dfd102eba6c7f32bfe25c472ccf1328c7fa2e3c5f7f2810bcff073d1ab59a5b7efd8d292fcab3fc73b6ac29363f6b3366828f6748d29e8387abc59d13c3af07f5e01da7aebd9085a893fa46c2d12685b47846137f53b2a63f4c613d19e86b63aa61d2b1ea750720f79c971992b521e8411b95d8e9a002ee74ec30daab993f530f76f106449f577580f6c7e6076a2cfc121a61f6592fdad2061ab4f0be33e02c9784e30215eeb6b6dae614d011cf6a594c895cefe9f336351d1dfc919b865842f9c89cd34f5a0d300ba0181c2998577a6dfee8a07ae10bc5676877db21552a3c363df025dcce02ae8c1fddce4bdbdffc1105b9affe081c94bb18a4643b134e3543c9091272a7cc2573530cd94eda79634175938359da0a60148aece06cb9adf4c7a59e07a22b5949c3664d517a12e1f2a2e6034b2453396947e5c49ce79ad99609197fb9112a5ce8137a83c0be1525a7ab42e7ef497467cecfd4d4ce31c719ad3317cae0b2f895b3b07f9556f3e2920e79ab8e924ef47179cc72086cdf51653142c33ffb492272f53b2d320ad73b977b302fcffbe57dbaf9f1cb78d6e78b82d27185d01309c5f9141c2be62cc79847d3a18d3a97e780eb47b883485cefe18781a516d52e2158feb37968e945d79dcdcea3b0fdac209c7b94751311b06a3adb7909a859b419f6985c9262fef754f9a2cfe9bf7c0a349d34751337931fb028a35abbbbdd8f5f20e6b822f8ca8244e5e5e3909a7c2afd9cdde990f8963f13a2c3afa0d902a48283c49d7d8de6a1332b21f76b83b029d41b912769cae51e9205f55aa8463d92622450e87dc7060df91865066640087ca02b054ebfe12cda6d760dcf43d6d8384c7e294baa8314c4a10cdadcb93ac1fc1cc78efd1b6a0f59d51bf5aa0275cc19733dd30b3384ad844f1054b177213144161fe88ea4e52c6f59e1e8b21cd77a9c838569f840a8bce769f8e6e733d0c20474508ffd6f5b2c8717b53bd91374db54c6a4151070cca2d6d91d4e2cd8c970d7825b3c93414a666a942e6901465bf39381208ef285834d565c835e916edb8803459ad3b61db570b0e6e2634a0f522132982c1a1bb386571f2af9261ad1e5e3d4c90c4f9c78495da69590f2269137ae6beb478320fcbf8dd18185389674648f0b90197503446d7ab87b920c28d5152c1b1d5e93d73f89feb002a82bb96d76859dad780785bd5de49db6cafc99f1e0ff89ea58dac7f98d29ca8d1d2edcbd63f09bc4b73a4bb72dac1f4ea058caf3d80b40a21860ba693fa075e56f927e5b189ba1ea56b1c81d1aa4378dcb32dce8436688f2a85361a1c95e0d7ddf27fe645534147651d0feb5ee93ac7b8d43a2656af14c24ed4879007355ac1db0131bacd2545b108e0347c3e3bb2412fb3ddc3383c542bb2db6807f54d8e022503bb6c5357922394a7913283aa78599dbc83c07b397ec85d8722181241770d2a02c23fbdca8873fe74039ac627d0eab18e7146f7ec3f5db12ccafbec5d53dca662f212a8a514ef8e2ceab5a06870fa6a20fb45c69126ff959a81b9770db0452905064d23651fe6880c93d12a10d0a7d923af873e205172bc81c4a19f5802ec1577080a7e8bebf6f271b50e95290e8628e6e1aa056316eb6c740b25eee265b6f87c9d2eae955a654e7382976c7d1356cc0a961c78e523ba68520ddea60e0f67b41c2dc82b7dfb6c9637d427b392222d4702c619f00d402e1c2432829d270dbe64b76fea0bde826eeaf1c9fde29146a2ef8324707eaf4cda1a5bc655159fc46c988032875ff198bdf27e3eb4eee758d0aed2e0218cbdf6899ff517229c12277fa0f0b39ebd2fadd3f1be499b10b2ef916e7d91dcbaf11675f9d75f9e2a44f1fd87ecc436dbe08df479e9cb8be2af28fe611a279ffaae84c979cc0f1315da9c33e0bfc5d072875eaba84e31f8d5ed2c608d6f7b7d504451b1ce539aa38b97fb9ed1ae553f32e66ce615bde6c8c9f4e45b149af62ca4eec957af83cb58e299ece8869b6fc9903119c6583c274f86983d825f125459c499c590e330ba0f1b4f96b6e4554275dec04144920ad2836a87e8c1861bc94c1c422fc05ad21919325154430e068767206247b3e3d40d1b470485c618e68acc5ab1edf86db37d24501d9f25af6529df0421fba8b78b4ac589a4700e7ba85e02092b60c00ccb343a99be7ec869e57ca7b409fac43f0164332b8d031427972365bcaa70049c5fecf250335494cb23781e282accabda651b310c06b7e71140ca5cac010d4487974febf3deb082c8dc42b528a843fc4963b3f863de8d30f7f2be74204c1543359e367ccd2641e1f85950a314e9c57e7f87b66576971349abb7ca1996cf5850f90cbae7d4927dd767433f71d459c693b8374856ba94b0c6e9306e099395efb60388eee7fd57be8b2b62a1d24fbd1416d8016a224ac2ff4f846cd10bcf60b11724497239d95b7cc4ecf730379ba4e91472a5b97fd8732ef5e14144be661c76ed4f01f9fe5eb361ce75aa568a35df3e50e08af896aae4d5fdae6c6134437a150d919024771346bad54a198b86e2828c19834be7714f7e6f68b3b98a4ef6003ee321cfe4e265bdead9d5e43607c02e4009dca03c7e48240f34d2e577482310fe6cfe9999698a9b42ec850903d283098110d2946a9b11eeb8e9ef1eb3247e4dba815a2f9ee6c469847cb5910b9755b5b74a73ccdd295aeee8ab1fec202957e44f515f97216ae852a811322db3e13b1a08eb2aa11ca71af4681755f49971720d0fbdcf2ab4e2caf2bf2f635e6858b115d8d22fd920ea60fddc90aeb708e138d3bdd3d26d06af7b2eff4f57bfb002e8c58e7b433caad2d1bdc79cbbfbf3a6a4e261ac6c270f93b645ce0d027de0b00f553e7b68b31f648e258c96655c9204221123f719b485b69e1e971348e9cf20a8fb7f3eda6758d54a8aa3e33e973d3a9635d2c164bb096e7e45d5d5e6103ca5d41bf0b0e46606306a10639fe8f191ecf74c686ed7df5df2554012ad045cb2e926fec485f1f4e01f9580f8cf326cebf6c2149cc97bdf8db89810580b6d730c779918770bea44d422a434c91026df28d312a32a301665672285d2cf3c008ad0c10daafb5f782f4f332acac0f9c2ccddf1ae3a3aaf9b20b2f1fb840ba0e02c6eb6b1b293c8521a3977afd14aef1f7ae0dc042c63ad7c16fa6d0afc6bcb7a641c11fabdbbacca1242b432c0ed145a3ba7c020f467bbb3b1c0e73ea1d5422ff9e1e280f15ce3cb4f7f74bed27f12c7b62de37ba8aa6cd2070c7ef0ceb39f0ba6bf9ee861f6240b8018edeb30caa2dddfcbddfef384e268688dbd2907a00ecdad0e719d52f5e408df8186c0eb595d8e901acb35a7632bfec80db6f2d6a55965737a5f20213a8d2e73c71767c2fec9630ec53cec07dc32f37c9803970c1caf396c5c76d82b5384f5eac63262f1ed4de66650181fe04488ea3f0818e10c5104e75584ef32305abe0a5e741340df6de4c6f42728600bfb04438dcc0f31a5da43923ef84149c5998d34d0cdacff6535aeb06b878b72ceb6c3f4eb90bb3c5cf271946ea11aa014097ba34ded5cbd8607c2b1b6e6e151f730b20bd84e67597366dea91e7701c888d543df0d7810fc99a4cd5fcda7c9e949432b47ce5ecfced5c63f4a199e7c4041624279d5819363f05075e5a7a862cbcebfb02a1865c22c6175f0244bd1df079beba204290b04b0c684b0aa1d598bb32b2ead8ebad4bb26941b65c2132b46454c7fc878e10efb3904b0a62bcd914302a1202ef52d04fa533382d8bb2a3b250211ebcff9fd7f257c43e49935327d530aa8501b174a9b7ee50a2244ce71f472710389a3ae480883ec982e00410d271e29d34fef127707e224194c34742a4a9db257b82dfa8c68c2858df2ffc3692f3338f895eb1dae1bb7db7e789a6a6241ee670553ef3d7322cc48035590bbdedaa44a3a8f0d1a836809a14ffef3ea986b0ae2a1692fa9daec1adaca12b1b6bed9d08c1b1f169b8b184b3d8254ec328db609d6f78f24f83e37f496655460cb493f6799e170836c9aaefa6f90628f7fcfaf490fbe473c8d505ea8f3c199a887b59c27a6d22e45aedaf7c88e73ce677a28171ce04d506a55d3108a46236a519681b1028799523d1ae1db288fbdf1860d2bb17f8e444adddedc867c696dba33d833a33463bb2a9ae92ebbeba9e542d0e00e2813bc60cb6c6686ec948b996f5cb00a86969198dae1b5c4a64385474dc3a4139ccf75de715f99989ec41d8063b8662d7988c0fa39e4c135a448b7887ff94756a2b9e8133463c6326f5e65f4b9f3ac542a924e69801cbff98aeb31a692eaebc0892ab34d6f603a68e8bbae72bc5cf554f80e55af614c6408c711e92cc3efa5a4cf076e20a7220fc312d607c8ef7f8354c05fb522b07cf280467c0196b40cfa34f1fdc0b55087ad735a2f4a82e5d7358c0f07a6d416c16fe35c4f50bb54186dbfa50b4d5276553dae1edaefd8464ca942e70d109d0f1ec6a7c215e29fbfdd508e0575fc865472168f67a3b2c5e887e2534d2f72394c75d86531a63dd3a43057d4c98e0543c1b43191746fcc1a9d653fa2228c55400226db3b91d99d1e70d43a20abea8445816d4bf07be348658f9b1695d046369d639becc8c0c45c7d3696b9bf1f1424d213b3d1f65db5f738f9bab8b8ef5d17eee020dcd2701518fab10ea20c08542aeb72d7ef65e3b22c20e11d12b78bbd167ae19dfa72bdc45daab033ff6ef8156cf91e00c49c7cecd7b6de7a565abda3ba86e493b91cdb594e099affef692fbae57d887c5b7ad9175b72b9f5725144e6c26dd5a6677d30e18773c5f0033123c03af9c78feabb89914e765d8876e3a93b5a56d0e6640c4a1b77f444211221de3124a7019a7ac92615a3574aec7dbe108a3a61260bac3542b5e58ab9db78ef071d2b74feae220f1d726f84e30e90cc5963ead7d3dd13ca8dc2410886c7f3f272d2cbf8ed5972c8e62004b4842e28f7843929af264290bbba65932e7c4d8d91266b9ec84b1f2fb4b9d5b70fe822df6e4f597853d3ece91b30325a1f7ed98a5ec406a7d11fcc62cb0e01d8208cff07ca146d18b0e8e7f1ec3c5ac0b25a885dd899e4aa61b82aa2426006fcc01b09d36b053811647ac0a2c69bd98bc6cf4dd19443d5ecb10f87e729859a09dbb4db718617428d3304cc704b50c2457df260670a49d7a397f7162e616fc745de212b483b5a126119a27b97cb0a94b4f8540b3fa543b9dac426e7cf25409127df66d9919e5771578b1bd38e19a3087655d981843f196af5cbfd8c757aa74f56763ffd3b1d3da0416edebccfea138bcd2efd27722fa431339905961a68544c6ef559724ab564d26b34950a2458191be49ad66718fd399aa80636ee98dddd5129e2a1f723e2d7bacd0ef61d7e6d9a49c06e550eaaf3dc2a2d576e8021e678e218a79c82fded544fb50be83337bb3af24ee7183b97b629000152a237df5f1f3c421d1d32b829dc5409de15ce6df504f2d3a1fcd740be39d7911fd2d730b1cbcde63c5aff42d77a84f28d47b93b8e5d3681aa6ed4871d3fc3ba9cab657df4b760fb85777f1244bb4ce761ef4514d6858a57a41bef06b696b36286be9e60ad7ff3c119f1ae1543300e875c156e94ce9238a3e05b70e6608fea0317371ab3774c307f5fbdf9d83be00a8954bba589cf4f005223e74cbaf3aefc6fd70c11796463f95ea54a74880fb702280480354c66c35a20773cad0c01b4fe972b6da432d7b99ef14cbcb043c464021e7d2d616ffb782f4a84622594bff83d3069f9458c0695bce28a2f3e5ad5003707a53639949e63ce5cb81af9718f975018dc5dc941891511020bc36f83d68de85a7c38d83ee9612f98216d58fd04ef2d33a8afb1e926941210bd802139478285490d85a89e5110439f75935fa37bda1c2420fcb7b7807056bcfca5d079504e1675ac1567ec311c51b1b1fe363255e47b992bb56f7360952d14ec82ee45fb6991ef1830fa91e1f72a6144217892aa0f444619e597c39d5c68eef3771211b5bd75a979033e8d6aa89108fdf1ea34d738ba54e6142fd87880d9c5b165a7c778fc6c6b6dc42f588e12145373f7767cf3b26d9898ed0d57d703b50e227dc7faea32cf7cd91f60c6ec2ebb643c6daa7dcab3971b81a55732fb8a121fe5ac192e7ab784f99805896854a1cb3a59aa82dfb12e610aed7a519a60f145cd83b0437e87d4964309a91ab2f027f497dbfb31d6f55ad8c5e2b6efea604f8638f2d926450aea1351fc8bacf07e4c123b5fbb47cee43284fd0ffa797b792a323ff8f4ee6d0c68fdd1c1cfc6d2ff677b9409c6595adccde47b2f1ae6b88cb36b88a3e4139d72781e47dbac42ca6262fab2e07c072ef5d311a2dc1586266970c70ef5cf850227f83473f352719cac6129b170ef8fe941c23a80a3264ead22d15e917c2b67adb17bdebf8a52f84226b9ee19e8efc90b6cd8910f14aaca4831b30ce1eb962bf519953893a8cdad6008f86c236fa6fa06b50395e38c3477fb487f132f5ffd30c1739d673bcdc83159dad262a7230c5e70cadd4b7ad2b0c353192d952a0a97e071ae6e49fa96dcd7849d5db8363e5ffb4fdbd61c7a307a285148f987c14f55a2bb5d4b2d5dff380c707c6a2126918da3267fbc7c4e93d451ca817947a96283d27af093a300f78858268acdd8f0b61aee06e450ecea6d9eeef4aa58f494abc2ec6dc414cc4ca311e5e266970de197b5c92c79e1abdf243d014b0cc23b7013bba92d4d70bb8cfbef10e0ff0efd8479c9a8ff14901d3bbb6e7437bc597ce93b54fb1625e266301cb3ccbc4f859e36afec1da915a18dad41b7a68d72c82376eb76aed6effead8f06a50dd1bfb60c5ec7ba4f4cc5016ac9d35fe54e9a5d1b0e973212a942ac7350e249877091d1da102bc4fcc1e8d18ccd26ffb94a1c72c717969c7cbac14c13dddbfceefef6eea8144413d5745f31352045ec77e3eabee4f3e5140a3ee6a885b6f67f7192cffd14371890c7278e1089e64df9d65195e4429b43179e99571fb6e35f9c805b451d9cf6d72c6fe14eba0d6cf7ca8ec6584def81bc64b75ad3350c6b68b4ae153067b7834821293138d4668417f8c172ec28b3a2ec55677ca24fe8e9dc837392f4d0146481361e3f756737296e8e6f2d21ac078cc41f07a345d61405cd2d4904f825e66dc233c54ebade52e0e7cea8e0064091b665e7dc59f70f2839ef779d88d93e9e5157788f73505eadcae0eec42050a4374d4974997ceb1ca3e5701ccee78e3da28563b50f3ca68a33bb0c0cbba5e3e5e29487cfb0d862e5feb1b32ffb32566db2dfcb549357c838ca9f4f31be525cc2d66ac44fdcdbbeb3feb6324781e96afa6f4230d720e6cbb9ec47372d80a322df09c420efb14ba2649cd52c858201cd7c2d4e3f5a91ade097129b7f03cbd4b47d4322d329a2b2df1c1ed88d29d3c9b33aa406c26e09191e7e06021e3f54ba8c2b6efe21071ee21e0cd6553dbdc1b831aa172a7b8aa44a84f0a3b94e8b48ecbeb395ab959f2d8b9e2be6898e041527aaed76775b8caab213e718d099f35ede0493248fb2730948c75765fe2e7e94a495d005a9162fd083bbd5ebb4f217fbe776b1e5b5234dd567b3a91e71a77328d335ee5dbc30d41d485885935112693dea172f3d538bd3b77f18e225aefe1acfb963e595ef9dae2ae7d958e13c69c6dc8bd18eaed0dd3313e47dbfa2d782614e8a46e9f1234ebdb12b5e16dfa03472ae36009dacbfcd572c2c55d423ef800f24010dc91be6aa34de771719acf923207b1005f883e014da128fe7a8fa6866fc98ac9a3a5e1848e606a42fb19045c46fb7d02777bc1a7db0236ffb9f12d9ddaba7a6d31834f9373b25cfe2ce3872c037e78259f14edcefc0cfe9a2a43cc1a89c8a8ca3303bbf3baef085d8d7efe2794849b79a3438d60f2467bdd2b1374f43a73b57a0ddad7452cacdaf177947407e3da29c84a3b1f17c6616d1924eb951cb88a3786810deab27c43fa21b336d419b6a81424e54e7bb306a33f05154684bf0edc7ae0009a859de46d149869d4d80c1c2f61f31de5730c4ceb9f4a162132c6d4d78b65a94f4dbd096cb13de72bd4705d26b49718c33a2a4990d2fa487d54aa49e69e785779abc7532096be8ea841618cd557d7a18c536991236a708b50cf854bd8c1e972816171fbe3d5d9618724c89cebf0d98cc429c7b019e913821e0bc32beef7abe31fa4f83cc25417d14e5b1818932b4b1fe1b82f1dd3af91862e05112a9edc5ab072ec31d105e27bb84bb7bffcd77674cce79e5006fd72be040d1bf531e62a109f65dabc709351d131b2fc2449c66477a6d7b281c3795dd7732c9589190cd86a787e7ba6c0b6c22bcf0e35d37e627e0c6c679db3cf228e99469b910b6cbc6cd0524e3758de2ef87d7621c0d156de0b4d34ae76983a0725028cd497220ff47dfaf552f9e98c9f56d88017c7c717077f4c59be225fdbc29c298bb011dd4e72f94a56c6bb38e78117b19736a3c51bd89dca5fe7e82bb59cb4ddde4e5bf72f613c6c5cbbb55132b08ca430ce80b965e7bee3de251715fe315547b861ab9e4f0a24c81c8f6c6b9769985bf9ba4ba239a0df033cd4cf5e43daaec77460371ccd9f1b49b23eb38d6153ef041efce7c0b76c84447c6ac9fbdf558732ae9e540e2062329dd2ce27ff1bc16de31a307d6dc42674609eef8d2000ad422faa0fe2d4304dfb127603f7e18a06f602a655f35d4fa7a9f8cb60565c72172de1649e49cde58ddcb4215b34722c678d4891c3913aa9fac0304cc6e7820d9ce333b360fc7c40b7ce07c255161aec471547036d9309b916e97a4bb06c03646759f31fc007da5cc033ae63b940b57045a058ccc6672c95bbc84cbc6c05db8ed9bcf1906b39bb9b582b6d5428e944d6046227fd55d6c17362834a78337c4f3fb13f3eee8136c3f7fe597390d31eae973214d0eda64748732ae258cb9b762751cef446be345f3bfb1d736b152cd5398c0b2b87084cf1614d388cb58d193506b77e141e9d0e5551dcf998cfb6ce767461319004daac461096c6c228d518b7de6318a6916f8789e2a2192031483ca4ad1931753195c125e568c854ea8e38e590d6a7f3ce1a0ec1860fefd27e9526eb821051413be26c3d55fe8fc7b0cce2fa348cba62d7783bc2e1ce406459ea83cd6446bbcc5f36f50e744601dd11e43ec8838643dfba25862cc46d0ffd6a08824627fde8ce6baab6e1b7acd50534842f1cc0973a47147db5886add600abd7f9597d734e5c002606c16cf938d65810b932333ed81ca826f448f516bfed0bd71b5cb0d12f2747e31e67f499c368d4e6f25febe0ca36f2a2f1100157b38b43b64ed731cc2de1f6bfe8e3d007bd5bf6e278a8b1dc5fe153ab5ef6fcc930b6ee29fc1fd9367211e5a7635abc6f711e2463c3c699ad85701cb39c3414d3189f27449495a8ba01ba22225cbf47f2020a0d82b30f32652505b1774d5ecdbb8551e3174bba2b220068ce770227b8f0e01a81ed009da9198c8241593d3e4622324dd96f12747a18bfc25b108aa0ca010e6683acaed8eda3e7d26ad98bb7c689c9f8f0f1ee9281e6b7a3f5e2c7ec326ae00f2f9f374ab5debc6aa372b440d3bba0ab2ea12ada7092271e5e7fbda49dedcc02694aed7c91260b3f0ea03b497b86c983352ce933a5a85dae7b1fb38426ec489121906626ecc5a0db7d78bf0a73438471d1f3344b635fac25ef870e105e5c5369c3891daad03b1b846b3b7ae7fe1527af51cd1f7dc26161263bcff1b65b10e29c065048a214b09ac4133cd815e62d01b08a2520cd300a343ae50e1bf0f5847095209d8ce622b6080f9d3f0ec17eb48ad8fdfc718305ca6d8ccd75e509370c5f7630c045ce7c12ed4495bb69b7f390c5ddfcb945c62bc47e94f0c369a470ee58c88062a7cba4feb9ee30a809da271362134f7e97c1bbab0568839284dc7d57faaa73091ea4867639c548dbf803dce1cee803a99cf1df7106c9a610e6805dfca0ed6d9d08f8b3daa621a6cd81f5a82ec1abe60e91f3a1cb1c438d9b58fafcc461b5dbce29ceafaaa1bd6ffa3a126276625eb4ef2ede8f0cdec9612fb9bc3c31e23443fc26e1d010d3041d2e609883a739ba8f81ec0543e00510fd1defc00e42da1452898be3afac43b499adfb946be5e375c4bae86b03e144656776315798d9fa1af392a0810ce84b07bde25b406a6f822939383bc48feba05700f5dbab990dd92a0a1eeeeb7dcae92cbe054646b77678eae1123355547cbf94f4e5f5eb65917b74ff28075acd264565722885cd25b27cf64faf8f11d286a1667151fb2c3f89d379b11b8d84fb88d06b2e7f9ef76e3648931ab31b10720077efbb2c20eab716fa687e2d056f71e261e8be1ce45c36dac2d832965eb02897a87e1ce052f10ccd4b4f99491f47604201873a472a95efb65f0ad121a4df08527f134b47f3e93a4a6db101d4837a0eb52a4ff6e0adb596c23bb83326f60b45ce438d2b694c0eff332f607dba6bd170fe47aa9396b64a1e95411900e3da65ecac6427341c0b4d7aa3492a012c53a8354f0ac965e473ce9fbd8477479d1b84911e2cf3f0fdf1830f79e03ab05d8019ddad9a04594554d86cbe30560f67a13bb860be2d99355377626e4aa5b075517168ca597145d85717a8e70a65b013cc44e18dfbd4cf9526f9bec55419053195e3c83499137256e7bf899e847bf30c362d010dcff32ae7375324b29a0ab2b766cce1c553aa73736b26723b52368069c3c66c73d3786461f53c766a499819314daca5faf305ca85ae8d75ec0ea48a229d9c615ec67fcb9ba9c2aec7c70a3d06db381bb1b7357caa2121d5191cdf372d49ec879d8c9593bdd79cfecfbd9ad0a8a6883f49ad5094c83a8d39c32d2ab067e4bfb629c0ccd65be05868131bd981936a0b4196c988afc55acf98903cd6c2b7c70b7ec66af495177080616cce53564d326cda8ba98bae97a790dcc6a0300299c0c3badda3957c39a9276f8112add6b4a4403ce500caee58b8e44080f88106973b88bbc34cefdb33be62d77cbf67a4602f4862409a0f4b86466e4621e988cafc272809ca48869f5eb9e67627b580e54e327fa9faeec0363c7cc35395d7cd11488b53cf8585ae72505b5df5c355e3ce61fa0cb08f4bb7d7fcfca1b3abf6b3b0954610123a3ddabc6945c70f263576d6ee5733a7dad5260baaa04aa039c0440ee072c7eddbea9ac4085f0d9f8b51fd5889e22c2b00943fc3cc01398ba4ab28fbede69f7796d612d9181b8db020e4688cbec480d03cb64f0d9d1008a0be50002ecf221b6660b1feb94e62623624e1421b9f5d8daabe642084a9026602ef46f6df9683d769f67acc190e479a469c2f5c3c82d9f901810cf0ad8c9bdc14868b0840d57b50d80a8ad66ac57d04410e0d5bc8383ff6b36d488a8b7cbebc64cf24949a71ddb0ee9b25b0cab5e5e130ada91f6e00d17d28bd9f4c1582f355fad27497504262a14a231542b60d70c902aad69045d24e8613f3ace52a24e205f9768b2329bd53898afacc2497852db6962ee30056ffa120b36866c3e661435f6dd4f07044c6f1e6e18d6ce7f6dcb46f91b4a23ffeee8ae347ae85415749265fcacc101b3f94c5fda228b442e50f2577cf53248eb5af8d1fa10106b104e3f38aebfb2372e6655b9a61c24dcd75f3a00b9146c8e53d9a94e6856c975d6db97d30ec0e18d01b31600eebe288d2c37ac1934746623ffa793b1d88ed9a2ef52563cc43c543eb921000f5fd5ced74ff771676847980636757e3457f5e7a6f037e62667036c4b6864aa1fbd4744fcede92f5bbdc9662518238b24357443b45976517c824797686af3942dcb94f4934f17e9ebed86c8e57ca876987ab9ebad44f46b4e9783b51160f9a7779e41469311a456dd192686ff0b0bce4500570726d9bdbf168790976a1525e50edbe3e985585843b0dc8b029818fecfa94608349e989448c7cbdd12269a14f210811e62960d18ddfc425a3c501bf3ab9330ba57dc98fc3f2c725e044a684dccd8a0a9b8cd2a0d8f85de56e874cd37e9a2c3d993f3fc147f58ec9cb80cdd991f7d1cce7e53d10ac6a09bdad20582d31acb710b12522648fd8fe89e3485d4af889472d1af1fab59fd721ba2db65cfcca2f4aad5c52f18be5ce7109fbc1db5043f6630adba8de0573b81686530b5dec7280512428d9873c299b69f853e9077344ca885b5732c698d85e795edd67bdf8d05f64e35c5f07bb360a0ea08f0e09db7a7f3a1384c8db04b307401944139729a9d95916902245d760072025e801ef28621c34d8627223c130735d02e74eee949ae98a08316a17b15667b609591727eabed75072ce5011b278fa49e1d83a8ba2a8e7c35d2d0e7639b1da7b37a1c32515f3424ccb6cf75a2ee5ddaa231d4123149409fa1c028e11db831671b2458ff205366773d838a0eb55f97215298db1810869ed2ecbd240e55ae9e6b6d782d94110385d3ca625f841550f55bd3780c7138ce629d962c9b2ec11b1b081c4a460135f55c4bb3ba3d07720a3c558978f423515dcb67a29ac15b20ad74d72a20ecabd10c219792a978a9262242211ef86a6fb25139341db2cb514e602a34f92cd662c1d852569cb9ce5c20cd2d84f1f8c89bfd3244330ce3b98ee454624f174fcc421165a7eecfbb58b4c0357e1a3c8c57b63b2d6ca85868de2c04cc939e47ea12aaec96cf0dfd7f5d2441c3717e98d9a021d5ad5b9a07e36d829fe50bb9a864cd48d5ab4d71a55574667681fe29a0f7e9537bb02e532355da5e4d9359b1ed559f53852f4f26660ce3df787933b14e44eb849e31022c6d66c72b26e0014fccdb063649116ec91a5374655f271b721a1a3e26c9f79f7daacedaac9c5e61e4d160538c7ebac84626d418980c8d7154ae9b559396501d43c9403c9aadc9e67921c6ea47f92e10c9d7db0da6e1166b88eee83047a86d8e471bb62708aa8dc5c3be85dc52e24f189f444c9943429de3d7ae8b7bc3c468e508bb00dd1cb1cf3cfa98c1c0c6033300f2da229e4b276ea85ada512bd128c153f334bfb516edf6744dd7f2acd1225a40e8df3d466f50cd96d36d1768d7728886e5ad382a5dad387e453e61cde239c8db0972cc8ee655dca55fd08a679e1abc1b65c9b64fbc128d0618ec11c7978fa74bddbab5f0458fc0c55775abbaf42a88f168f2b7f664580f1c8702a9555dc65364ce6568b5f86316340c33fdbf40dab75e41d3cf2d9dc9338ce552d1ec546a51f412bd58e6e6143d78c18e9ed4e576924cb2791b4dc0fd1258b4cdd00114b5d82670d99cbfa26443e0a20ab46312f49607653d283cba6a5ad69b3d42586658c7f7e13ed7b9e3841ccee66e91b3c9e56b09cd07fd9738fdf3ccb9eb7d2b419c048efbc58f490db6b48048603fad61db2adeea1934ea6b198f2c8570066852117bd10d27b9750be0b76f0e81badef6f1ff662bc84314ff05eff8b0ae4ab0e143b1568d0a251fa4e2729676bb8bc55621c4a93a706937c5a304efedc1360a281bdf6286c5edf749652bc2666966fbda6659ea808d1ceb5b2a2ea42be5c5d2b9647f70a2ca9b92ae8c16f1d6ffa4f9aaf870fb080af0db4b6596b77021930d9405aa3d1dca09098edd98541fd4803b7715ad3d3e83488c71c3e3aff5242483074354cf2ff023b1ff37c6a05ade505aca3973ee7ab9125e7848b3a466bdf6fdb76795dbde3aadf34cb4ea97b00d9169955280d0a1a9c2492984315c402812ccbe5fa07ed4164686452d11b2705fea50fe0e5c2db1d9bd95fd68eb640fbae2ada5ce1aae95c97ea2cc6794b697d72d3d86b23edce916944b2710a624987663e55db2146bd2b29bdb3cf3ac2160414c721ef42732941bc588c21bcbe12b9e96858d1c7a16e350a8d9d47a2b145398f08e361993c269b53019c0d67553929d15fae1495090ef1f80dbeb0c963bcf0cf40d209e91896f666eb8b8f4cb3fd2ccd4798f4bdf5d298c694685d056c9d419460b92a6ce42ccc931d793fb91839ff116c03bb5789368471e6279fa61855126b93c38235cc85b12f661770b121ccc88623dabddd96ad2fbddcd8469d0383e3b79f81a347cfe9822677332094cbb6098996c939ebf1174482eeee550de1dcdf313ded50eb7762b2909932e08f64f9f86f6885787965bd931a899c856c84912de3ef437de61babb7c3b8b17afc8ff0d55c8bfd963a320f41a4f4e73ec70df19d56504ad76139ca9f70cb37651095e53c7a4d9794130e46dabf78763fbe82c536c8db9ab31dbca173000630c13897808fd07a57353e0b67f053bae94db64373940d8841c6e8eb3d86438d9602c47a439c567b201569c8707f35128f4209f1176642705cef7f47837392e205bb765460912e7e44ea53483dd7965b7800def62b6268da9869acf566b628ea1063294833058a9217174af8977ad2879cb7f1133a6af51431793498be0efd0d97d35af5b4d89addf43e9cf7e7b4b761d4b0deea36a1f22c13098ea1350f6c061efca07a77e76009a2330bb5b3655d6fca7c4881146c6963412c59758e0a0b5a2a655d08737ca1cf56d3d569f61b58288bec775f431015bd3094a796aaf3e4ed2f0d4bbc0d37b96bdb6c8504334a82d2fd476fd90955b666626b0591c0652f99683a1db101867dd4a3c7a14014a37a54134ba40e3626ec0c1ba72efcf5cf68165b9c1e825c52637ef1530471fd0f6b4e6dc2631563e267f14ed6b8c605a4b3ac52a9c2a20865c7d159319c46e3be97a5ceb3e4852fd1d28223c711a330b191315784089b54dfc4774436a7ea4d86d99e0b654928b86e5970c5ac85da0458fa7c30524b338ec9a8aaf12238620e132b5f374d20b896d2e3b75c534e41a5f207af1e6131698f2c1dfba83d066893a3b7625874e446a7a10c8f17e42a1f3c9bc34cb19d9aaab9dea03444f72d049a38a11af810e53844c12a1c3794d3a1c628c435b52a0838ac2ab2a8d556ccf0d0ef176566ee85f98bc642e4073c396c37027b289b772d6614b8201ade1ece48c89027fce6b3cf21dd93ca7bb5cef462fa5e66dd3c8ec23647913adeba5d29d869b0967163a65f8fcc80deb01763ffca826565a7e4cf2a8e620fd3d6b3e6485069b2901c498a8b785a7a342d8ca930ae43af4decef750a5e0c7d0ed074016a630e3f243318d23dfe0ab89003b3047cbc472018e19ecb5ce4e486c3e85816cdbb221b9b66e75a0176283addf0684b893f4c031267cc8adc890b97074cbd507dd847a46ffb6de5d34b954b2f0ebf231b303a80c1147959db964c8b953a197df9e90812524f18be52c0699dd6576828b25944a6f4cdf66466d061d1a41bdc34deb2130c45502dd50b3ab98be7b8bc83059b5812285741a0a3301b08b45ed8eabfb00c7d013896be782d25500d7b738e2c4c1aa380637aff687644da38cf2f9853e73473e544b2c1e8f6654b881e364074ff47b6b9f86515809c48df391d32a10b2c8c9323c00e150b4f78b8518fd1ad6f8519ac15656b96323ca9bd27d9b6aa7f0f5612f3a76c8a8d9c458d56c6d54cec8ae21cb01a250d79b96246526df0b1de41339c0e358072fc12aeaf951ea670983717d1cf8c364c818c234d953db15bce4b49b9051454a86b4ff0456229f0e8efe910916e37a0067abfed1c4d27aba842eb0ef2985b499ec08db9ae0157884ca46f5024001cbd97dd9d95b347289ac84e14417fdaf3cec7f87bd750d7c64f7281012f84d7f008114122def267dec780ef9e3dcfbfdd3f3f3adc2a136cb270c7092f7400c329d301fae760fb6ccf5fea4038fd3bf6e9c7ba0eb87675b261956ccc9b169be39c202e365cd83cfb63924ea2307dd3e443d126bf14fd31220d5eb18723e2a750fb1e18f4e315f57dac8c10a6c6a0f1edaeb5a46074979370faabaaaf096fa3dc9c78cb8392082a7732541118efe8f890b45f1a1838ffa59bf6fe3c2c22cc44fd5b7a3c63380d739fefc40a1eb08ce450b56415297f1951c14d0daba7d96f3640705dbb9767e85f25d88a933ea64797d985de61d7862a9532ecf3b1dc34954038ba4594a478238cab96609792bbe0001f2d85d15e8a67ea9031c1f5c1db7e280e8de0958dc0abf2fdff2adacfeeb8f377947b188eb8ae992a57b3145e7c9a8bb1c2d5b6b6fcd6598efda0cae1188b30e091541aedb503948eac632064abacf6107029e3b9ad27ab07b2e97bdc92595e02adb07fd6b4ad405f63bb5db73686a8af1d75f2ef9a1a18dd755bb544ad2581251a8a754a584ccc5c9f81e195641c7b628301b6aecab0dcab4b537809060f5640a38d60e2778a4ef81accea0b51ba921bbfe71bd5b6be3463cab80d6ab77caccb7dc79b8f8583bdb2a39137fccc001c68bca8a3af054c79ed91b40406cb5a565e6f7a2273bb88ce9cfab50fd7ac80b4263f206b7fea8707005106c4f7e0bfadc61a0e4721761216506e6bbc3e16b276f204c6725555c81a87c7fdf075bda05bae114633f7682ae9ce33fd84cd8d86a2c8e896f0f845c02364086b870e575178fd77c57baf6e2dc4fb0cec07f6c9f12359cf87af603342426721be96ac9f9c79b82b24188023da21ec835787b530d33aaefb55e3ea649a529a3e266cf7c1fb5717bce656c1ed18f4b0ae0e8a4c6030cdb575fabf04ba17e8f2f067380efff5eccdca13e2364aea234711130897029c45daf0a6aef409803d452388a4cd69cb93e0a6243201581412d6f510cfd415aea453e4c0cbf5637ca82796001cd4d0f937755ebebe527d5f100c7f2dd8f5f995892f45a3d9a9cfab06d6b23f6c326a1a98817eddd9cfc7f9aacfc760d3660b3b0fdc15797444f35c7475881e6619da54a770832a0042f0039c22d093bf25e4ad721053793e14c37565c4bf84ff9691697452999505055ec7e6250fe2d67fac859d3009aa62e6eb17475a1cf196e672004b40eacbfc6eb9c35871a54b7cfc6cc4bd8468b8b7384efc386b656fa160d96b691bef00716312254e1ee98ba7095187a7fcfe37d9260036af9e6921681c8197b67c91d53d264b7dd937af4395623310da83f7804a2868d7a47c2fc7ba14a7f2ef9145517e52d10ffadf67852cfe056620a02548f213d18a70e304d0f15bb785bbb3a53e269a456cff9b2c3aefe2ff2a8a3b6b65a29d38816bd520c6ce5bc3e08735f9b0591dd63f7cbdfdaf481c96de7271f99156f595752977c045e9f11f315edb472faac40c99a8746f8514c6d6edf30f71f51cc1fdd6c7fae4c14e87ff1ef57294b1a6b9fe6de3dc6bceada5970951cd1b458b281770b93917b7c3a95ed80140cf33114051f4d6c7528af73313f2ae18161b9c181e2751ea372bce0956fe47cf8d610078b3e9134d349da4c2c745a3761d59a5563d75a97b851be3e3fedc8776efbe5a8ec7ab1ec19436cfd5f7b1dc00891f51c7e61037741ceb8fc8ab26661dad161698f0272f09c59016b59fd6a2d6c718fe481efc46d05d51e70920b100a93fd3bf25138df06f3e850e3fda0a832ab6ffc8b0ad2c10b19dc0485f96e8a75b2193ea3826d83885b1a023d207e087c44fd36cff891be17765179a1ba03104cd08983a38fdf64ee7dcb2f4d566e0cc08c5e2c9d4023af1996a75f728696c038465970b2a6d8bf1b2a301376fa12c5b317adc355835ff796725e4858b459f7f3b1e0c17d78a71a6a49d2d72ca62d3482e575286e104a13b86ea2553012d1fb44eb5047ef1256fe58e9e49fb9c6dfea02c1f526e77c6d00ef2e93993bfa9c82ff11f6451dce992214450e80239a3ac0a701230943bd1c24d74d38c4277d81f4af1c454ae3dd7c73f680c7a73b6f25d15a4f40287c23491d10016fc8a08f64393d9298958889c01fcef8b155b6d096b69baee0ba418aaa22884bdd05c8935ab72b23136d26930b9a30136e9c0b188fc608074ea52a50257abaa488dc2141963f303e4e3070d60d822e82546a9d2fa97bc852958cd786f1ad9839b1316692e9b041be9ad3d89e1ed8622c18f7ed4f45914db4ec9aef4c14073f1aa6907b0920f43cdfdecc2e8e6a7d3cf8e8f08ff796d2be2136cc26018423d930e382e0905da3046bd8b7fa54abdb6a526ab1b74c464d807bb69c4325f6280fe389cf73bdfe71bdfb165448bc6ccd4404165449c9d993e9249b9dab48146da8e5734e9506f9e67ecae78ba58cd795860f936626569cd4cd4d2c34818119f16d28cca421881b03e18c3a9a389acb4111c8599ccb81d83c476e57b07f024aeb063fe0f9eddb4e765251b76c9c7e579e394e104fc85a0ebf2c0e8f273a7c0394948bebe4e00f499ea8d1e341f46ea318252ec91e43b8c048cd04b51736ffaceb8bd886d4f1ca33d445dd0a3fa16ebdb8713f19c3d803b455e025ff4745da47322fce6aa02f6921ea7659da5e3c1b713f8ce797518ad81e058ee29ac861619ec3c11409517d7cb1deddcf5c9ec291a5326b26ea5bf2609e81a42f688c325486844c57ae0575e1411a3b55e959cb505956dc9f938f06f5a0bb48fe5560cfebc6afb08f38004707ba264b9ca9908d53ce95137f8e678edcf8c38c4b7402854a5665b9970fb716b3a6b1606706ade80d28b7869d4de19dd0d7f91b0fa7b1113dd254465d1fd83e5d0f007687107ec659308dbdb40263f2f8f8d7ad9c5e5e2a223a4c999daa5afc84c321455b0f4dd1c60055cf9e08c91b34b70d4bcf67bc26ff4bbdaaf08ea36c24ee2d2fc96098cf80af336cc1ef14091744d7b6921fa9dafc13760ef11f7b2d3c812b3385cf20cabe1db8daffbe279e31620eb2c8fb7a202527bfea6d6571c1ef63bfa8fbd1b3a5696904c223fbc61618f2f470974b503c775dcd56c48ea11030213852be4fab27bb1e505842ceb9636d89ff81305517b62e0feb7f1bf265b57056480f0d9150984cf75e683139b9395b65593c1a70ad2e26da7876dcd98245312057e1b9ce84eac7ed060aa0928170c6a5b5c488acfc3ed24ec61257f9540b33016bd491269069606d0d303e7db67c7877753a9cfc4255bcd9360b2019d3c8071591adb35e153c8460eb60e538a04f23c9850f8074c4b2b8a4c6c7825ec226d6a4bc2391d30e9403995817cf75f1d256fec83fd8f662ddd5b12446777e85e75a28b40514093b065ffe2a08390814e81e33b33d1161fa948ebb76eaa047ff90aca69caa878cdaadfd7e921da14f155f75ab7db7bb49b1094affd91a49d47289f6adf4bc8f8add8a15e8753bfb04780eb0041b1d905105d284fa4b662372cf428f95d7694a8fc08bd49f7ab6e5128a5449d1ac0b0410ac3ae9efa7a33f5f37aa7e8162f5d5907ba3eb87c343fa4740d78a8750d4b6a465608cdc14c0bc6f54defbef3f924e2f4dd859acb6c5e71deff740ed059b7ed5cfa8623973839a94bd17892966f552bac18434d73199017d86fcfdb8b6b50db22e3ff8c8b2be8cb96f934dbfe8e8a93630e8d5bbe0124410613e45fa10cd4c121a452b6a2a1b34fb0e8ee41b42f05d76de7b2b1d55883378aa34d0bfb1747e807d57774eccca9b28d33ec75c378e1836913800c2f85fde7b2f7fdb7dab3ef65589725ca41ab90cd3f581d8c3308ca098becc1f1c2ac9c6cf819e6564884429ada88876bc384290c1afac5befc37792c6fbd759c6aff29df610bb1d1ffe97576f096fb3c08dbd59b29de65da9a9bb538191d73c18eff6fb7d9b587fd15524af2bcc770374158cf6781292af232eac06a86babdf3c3a299f90cd3a6af175f1da625012f3c06c0f1499c8fcc5f107fac35aaae24bff17a6af98af3a32926c7023b09e2c05888a8cbbd4358437a097ffe165974baa76ae355d6143eb7d9ee912e0740cbe50ac26ec7b5be0bbc782ba73c25add4d32d488f73637dac599c6ca11524ce8540352dd779bc08e946c93d35a390addb0aca2fc2c1a058a2bd9623c71f0e6b3c3092aaee29a771d3b42373492a62758a13c0356c40b320ab1dcf520fd680a22365e53c5682b54b3bdf967faf6d7d9098a61664aeaad176ba88c1248e95dcb306165b4cd1eafb71cc818a98099b93a7b2a41e84d746b7fc52a00fca6cd59c0b978d73e6decf8f2cae4243e4c74c5006cd3df13147693d5152cbd878034a2ded5480e287a4f6c10e66dbfcb64e72471a16cc3e05b4f9c3c3393f07ef02fbaa44a91ccd11e4482189a378214c7a4f02a9385163a8be968a2cbcaf530a05c25be16e0e7ae1ad157c49a29c1ea6c4fc8fdab3e441b6442ff7e5efe6d1c1445bcd7960c87d30f2871895d2caceeb9871f3c3c950e5c4b0703e94380decc9f161ba3fd23419e65a94ce6b003ac9a857659c5a805f1ed19eae8a7ec9cf48696d784325db8909b9128b1e32832afd7b958511c95c7b5e96c269209d4afca454ea2bf617494d949e52d27fca456697b8b275d7ef3c8c7d514e3396504e6f188555ee1b42d94cbd10a1074ebac8099219515714a3653971422fbbc0546d1b97e72378546990ea6d38c6b6c17b02abd634f45a246b04928d937a2dc79006f1441bc82bf19c3c956c67e1e063c4f76bdb81b474aebbcdf094307cdd1477ddecb9681ee65336736a223f3c097f9daff14e63854f7e818a3b76bb48087939fd62a91a0af548226c9dbced972c8eefb320118b9187b230d749eb0840731d2381b0c5ff55ef9e317755a8ecd85ab6e9795db8c4a80e7a1cfee1dd5cea27825d0724cfd24bd2f915968fc5b94dafc0811aad11ee03f77648c701017539ab295ea49ceaca663e8c7105fa8f4161ef867c59d98ae2091144a08ca8a5199febbf027ca166c28324a2e704c779e347ae57243d601e62f5a96798b3f2fbd5b6276c4780e092bdb4c2ce5dacbf47fec50a9977bd8b14c91644813d38efcfb3f56fe9bf3df18d0a22b8e2f0d8c4f31ee92cb790969da50a200e670cb5417f4de61e3ed1946e4f4921dab4694d12b157be3277a62101150bd111328beffb420a6b481d432b772ac5a97b231d508feb0528af23033a621ee58a2945d09c6c52a0a758ceb40fa39083213b9738813b55b50d4d4f6a129b44d42ecd83679bdf52da82d3eadb5b4f0f5c81dcb06f42c7019b4b2ff3449f2cd4293c16e25840317b5fe7e74c61be74c318303f78a5258e779c9cf9874607897cda482a49a13d80fd8ac4108d8c0fa460f07d4b251c784d016fa56987f40247911c70a2277c1c4c6179bb64d1614cc0b5b40b40fdce31f131cbee2101ad40203f8cab9f206cb5523968eaa23a8283b2a9fa4d49437bfca8499c6f64f00b696c31b24ebf658904271e8e97790d452eb730ae591ec95eec278216722217a9d1a11fd3a4d647499704d4184cc7de0eac4e068003a6d4a75025d76fe2f34af60a6bc310f62891eab25d4ba2f7bcfdf3d2be28605ec9d84c7c15ee649054ab91c3c77132b9c01e76bbacf25374c7ab0eaa0e24e29b350495ad9b71711cc197fd71aa028b951269af37f55c3d91715d929081609d4ab44da57e43943b40ed39d8e86de7c173ac9cc933813f81549436fe213301333cc3842db02929a1f4ec672fb6b28a5ea953fbfab9133e736eaebe8d3931f7be3e7be456339c664d4ceb55852d7604e3436785a9cf6812de8f809e8ffba155cf0e335dac37e6b68c4a2c0d9f4a0b0fb0716266ad914f7305acb9e04df0c78b49f3873e99c6eb8b98ce541ad3608d0d699311485ec35e72d85596daf8729424e15de254a8f595086f9bd254e33196fc2e63e2165fcf2ce8206ef20c2757c91bd64540e5288a268755cfbb81a0831fd9ee078af01ee1545aea5b28c1dbe635906271cf17fb9f9e7fa39f194a2d45e6d47c6c6ca217ac1831ce34be1af9f604319c5968346b70cb8e8b5c667e31e90375cbf469e298e3720dd18bed3cfdd9544fa370773a0232e44c81d0c1db6e39c7ee8891d65e01a0ad2a06ed5b818cdacbcfc8a8f14987747e0b2948657331806d95b703c24042370e1091f98c92462723e047825006d41b837567ee177d11c58fb8a9da8e83bd758d16f965b0fcdad3da634fa35abb476f2e37d06320986965054a27a6888ec1337f18d76ed85cc2f6bc4f6bd541557feace977bb3d1e18acdcc17ceb22e2b97504ec4476d582a2420b3fb00a3a2dc0746e05ad155931d5d665305fa99d27a8f4456a0a0940dd7291235f6ce71a5ba211a617708c3ad327c5a915b97ba6157529f2a407478c598f850082f654cdd2a4323ddc6db0cd67569d1a2a4ecd68dc82990e114cbd25d103b6bd17ba4b65dfa23ff6403ad8a1d5162316cca5eb1cf580736388c044fcd714f546655c92f04ac924e16bd38cf903de81808e9a028c4efa07389cb2bf45d441c09938fddcae21b3fb2152bd1cc7a4c3574cd4ff97f60736e29f9bc59d4673911068f9faa04d17c49610f692e2c99cd33b3fea2dc20c19cd08bb828a564f4605b2db723905cfb06ee138ae2c50b53dbb34b5df85d1f02851d355dbdb83000d43d69a873334867aee3d365d5dd26e2fa3916873b66a0f522fc575153a239aa9390fbb02d6a72a2cf47ff8affd9d22a10db5d60e70df632f7eae072462973f1584fc36f59312756f4838109d6a481926618ff83da6e62feded727508ce37054b09d36544ade5099bde58fb24c9a07c7ad81e3a0042ee3a9b7014e7d8eeb3c414f536d590c74cc3a43727c997466c4a16ee39feadb9f60ecc3110120105bb36dbcda7990aa99cc2bdfb60d83fa4c0f3e0a7dace2c3430a4b112c844b16ab2a7518139e148d033e7c68d3ec13828ddd7d5ebb96301508a91768095eb83a2eecdfe990ccc00f39e0d539e40133e6185ea54d5cf9fb2be0bf1a9e622bce6ac6a13e3dc6fae806f39970a71e2ba0a573800d3d7a252727c9c71b808e35a5f4f14fc640eeb054d228d09ca8261f08b56eeecd90dccc2ae33bcf6d182b067a93eeb5bddde704831d10665d86a694c64cdf1dbbde9157d4fef4fbfdeec685a3fa9635b1ddb75cbc3dc66c9f83f14f7f803856fbac1a276326b3e9b3beef534d6cf3a7948d143560880d7a27517f8863014d59b6edc958c2a3b2561a73d830005f8bbb0a6981fa339e3aedd901b9899d6be5eead8bb6f53ae69023ebce8c4f0369339353a8e0ca69030ad639878f605cff42f3b0c28b000e5d53b5fdeb09513eae8a4cf6fee52320229a919588b87fdda6edc18b73f188d87a348bf2a6bc43b1795da825a75520b7b4307582640399e03cd267097a51685d72032e27d6144597fa8d40687c8c805c896054c395ca549bf5b8cb7ff401afc51685b9585d18bfcfdf2f0783840f52461dd80fad1cc617ccea893cb898fae7159500ae424d4fb7927a33f08fa684d76056c491498b44cf409eb69ddea67e9f60a3d3cb23508591286a8170c9dc28dd1fffe435c527d0cc14f21a296a6035c146309528fb2d6f9748865554a1949b5ed306d1c0caf4dc1a6ab8da791be4c466b5f2b960d6eca4e0afa1b9c0bdc78d937a815b6dfd9357499ac1fcb9b80a0ca5dc4c80a0743d3af91d5656c91b8a2feef3ce03195d1b34f27a6436eb13624648820bad2137ae28d17b3302a51957fa52d39387a241a3cfc3d3be5777d1de2fc6b774d25cd01b3d82c5406771f0a2dc5c30cff366f1d9a761e2077653cfcc769348fd7a82bfbd988d9826e079f1afada51d5464e3e7d1c31499b79e0bd95ca39c3d08408cb5c6d5159132edb079dc94c5c7fa2376fcd418874a0c91169771db47ece4921b7f90fc4519484828d0da137e328f2bb27f13794cc420d2d49b453eb114fbce040613938a82c44f60af8fe97acd2570062e097dd1ca06939d2bece4dbf84eb08ba7371eff8fb4d903d093d27b0336b98a9597d3f3f467aa24ae15a8eb54a43b95583b41cf556dd64bdb4a4e490b007e4d187afad64d49eb2ae877633ca7dce9c5672f25b76ab72bc7d2d493b89fad6fcb9e4bae7c11e40bc1d47193630f09d100763b19f0eabdd17dbff61ce1b2449e482ee34dc06eea8a0378a16382639f2a4c5dc2994deb953d8faf0ef66c89835b75fb9a4778bdef59171bffedb89e08bc252268b810352f9491049b836ea3ca741e4ad2b28ae6cc3bd81c4989d4ef77b2260cafb8d8d387155fd6486196c7b0a6482dc7be26b9fb929f5357281c9d671933f6b62ae26dd3127b80b965d27bc15a842a444a9a8401286c8b332b3a5f42326e4bdc7d1d5d0df3b829c9394f5a62c40d75578052887bc13373cb472eaa21b0c83a5923dcac3f70887339c7f510f0701912edbf1d4b9a873d83fd9db8071a58b87d8124271daf215bd5b7e7dcd7fab5e23a94fed24df0231d4053c2cc354ed7c9bdd5b141f79811afd79966c0baa8364317448856e248fa4eb4e6955a6b989de76ba677b8329bb8a874aa30fa965c478f0d6efce8aa064e5bc9807b845f54740d209e305937753e911d5fc266b9529a0be616aad3dfb3659ef9eab7c3aa89fe6d451a72b194642ed3503f75b96140a3a63b1458665518863d8bc94ec15a3ebc2a2c35756f013f7f195b917b4bf1a4a3c840fe50cede913dec4d4d57f9f8e39f0d9c12c27a53eadbfba2c27710d2e4626a5984ee7548a08ed920c31362784a991858afe4222350a8468c7f1306c41ed923ce045d918ec4940237f106fb2eb0107af9f503ed991bd9669e80f1d50b38488b40dbb7466a5b3a57ae0fe20756ecf9dfb38c04cf740d49c93fc961c49bb90107e4892a93f0175dbacd9181270426f98718bb0d450c27defd49e475ce98ec55b133076d1261cf3a373e81439fecc40afb8133e930f757aefd8aba2185c4c0744ce031288ef7499b0ccd43a660544d414723ba1577beec32e22f630e9e1106e6ff02f91a0b0cfe486eb672e30eef739a162dee2a7b2e1e59ad1e68794e0f9395355947cb142362e72649139c02df4771484fa4421dcdc9668c254c606daf75d94787bba3078ae5b93ccba04ecf43d26750b775e434228d958cf45123acad3d941502fd7af4f466702f65ac4d24673f75ba35cb0b1ab26a263e44e84dacd45adda1d96574bb9f24c0232746bcf256f2e534fce59c6d5c5b944f93ff4445e981f8b328271f206211601e7dcd29ca27923390ae121c4d2363fc36ddb93f213c4d7cf02669df16e9b4a026bc4aa71322e4a5af57c493d3c29300356d7ddc1f5d38b746e8ca16751f4400f52619d1f65e599bd795484afb1c2ef7a8545e1f0a782491c73cfa589575065467c6082e3bde61a61df44f49e336519d9c3a2f5143bc91461c4ec8d7d73b0f17a78e21cf97bf55ce48f370d3e3ceeaff7b478420ebd29d5d4696bf246db511436871aa3d4d44d77842fcf7ea333aaf4cf57d947056e5f0009096e3877da8023280afeb389622b3c2a46f4bb6aa969474726699060266bdd7cdbd2526c6f6d703fb1b951fef831eb8b3a063a54f19826501689fb490c5331a28b51654310a04cad870eb06b9a882b0ca035c11a513eb255df7f8c4aec931673acc67e45705ded3b0222f7b9eeb9298f4285df6c916d618b9b63db6bfe7308037df5f6021b3d3ed09225774e6defd74ab9acdc7ae982b30399f77b0627fadb16ca4886bbe0febb1547eb33938170566bbd940879f789f89d2b9d6652127e60224c00b8bb71b554f82cfd5d24d713796800ad22df447f36b5f6d102ba847541c2e2040e47d357d4341f74fc68c1a2c9f90ef05fb0c9e7d711cd3e7e9f77b02184f898a0df6e4bdffbeeba422ce4e40255652ac0999bbb00718fc46b72d83293634c7816c376e20fd22150cc51b1d64e623b77ff119dfb09123822b4659bdad51210c1a93a4b46ea9e6cfbbbae94e5dc845bd090cfdd20c96af663131002d7e53beedef25a974f2b479dcf1a76ef77bf25be029ec14ac2d1c1498034dace49453d5181a3aa230bde17fe55105758fdcc0bd561fc6db422c6c8827888533bb5990a403a109b3c636bdd7f5b09e0dea74da0db2503e7cba605daaddf28ba28febf8e0c3fe3593fef1982d31c02c9e28ff19202eed63f823793fa11cea2bd450a05af9b2d8715f6edf1ab232803cd2425311674d7341ecb12f44fc268f9e55566fd0aac1828a32017fc5db9f6be807d3bc0cf225d7e6d5ef9e9b1452c4601c840c096bf1303913865ee0c0c7c0f0be5bc754207fa9c4266756b2cb09a1cba21ec2ea595b28d15b63828c4a163c0d77a17502828657c579642caff613f4e3160a2cf6bd7772fc6d17802705d24d5f5e663446d4ffd49c5199ece03368d50ca1dbb1e0b3bfbfb18c348e68692db0ba03f37740b704336a932d4998df9008c9ff412c2ca5c71e0c8723cd370fc2192e4302b1be13b05183e4129e83efc5fb27bef65316d2b1559491d9bbdf6b5c9f2e40621d1854b82d27b74e44115849afb9544bceacfa19db37c82467a66e93f842b5f5062ab4bb9680efd6f23aab6518f929bea87d79f8153e4a7457f1b3251efff6b3c986d6e2abd1c1dd48521254e2d9d12060d47dcee1f822ddb9a2c7fa300f89e5b9261dc5f3a3c58fb96204f69dd09a6a37abb3f7c9e32709198001d081ebcf62ebae6beb412a982ce08f36269776ef84e013d0a9c82e3bf5d3a9dbff260eaa50b862a2e54064abc5df22d5e87ea2ff0d8f9041923f93f6ab7b9b3e832136bf5985215b83f823dff885594523b86cfcdeb2fff41248fd766cc844d8e29ad5ade07bacf6ab28063e389825679a913204aa8215eb0dfd5c8cb969c468207d355f9029edb159d05525f8e2747cb3abdb5e3115d0566b13a7259472fc777c2eafb3f4501cbc5c2e989d5a2ad6b54079752b0af5d943553e3644d5e02d78db7a257c6646b26a3a86051fe1b9dc4ecd7d7443734a60d1af8789227fda6f468e48fb6dd599c2828fc5044d6654b8877c07401518bdcad848cf9ad695984d0d1e6edf5da3c6d32fdc04d292be91a93ed36c7fdef506790130af75b9300730bd8abba2645a1ced38967d95eba3d702d1ba79d01e6fd0d937cd491e33bd3a86c4644958ac2cc9a56a67c7ed7afcb8f0b269882e32c74eb0087b9def9d701b527ce61889117ec0381734ec1ab557f4cf45f418deec609eca3092c482fe1e92e426f18de3224fde04d5c37ec91e4c21c8911ca99552222933b6ca8ee1fdecbec5a59bc9770f8b8ce7427a1161a917d57037b0de5a3231b13f86b6d53e884424a3191ad620b847313a4efa21e42152e38f7cae41d9126d4ee70a96a3cdb8c0517754e9d1a65d9c6e4f9a2b1e1d51ad6d85d7b58eed423c5e5695fa6ce2d99058352ce2c0477269685745e0650164290e6b195fbe90517fbfe10b4e253f83b3f2aa51dec1a45a733b6e90acb30b6b2745a0cdd26e10f5f586e77218190270b85c2be3a3981c5e36ed12aabb2c19516860814882597f9df901011713a7631b58f93a2f9ac64ed915d940105aea27d67f36e7b622f572123cf9699030d185deb3eab5a5424dd5dee1a2e5b9623ea2b1e15f308c330dc1399eec8743ea2569faf83066fa306e40ff0e2aef83590b8854ee06918b3eb8d837297d8171519bbfd581dbfc1762d5225c7767600408176e6d0aaea8addf33ff0f59a4ff2bff8e411dbb581db10b203daddbf4996161bde3733d3fb6669f7414bfd7ead8699d36371ac80a91e32eb91dd36300cf34b487d9b3d4417b2a024d3e9fc2432183b036923d321facaade2d89dc33b35fc1afc8a3e97c7acd332d045b2d94660d5f430fe8445f8b462147d620be387e08e654670cd5f8803378a8cf92efd0749e3f6f753e7e7e55ccecb93b5efa00e9dd4eaf6b58ff0fb8efb567a65379e2c61b919a3813ea89bdec46fe876d6d89a5b96c5606c43f2a01b6a1b756fa77caf79ee3c71255bd3d1fcf072511e0b1aac5e1484c8a5be325b45b0c9cb1c6bf446468980fba98530e5c1e92e109e1b2fe825c17ab0eee77121f2ee0ce8ccd7581c1b199269ebc18330edb8c4217a3ed8ba1910888064f80f3f64245bf7b4fdcce4558705b20d6a87d77dee5e1da2d04f50563ee3ba22fa226a0c0a3fbfa7b1e2bd3003e944d2f32bcea37ae2a628e898ad4654e08f522911c05a592b00f517d8c39d1975dc628a4bd98d02a09e4101c9d868df5a633a3d3b31476ecd10ca856c97b0886f8ad5b29972305a218f75f21788f006bcacc737cc4e97c91b0a568c76f1bc47732008de413b81013ac47443b488af5553fb8fa4955b123528a720d6460e3d9c13f549d7db35a9aaaa4b3b83be148ea6dd42d74794f7676b03245d88f12b4737b7de3fa9ac0d88c73919f4910a9308f4b81ac10baeb046d6556c0de654530a946ddfecb5a3debd64437f228e65a84cf9565c77697e7a7d24b99f1a5cac3dc9d060bbe6036b5a9e403e2db59570e3fd4b01c01cda912108b0b9acce051339fb85b9be55d0fec19ae1824c0eece3075cc9dacf9584fb34e10854c26adb9ef1357ad7978b55683839bf860a7d2db7ddaeacf3aa0e4bf91add4321155fcdd0f49063dc9e9824a1cf9cad0795f94ec432dd4a5ad16911948b6c7f55dc206f841ad220116030d1d677686bf45a29bc0d5c1851efdaa46657be820f0198d7ad7f50fbe415d8193f05a6036ee92990e9008913f8ad4e7be6f55728a9f37b022c1f4f0acee62708b8ea36500e23626608e4057eea6e7f604c14e71ed78c0302c4b95b2aea5e112e25d94388754e87cad39e82cac29b3afcce6b0c2a44ce42931bd416425281c1b7752af4cfc7903525b72e69947c96c261b1a7c2836855324fbcdb0e10447759b7c13c2baf1722174541c44748f2b48b7edc8d08c7a0e12c45152e61cc49ddb294a1784eb8f8f379ff3f7eb81cc7c41a0baab69b871541c9f6a0fd235c84e16d4773ed8d5aece28abe8050a5df379518932fb71795fb00fcd76b018135c41d9f1271e7e8069968ae3a28e3a894d4ad69d656876eb8dddd4f1a2641331e725d3babdb8ef8ed1bb5f787c74f58e8d2df68ecb2d5bd4db3fe9f30ab2375c0ee954de86a15adbf7182c245dc966b4c9c03b48f797455779d91b3a0e491e4c4b0a71d4016823eff47a89f95d631b566a2bcdf8b2c9bbce839bc50b69884c69540d16fc865a7f802689550a0ce97031a7cfbaad860c804da98523670ab010eceaa99293a455df746c25c69a5ddbe40012becab76c5cf8488e47443edcb22d02eb9caea274f40065edef433fe1b437eb79862b0643f0811dd741915dffc693c381a6d124a8e5a37d785a7c4de67ac6a2c238e1c39bd06a91596e03b0123e5dc8f7cba6a8dd1fa2fe1ddb1c8dd1fbc2d802abeeceecce5db0c2cfce5cdd402f6ff19e5a21e49747566dd02012a1030ce341115c68f0b1708546aef96ca4503056f75134067eb8c0bc3fe2784f5e491a0d22931afcbeb899cf1179d8d5c1d1c5ef32f5139d9d098794fbae82e8e5bf733718497c6c8d670de0bff2ed68cf82087b260cbc6808d1cbfc7b9b8b9e7547d927838dc54ad19831aeebc2ca7ae6778c06e0fe43f29f2c27fd8c282a0f97fe8ecf0f4b83abef771b3f2e8818ee92345d8f8516cfb6fe43393fd932b832e57fbf8a87dff42efa52cb9091b0632b8219e8e6696174e4133501529eb905f4eaa4ca270117951d0972b75be7f5c89c69bea72596c62fe4298eef43db73d789e99d276385131e13f8a91761a413cd33a85ebcb657e647d77c530bf816b4693d9287c27b0dd8f9ee1d92282fee8947c77b6c5ebeed9bb3c4c87c7a9abb911486ef416dff1fcdcf9e2c4f030678a9acacb7829acff8afc10a94917d70c0c631e32c657834dfbafa83ebc256d39b54840f72150291595141501d0157faa68d2c1dd73ed171a4ffa7c85cf6471ae3523bf11dc70677300b47ff4f93a60eac73deceba478395899d4a6e3edfe02e0ee0812972dc36dbf58023ae92f8c287172b88523383b10bbfd49f6810840471fb8a1e9145257f018ed3f934f68684e0da078647673322791725f4e22f15883bafdb85828b6a1c2c6bdaaa3649f43018a98cb6e5f654044d57199ea4df63bdbb9dc0934e7f29e2e6baa00c263b409cbd6106d4ba907407c73f0cc3526c92568172587ab1782d6e2eeb11b6450e74510a93fbaf50d0c778ad18e4d4998c0878238a957b101ed14d8587bf23f5e99f7cf96554c1d07a53743951a37bff12dac1104b8d0ef8b6508bf132f219690ccd8e3e9d0f31126626ecc049514046f17ed75c955f1e14dd9ada2e39c66b033c55579741f8fa3036f3e78dfa951ac7c7146008a46e79958c1640e6aa70fe8f6c5d7559e947d9a460f4080db91b1e4b180d197cf1d08717119005f8b96592dd9ba8026fba18c27808600b82775e74e9924a91a617e52e5c92533accb4ad44c3e5d104d8f9d2da51bb0ea17975423db5b499e4d7cd8b0a142eb2afdff4629800d7a768e442ff8c5bb7a75c2d84429c4313b5170c8dc5a21dd701991ba7b1dd4ac37cda941dd580516f85da6cd5ab474d22c026e08a42ce7b2108098b8e1924353f784dbd4e1f8428ae51cc525822933d2b801afa4636b1763db4978ea90aeee7652761de3098c988fcc4a919f34bbb621d49d11ab8049a627b18642c257a9ec8e845a03efeba4565aab08462536578bdc33d332b25d1e142309825a067e721e3d03ecca10a846c54090c0712b88d4d55cc0df0d22ebf4e0fbdf86517f2487307edf734984a3cf7359c03063f03e55fdcd1028afa26c4b6a5abd7f099f7008b3eb52112fd4a2aea54272674182f766f4e17b13c3f3527a91a7bf4632a504f13dc7524736124dcc9fe454b4588097aa6f4c20c45dff99e8b6df48a0ea6ca1a158860ab942f9773a882c4622612e43904d80fd5442f18e1ffb9754e510ff0bb49c7b756f10b9628a3b4a99c683e6b2bf325f7f627d7f4158800e82536a423896e642f1f521a21e071e0076510ad21b44359906ee7a0bdb467b3136868663816332531f6c77c99ee2d5ae47e11ab7f17f4f264a492f68f56863a3f5e77390c3dd41497427133eab5a34ab9df754ae9deb35659ac028efeb186b99f900f2c4d029b3f0b3501dac9bd51d4d6bf572e69f3db290725c629c764ee29280fa6789b9dfeb1df26f09a499ae2655318ddd0cae0a4713e866e2df996a67dbff688348827cbc76571ba26807199fb9f21a1dd4305282ef88845119161456d0d256b3410084d3b75f80230641a5ed1aed869a54424f7f3c6d41fbe8c7ef1a1deccd4fa27dd804f6638c4b5fd649d059c9e4d7c5fb0b6c54b7bcf094b03dfe9d5cb1ff2ea0dd878cf90f374f70eaf79a76017f4879a55ac38150f05ee87776b02a7da54924767c5001a06bb36f6ab37a37068c0c02f055e72f025caee69584121cee7b63a983a71f35a405b096d3caa5691aee9b91bd301b929359c2bd8a16943795c7ae5af44b9f7c8a94b1407397789018cd7fb85594e9d924bc23cbe1d608f34ab4df08a029fb47d252489856c2ba7539920e7a9f6083acc866ad8f7867695089a70be6540b4f814b4617d4bbc0958b789bdb5b5f7cfd9d592b4519a1c0eb88881b95cb448ec29e34b7a0b878bd32f286ac7db6da3b39b1e7c28936e33ba7edc8346a85a710afdfdfa86da5890c556bf72def7f72b780fff737dc4ce523fd94ac8585f10456dc60746183ea6320a607b28227594d6fe89908ae35a74418af750cb21f1a830232bde120d3fca15d7bc19959d7d68709a9ce6c1f4e3955478f8dfb7996a3ec281c46b947f47f3a50da0c3c4d21329f2f26ce4265bd96173d479af11b4a9ff1d3fc7d56529de8ad6d04447e615baac38fd6fe43fdfab057ed2f0b1dd7c9eac8e206792d7e018978cc9241d372f89d20869bdc4675efe08ea58926ff019d28ff183a10663f01034e29578242d547c4a3a42a98641e2602a8a49fee71629535a65615c8be1051a937ebdcde2e9a7d2e95845639650226b9ff417a74eade86c41ba886b6b990183cab3fdd045606333aaa3dab9cae3664737cd0f125e82356a8eb86325b9f6f28cd088e8c0bdc6f9554e881e39dc7ba6b156500011cd482de1700940dbbd212c9f5f9a084c9f6d1e3687662f4f426520ae7f0d0d390d95ce496c5bbe7e4d09bfcc9f91c7300e38135bfa2a56a1214b3137a7c53a2feae21da8dd76a7d2882e6028edf1d6dda7667a640b1287ae3b5c3617a183c589e41cb680ce84cc436b379db2239b440d2ec29f0742b73185cbd24661309a21918583df47e9266c28d7c5045dabd1f9a2bba0a94617bb3aac42a13bf2841697e363415a22d9b631885d25be7e744f4ceaded46de5553798b79065839b162fb3c95c5e7cc39dc7760ca52613c8804c56cff0a3313f217e61fd5b57c56172dc0f29f77a6301d2aa8daee4a7fff7e2330849ad1c40a7bc597eda5ad86c2fcf6dc50ab04303097cb17941e02d46131dcf189ea5021805699fdd80bcb7517a718ae42a895f4f29c73a5cc0f7624d611f187c716930d30676e4c3e3837f9a6d6d0dbb6715e920c3e8962ed851dc10a0a94657b2ba3d7440a437a0e22c09c67db917c49ddfc42ff5881a6f0131e1079c1792843ace014d52243c1f8aa45bc5819a98f59a7a6114d1df0db539bb32ec74be7204fd1087aa3fd6f0943143ed48e9a42abc54b7846f0e89704261b0227a7ee084b58f66ba6d711ed58294841a60a8f7d15863295332ea0d385c8895c32a74947fc8ace7a319463d9e484934b576f5efa9a27079339d320d9c808ec78b3da94766c3db466bb80147d75add840800830a15cc2abba34c3e2ab341fea454b0d727c88721897207e25ac4f115672860dc064803b2c307836c0507500d14dbe31b9c626792c720ff9fc674981ebaced2a08720b613ee3925de13008bc6aa072f5923c96ca084b8852b7b9e7941a41b7ebbeecc635f277faadeb048040c7ef901d8880b3b6f7aa5033a698ab3b57230d8a750aa3e52d358bc883a9dbf367caa1bf80a8af472a277cbc8afcb7f2d56591628ed845b295228af8b19434b674f2637e596bed1d7e3170f4f6de5f5a1a322bfe02722f8c54062000ef25b76efe89382d5e97920dfa6dbf90d72c512d445692726c2753e346dcead275d2b7beecaf5e56d23035cee10e63ada2441deb0a06f614bef6eb1197352b855b847be3053c2b1dfdc32cff48980ef316acb2a2fa34a69a5919f6430752f73d2ca33154009ac1f619a77703a8da7e9692bd2de3d2da024556fb55b46b88886eab45213500d106a21fe9bf30953cec76acb32182f0d9b96a4b57ac3181a7719d3e3c968c85cce9dbcc873ff52451627bdec7439260e72f3a5ee0fa926b555bd2384122d8b2314fa748c131da1d82c747adb0975e9a188bd478ccdc7bbb0ecbbd3e811b0a036fe775de1464c89a3898bfe2ce5928cc93b869e3f9abdabb9b50db5e3fd4c25b66085dedbeb4ba55ee8f4f71f49044783c92962442f45604722866b359a3ab8055c5eff51b646c215efcb2e4356af781a52b8778f488a779bb9d94d287a8641424870c1b4cab23bedc6888f283f7c9b564b14c55d93d00de9892ad2ed016d19e43f8ebed02f1bcd68f37ef93cb263ff1a88d4cf09ad2435c30b5053b49df6a965d34cb666bfe6f26584e7ae1c9a77d527aa467314f8a4e8d0265e7af40073556f30e1675d81d4d633794d9fd4b66f965ece0327012ba21b352f97e5b862722a670920a37ef57f8abcdb0f725915fe8529f32971149d29ff1163f8f1010ead25d06603575c3ea9e6baf67cbd8e4b8eb7d74884a9a40e8e4b1e223747c820cd5ab7d5550a0cebee06f92f67f358232d2876bb1c8c138c7c891897e0fc6964e40f66ae6d6625b9f3395c5b8add9c87ae1efbbc553cf5aa26c70db72df6bb7be586da2e9d18087fdb4108c9b4a947bdc73d7e617599023ba0a1a1ef3420132fcbb088c70c975703157d2e5ef97cfca5fe7350b13b8f63cf887b32e045548297792ed8d4936e88bde31508583ce86772d485262b9084675d5ed3062f4f4d489b0256d4442777fcab7bfcc875c44699292a3fb55732db071c277487f56c482340d171016e5d9f280ee2a4318faf1f4d5692bc52463cbbc2f63ffc679b3c601a6087667dac030d6764924b88de56afbc0c0799d8a25046b8a273858e23159a3493be71537c04b04de4a7c79c3bb5ee3ff62d4a8fc4ed6215334e6400dbcc4be9baf8bb2c788bf963fa37011f772f1a3ac88691f513130bfefa5bb8400480a84929fb541562f427d0b820dc7ad0a60f4bc20d0cb2ad15ae716a7e0ca6565beb770e7632ef33dcf1400a4abc487570acf0bfb768ae092fe493dcc9b9166b60a55ccf52287de55a016c1331d77d9b7cdc152fc98141a256e6d7184b07e5c2d8947d8f434c3f83588643fc63f47dddaf415193c6e826c9885a5d68e0cb3144bff0a18209930eef1348b4f71b6623b44b4f0dcbf3d433250581000a9f878ca1c96b34c1126548b9d41fb205b452724b54c52dd0f43378d6174ca7576fb233954c2195e637fc4ab8a0dd35ca9899933f8c1721dca03cea3127fedfbff17dc26254c21292335ebd08a8883a5413198f01845e10252dd594444694cc14a1e1f737e49f0ac70c0070d8501fb5593071969a9535d664be05271c964312e36222c35bb6ed2c761104c3a51469ec78cfd6409b8858262b5c3ff4e2598afa95469e71867cb70931cdf6d3cb41da88fcb549ec59ab7fc9ed74f4e1995a46d2b8a2f8b236ce79c4a1c7b80bf59c711f0091639df5c44267552405ae36f2302e4526545b7394b5b25032c711162996d2adbe667862a5fb73031719e9b07161471dcf555941c07bf4362f6bd528087caedbbddaf0387587777d56b931c0cecf93874bcca6e151263f724fd1ebad670b594b34c90d4b2abc5d99472a9f39dc51fb29903de7ce5fb91203bbc95648a9324fdde1fae0f8373cde71ebd884f95a99732ef076556e3f39c2cd533f91794f07925f5d6b93edba50ff0ccce0594c2cb25e02d3bab5bcb8a49f534ce60692564077e27d17d988602996b8f8a0c9b3d8ad69dc7759431b40a7cf1fdc51cb2874b8c25fc3a1b68737316c0dfdf99294e072a4ce89ef18039d2425da02450a4fcec4c42bf8433516f35d1f2d9f043ac78d56df2d05facfb8d0e332bec6d72524a27e474d8d5650594f4b223386084b7e9a299ffa4471aa548728cbafc9dfee3bea01f4cf40ca9b332bcec170300c9bf13d2eea934ff01b6ea99463986f4fb745a57552922ae8e29cec684dec53c4f9ade09c7619f5d84cee32379af500a403cd8cd3cd20c6d16d78393a5095415349a1662ea7cad6b596351239fb606ebda6d5384b1813114328aa8ec7caa726cafdf7f8f95d0ae620e9692005f189ff0353ded51b9532cc00903054484bc8745437fda6f287274f888abdd1330d99e92e97ca7336c92f94cb21e79d77d1159a372e3ee74b06fb6f64ef79d7119d15f54a22ca015bd5a355d1af1eaedef256d648a8f2b4bb502468dd5092f5fc3bdc0e4d4c381698b6e504c39b66b1340d599c663fbfe9d88738da706e6a995812b03a0b1635ab831416ceb751592b765605be73a67237824390dcdcd5353c90fae261e0e935042ee25d6ddf4da5c89b28f23a14475a7edf7ff11de2f3264c0d1c9aff337dfe29ba08b077c1a7c8eebdc8d5d4610e615c73ccee884865de624e99734771d6292fdd2f6aa59e4e560ca60634b885ddeb71c0dd67b1eec14d300ce99e885482fbc5e5eaf83ab527216177f7f39a4776861053a820336a6962d5201b2c9d3b8730b9bf02d8c0f7ca455cfbd9d0e624d9a1f75fd85e347fc7cd235141de01847e4955a92aad05c80e28e83a3ea8adf614bdf0ec3e2764ef90767df818a3b5f6edb090e17a9615ba56aef30a09bd706686f90daf0e0dd0105fa7cbbb4542af05ef70a30cd9ad8f903cef0af99e12649846668b096331f55e0c9e65411eca97e487e883f900a9f8187d3ce46aa8453783dbe3d4757f22fdf4c515f01aa90f3dcb3fed5536883c62346afd09878f55d4b79309a78aa567d7f99395384bac8bb0b87a28d783f31e6438d03359992549bc338ba2ecadaf51c11994a1895c3fe170fe8f267f8e8dfbf0d5d02de78d9b987ced1c21ca5eb88363e040755f62d573065d533ba5c640349c59f43de5a63897029574d814ff1cea4796786ad2ae87241d300a33a3ba5964f6b517b975c1c0eb18624276f6332611b13defd5a8261621ff6a37ee763d94abb09b4639358de601117bc72c2ef7c0119c6f9d5fb1620be5a985e005</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <summary type="html">Here&#39;s something encrypted, password is required to continue reading.</summary>
    
    
    
    <category term="编程与开发" scheme="http://blog.zhuangzhihao.top/categories/%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="Java" scheme="http://blog.zhuangzhihao.top/tags/Java/"/>
    
    <category term="JavaWeb" scheme="http://blog.zhuangzhihao.top/tags/JavaWeb/"/>
    
    <category term="MySQL" scheme="http://blog.zhuangzhihao.top/tags/MySQL/"/>
    
    <category term="Maven" scheme="http://blog.zhuangzhihao.top/tags/Maven/"/>
    
  </entry>
  
  <entry>
    <title>白话机器学习算法</title>
    <link href="http://blog.zhuangzhihao.top/%E7%99%BD%E8%AF%9D%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95/"/>
    <id>http://blog.zhuangzhihao.top/%E7%99%BD%E8%AF%9D%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95/</id>
    <published>2021-10-30T16:00:00.000Z</published>
    <updated>2021-11-23T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>机器学习算法是数据科学的力量之源，它和数据一起产生极其宝贵的知识并且帮助我们以新的方式利用已有信息。<a href="https://book.douban.com/subject/30442187/">白话机器学习算法</a>一书用通俗易懂的语言以及大量有趣的示例和插图讲解10多种前沿的机器学习算法。内容涵盖k均值聚类、主成分分析、关联规则、社会网络分析等无监督学习算法，以及回归分析、k最近邻、支持向量机、决策树、随机森林、神经网络等监督学习算法，并概述强化学习算法的思想。以下为阅读过程中所作的读书笔记，可供参考。</p></blockquote><a id="more"></a><h3 id="为何需要数据科学"><a href="#为何需要数据科学" class="headerlink" title="为何需要数据科学"></a>为何需要数据科学</h3><ul><li>借助现代计算机和高级算法，我们能够做到以下几点：<ol><li>从大型数据集中发现隐藏的趋势</li><li> 充分利用发现的趋势做预测</li><li>计算每种结果出现的概率</li><li>快速获取准确结果</li></ol></li></ul><h3 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h3><h4 id="准备数据"><a href="#准备数据" class="headerlink" title="准备数据"></a>准备数据</h4><ul><li>数据格式：数据点、数据集</li><li>变量（variable）：用于描述数据点，又叫属性、特征或维度<ul><li>二值变量（binary variable）：最简单的变量类型，只有2个可选值</li><li>分类变量（categorical variable）：用来表示有2个以上选择的情况</li><li>整型变量（integer variable）：用来表示整数</li><li>连续变量（continuous variable）：用来表示小数</li></ul></li><li>变量选择是一个试错的过程，需要根据反馈结果不断更换变量，选取那些最有希望的变量，以待进一步分析</li><li>特征工程（feature engineering）是将原始数据转化成更好的表达问题本质的特征的过程，使得将这些特征运用到预测模型中能提高对不可见数据的模型预测精度</li><li>解决数据缺失：近似、计算、移除</li></ul><h4 id="选择算法"><a href="#选择算法" class="headerlink" title="选择算法"></a>选择算法</h4><ul><li>无监督学习（unsupervised learning）：依靠算法从数据中找出隐藏的模式<ul><li>k 均值聚类、主成分分析、关联规则、社会网络分析</li><li>通过间接手段，可以对无监督学习模型输出的结果进行验证</li></ul></li><li>监督学习（supervised learning）：基于数据中已有的模式做预测<ul><li>回归分析、k 最近邻、支持向量机、决策树、随机森林（random forest）、神经网络</li></ul></li><li>强化学习（reinforcement learning）：使用数据中的模式做预测，并根据越来越多的反馈结果不断改进</li><li>除了要了解算法使用的任务类型外，还要了解各种算法对不同数据类型的分析能力，以及结果的本质</li></ul><h4 id="参数调优（parameter-tuning）"><a href="#参数调优（parameter-tuning）" class="headerlink" title="参数调优（parameter tuning）"></a>参数调优（parameter tuning）</h4><ul><li>不同的算法有不同的调节参数，即便是同一个算法，如果参数调的不一样，所产生的结果也各不相同</li><li>过拟合模型：过度敏感，把数据中的随机波动当成持久模式，对当前数据有着很高的预测准确度，但是对未知数据的预测准确度较差（泛化能力不强）</li><li>欠拟合模型（underfitting）：过于愚钝，很可能会忽视数据中的重要趋势，这会导致模型对当前数据和未知数据的预测准确度下降</li><li>理想拟合：算法能在识别主要趋势和忽视微小变化之间找到平衡，使最终得到的模型非常适合做预测</li><li>对于大多数模型而言，过拟合（overfitting）是常见问题，所以增加预测模型的复杂度能最大限度的减少预测误差，但容易出现预测边界过度复杂</li><li>通过正则化（regularization）引入惩罚参数，通过人为增大预测误差，对模型复杂度的增加进行惩罚，从而使算法同时考虑复杂度和准确度使模型保持简单，有助于提高模型的泛化能力</li></ul><h4 id="评价模型"><a href="#评价模型" class="headerlink" title="评价模型"></a>评价模型</h4><ul><li>使用一些评价指标来比较模型的预测准确度：预测准确率、混淆矩阵和均方根误差（root mean squared error）</li><li>分类指标（classification）<ul><li>预测准确率：正确预测所占的比率，无法通过预测准确率得知预测误差是如何产生的</li><li>混淆矩阵（confusion matrix）：在预测准确率的基础上添加假正类型和假负类型，辨别预测误差数</li></ul></li><li>回归指标<ul><li>由于回归预测使用连续值，因此误差一般被量化成预测值和实际值之差，惩罚随误差大小而不同</li><li>均方根误差：将每个误差都取平方，放大大误差，这使得均方根误差对异常值极其敏感，对这些值的惩罚力度也更大，避免较大的误差</li></ul></li><li>验证：评估模型对新数据的预测准确度，避免过拟合模型在面对当前数据表现良好而面对新数据时可能表现糟糕的情况</li><li>在评估模型时并不一定非要使用新数据，而是可以把当前的数据集划分成训练集（training dataset）和测试集（test dataset）<ul><li>训练集用来生成和调整预测模型，测试集用来充当新数据并评估模型的预测准确度</li><li>最好的模型针对测试集所做的预测一定是最准确的</li><li>为了使验证（validation）过程行之有效，需要不带偏差的把数据点随机分派到数据集和测试集中</li></ul></li><li>交叉验证（cross-validation）：使用同一个数据集进行训练和测试，避免因为原始数据集很小而无法留出足够的数据形成测试集的情况<ul><li>把数据集划分成若干组用来对模型进行反复测试</li><li>在单次迭代中除了某一组外其他各组都被用来训练预测模型，然后留下来的那组被用来测试模型</li><li>这个过程重复进行直到每一个组都测试过模型，并且只测试过一次</li></ul></li></ul><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><ul><li>数据科学研究的 4 个主要步骤：<ol><li>准备待分析的数据</li><li>根据研究需求挑选合适的算法，为数据建立模型</li><li>对算法的参数进行调优，优化模型</li><li>根据准确度评价模型</li></ol></li></ul><h3 id="k-均值聚类（k-means-clustering）"><a href="#k-均值聚类（k-means-clustering）" class="headerlink" title="k 均值聚类（k-means clustering）"></a>k 均值聚类（k-means clustering）</h3><h4 id="定义群组"><a href="#定义群组" class="headerlink" title="定义群组"></a>定义群组</h4><ul><li>群组数量要足够大，以便提取有意义的模式用作商业决策参考，还要足够小，能够确保各个群组之间有明显的区别</li><li>使用陡坡图（scree plot）确定合适的群组数量<ul><li>陡坡图可以展现群组内散度随群组数量增加而降低的过程</li><li>陡坡图曲线的拐弯处表示最佳群组数量，此处的群组内散度较为合理</li></ul></li><li>通过检查群组成员与群组中心点的距离判断该群组的有效性（群组最好由密集的数据点组成）<ol><li>猜测每个群组的中心点，因为暂时不能确定通过猜测得到的中心点是否正确，所以称它们为伪中心点</li><li>把每个数据点分配给最近的伪中心点</li><li>根据群组成员的分布调整为中心点的位置</li><li>重复步骤 2 和步骤 3 直至群组成员不再发生变化</li></ol></li><li>聚类也可以在更多的维度上进行，虽然多维度分析很难进行可视化，但是可以借助程序计算数据点和群组中心点在多维度情形下的距离</li></ul><h4 id="局限性"><a href="#局限性" class="headerlink" title="局限性"></a>局限性</h4><ul><li>每个数据点只能属于一个群组：恰好位于两个群组中间的数据点无法确定应属于哪个群组</li><li>群组被假定是正圆形的：若群组的实际形状是椭圆形，那么位于椭圆两端的数据点可能被划入邻近的其他群组</li><li>群组被假定是离散的：k 均值聚类既不允许群组重叠，也不允许它们相互嵌套</li><li>弥补局限性的方法：先用 k 均值聚类方法大致了解数据结构，再综合运用其他更高级的方法进行深入分析</li></ul><h4 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h4><ul><li>k 均值聚类用于把相似的数据点划入同一个群组，群组数量 k 必须事先指定</li><li>给数据点分组时，首先把各个数据点分配到距离最近的群组中，然后调整群组中心点的位置，重复这2个步骤直到群组中的成员不再发生变化</li><li>k 均值聚类最适用于正圆形、非重叠的群组</li></ul><h3 id="主成分分析（principal-component-analysis）"><a href="#主成分分析（principal-component-analysis）" class="headerlink" title="主成分分析（principal component analysis）"></a>主成分分析（principal component analysis）</h3><h4 id="主成分"><a href="#主成分" class="headerlink" title="主成分"></a>主成分</h4><ul><li>主成分分析用于找出最能区分数据点的变量，这种变量被称为主成分，数据点会沿着主成分的维度最大限度地分散开</li><li>主成分可以用已有的一个或多个变量表示</li><li>标准化（standardization）类似于使用百分位数表示每个变量，以此将所有变量统一到一个标准尺度上</li><li>采用主成分分析之后，可以不再通过试错法组合变量，而是通过精确计算各个变量的权重来获得最优变量组合</li></ul><h4 id="确定主成分数量"><a href="#确定主成分数量" class="headerlink" title="确定主成分数量"></a>确定主成分数量</h4><ul><li>由于主成分来源于原始变量，因此用来区分数据点的可用信息会受到原始变量个数的制约</li><li>为了让结果更简单、更通用，应该只选择前几个主成分进行可视化和后续分析<ul><li>将主成分按照其对数据点的区分效果进行排列</li><li>随着主成分个数增多，区分数据点的效果会变差</li><li>陡坡图曲线的拐弯处往往体现了最佳主成分数量</li></ul></li><li>对当前的数据样本进行解释时，使用的主成分越少，泛化能力就越强</li></ul><h4 id="局限性-1"><a href="#局限性-1" class="headerlink" title="局限性"></a>局限性</h4><ul><li>散度最大化：主成分分析有个重要假设，即数据点最分散的维度是最有用的</li><li>解释成分：主成分分析必须对其产生的成分进行解释，但有时可能很难解释变量按某种方式进行组合的原因</li><li>正交成分：主成分分析算法成分之间存在正交关系，然而真实信息维度之间可能不存在正交关系</li><li>弥补局限性的方法：独立成分分析（不需要假设正交关系，在确定成分时还无需考虑数据的散度）</li></ul><h4 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h4><ul><li>主成分分析是一种降维技巧，它使得我们可以使用较小的变量来描述数据，这些变量即为主成分</li><li>每个主成分都是原始变量的某种加权组合，最好的主成分可以用来改进数据分析和可视化</li><li>当信息最丰富的几个维度拥有最大的数据散度，并且彼此正交时，主成分分析能有最佳效果</li></ul><h3 id="关联规则（association-rule）"><a href="#关联规则（association-rule）" class="headerlink" title="关联规则（association rule）"></a>关联规则（association rule）</h3><h4 id="支持度、置信度和提升度"><a href="#支持度、置信度和提升度" class="headerlink" title="支持度、置信度和提升度"></a>支持度、置信度和提升度</h4><ul><li>识别关联规则的常用指标有3个：支持度、置信度和提升度</li><li>支持度：某个项集出现的频率，可以人为设定一个支持度阈值，当某个项集的支持度高于这个阈值时，就把它称为频繁项集</li><li>置信度：当 X 项出现时 Y 项同时出现的频率，记为 {X-&gt;Y} ，但它可能会错估某个关联规则的重要性</li><li>提升度：X 项和 Y 项一同出现的频率，同时考虑这两项各自出现的频率</li><li>{X-&gt;Y} 的提升度 = {X-&gt;Y} 的置信度 / {Y} 的支持度</li></ul><h4 id="先验原则（apriori-principal）"><a href="#先验原则（apriori-principal）" class="headerlink" title="先验原则（apriori principal）"></a>先验原则（apriori principal）</h4><ul><li>先验原则是指如果某个项集出现的不频繁那么包含它的任何更大的项集必定也出现的不频繁</li><li>寻找具有高支持度的项集<ol><li>列出只包含一个元素的项集</li><li>计算每个项集的支持度，保留那些满足最小支持度阈值条件的项集，淘汰不满足的项集</li><li>项候选项集中增加一个元素，并利用在步骤2中保留下来的项集产生所有可能的组合</li><li>重复步骤2和步骤3，为越来越大的项集确定支持度，直到没有待检查的新项集</li></ol></li><li>寻找具有高置信度或高提升度的关联规则<ul><li>因为置信度和提升度都是基于支持度计算出来的，因此一旦识别出具有高支持度的项集，寻找关联规则就不会那么费劲了</li></ul></li></ul><h4 id="局限性-2"><a href="#局限性-2" class="headerlink" title="局限性"></a>局限性</h4><ul><li>计算成本高：当库存量很大或者支持度阈值很低时，候选项集仍然会很多</li><li>假关联：当元素的数量很大时，偶尔会出现假关联，为了确保所发现的关联规则具有普遍性，应该对他们进行验证</li><li>弥补局限性的方法：使用高级数据结构对候选项集进行更高效的分类，从而减少比较的次数</li></ul><h4 id="小结-3"><a href="#小结-3" class="headerlink" title="小结"></a>小结</h4><ul><li>关联规则用于揭示某一元素出现的频率以及它与其他元素的关系</li><li>识别关联规则的常用指标有3个<ol><li>{X} 的支持度表示 X 项出现的频率</li><li>{X-&gt;Y} 的置信度表示当 X 项出现时，Y 项同时出现的频率</li><li>{X-&gt;Y} 的提升度表示 X 项和 Y 项一同出现的频率，并且考虑每项各自出现的频率</li><li>利用先验原则可以淘汰一大部分非频繁项集，从而大大地加快搜索频繁相机的速度</li></ol></li></ul><h3 id="社会网络分析"><a href="#社会网络分析" class="headerlink" title="社会网络分析"></a>社会网络分析</h3><h4 id="Louvain-方法（Louvain-method）"><a href="#Louvain-方法（Louvain-method）" class="headerlink" title="Louvain 方法（Louvain method）"></a>Louvain 方法（Louvain method）</h4><ul><li>通过对节点分组可以找出网络中存在的群组，研究这些群组有助于理解网络各部分的区别和联系</li><li>Louvain 方法用来在网络中找出群组，它会尝试使用不同的聚类配置来做如下两种事：<ol><li>同一群组中各个节点间的边数和强度最大化</li><li>把属于不同群组的节点间的边数和强度最小化</li></ol></li><li>模块度用于表示上述两件事的完成程度，模块度越高，群组越理想</li><li>为了获得理想的聚类配置，Louvain 方法会不断迭代<ol><li>把每个节点看作一个群组，即一开始群组数和节点数相同</li><li>把一个节点重新分配给对提高模块度有最大帮助的群组，如果无法进一步提高，模块度节点保持不动，针对每个节点重复这个过程直到不能再分配</li><li>把步骤2中发现的每个群组作为一个节点构建出一个粗粒度网络，并且把以前的群间边合并成连接新结点且带权重的边</li><li>重复步骤2和步骤3直到无法再重新分配和合并</li></ol></li><li>Louvain 方法先发现小群组，然后在适当的情况下合并它们，帮助我们找出更重要的群组，但它有一定的局限性<ul><li>重要但较小的群组可能会被合并：需要检查在中间迭代阶段被发现的群组，如果有必要就把它们保留下来</li><li>有多种可能的聚类配置：若网络中包含重叠或嵌套的群组，需要依据其他信息源对群组予以验证</li></ul></li></ul><h4 id="PageRank-算法（PageRank-algorithm）"><a href="#PageRank-算法（PageRank-algorithm）" class="headerlink" title="PageRank 算法（PageRank algorithm）"></a>PageRank 算法（PageRank algorithm）</h4><ul><li>虽然群组可以反映出相互作用高度集中的区域，但是这些相互作用可能受占主导地位的节点支配，群组则围绕着这些主导节点形成，为了找出占主导地位的节点，需要对节点进行排序</li><li>PageRank 算法是谷歌公司最初用来为网页排名的算法之一，以 Larry Page 的姓氏命名</li><li>在PageRank 算法中，决定一个网页排名的因素有如下3个：<ol><li>链接数量：被其他网页链接的次数越多，该网页的访问者可能就越多</li><li>链接强度：这些链接被访问的次数越多，该网页的流量就越大</li><li>链接来源：如果被其他有较高排名的网页链接，那么该网页的排名也会升高</li></ol></li><li>尽管 PageRank 算法易于使用，但它有偏向于旧节点的局限性：如果一个新网页包含非常棒的内容但一开始访问者人数很少，那么它的排名就比较低</li><li>可以定期更新 PageRank 值，让新网页随着自身知名度的提高获得提高排名的机会</li></ul><h4 id="小结-4"><a href="#小结-4" class="headerlink" title="小结"></a>小结</h4><ul><li>社会网络分析可用于绘制和分析多个实体之间的关系</li><li>Louvain 方法用于在一个网络中找出群组，具体做法是将群组内部的相互作用最大化，同时把群组之间的相互作用最小化，当群组大小相同且相互分离时，该方法的效果最佳</li><li>PageRank 算法根据链接的数量强度以及来源对网络中的节点进行排序，这个算法有助于找出网络中占主导地位的节点，但对链接数不太多的新节点并不友好</li></ul><h3 id="回归分析（regression-analysis）"><a href="#回归分析（regression-analysis）" class="headerlink" title="回归分析（regression analysis）"></a>回归分析（regression analysis）</h3><h4 id="趋势线"><a href="#趋势线" class="headerlink" title="趋势线"></a>趋势线</h4><ul><li>趋势线是做预测时常用的工具，他们很容易生成，也很容易理解</li><li>一般的趋势往往只涉及单个预测变量，这个变量用来产生预测结果，不过通过添加更多预测变量可以改善预测结果</li><li>回归分析不但可以通过考虑更多预测变量改善预测结果，还可以比较各个预测变量的强弱</li></ul><h4 id="梯度下降法（gradient-decent）"><a href="#梯度下降法（gradient-decent）" class="headerlink" title="梯度下降法（gradient decent）"></a>梯度下降法（gradient decent）</h4><ul><li>在回归分析中预测变量的权重是主要参数，通过解方程可以求得最优权重</li><li>梯度下降法先初步猜测合适的权重组合，再通过一个迭代过程，把这些权重应用于每个数据点做预测，然后调整权重以减少整体预测误差</li><li>这个过程类似于一步步走到山底下，每走一步梯度下降法都要判断从哪个方向下是最陡峭的，然后朝着那个方向重新校准权重，最终到达最低点，这个点的预测误差最小（经过优化的回归趋势线与梯度上的最低点相对应）</li><li>除了回归之外，梯度下降法也能用来优化其他模型中的参数，比如支持向量机和神经网络</li><li>梯度下降法的结果可能会受到初始参数值（下山起点）的影响，若起点下方恰好有一个小凹坑，那么梯度下降法可能会将其误认为是最优点</li><li>为了降低陷入这种凹坑的风险，可以使用随机梯度下降法，每次迭代并不是采用所有的数据点，而是只从其中选取一个来调整参数，引入多变性，有助于算法逃离凹坑</li></ul><h4 id="回归系数"><a href="#回归系数" class="headerlink" title="回归系数"></a>回归系数</h4><ul><li>在为回归预测变量求得最佳权重之后，需要对它们进行解释</li><li>回归系数：回归预测变量权重，它表示某个预测变量相比于其他预测变量的影响大小</li><li>预测变量的度量单位不同也会影响对回归系数的解释，因此应该在做回归分析之前先对预测变量的度量单位进行标准化，经过标准化之后预测变量的系数被称为标准化回归系数</li></ul><h4 id="相关系数（correlation-coefficient）"><a href="#相关系数（correlation-coefficient）" class="headerlink" title="相关系数（correlation coefficient）"></a>相关系数（correlation coefficient）</h4><ul><li>相关系数：当只存在一个预测变量时，该预测变量的标准化回归系数</li><li>关联方向：相关系数为正表示预测变量和结果变化的方向一致，为负则表示两者变化方向相反</li><li>关联强度：r 值越接近于 -1 或 1，预测变量的作用就越大，若值为 0 则表示预测变量和结果之间不存在关系</li><li>因为相关系数表示单个预测变量的绝对强度，所以相比于回归系数，相关系数在对预测变量进行排序时更可靠</li></ul><h4 id="局限性-3"><a href="#局限性-3" class="headerlink" title="局限性"></a>局限性</h4><ul><li>对异常值敏感：回归分析平等地对待所有的数据点，只要存在几个有异常值的数据点，就会给趋势线造成很大的影响，因此在做进一步分析之前，可以先使用散点图找出异常值</li><li>多重共线性问题（multicollinearity）：如果回归模型包含高度相关的预测变量，就会造成相关预测变量权重失真，因此可以使用更高级的技术，如套索回归或岭回归</li><li>弯曲的趋势：需要对预测变量的值进行转换，或使用支持向量机等其他算法</li><li>并不说明存在因果关系</li></ul><h4 id="小结-5"><a href="#小结-5" class="headerlink" title="小结"></a>小结</h4><ul><li>回归分析用于寻找最佳拟合线（best-fit line），使得尽可能多的数据点位于这条线上或附近</li><li>趋势线由带权重的组合预测变量得到，这些权重被称为回归系数，表示某个预测变量相对于其他预测变量的影响强度</li><li>以下情况下，回归分析的效果最好：<ol><li>预测变量之间的关系不强</li><li>无异常值</li><li>趋势可以用直线表示</li></ol></li></ul><h3 id="k-最近邻算法（k-Nearest-Neighbors）和异常检测"><a href="#k-最近邻算法（k-Nearest-Neighbors）和异常检测" class="headerlink" title="k 最近邻算法（k-Nearest Neighbors）和异常检测"></a>k 最近邻算法（k-Nearest Neighbors）和异常检测</h3><h4 id="k-最近邻算法"><a href="#k-最近邻算法" class="headerlink" title="k 最近邻算法"></a>k 最近邻算法</h4><ul><li>k 最近邻算法根据周围数据点的类型对某个数据点进行分类（物以类聚，人以群分）</li><li>在 k 最近邻算法中，参数 k 表示周围数据点的个数，选择 k 值的过程叫做参数调优，它对预测的准确度起着至关重要的作用</li><li>使用不同的 k 值进行拟合：<ul><li>如果 k 值太小，数据点只与最近的邻居匹配，并且随机造成所产生的误差也会被放大</li><li>如果 k 值太大，数据点会尝试与更远的邻居匹配，其中隐含的模式会被忽略</li><li>只有当 k 值恰到好处时，数据点才会参考合适数量的邻居，使得误差相互抵消，有利于揭示数据中隐藏的趋势</li></ul></li><li>为实现理想拟合并把误差降到最低，可以使用交叉验证法对参数 k 进行调优</li><li>对于二分类问题，可以把 k 设置成一个奇数，以避免出现平局的情况</li><li>除了用来为数据点分类，k 最近邻算法还可以通过合计周围数据点的值来预测连续值</li><li>通过使用加权平均值，能够进一步改善预测结果，离数据点越近的邻居，其值越能反映该数据点的真实值，因此赋给它的权重应该更大</li></ul><h4 id="异常检测"><a href="#异常检测" class="headerlink" title="异常检测"></a>异常检测</h4><ul><li>k 最近邻算法不仅可以用来预测数据点的类别和取值，还可以用来识别异常，比如检测欺诈行为</li><li>在异常检测的过程中还可能会有新发现，比如发现之前被忽略的预测变量</li><li>事实上任何能够产生预测模型的算法都可以用来检测异常，比如在回归分析中，如果某个数据点明显偏离最佳拟合线，那么就会被识别为异常点</li><li>异常数据点既可能因缺失预测变量所致，也可能因预测模型缺少足够的训练数据所致</li><li>一旦找到异常数据点，就要将它们从数据集中移除，然后再训练预测模型，减少数据中包含的噪声，进而提高模型的准确度</li></ul><h4 id="局限性-4"><a href="#局限性-4" class="headerlink" title="局限性"></a>局限性</h4><ul><li>类别不平衡：可以使用加权投票法来取代少数服从多数原则，确保较近数据点类别的权重比较远的更大</li><li>预测变量过多：在多个维度上识别和处理近邻会导致你计算量大增，需要降维（dimension reduction）</li></ul><h4 id="小结-6"><a href="#小结-6" class="headerlink" title="小结"></a>小结</h4><ul><li>k 最近邻算法根据周围数据点的类型对某个数据点进行分类</li><li>k 表示用作参考的数据点的个数，可以使用交叉验证法来确定</li><li>当预测变量数目不多，并且类别大小差别不大时，k 最近邻算法才能产生非常好的效果</li><li>不准确的分类可能会被标记为潜在异常</li></ul><h3 id="支持向量机（support-vector-machine）"><a href="#支持向量机（support-vector-machine）" class="headerlink" title="支持向量机（support vector machine）"></a>支持向量机（support vector machine）</h3><h4 id="勾画最佳分界线"><a href="#勾画最佳分界线" class="headerlink" title="勾画最佳分界线"></a>勾画最佳分界线</h4><ul><li>支持向量机的主要目标是得到一条能用于分组的最佳分界线，需要注意的是，能用于分组的分界线可能有很多条</li><li>为了找出最佳分界线，首先需要从一组中找出距离另一组最近的外围数据点，然后在两组的外围数据点之间画出最佳分界线，由于这些外围数据点在寻找最佳分界线的过程中起了支持作用，因此叫做支持向量</li><li>支持向量机的一个优点是计算速度很快，仅依靠外围数据点就能找到决策边界</li><li>这种对数据点子集的依赖也有缺点，这是因为决策边界对支持向量的位置比较敏感，选取不同的数据点作为训练数据，相应支持向量的位置也不同</li><li>支持向量机算法有一个关键特征——缓冲带<ul><li>缓冲带允许一定数量的训练数据点位于错误的一边，由此得到一条更软的分界线</li><li>缓冲带对异常值有更强的耐扰性，因此对新数据有更强的泛化能力</li><li>缓冲带通过调整惩罚参数得到，这个参数决定了对分类误差的宽容度，惩罚参数越大，宽容度就越大，缓冲带也就越宽</li><li>为了让模型对当前数据和新数据有较高的预测准确度，可以使用交叉验证法求得最佳惩罚参数</li></ul></li><li>支持向量机的另一个强项是找到决策边界的凸弧，它在发现错综复杂的凸弧时有着更出众的计算效率<ul><li>支持向量机的秘诀是核技巧（kernel trick）</li><li>支持向量机不会直接在在数据平面上绘制有凸弧的分界线，而是会首先把数据映射到高维空间，然后在高维空间中将数据点用直线分开，这些直线容易计算，并且当映射回低维空间时，也很容易转化成曲线</li></ul></li><li>支持向量机具备在高维空间操纵数据的能力，使得它在分析有多个变量的数据集时大受欢迎</li><li>支持向量机的常见应用场景包括遗传信息破译以及文本情感分析</li></ul><h4 id="局限性-5"><a href="#局限性-5" class="headerlink" title="局限性"></a>局限性</h4><ul><li>小数据集：由于支持向量机依靠支持向量确定决策边界，因此样本量少，用来对分界线进行准确定位的数据也少</li><li>多组数据：支持向量机每次只能对两组进行分类，如果存在2个以上的组，则需要对每一组都应用支持向量机（多类支持向量机）</li><li>两组之间存在大量重叠：靠近边界的数据点可能更容易发生分类错误，而且支持向量机没有给出每个数据点遭遇错误分类的概率，但可以通过数据点到决策边界的距离来估计其被正确分类的可能性</li></ul><h4 id="小结-7"><a href="#小结-7" class="headerlink" title="小结"></a>小结</h4><ul><li>支持向量机用来把数据点分为两组，其方法是在两组的外围数据点（支持向量）的中间画一条分界线</li><li>支持向量机对异常值有较好的容忍度，它通过一个缓冲带允许少量数据点位于错误的一边，此外他还通过核技巧高效地求得带凸弧的决策边界</li><li>当需要把大样本中的数据点分为两组时，支持向量机能够发挥最佳作用</li></ul><h3 id="决策树（decision-tree）"><a href="#决策树（decision-tree）" class="headerlink" title="决策树（decision tree）"></a>决策树（decision tree）</h3><h4 id="生成决策树"><a href="#生成决策树" class="headerlink" title="生成决策树"></a>生成决策树</h4><ul><li>递归拆分（recursive partitioning）<ol><li>确定一个二元选择题，它能够把数据点拆分成两组，并最大限度地提高每组数据点的同质性</li><li>针对每个叶结点重复步骤1，直到满足终止条件</li></ol></li><li>终止条件可能有多个，可以使用交叉验证法进行选取<ul><li>每个叶节点的数据全属于同一类或有相同的值</li><li>叶节点包含的数据点少于5个</li><li>进一步分支会超出阈值并且不能提高同质性</li></ul></li><li>由于递归拆分只用最佳二元选择题来生成决策树，因此不显著的变量并不会影响结果</li><li>而且二元选择题往往围绕着最重要的值划分数据点，所以决策树对异常值有较强的耐扰性</li><li>决策树易于可视化，使我们更容易评估预测变量及其相互作用</li></ul><h4 id="局限性-6"><a href="#局限性-6" class="headerlink" title="局限性"></a>局限性</h4><ul><li>不稳定：决策树是通过把数据点分组生成的，数据中的细微变化可能影响拆分结果，并导致生成的决策树截然不同</li><li>容易产生过拟合：决策树每次拆分数据点时都力求找到最佳拆分方式</li><li>不准确：一开始就是用最佳二元选择题拆分数据点并不能保证结果最准确</li><li>弥补局限性的方法：每次拆分时可以不采用最佳拆分方式，而是尽量让决策树多样化，然后综合不同的决策树产生的预测结果，让最终预测结果具有更好的稳定性和准确性</li></ul><h4 id="决策树的多样化方法"><a href="#决策树的多样化方法" class="headerlink" title="决策树的多样化方法"></a>决策树的多样化方法</h4><ul><li>随机森林：随机选择不同的二元选择题，生成多棵决策树，然后综合这些决策树的预测结果</li><li>梯度提升（gradient boosting）：有策略地选择二元选择题，以逐步提高决策树的预测准确度，然后将所有的预测结果的加权平均数作为最终结果</li></ul><p>虽然随机森林的和梯度提升能够产生更准确的预测结果，但是它们往往比较复杂并且很难进行可视化（黑盒）</p><h4 id="小结-8"><a href="#小结-8" class="headerlink" title="小结"></a>小结</h4><ul><li>决策树通过询问一系列二元选择题来做预测</li><li>若想生成决策树，就要不断拆分数据样本以获得同质组，直到满足终止条件，这个过程被称为递归拆分</li><li>虽然决策树易于使用和理解，但是容易造成过拟合问题，导致出现不一致的结果，为了尽量避免出现这种情况，可以采用随机森林等替代方法</li></ul><h3 id="随机森林"><a href="#随机森林" class="headerlink" title="随机森林"></a>随机森林</h3><h4 id="集成模型"><a href="#集成模型" class="headerlink" title="集成模型"></a>集成模型</h4><ul><li>集成方法（ensembling）：通过组合有不同优缺点的模型来提高预测准确度的方法</li><li>集成模型：通过组合许多模型的预测结果得到的预测模型，在组合模型时，既可以遵循少数服从多数的原则，也可以取平均值</li><li>随机森林是决策树的集成模型</li><li>相比于子模型，集成模型的预测准确度更高，这是因为准确的预测模型会彼此强化，错误的则会彼此抵消<ul><li>为了达到这种效果，集成模型的子模型一定不能犯同类错误，换言之，子模型必须是不相关的</li></ul></li><li>自助聚集法：用来生成不相关的决策树的系统化方法</li></ul><h4 id="自助聚集法（bootstrap-aggregating）"><a href="#自助聚集法（bootstrap-aggregating）" class="headerlink" title="自助聚集法（bootstrap aggregating）"></a>自助聚集法（bootstrap aggregating）</h4><ul><li>自助聚集法用来生成数千棵决策树，这些树彼此有明显的不同</li><li>为使决策树之间的关联度最小化，每棵树都由训练数据集的一个随机子集产生，并且使用的是预测变量的一个随机子集，这让生成的决策树各不相同，但仍然保留了一定的预测能力</li><li>通过限制每次拆分时所用的预测变量，能够生成各不相同的决策树，从而避免发生过拟合问题</li><li>为进一步降低发生过拟合问题的可能性，可以增加随机森林中决策树的数量，使模型更通用、更准确</li></ul><h4 id="局限性-7"><a href="#局限性-7" class="headerlink" title="局限性"></a>局限性</h4><ul><li>随机森林由随机生成的决策树组成，并不存在明确的预测规则，这种不可解释性可能会带来一些伦理问题</li><li>因此随机森林适用于那些预测准确度比可解释性更重要的场合</li></ul><h4 id="小结-9"><a href="#小结-9" class="headerlink" title="小结"></a>小结</h4><ul><li>随机森林的预测结果往往比单棵决策树更准确，这是因为它充分利用了两种技术：自助聚集法和集成方法</li><li>自助聚集法通过随机限制数据拆分过程所用的变量来生成一系列不相关的决策树</li><li>集成方法则把决策树的预测结果组合在一起</li><li>虽然随机森林的预测结果不具有可解释性，但仍然可以根据对预测结果的贡献度大小对各个预测变量进行排序</li></ul><h3 id="神经网络（neural-network）"><a href="#神经网络（neural-network）" class="headerlink" title="神经网络（neural network）"></a>神经网络（neural network）</h3><h4 id="神经网络的诞生"><a href="#神经网络的诞生" class="headerlink" title="神经网络的诞生"></a>神经网络的诞生</h4><ul><li>数据存储和共享技术取得进步：为训练神经网络提供了海量数据，有助于改善神经网络的性能</li><li>计算能力越来越强大：GPU的运行速度最快能达到CPU的150倍，能为在大数据集上训练神经网络提供强大的支持</li><li>算法获得改进</li></ul><h4 id="神经网络的构成"><a href="#神经网络的构成" class="headerlink" title="神经网络的构成"></a>神经网络的构成</h4><ul><li>输入层：该层处理输入图像的每个像素<ul><li>为提高预测准确度，可以使用卷积层</li><li>卷积层并不处理单个像素，而是识别像素组合的特征，这种分析只关注特征是否出现而不关注出现的位置</li><li>所以即使某些关键特征偏离了中心，神经网络仍然能够正确识别，这种特性叫做平移不变性（translational invariance）</li></ul></li><li>隐藏层：在像素进入神经网络之后，通过层层转换不断提高和那些标签已知的图像的相似度<ul><li>标签已知是指神经网络以前见过这些图像</li><li>虽然转换得越多，预测准确度就会越高，但是处理时间就会明显增加，一般来说几个隐藏层就足够了</li><li>每层的神经元数量要和图像的像素数成比例</li></ul></li><li>输出层：该层产生最终预测结果，在这一层中神经元可以只有一个，也可以和结果一样多</li><li>损失层：该层通常位于最后，并提供有关输入是否识别正确的反馈，如果不正确则给出误差量<ul><li>在训练神经网络的过程中，损失层至关重要，若预测准确，来自于损失层的反馈会强化产生该预测结果的激活路径</li><li>若预测错误，则错误会沿着路径逆向返回，这条路径上的神经元的激活条件就会被重新调整，以减少错误，这个过程称为反向传播（back propagation）</li></ul></li><li>通过不断重复这个训练过程，神经网络会学习输入信号和正确输出标签之间的联系，并且把这些联系作为激活规则（activation rule）编入每个神经元，因此为了提高神经网络的预测准确度，需要调整管理激活规则的部件</li></ul><h4 id="激活规则"><a href="#激活规则" class="headerlink" title="激活规则"></a>激活规则</h4><ul><li>为了产生预测结果，需要沿着一条路径依次激活神经元，每个神经元的激活过程都由其激活规则所控制，激活规则指定了输入信号的来源和强度，在神经网络的训练过程中激活规则会不断调整</li><li>良好的激活规则有助于产生准确的预测结果，其关键在于确定合适的权重和阈值</li><li>另外神经网络的其他参数也需要调整，比如隐藏层的数量、每层的神经元数量等。可以使用梯度下降法优化这些参数</li></ul><h4 id="局限性-8"><a href="#局限性-8" class="headerlink" title="局限性"></a>局限性</h4><ul><li>需要大样本：神经网络的复杂性使之能够识别带有复杂特征的输入，但前提是我们能为他提供大量训练数据，如果训练集太小就会出现过拟合问题</li><li>降低过拟合风险：<ul><li>二次取样（subsampling）：为了降低神经元对噪声的敏感度，需要对神经网络的输入进行平滑化处理，即针对信号样本取平均值</li><li>畸变：当缺少训练数据时，可以通过向每幅图像引入畸变，来产生更多数据，每幅畸变图像都可以作为新的输入，以此扩大训练数据的规模，畸变应该能够反映原数据集的特征（弹性变形）</li><li>丢弃（dropout）：为解决小的神经元集群之间彼此产生过度依赖，可以在训练期间随机丢弃一半的神经元，这些遭丢弃的神经元将处于未激活的状态，剩下的神经元则正常工作，下一次训练丢弃一组不同的神经元，迫使不同的神经元协同工作，从而揭示训练样本所包含的更多特征</li></ul></li><li>计算成本高：训练一个由几千个神经元组成的神经网络可能需要很长时间，一个简单的解决方法是升级硬件</li><li>另一个解决方法是调整算法，用稍低一些的预测准确度换取更快的处理速度<ul><li>随机梯度下降法：为了更新某一个参数，经典的梯度下降法在一次迭代中使用所有的训练样本，当数据集很大时这样做会耗时，随机梯度下降法是在每次迭代中只用一个训练样本来更新参数，虽然使用这个方法得到的最终参数可能不是最优的，但是准确度不会太低</li><li>小批次梯度下降法：虽然使用随机梯度下降法能够提升速度，但最终参数可能不准确，算法也可能无法收敛，导致某个参数上下波动，小批次梯度下降法是每次迭代使用训练样本的一个子集</li><li>全连接层：随着加入的神经元越来越多，路径的数量呈指数增长，为避免查看所有可能的组合，可以使初始层（处理更小、更低级的特征）的神经元部分连接，只有最后几层（处理更大、更高级的特征）才对相邻层的神经元进行全连接</li></ul></li><li>不可解释：神经网络由多层组成，每层都有几百个神经元，这些神经元有不同的激活规则控制，这使得我们很难准确地找到产生正确预测结果的输入信号组合<ul><li>但和回归分析不同，回归分析能明确地识别重要的预测变量，并比较它们的强度，神经网络的特性使之难以证明其使用得当，在涉及伦理问题时尤其如此</li></ul></li><li>尽管存在上述局限性，但是神经网络本身拥有的强大能力，使之得以应用于虚拟助手、自动驾驶等前沿领域，随着算法不断改进以及计算能力不断提升，神经网络将在物联网时代发挥关键作用</li></ul><h4 id="小结-10"><a href="#小结-10" class="headerlink" title="小结"></a>小结</h4><ul><li>神经网络由多个神经元组成，训练期间，第1层的神经元首先被输入数据激活，然后将激活状态传播到后续各层的神经元，最终在输出层产生预测结果</li><li>一个神经元是否被激活取决于输入信号的来源和强度，这由其激活规则指定，激活规则会根据预测结果的反馈不断调整，这个过程被称为反向传播</li><li>在大数据集和先进的计算硬件可用的情况下，神经网络的表现最好，然而预测结果在大部分的时候都是无法解释的</li></ul><h3 id="A-B-测试（A-B-testing）和多臂老虎机（multi-arm-bandit-problem）"><a href="#A-B-测试（A-B-testing）和多臂老虎机（multi-arm-bandit-problem）" class="headerlink" title="A/B 测试（A/B testing）和多臂老虎机（multi-arm bandit problem）"></a>A/B 测试（A/B testing）和多臂老虎机（multi-arm bandit problem）</h3><h4 id="A-B-测试的局限性"><a href="#A-B-测试的局限性" class="headerlink" title="A/B 测试的局限性"></a>A/B 测试的局限性</h4><ul><li>测试结果具有偶然性：为提高测试结果的可信度可以增加受测人数，但是会导致另一个问题</li><li>潜在的收入损失：如果把受测顾客增加一倍，那么看到糟糕广告的人数也会增加一倍，这有流失的顾客的风险</li><li>这两个问题体现了 A/B 测试中的两个权衡因素：探索和利用</li></ul><h4 id="epsilon-递减策略（epsilon-decreasing-strategy）"><a href="#epsilon-递减策略（epsilon-decreasing-strategy）" class="headerlink" title="epsilon 递减策略（epsilon-decreasing strategy）"></a>epsilon 递减策略（epsilon-decreasing strategy）</h4><ul><li>epsilon 指的是探索时间与总时间的比例，随着对效果较好的广告越来越有信心，我们使 epsilon 值递减，这个方法属于强化学习的范畴</li><li>A/B 测试由探索和利用前后两个阶段组成，而在 epsilon 递减策略中，探索阶段和利用阶段是分散的，并且一开始时探索得多一些，越接近尾声，探索得越少</li></ul><h4 id="多臂老虎机"><a href="#多臂老虎机" class="headerlink" title="多臂老虎机"></a>多臂老虎机</h4><ul><li>假设有两台老虎机 A 和 B 可供选择，玩2000个回合，每个回合要么赢1美元，要么没有收益，老虎机 A 的返还率为50%，老虎机 B 的则为40%，但我们事先并不知道这些信息，问要怎么玩才能多赢钱？<ul><li>全探索：如果随机选择老虎机，平均会赢900美元</li><li>A/B 测试：用前200个回合探索哪台老虎机的返还率更高，然后在剩下的1800个回合中选择这台老虎机，平均会赢976美元，但由于两台老虎机的返还率接近，由此存在误判的可能性（误判概率8%）</li><li>为降低误判的风险，可以把A/B 测试的探索范围扩大到500个回合，这样做可以把误判概率降到1%，但是平均中奖金额也会减少到963美元</li><li>epsilon 递减策略：如果采用 epsilon 递减策略边探索边利用，平均会赢984美元，并且误判概率为4%，通过增加探索比例（增加 epsilon 值）能够降低误判概率，但仍会减少平均中奖金额</li><li>全利用：如果一开始就掌握内部消息并选择返还率最高的老虎机 A，平均会赢1000美元，但这个假设不现实</li></ul></li><li>由此看到，在不掌握内部消息的情况下，采用 epsilon 递减策略的收益最高，而且由于存在收敛性这一数学特征，由此 epsilon 递减策略能确保在回合数足够多的情况下找出返还率最高的老虎机</li><li>胜者为先：范加尔在曼联采用了一个非常规策略来决定罚点球的球员，第一个被指定罚点球的球员会负责到底，除非他没有打进球，接下来新换的球员继续负责罚点球，如果没有罚进就再换一名球员，依此类推<ul><li>频繁地换老虎机，会导致探索过多而利用过少，只比随机选择老虎机稍好一些，而且胜者为先策略只根据上一次的结果来评估老虎机，这忽略了老虎机之前的表现</li></ul></li></ul><h4 id="epsilon-递减策略的局限性"><a href="#epsilon-递减策略的局限性" class="headerlink" title="epsilon 递减策略的局限性"></a>epsilon 递减策略的局限性</h4><ul><li>采用 epsilon 递减策略的关键在于控制好 epsilon 值，如果 epsilon 值递减的过慢，就会失去利用老虎机的机会，而如果递减得过快，就可能会选错老虎机</li><li>epsilon 值的最佳递减速度主要取决于两台老虎机返还率的相似程度，采用汤普森取样方法，可以计算 epsilon 值</li><li>epsilon 递减策略还依赖于如下假设：<ul><li>返还率恒定不变</li><li>返还率与上一次游戏无关</li><li>玩游戏和观察返还率之间的延迟极小</li></ul></li></ul><h4 id="小结-11"><a href="#小结-11" class="headerlink" title="小结"></a>小结</h4><ul><li>多臂老虎机问题的实质是如何以最佳方式分配资源</li><li>一种策略是先探索可用选项，然后把所有剩余资源分配给表现最佳的选项，这个策略叫做 A/B 测试</li><li>另一个策略是给表现最佳的选项，逐渐分配更多的资源，这个策略叫做 epsilon 递减策略</li><li>虽然 epsilon 递减策略在大多数情况下能够提供比 A/B 测试更高的回报，但是确定资源分配的最佳更新速度并非易事</li></ul><h3 id="更多评价指标"><a href="#更多评价指标" class="headerlink" title="更多评价指标"></a>更多评价指标</h3><h4 id="分类指标"><a href="#分类指标" class="headerlink" title="分类指标"></a>分类指标</h4><ul><li>接受者操作特征曲线下面积（曲线下面积）：这个指标允许我们在最大化正例率和最小化假正例率之间做权衡<ul><li>正例率：被模型正确预测为正类别的样本所占的比例</li><li>正例率 = 正例数 / ( 正例数 + 假负例数 )</li><li>假正例率：被模型错误预测为正类别的样本所占的比例</li><li>假正例率 = 假正例数 / ( 假正例数 + 负例数 )</li><li>在极端情况下，可以把所有样本全部预测为正类别，以此实现正例率最大化（正例率为1），虽然这样做可以避免出现假负例但会明显增加假正例</li><li>接受者操作特征曲线（ROC 曲线）体现了最大化正例率和最小化假正例率之间的权衡</li><li>模型性能通过 ROC 曲线下方的面积来衡量，所以该指标被称为曲线下面积，模型的准确度越高，曲线越靠近左上角</li><li>完美的预测模型会产生一条曲线下面积为1的曲线（曲线下面积等于整个图形的面积）</li></ul></li><li>对数损失指标利用置信度来校正其对预测误差的惩罚，具体来说，模型对错误预测的置信度越高，惩罚就越重<ul><li>由于对数损失指标根据对预测结果的置信度来调整惩罚程度，因此它通常用于错误预测极其有害的情况</li></ul></li></ul><h4 id="回归指标"><a href="#回归指标" class="headerlink" title="回归指标"></a>回归指标</h4><ul><li>平均绝对误差：平等的惩罚所有预测误差，具体做法是对所有数据点的预测值和实际值之差取平均值</li><li>除了考虑误差大小之外，还可以通过均方根对数误差把误差方向纳入考虑范围</li></ul>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;机器学习算法是数据科学的力量之源，它和数据一起产生极其宝贵的知识并且帮助我们以新的方式利用已有信息。&lt;a href=&quot;https://book.douban.com/subject/30442187/&quot;&gt;白话机器学习算法&lt;/a&gt;一书用通俗易懂的语言以及大量有趣的示例和插图讲解10多种前沿的机器学习算法。内容涵盖k均值聚类、主成分分析、关联规则、社会网络分析等无监督学习算法，以及回归分析、k最近邻、支持向量机、决策树、随机森林、神经网络等监督学习算法，并概述强化学习算法的思想。以下为阅读过程中所作的读书笔记，可供参考。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="读书笔记" scheme="http://blog.zhuangzhihao.top/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>计算机组成原理（下）</title>
    <link href="http://blog.zhuangzhihao.top/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E4%B8%8B/"/>
    <id>http://blog.zhuangzhihao.top/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E4%B8%8B/</id>
    <published>2021-10-11T16:00:00.000Z</published>
    <updated>2021-11-26T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>计算机组成原理是计算机专业本科教学中的重要课程，它可以帮助我们系统地理解计算机硬件系统的组织结构和工作原理、掌握计算机硬件系统的基本分析与设计方法以及建立计算机系统的整体概念，为进一步学习计算机设计实践课程、培养系统开发、调试以及设计创新能力奠定良好的基础。计组是考研的最重最难点，在408计算机学科专业基础综合考试中占有45分。我选择的课程是哈工大的<a href="https://www.icourse163.org/course/hit-309001">国家精品课</a>，配合天勤高分笔记，以下为所记课堂笔记下半部分，包含CPU、总线和I/O系统的知识点，可供参考。上半部分笔记请访问<a href="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E4%B8%8A">计算机组成原理（上）</a></p></blockquote><a id="more"></a><h3 id="中央处理器"><a href="#中央处理器" class="headerlink" title="中央处理器"></a>中央处理器</h3><h4 id="计算机工作过程"><a href="#计算机工作过程" class="headerlink" title="计算机工作过程"></a>计算机工作过程</h4><ul><li>加电——》产生reset信号——》执行程序——》停机——》停电</li><li>产生reset信号的任务<ul><li>任务一：使计算机处于初始状态</li><li>任务二：从PC中取出指令地址</li></ul></li><li>控制器作用是协调并控制计算机各部件执行程序的指令序列</li></ul><h4 id="控制器的组成"><a href="#控制器的组成" class="headerlink" title="控制器的组成"></a>控制器的组成</h4><ul><li>控制器的功能<ul><li>取指令：发出指令地址，取出指令的内容</li></ul></li><li>分析指令<ul><li>对操作码译码产生操作相应部件的控制信号</li><li>根据寻址方式形成操作数地址</li></ul></li><li>执行指令<ul><li>根据分析指令后产生控制信号、操作数地址信号序列，通过CPU及输入输出设备的执行实现每条指令的功能</li><li>结果回送存储器</li><li>形成下条指令的地址</li></ul></li><li>控制程序和数据的输入和结果输出</li><li>对异常情况和某些请求的处理<ul><li>异常情况的处理：例如算术运算的溢出、数据传送奇偶错</li><li>某些请求的处理</li><li>“中断请求”信号</li><li>DMA请求信号</li></ul></li><li>控制器的组成<ul><li>程序计数器（PC）：即地址寄存器，用来存放当前正在执行的指令地址或即将要执行的下一条指令地址</li><li>指令寄存器（IR）：用以存放当前正在执行的指令，以便在指令执行过程中控制完成一条指令的全部功能</li><li>指令译码器或操作码译码器：对指令寄存器中的操作码进行分析解释，产生相应的控制信号</li><li>脉冲源及启停线路：脉冲源参数一定评率的脉冲作为整个机器的时钟脉冲，是机器周期和工作脉冲的基准信号，在机器刚加电时，还应产生一个总清信号（reset）</li><li>时序控制信号形成部件：当程序启动后，在CLK时钟作用下，根据当前正在执行的指令的需要，产生相应的时序控制信号，并根据被控制功能部件的反馈信号调整时序控制信号<ul><li>控制存储器</li><li>微指令寄存器：控制字段+下址</li></ul></li></ul></li><li>周期概念<ul><li>指令周期：完成一条指令所需的时间，包括取指令、分析指令、执行指令</li><li>机器周期：也称为CPU周期，是CPU从内存中读取一个指令的时间，通常等于取指周期</li><li>时钟周期：称为节拍脉冲或T周期，是基准脉冲信号</li><li>三条假设<ul><li>程序是存放在主存中的，当执行完一条指令后才从主存中取下一条指令（非流水线）</li><li>指令的长度是固定的，并限制了寻址方式的多样化</li><li>在程序运行前，程序和数据都已存在主存中</li></ul></li></ul></li><li>指令执行过程（运算器和控制器配合）</li><li>组成控制器的基本电路<ul><li>具有记忆功能的触发器以及由它组成的寄存器，计数器和存储单元</li><li>没有记忆功能的门电路及由它组成的加法器，算术逻辑运算单元（ALU）和各种逻辑电路</li></ul></li><li>控制器的功能就是按每一条指令的要求产生所需的控制信号</li><li>产生控制信号的方法<ul><li>微程序控制</li><li>硬布线控制</li></ul></li></ul><h4 id="微程序控制计算机的基本工作原理"><a href="#微程序控制计算机的基本工作原理" class="headerlink" title="微程序控制计算机的基本工作原理"></a>微程序控制计算机的基本工作原理</h4><ul><li>微指令：在微程序控制的计算机中，将由同时发出的控制信号所执行的一组微操作</li><li>微命令：将指令分为若干条微指令，按次序执行这些微指令。组成微指令的操作即微命令</li><li>微程序：计算机的程序由指令序列构成，而计算机每条指令的功能均由微指令序列解释完成，这些微指令序列的集合就叫做微程序</li><li>控制存储器<ul><li>微程序一般是存放在专门的存储器中的，由于该存储器主要存放控制命令（信号）与下一条执行的微指令地址（简称下址）</li><li>存储单元内容<ul><li>微指令的控制信号——控制位</li><li>下条微指令的地址——下址字段</li></ul></li><li>存储芯片：ROM</li></ul></li><li>执行一条指令实际上就是执行一段存放在控制存储器中的微程序</li><li>实现微程序控制的基本原理<ul><li>控制信号（23条）</li><li>加法的过程</li><li>微指令格式：控制字段+下址字段</li><li>23个控制位，12个下址位——》容量为4K</li><li>取址微指令的操作对所有指令都是相同的，所以是一条公用的微指令，其下址由操作码译码产生</li></ul></li><li>微程序控制器</li><li>时序信号及工作脉冲的形成</li><li>停机和停电的区别</li><li>停机：电压稳定、存放内容保持、重启PC内容为断点指令地址</li><li>停电：电压消失、RAM的内容消失、重启PC内容为第一条指令地址</li></ul><h4 id="微程序设计技术"><a href="#微程序设计技术" class="headerlink" title="微程序设计技术"></a>微程序设计技术</h4><ul><li>如何缩短微指令字长<ul><li>直接控制法（容量太小）<ul><li>编译方法：每一位代表一个控制信号，直接送往相应的控制点</li><li>优点：控制简单</li><li>缺点：微指令字长过大</li></ul></li><li>字段直接编译法<ul><li>选出互斥的微指令</li><li>每个字段都要留出一个代码，表示本段不发出任何指令（000）</li><li>优点：节省微指令的字长</li><li>缺点：增加了额外的硬件开销</li></ul></li><li>字段间接编译法<ul><li>指令之间相互联系的情况</li><li>举例：A为0-7，B为0-3，如果是直接编译——3+2=5，如果是间接编译——3+1=4</li><li>编码方法：在字段直接编译法中，译码输出端要兼由另一字段中的某些微命令配合解释</li><li>优点：减少了微指令长度</li><li>缺点：可能削弱微指令的并行控制能力，同时增加硬件开销</li></ul></li><li>常熟源字段E</li></ul></li><li>如何减少微指令长度<ul><li>现行微指令/微地址<ul><li>现行微指令：当前正在执行的指令</li><li>现行微地址：存放现行微指令的控制器存储单元</li></ul></li><li>后继微指令/微地址<ul><li>后继微指令：下一条要执行的微指令</li><li>后继微地址：存放后继微指令的控制器存储单元</li></ul></li><li>增量与下址字段结合产生后继微指令的方法<ul><li>下址字段分成：转移控制字段BCF和转移地址字段BAF<ul><li>BCF：控制微程序的转移情况</li><li>BAF：转移后的微指令所在地址</li></ul></li><li>BAF有两种情况<ul><li>与uPC的位数相等——转移灵活，但增加微指令长度</li><li>比uPC短——转移地址收到限制，但可缩短微指令长度</li></ul></li><li>优点：微指令的下址字段很短，仅用于选择输入uPC计数器的某条线路有效</li><li>缺点：微程序转移不灵活，使得微程序在控存中的物理空间分配有困难</li></ul></li><li>多路转移方式：一条微指令存在多个转移分支的情况称为多路转移</li><li>微中断<ul><li>微中断请求信号是由程序中断请求信号引起的</li><li>在完成现行指令的微程序后响应该微中断请求</li><li>由硬件产生对应微中断处理程序在控存中的入口地址</li></ul></li></ul></li><li>如何提高微程序的执行速度<ul><li>微指令格式</li><li>水平型微指令——直接控制，字段编译（直接、间接）<ul><li>特点：在一条微指令中定义并并行执行多个微命令</li></ul></li><li>垂直型微指令<ul><li>特点：不强调实现微指令的并行控制功能</li><li>定义：采用微操作码编译法，由操作码规定微指令的功能</li></ul></li><li>微程序控制存储器<ul><li>一般采用ROM存储器</li><li>也可采用RAM，为防止断电后内容消失，则必须开机后将外存中存放的微程序调入控存RAM，然后才能执行程序。</li><li>当前为了能不断扩展指令系统，通常采用ROM+RAM</li></ul></li><li>动态微程序设计<ul><li>定义：能根据用户要求改变微程序</li><li>优点：是计算机能更灵活、有效的适应于各种不同的应用目标</li></ul></li><li>控制存储器的操作<ul><li>串行方式</li><li>并行方式——比串行多了微指令寄存器</li><li>微周期=max(取微指令时间,执行微指令时间)</li><li>由于取微指令、执行微指令同时进行，故对于某些后继微地址的产生根据处理结果而定的微指令，则延迟一个微周期再取微指令</li></ul></li></ul></li></ul><h4 id="硬布线控制的计算机（RISC）——特点快"><a href="#硬布线控制的计算机（RISC）——特点快" class="headerlink" title="硬布线控制的计算机（RISC）——特点快"></a>硬布线控制的计算机（RISC）——特点快</h4><ul><li>形成操作控制信号的逻辑框图</li><li>操作控制信号的产生<ul><li>取值周期cy1所产生的信号对所有指令都是相同的，即与当前执行的指令无关，逻辑式得到最简单的形式</li><li>通常，同一个控制控制信号在若干条指令的某些周期（或再加上一些条件）中都需要，为此需要把它们组合起来</li><li>同种类型的指令所需要的控制信号大部分是相同的，仅有少量区别</li><li>在确定指令的操作码时（即对具体指令赋予二进制操作码），为了便于逻辑表达式的化简以减少逻辑电路数量，往往给予特别关注</li></ul></li><li>设计组合逻辑电路从而产生需要的控制信号的步骤<ol><li>实际逻辑问题</li><li>真值表</li><li>公式化简</li><li>逻辑电路图</li></ol></li><li>设计目标：使用最少的电路元件达到最高的操作速度</li></ul><h4 id="流水线工作原理"><a href="#流水线工作原理" class="headerlink" title="流水线工作原理"></a>流水线工作原理</h4><ul><li>每条指令的执行时间不变</li><li>每条指令处理结果的时间缩短</li><li>流水线处理速率最高时=流水线处于满载的稳定状态</li><li>流水线处理速率最低时=流水线未满载状态</li><li>为了满足在重叠时间段不同指令的机器周期能够完成指定的操作，将时间段=操作完成的最长时间</li><li>为了保证一个周期内流水线的输入信号不变，相邻时间段之间必须设置锁存器或寄存器</li><li>除了指令执行流水线，还有运算操作流水线</li><li>流水线阻塞<ul><li>数据相关产生</li><li>假设第二条指令需要的操作数是第一条指令运算的结果，那么出现了数据相关</li><li>指令执行时间不同产生</li><li>程序转移的影响</li><li>异常情况响应中断</li></ul></li></ul><h3 id="存储系统"><a href="#存储系统" class="headerlink" title="存储系统"></a>存储系统</h3><h4 id="存储系统的层次结构"><a href="#存储系统的层次结构" class="headerlink" title="存储系统的层次结构"></a>存储系统的层次结构</h4><ul><li>cache-&gt;主存-&gt;辅存</li></ul><h4 id="高速缓冲存储器"><a href="#高速缓冲存储器" class="headerlink" title="高速缓冲存储器"></a>高速缓冲存储器</h4><ul><li>cache的工作原理<ul><li>局部性原理</li><li>主存地址和cache地址（P166 图7.2）</li><li>块长：块长一般取一个主存周期所能调出的信息长度（一般为16个字）</li><li>cache的容量和块的大小是影响cache的效率的重要因素</li><li>命中率：CPU所要访问的信息是否在cache中的比率，而将所要访问的信息不在cache中的比率称为失败率</li><li>一致性策略<ul><li>标志交换方式（写回法）</li><li>通过式写入（写通法）</li><li>写操作直接对主存进行，而不写入cache</li></ul></li><li>cache的平均存取时间=h*tc+(1-h)(tc+tm)</li><li>最好替换策略：按照被替换的字块是下一段时间最少使用的，由替换部件实现</li></ul></li><li>cache组织地址映像<ul><li>直接映像<ul><li>cache中许多空的位置被浪费</li><li>主存地址：主存字块标记+cache字块地址+字块内地址</li></ul></li><li>全相联映像<ul><li>成本太高而不能采用</li><li>主存地址：主存字块标记+字块内地址</li><li>优点</li><li>方式灵活，缩小了块发生冲突的概率</li><li>缺点</li><li>增加了标识位位数</li><li>增加了寻找主存块在cache中对应块的时间</li></ul></li><li>组相联映像<ul><li>直接映像和全相联映像的折衷</li><li>主存地址：主存字块标记+组地址+块内地址</li></ul></li></ul></li></ul><h4 id="虚拟存储器"><a href="#虚拟存储器" class="headerlink" title="虚拟存储器"></a>虚拟存储器</h4><ul><li>存储管理部件（MMU）</li><li>现代计算机一般都有辅助存储器，但具有辅存的存储系统不一定是虚拟存储系统</li><li>虚拟存储系统的特点<ul><li>允许用户程序用比主存大的多的空间来访问主存</li><li>每次访存都要进行虚实地址的转换</li></ul></li></ul><h3 id="辅助存储器"><a href="#辅助存储器" class="headerlink" title="辅助存储器"></a>辅助存储器</h3><ul><li>半导体存储器可随机访问任一单元，而辅助存储器一般为串行访问存储器</li></ul><h4 id="辅助存储器的种类"><a href="#辅助存储器的种类" class="headerlink" title="辅助存储器的种类"></a>辅助存储器的种类</h4><ul><li>磁表面存储器<ul><li>数字式磁记录：硬盘、软盘和磁带</li><li>模拟式磁记录：录音、录像设备</li></ul></li><li>光存储器：光盘</li></ul><h5 id="串行存储器"><a href="#串行存储器" class="headerlink" title="串行存储器"></a>串行存储器</h5><ul><li>顺序存取存储器</li><li>直接存取存储器</li></ul><h5 id="辅助存储器的技术指标"><a href="#辅助存储器的技术指标" class="headerlink" title="辅助存储器的技术指标"></a>辅助存储器的技术指标</h5><ul><li>存储密度：单位长度或单位面积磁层表面磁层所存储的二进制信息量</li><li>道密度：沿磁盘半径方向单位长度的磁道数称为道密度，单位为道/英寸tpi或道/毫米tpmm</li><li>位密度或线密度：单位长度磁道所能记录二进制信息的位数叫位密度或线密度，单位为位/英寸bpi或位/毫米bpmm</li><li>每个磁道所存储的信息量是一样的</li><li>存储容量：C = n × k × s</li><li>寻址时间：平均寻址时间Ta=平均找道时间Ts+平均等待时间Tw</li><li>数据传输率：Dr = D × V</li><li>误码率</li><li>价格</li></ul><h4 id="硬磁盘存储器的类型"><a href="#硬磁盘存储器的类型" class="headerlink" title="硬磁盘存储器的类型"></a>硬磁盘存储器的类型</h4><ul><li>固定磁头和移动磁头</li><li>可换盘和固定盘</li></ul><h4 id="磁盘存储器"><a href="#磁盘存储器" class="headerlink" title="磁盘存储器"></a>磁盘存储器</h4><ul><li>温彻斯特磁盘简称温盘</li><li>磁盘存储器由驱动器（HDD），控制器（HDC）和盘片组成</li><li>最外面的同心圆叫0磁道，最里面的同心圆假设称为n磁道</li><li>驱动器的定位驱动系统实现快速精准的磁头定位</li><li>主轴系统的作用是带动盘片按额定转速稳定旋转</li><li>数据控制系统的作用是控制数据的写入和读出，包括寻址，磁头旋转，写电流控制，读出放大，数据分离</li><li>磁盘控制器有两个方向的接口<ul><li>与主机的接口</li><li>与驱动器（设备）的接口</li></ul></li></ul><h4 id="光盘"><a href="#光盘" class="headerlink" title="光盘"></a>光盘</h4><ul><li>采用光存储技术</li><li>利用激光写入和读出</li><li>第一代光存储技术采用非磁性介质，不可擦写</li><li>第二代光存储技术，采用磁性介质，可擦写</li><li>光盘的存储原理<ul><li>只读型和只写一次型：热作用（物理或化学变化）</li><li>可擦写光盘：热磁效应</li></ul></li></ul><h3 id="输出输出（I-O）设备-系统"><a href="#输出输出（I-O）设备-系统" class="headerlink" title="输出输出（I/O）设备/系统"></a>输出输出（I/O）设备/系统</h3><h4 id="设备控制器（I-O）的基本功能"><a href="#设备控制器（I-O）的基本功能" class="headerlink" title="设备控制器（I/O）的基本功能"></a>设备控制器（I/O）的基本功能</h4><ul><li>实现主机和外部设备之间的数据传送</li><li>实现数据缓冲，以达到主机同外部设备之间的速度匹配</li><li>接受主机的命令，提供设备接口的设备，并按照主机的命令控制设备</li></ul><h4 id="I-O-编址方式"><a href="#I-O-编址方式" class="headerlink" title="I/O 编址方式"></a>I/O 编址方式</h4><ul><li>统一编址：用取数、存数指令</li><li>不统一编址：有专门的 I/O 指令</li></ul><h4 id="I-O-与主机的连接方式"><a href="#I-O-与主机的连接方式" class="headerlink" title="I/O 与主机的连接方式"></a>I/O 与主机的连接方式</h4><ul><li>辐射式连接<ul><li>每台设备都配有一套</li><li>控制线路和一组信号线</li><li>不便于增删设备</li></ul></li><li>总线连接<ul><li>便于增删设备</li></ul></li></ul><h4 id="I-O设备"><a href="#I-O设备" class="headerlink" title="I/O设备"></a>I/O设备</h4><ul><li>人机交互设备：键盘、鼠标等</li><li>计算机信息的驻留设备：硬盘、光盘等</li><li>机——机通信设备：MODEN等</li></ul><h4 id="为什么要设置接口？"><a href="#为什么要设置接口？" class="headerlink" title="为什么要设置接口？"></a>为什么要设置接口？</h4><ul><li>实现设备的选择</li><li>实现数据缓冲达到速度匹配</li><li>实现数据串 并格式转换</li><li>实现电平转换</li><li>传送控制命令</li><li>反映设备的状态（“忙”、“就绪”、“中断请求”）</li></ul><h4 id="中断服务程序的流程"><a href="#中断服务程序的流程" class="headerlink" title="中断服务程序的流程"></a>中断服务程序的流程</h4><ul><li>保护现场<ul><li>程序断点的保护</li><li>寄存器内容的保护</li></ul></li><li>中断服务<ul><li>对不同的 I/O 设备具有不同内容的设备服务</li></ul></li><li>恢复现场：出栈指令</li><li>中断返回：中断返回指令</li></ul><h4 id="单重中断和多重中断"><a href="#单重中断和多重中断" class="headerlink" title="单重中断和多重中断"></a>单重中断和多重中断</h4><ul><li>单重中断：不允许中断 现行的 中断服务程序</li><li>多重中断：允许级别更高 的中断源（现行的 中断服务程序）</li></ul><h4 id="DMA-方式"><a href="#DMA-方式" class="headerlink" title="DMA 方式"></a>DMA 方式</h4><ul><li>主存和 I/O 之间有一条直接数据通道</li><li>CPU 和 I/O 并行工作</li><li>DMA 的三种工作方式<ul><li>CPU暂停方式</li><li>CPU周期窃取方式</li><li>直接访问存储器</li></ul></li><li>DMA 接口功能<ul><li>向 CPU 申请 DMA 传送</li><li>处理总线 控制权的转交</li><li>管理 系统总线、控制 数据传送</li><li>确定 数据传送的 首地址和长度，修正 传送过程中的数据地址和长度</li><li>DMA 传送结束时，给出操作完成信号</li></ul></li><li>DMA 传送过程：预处理、数据传送、后处理</li></ul><h4 id="外设接口"><a href="#外设接口" class="headerlink" title="外设接口"></a>外设接口</h4><ul><li>设备与主机相连时，必须按照规定的物理互连特性、电气特性等进行连接，这些特性的技术规范称为接口标准</li></ul>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;计算机组成原理是计算机专业本科教学中的重要课程，它可以帮助我们系统地理解计算机硬件系统的组织结构和工作原理、掌握计算机硬件系统的基本分析与设计方法以及建立计算机系统的整体概念，为进一步学习计算机设计实践课程、培养系统开发、调试以及设计创新能力奠定良好的基础。计组是考研的最重最难点，在408计算机学科专业基础综合考试中占有45分。我选择的课程是哈工大的&lt;a href=&quot;https://www.icourse163.org/course/hit-309001&quot;&gt;国家精品课&lt;/a&gt;，配合天勤高分笔记，以下为所记课堂笔记下半部分，包含CPU、总线和I/O系统的知识点，可供参考。上半部分笔记请访问&lt;a href=&quot;/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E4%B8%8A&quot;&gt;计算机组成原理（上）&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="计算机专业" scheme="http://blog.zhuangzhihao.top/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%93%E4%B8%9A/"/>
    
    
  </entry>
  
  <entry>
    <title>开发团队调度软件实战</title>
    <link href="http://blog.zhuangzhihao.top/%E5%BC%80%E5%8F%91%E5%9B%A2%E9%98%9F%E8%B0%83%E5%BA%A6%E8%BD%AF%E4%BB%B6/"/>
    <id>http://blog.zhuangzhihao.top/%E5%BC%80%E5%8F%91%E5%9B%A2%E9%98%9F%E8%B0%83%E5%BA%A6%E8%BD%AF%E4%BB%B6/</id>
    <published>2021-10-08T16:00:00.000Z</published>
    <updated>2021-11-10T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>在学习完 <a href="/Java%E5%9F%BA%E7%A1%80">Java 基础编程</a>的全部知识点后，为了更加熟悉 Java 面向对象的高级特性，进一步掌握编程技巧和调试技巧，实现模拟一个基于文本界面的开发团队调度软件，并以文档的形式记录软件设计结构、实现方法和一些疑难之处，主要涉及类的继承性和多态性、对象的值传递和接口、static 和 final 修饰符、特殊类的使用（包装类、抽象类、内部类）、异常处理等知识点。</p></blockquote><a id="more"></a><h3 id="软件需求"><a href="#软件需求" class="headerlink" title="软件需求"></a>软件需求</h3><ul><li>软件启动时，根据给定的数据创建公司部分成员列表（数组）</li><li>根据菜单提示，基于现有的公司成员，组建一个开发团队以开发一个新的项目</li><li>组建过程包括将成员插入到团队中，或从团队中删除某成员，还可以列出团队中现有成员的列表</li><li>开发团队成员包括架构师、设计师和程序员</li></ul><h4 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h4><ul><li>软件采用单级菜单方式工作，当软件运行时，主界面显示公司成员的列表</li><li>当选择“添加团队成员”菜单时，将执行从列表中添加指定（通过 ID）成员到开发团队的功能</li><li>如果添加操作因某种原因失败，将显示失败信息（失败原因视具体原因而不同）</li><li>当选择“删除团队成员”菜单时，将执行从开发团队中删除指定（通过 TeamID）成员的功能</li><li>当选择“团队列表”菜单时，将列出开发团队中的现有成员</li></ul><h3 id="软件设计结构"><a href="#软件设计结构" class="headerlink" title="软件设计结构"></a>软件设计结构</h3><ul><li>软件由 view、service、domain 三个模块组成<ul><li><code>com.atguigu.team.view</code> 模块为主控模块，负责菜单的显示和处理用户操作</li><li><code>com.atguigu.team.service</code> 模块为实体对象（Employee 及其子类如程序员等）的管理模块，<code>NameListService</code> 和 <code>TeamService</code> 类分别用各自的数组来管理公司员工和开发团队成员对象</li><li>domain 模块为 Employee 及其子类等 JavaBean 类所在的包</li></ul></li><li><code>com.atguigu.team.domain</code> 模块中包含了所有实体类<ul><li>其中 Programmer 及其子类，均会领用 Equipment</li></ul></li></ul><h3 id="创建项目基本组件"><a href="#创建项目基本组件" class="headerlink" title="创建项目基本组件"></a>创建项目基本组件</h3><ol><li>创建 <code>TeamSchedule</code> 项目，按照设计要求创建所有包，将项目提供的几个类复制到相应的包中<ul><li>view 包中：TSUtility.java</li><li>service包中：Data.java</li></ul></li><li>   按照设计要求，在 com.atguigu.team.domain 包中，创建 Equipment 接口及其各实现子类代码</li><li>   按照设计要求，在 com.atguigu.team.domain 包中，创建 Employee 类及其各子类代码</li><li>   检验代码的正确性</li></ol><h4 id="键盘访问的实现"><a href="#键盘访问的实现" class="headerlink" title="键盘访问的实现"></a>键盘访问的实现</h4><ul><li>项目 view 包中提供了 TSUtility.java 类，提供了以下静态方法，可用来方便地实现键盘访问<ul><li>public static char readMenuSelection()：该方法读取键盘，如果用户键入’1’-’4’中的任意字符，则方法返回。返回值为用户键入字符</li><li>public static void readReturn()：该方法提示并等待，直到用户按回车键后返回</li><li>public static int readInt()：该方法从键盘读取一个长度不超过2位的整数，并将其作为方法的返回值</li><li>public static char readConfirmSelection()：从键盘读取‘Y’或’N’，并将其作为方法的返回值</li></ul></li></ul><h4 id="Equipment-接口及其实现子类的设计"><a href="#Equipment-接口及其实现子类的设计" class="headerlink" title="Equipment 接口及其实现子类的设计"></a>Equipment 接口及其实现子类的设计</h4><ul><li>根据需要提供各属性的 get/set 方法以及重载构造器</li><li>实现类实现接口的方法，返回各自属性的信息</li></ul><h4 id="Employee-类及其子类的设计"><a href="#Employee-类及其子类的设计" class="headerlink" title="Employee 类及其子类的设计"></a>Employee 类及其子类的设计</h4><ul><li>memberId 用来记录成员加入开发团队后在团队中的 ID</li><li>Status 是项目 service 包下自定义的类，声明三个对象属性，分别表示成员的状态<ol><li>FREE-空闲</li><li>BUSY-已加入开发团队</li><li>VOCATION-正在休假</li></ol></li><li>equipment 表示该成员领用的设备</li><li>bonus 表示奖金</li><li>stock 表示公司奖励的股票数量</li><li>可根据需要为类提供各属性的 get/set 方法以及重载构造器</li></ul><h4 id="Status-类"><a href="#Status-类" class="headerlink" title="Status 类"></a>Status 类</h4><ul><li><p>Status 枚举类位于 com.atguigu.team.service 包中，封装员工的状态</p><pre><code class="java">package com.atguigu.team.service;public class Status &#123;    private final String NAME;  private Status(String name) &#123;      this.NAME = name;  &#125;  public static final Status FREE = new Status(&quot;FREE&quot;);  public static final Status VOCATION = new Status(&quot;VOCATION&quot;);   public static final Status BUSY = new Status(&quot;BUSY&quot;);  public String getNAME() &#123;      return NAME;  &#125;  @Override  public String toString() &#123;      return NAME;  &#125;&#125;</code></pre></li></ul><h3 id="实现-service-包中的类"><a href="#实现-service-包中的类" class="headerlink" title="实现 service 包中的类"></a>实现 service 包中的类</h3><ol><li>   按照设计要求编写 NameListService 类</li><li>   在 NameListService 类中临时添加一个 main 方法中，作为单元测试方法</li><li>在方法中创建 NameListService 对象，然后分别用模拟数据调用该对象的各个方法，以测试是否正确<ul><li>测试应细化到包含了所有非正常的情况，以确保方法完全正确</li></ul></li><li>   重复以上3步，完成 TeamService 类的开发</li></ol><h4 id="NameListService-类的设计"><a href="#NameListService-类的设计" class="headerlink" title="NameListService 类的设计"></a>NameListService 类的设计</h4><ul><li>负责将 Data 中的数据封装到 Employee[] 数组中，同时提供相关操作 Employee[] 的方法</li><li>employees 用来保存公司所有员工对象</li><li>NameListService() 构造器<ul><li>根据项目提供的 Data 类构建相应大小的 employees 数组</li><li>再根据 Data 类中的数据构建不同的对象，包括 Employee、Programmer、Designer 和 Architect 对象，以及相关联的 Equipment 子类的对象</li><li>将对象存于数组中</li><li>Data类位于 com.atguigu.team.service 包中</li></ul></li><li>getAllEmployees()：获取当前所有员工<ul><li>返回：包含所有员工对象的数组</li></ul></li><li>getEmployee(id : int)：获取指定ID的员工对象<ul><li>参数：指定员工的 ID</li><li>返回：指定员工对象</li><li>异常：找不到指定的员工</li></ul></li><li>在 service 子包下提供自定义异常类：TeamException</li><li>另外，可根据需要自行添加其他方法或重载构造器</li></ul><h4 id="TeamService-类的设计"><a href="#TeamService-类的设计" class="headerlink" title="TeamService 类的设计"></a>TeamService 类的设计</h4><ul><li>关于开发团队成员的管理：添加、删除等</li><li>counter 为静态变量，用来为开发团队新增成员自动生成团队中的唯一 ID，即 memberId（应使用增1的方式）</li><li>MAX_MEMBER：表示开发团队最大成员数</li><li>team数组：用来保存当前团队中的各成员对象</li><li>total：记录团队成员的实际人数</li><li>getTeam() ：返回当前团队的所有对象<ul><li>返回：包含所有成员对象的数组，数组大小与成员人数一致</li></ul></li><li>addMember(e: Employee)：向团队中添加成员<ul><li>参数：待添加成员的对象</li><li>异常：添加失败，TeamException 中包含了失败原因</li></ul></li><li>removeMember(memberId: int)：从团队中删除成员<ul><li>参数：待删除成员的 memberId</li><li>异常：找不到指定 memberId 的员工，删除失败</li></ul></li><li>另外，可根据需要自行添加其他方法或重载构造器</li></ul><h3 id="实现-view-包中类"><a href="#实现-view-包中类" class="headerlink" title="实现 view 包中类"></a>实现 view 包中类</h3><ol><li>   按照设计要求编写 TeamView 类，逐一实现各个方法，并编译</li><li>   执行 main 方法中，测试软件全部功能</li></ol><h4 id="TeamView-类的设计"><a href="#TeamView-类的设计" class="headerlink" title="TeamView 类的设计"></a>TeamView 类的设计</h4><ul><li>listSvc 和 teamSvc 属性：供类中的方法使用</li><li>enterMainMenu()：主界面显示及控制方法</li><li>以下方法仅供 enterMainMenu() 调用：<ul><li>listAllEmployees()：以表格形式列出公司所有成员</li><li>getTeam()：显示团队成员列表操作</li><li>addMember()：实现添加成员操作</li><li>deleteMember()：实现删除成员操作</li></ul></li></ul>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;在学习完 &lt;a href=&quot;/Java%E5%9F%BA%E7%A1%80&quot;&gt;Java 基础编程&lt;/a&gt;的全部知识点后，为了更加熟悉 Java 面向对象的高级特性，进一步掌握编程技巧和调试技巧，实现模拟一个基于文本界面的开发团队调度软件，并以文档的形式记录软件设计结构、实现方法和一些疑难之处，主要涉及类的继承性和多态性、对象的值传递和接口、static 和 final 修饰符、特殊类的使用（包装类、抽象类、内部类）、异常处理等知识点。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="开源项目" scheme="http://blog.zhuangzhihao.top/categories/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/"/>
    
    
    <category term="Java" scheme="http://blog.zhuangzhihao.top/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>从2020的视角看线性代数</title>
    <link href="http://blog.zhuangzhihao.top/%E4%BB%8E2020%E7%9A%84%E8%A7%86%E8%A7%92%E7%9C%8B%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/"/>
    <id>http://blog.zhuangzhihao.top/%E4%BB%8E2020%E7%9A%84%E8%A7%86%E8%A7%92%E7%9C%8B%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/</id>
    <published>2021-09-19T16:00:00.000Z</published>
    <updated>2021-12-24T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>2020 年 MIT 数学教授 Gilbert Strang 录制了一个关于线性代数的学习和教学的一个新的、启发性的课程，从矩阵 A 的列空间和组合这些列的乘法 Ax 开始，包括了线性代数的概览、正交向量、特征值和特征向量、以及奇异值和奇异向量等方面的内容。以下为所记课堂笔记，笔记以中文形式记录，方便理解，可供参考。</p></blockquote><a id="more"></a><h3 id="矩阵的列空间"><a href="#矩阵的列空间" class="headerlink" title="矩阵的列空间"></a>矩阵的列空间</h3><h4 id="常用矩阵"><a href="#常用矩阵" class="headerlink" title="常用矩阵"></a>常用矩阵</h4><ul><li><p>$A_{0}=\begin{bmatrix}<br>1 &amp; 3 &amp; 2 \<br>4 &amp; 12 &amp; 8 \<br>2 &amp; 6 &amp; 4<br>\end{bmatrix}$</p><ul><li>$A_{0}$ 所有的行向量在同一个方向并且所有的列向量在同一个方向</li></ul></li><li><p>$A_{1}=\begin{bmatrix}<br>1 &amp; 4 &amp; 2 \<br>4 &amp; 1 &amp; 3 \<br>5 &amp; 5 &amp; 5<br>\end{bmatrix}$</p><ul><li>$A_{1}$ 第一行加第二行等于第三行</li></ul></li><li><p>对称矩阵</p><ul><li><p>$S_{2}=\begin{bmatrix}<br>2 &amp; -1 \<br>-1 &amp; 2<br>\end{bmatrix}$</p></li><li><p>$S_{3}=\begin{bmatrix}<br>1 &amp; -1 &amp; 0 \<br>-1 &amp; 2 &amp; -1 \<br>0 &amp; -1 &amp; 1<br>\end{bmatrix}$</p></li><li><p>$S_{4}=\begin{bmatrix}<br>2 &amp; -1 &amp; 0 \<br>-1 &amp; 2 &amp; -1 \<br>0 &amp; -1 &amp; 2<br>\end{bmatrix}$</p></li></ul></li><li><p>正交矩阵</p><ul><li>$Q_{5}=\begin{bmatrix}<br>\cos \theta  &amp; -\sin \theta  \<br>sin\theta  &amp; \cos \theta<br>\end{bmatrix}$</li></ul></li><li><p>$A_{6}=\begin{bmatrix}<br>3 &amp; 0 \<br>4 &amp; 5<br>\end{bmatrix}$</p></li></ul><h4 id="A-的列空间（列的所有线性组合）"><a href="#A-的列空间（列的所有线性组合）" class="headerlink" title="A 的列空间（列的所有线性组合）"></a>A 的列空间（列的所有线性组合）</h4><ul><li><p>将矩阵乘以向量</p><ul><li><p>$Ax=\begin{bmatrix} 1 &amp; 4 &amp; 5 \ 3 &amp; 2 &amp; 5 \ 2 &amp; 1 &amp; 3 \end{bmatrix}\begin{bmatrix} x_{1} \ x_{2} \ x_{3} \end{bmatrix}=\begin{bmatrix} 1 \ 3 \ 2 \end{bmatrix}x_{1}+\begin{bmatrix} x \ 2 \ 1 \end{bmatrix}x_{2}+\begin{bmatrix} 5 \ 5 \ 3 \end{bmatrix}x_{3}$</p></li><li><p>$Ax$ 为一种特殊的列的线性组合</p></li><li><p>$A$ 的列空间 = $C(A)$ = 所有 $Ax$ 向量 = 各列的所有线性组合</p></li><li><p>$C(A)$ 是一个平面</p></li></ul></li></ul><h4 id="列空间的基"><a href="#列空间的基" class="headerlink" title="列空间的基"></a>列空间的基</h4><ul><li><p>$A=CR=\begin{bmatrix}<br>1 &amp; 4 \<br>3 &amp; 2 \<br>2 &amp; 1<br>\end{bmatrix}\begin{bmatrix}<br>1 &amp; 0 &amp; 1 \<br>0 &amp; 1 &amp; 1<br>\end{bmatrix}$</p><ul><li><p>行秩 = 列秩 = r = 2</p></li><li><p>C 是平面的两个独立列向量，而 R 则表示了 A 是如何通过 C 中的两个向量重组 A 的</p></li><li><p>R 的 r 行是行空间的一组基</p></li></ul></li><li><p>$A = CR$ 表明 A 的行秩等于列秩 </p><ul><li>C 的 r 列相互线性独立（由定义可知）</li><li>A 的每一列都是（C 的）这 r 列的线性组合（因为 A = CR）</li><li>R 的 r 行相互线性独立（这 r 列包含了 r × r 的矩阵 I ）</li><li>A 的每一行都是（C 的）这 r 行的线性组合（因为 A = CR）</li></ul></li><li><p>核心内容 </p><ul><li>C 的 r 列组成了 A 的列空间的基：维度 r </li><li>R 的 r 列组成了 A 的行空间的基：维度 r</li></ul></li><li><p>基包含两个向量 </p><ul><li>A 的秩等于 r = 2 </li><li>$n − r = 3 − 2 = 1$</li></ul></li><li><p>计数定理 </p><ul><li>$Ax = 0$ 有一组解 $x = (1, 1, −1)$ 有 $n − r$ 组独立解可使 $Ax = 0$ 成立</li></ul></li></ul><h4 id="秩为-1-的矩阵-A"><a href="#秩为-1-的矩阵-A" class="headerlink" title="秩为 1 的矩阵 A"></a>秩为 1 的矩阵 A</h4><ul><li>如果 A 的任意一列均为第一列的若干倍，那么 A 的每一行均为某行的若干倍</li><li>用 A = CR 来证明<ul><li>C 当中的一列 $v$ ⇒ R 当中的一行 $w$</li><li>$A=\left[ v\right] ^{\left[ w\right] }$ ⇒ 每一行都是 $w$ 的倍数</li></ul></li></ul><h4 id="A-CR-的优良性质"><a href="#A-CR-的优良性质" class="headerlink" title="A = CR 的优良性质"></a>A = CR 的优良性质</h4><ul><li>C 的列直接来源于 A：体现了此公式的内涵</li><li>R 变成了A 的行化简阶梯形</li><li>“行秩 = 列秩”这一结论变得显然：C = 列的基，R = 行的基</li></ul><h4 id="A-CR-不好的性质"><a href="#A-CR-不好的性质" class="headerlink" title="A = CR 不好的性质"></a>A = CR 不好的性质</h4><ul><li>C 和 R 可能是病态矩阵</li><li>如果 A 是可逆的，则有 C = A 和 R = I ⇒ A = AI，原地打转</li></ul><h3 id="线性代数概览"><a href="#线性代数概览" class="headerlink" title="线性代数概览"></a>线性代数概览</h3><h4 id="线性方程组"><a href="#线性方程组" class="headerlink" title="线性方程组"></a>线性方程组</h4><ul><li>若 $Ax = 0$ 则有 $\begin{bmatrix} 1 \ \vdots \ m \end{bmatrix}\left[ x\right]=\begin{bmatrix} 0 \ \vdots \ 0 \end{bmatrix}$，x 与 A 的各列均正交<ul><li>每个处于 A 的零空间当中的 x 都与 A 的行空间正交 </li><li>每个处于 $A^T$ 的零空间当中的 y 都与 A 的列空间正交</li></ul></li><li>$N\left( A\right) \bot C\left( A^{T}\right) $ 与 $N\left( A^{T}\right) \bot C\left( A\right) $<ul><li>两对正交子空间，其中一对子空间的维度之和等于 n，另一对等于 m</li></ul></li></ul><h4 id="宏观视角下的线性代数"><a href="#宏观视角下的线性代数" class="headerlink" title="宏观视角下的线性代数"></a>宏观视角下的线性代数</h4><ul><li><img src="https://cdn.jsdelivr.net/gh/Bezhuang/Imgbed/blogimg/%E4%BB%8E2020%E7%9C%8B%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B001.png" style="zoom:67%;"></li><li>一对子空间处于 $R_{n}$ 之中，另一对处于$R_{m}$ 当中</li><li>从行空间变换为列空间——由此可知 A 是可逆的</li></ul><h4 id="列与行相乘（六组因式）"><a href="#列与行相乘（六组因式）" class="headerlink" title="列与行相乘（六组因式）"></a>列与行相乘（六组因式）</h4><ul><li>A = BC = 秩为 1 的矩阵之和（列乘以行：外积）</li><li>对矩阵相乘的全新理解（高层次），每次拿一列乘以一行是低层次的<ul><li><img src="https://cdn.jsdelivr.net/gh/Bezhuang/Imgbed/blogimg/%E4%BB%8E2020%E7%9C%8B%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B002.png" style="zoom:67%;"></li></ul></li><li>$A=\begin{bmatrix} 2 &amp; 3 \ 4 &amp; 7 \end{bmatrix}=\begin{bmatrix} 1 &amp; 0 \ 2 &amp; 1 \end{bmatrix}\begin{bmatrix} 2 &amp; 3 \ 0 &amp; 1 \end{bmatrix}=LU$ （将矩阵拆分成上下两个三角矩阵）<ul><li>$2x+3y=7$ ， $4x+7y=15$  ⇒ $x=2,y=1$</li><li>若两行发生交换，则 $PA = LU$ （P 指的是排列矩阵）</li></ul></li></ul><h4 id="用消元来解Ax-b（因式-A-LU）"><a href="#用消元来解Ax-b（因式-A-LU）" class="headerlink" title="用消元来解Ax = b（因式 A = LU）"></a>用消元来解Ax = b（因式 A = LU）</h4><ul><li>下三角矩阵 L 乘以上三角矩阵 U</li><li><img src="https://cdn.jsdelivr.net/gh/Bezhuang/Imgbed/blogimg/%E4%BB%8E2020%E7%9C%8B%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B003.png" style="zoom:67%;"></li></ul><h3 id="正交向量"><a href="#正交向量" class="headerlink" title="正交向量"></a>正交向量</h3><h4 id="正交向量-–-矩阵-–-子空间"><a href="#正交向量-–-矩阵-–-子空间" class="headerlink" title="正交向量 – 矩阵 – 子空间"></a>正交向量 – 矩阵 – 子空间</h4><ul><li>$X^{T}y=0,y^{T}x=0,\left( x+y\right) ^{T}\left( x+y\right)=x^{T}<em>{x}+y^{T}</em>{y}$ （直角三角形）</li><li><img src="https://cdn.jsdelivr.net/gh/Bezhuang/Imgbed/blogimg/%E4%BB%8E2020%E7%9C%8B%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B004.png" style="zoom:67%;"></li><li>$Q=\dfrac{1}{3}\begin{bmatrix} -1 &amp; 2 \ 2 &amp; -1 \ 2 &amp; 2 \end{bmatrix}$ ，$Q^{T}Q=I,QQ^{T}\neq I$ ，$QQ^TQQ^T = QQ^T$</li></ul><h4 id="正交矩阵"><a href="#正交矩阵" class="headerlink" title="正交矩阵"></a>正交矩阵</h4><h3 id="特征值和特征向量"><a href="#特征值和特征向量" class="headerlink" title="特征值和特征向量"></a>特征值和特征向量</h3><h3 id="奇异值和奇异向量"><a href="#奇异值和奇异向量" class="headerlink" title="奇异值和奇异向量"></a>奇异值和奇异向量</h3>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;2020 年 MIT 数学教授 Gilbert Strang 录制了一个关于线性代数的学习和教学的一个新的、启发性的课程，从矩阵 A 的列空间和组合这些列的乘法 Ax 开始，包括了线性代数的概览、正交向量、特征值和特征向量、以及奇异值和奇异向量等方面的内容。以下为所记课堂笔记，笔记以中文形式记录，方便理解，可供参考。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="数学" scheme="http://blog.zhuangzhihao.top/categories/%E6%95%B0%E5%AD%A6/"/>
    
    
  </entry>
  
  <entry>
    <title>操作系统（下）</title>
    <link href="http://blog.zhuangzhihao.top/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E4%B8%8B/"/>
    <id>http://blog.zhuangzhihao.top/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E4%B8%8B/</id>
    <published>2021-09-10T16:00:00.000Z</published>
    <updated>2021-11-30T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p> 操作系统（OS）是管理和控制计算机硬件与软件资源，是计算机上直接运行的最基本的系统软件，任何其他软件都必须在操作系统的支持下才能运行。操作系统是用户和计算机的接口，同时也是计算机硬件和其他软件的接口。操作系统的功能包括管理计算机系统的硬件、软件及数据资源，控制程序运行，提供人机交互界面，为其它应用软件提供支持等。我选择的课程是苏州大学的<a href="https://www.icourse163.org/course/SUDA-1001752241">国家精品课</a>和汤子瀛版教材，以下为所记课堂笔记下半部分，包含内存管理、文件管理和设备管理的知识点，可供参考。上半部分笔记请访问<a href="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E4%B8%8A">操作系统（上）</a></p></blockquote><a id="more"></a><h3 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h3><h4 id="内存管理概述"><a href="#内存管理概述" class="headerlink" title="内存管理概述"></a>内存管理概述</h4><ul><li>内存管理的功能是为多道程序的运行提供良好的环境<ul><li>内存的分配和回收：记住内存空间的使用情况、实施内存的分配、回收系统或用户释放的内存空间</li><li>地址变换：将逻辑地址转换为物理地址</li><li>扩充内存：虚拟存储技术或其他自动覆盖技术</li><li>存储保护：由硬件和软件配合完成</li></ul></li><li>应用程序的编译、链接与装入<ol><li>经过编译程序将源代码编译为若干个目标模块</li><li>通过链接程序将编译好的目标模块以及所需的库函数链接在一起，形成完整的装入模块</li><li>通过装入程序将这些装入模块装入内存并执行</li></ol></li><li>源程序（名地址）-&gt; 目标程序（逻辑地址）-&gt; 可执行程序（物理地址）<ul><li>对程序设计者来说，数据的存放地址由数据名称决定，称为名地址或符号名地址，即为源程序的地址空间</li><li>当链接程序将多个模块链接为装入模块时，链接程序会按照各个模块的相对地址，将其地址构成统一的从0号单元开始编址的相对地址</li><li>当装入程序将可执行代码装入内存时，程序的逻辑地址与程序存在内存的实际地址，通常不同这就需要通过地址转换将逻辑地址转为物理地址，这个过程叫重定位</li></ul></li><li>程序链接的 3 种方式<ul><li>静态链接：在程序运行之前，先将各目标模块及所需的库函数连接成一个完整的可执行程序（装入模块），之后不再拆开</li><li>装入时动态链接：将各目标模块装入内存时，边装入边链接的链接方式</li><li>运行时动态链接：在程序执行中需要该目标模块时，才对它进行链接。其优点是物理地址便于修改和更新，便于实现对目标模块的共享</li></ul></li><li>程序装入的 3 种方式<ul><li>绝对装入：在编译时就知道程序将要驻留在内存的物理地址，编译程序产生含有物理地址的目标代码</li><li>可重定位装入：根据内存当前情况将装入模块装入到内存的适当位置，地址变换通常在装入时一次完成，容易实现，无需增加硬件地址变换机构</li><li>动态运行装入：允许程序运行时在内存中移动位置，在程序执行过程中，每当访问到相应指令或数据时，才将要访问的程序或数据的相对地址转换为物理地址，可以将程序分配到不连续的存储区中</li></ul></li><li>在重定位中通常会设一个重定位寄存器，用来存放进程分配的内存空间的地址（基址寄存器）<ul><li>当 CPU 需要访问内存时，将逻辑地址转换为物理地址</li><li>物理地址 = 基址计算器内容 + 逻辑地址</li></ul></li><li>逻辑地址和物理地址<ul><li>逻辑地址是指由程序产生的与段相关的偏移部分地址（与页无关，因为只有段对用户可见）</li><li>物理地址是指出现在 CPU 外部地址总线上的寻址物理内存的地址信号，是逻辑地址变换后的最终结果地址，物理地址空间是指内存中物理地址单元的集合</li><li>从逻辑地址到物理地址的转换过程由硬件自动完成，这个转换过程叫做地址重定位</li></ul></li><li>内存保护<ol><li>界限寄存器方法<ul><li>上、下界寄存器方法：分别存放作业的结束地址和开始地址</li><li>基址和限长寄存器方法</li></ul></li><li>存储保护键方法：给每个存储块分配一个单独的保护键</li></ol></li></ul><h4 id="交换与覆盖"><a href="#交换与覆盖" class="headerlink" title="交换与覆盖"></a>交换与覆盖</h4><ul><li>覆盖技术，就是把一个大的程序划分为一系列覆盖，每个覆盖是一个相对独立的程序单位<ul><li>把程序执行时并不要求同时装入内存的复盖组成一组，称为覆盖段</li><li>将这个覆盖段分配到同一存储区域，这个存储区域称为覆盖区</li><li>覆盖区与覆盖段一一对应</li><li>覆盖技术只能覆盖与覆盖程序段无关的程序段</li><li>为了使一个覆盖区能被相应覆盖段中每个覆盖在不同时刻共享，其大小应由覆盖段中最大覆盖来确定</li><li>覆盖技术的特点是打破了必须将一个进程的全部信息装入主存后才能运行的限制，但当同时执行程序的代码量超过主存时，程序仍然不能运行</li></ul></li><li>交换技术就是把暂时不用的某个程序及数据部分从内存移到外存中，以便腾出必要的内存空间，或把指定的程序或数据从外存读到相应的内存中，并将控制权转让给他，让其在系统上运行的一种内存扩充技术<ul><li>处理器三级调度中的中级调度就是采用了交换技术</li><li>与覆盖技术相比，交换技术不要求程序员给出程序段之间的覆盖结构，且交换主要是在进程或作业之间进行，而覆盖主要在同一个作业或进程中进行</li><li>交换进程由换出和换入两个过程组成</li><li>交换技术的特点是打破了一个程序一旦进入主存便一直运行到结束的限制，但运行的进程大小仍然受实际主存的限制</li><li>交换需要备份存储</li><li>影响交换时间的因素主要是转移时间</li><li>如果换出进程，必须确保该进程完全空闲</li><li>交换空间通常作为磁盘的一整块，且独立于文件系统</li><li>交换通常在有许多进程运行，且内存空间紧张时开始启动，而在系统负荷减轻时暂停</li></ul></li></ul><h4 id="连续分配管理方式"><a href="#连续分配管理方式" class="headerlink" title="连续分配管理方式"></a>连续分配管理方式</h4><ul><li>内部碎片和外部碎片<ul><li>内部碎片是指已经分配给作业，但不能被利用的内部空间</li><li>外部碎片是指系统中还没有分配给作业，但由于碎片太小而无法分配给申请内存空间的新进程的存储块</li></ul></li><li>单一连续分配：将内存分为两个连续存储区域，其中一个存储区域固定的分配给操作系统使用，通常放在内存低地址部分，另一个存储区域给用户作业使用<ul><li>通常用户作业只占用所有分配空间的一部分，剩下一部分实际上浪费掉了</li><li>单一连续分配方式采用静态分配，适合单道程序，可采用覆盖技术</li><li>作业一旦进入内存，就要等到其结束后才能释放内存，因此这种分配方式不支持虚拟存储器的实现，无法实现多道程序共享主存</li><li>单一连续分配会产生内部碎片</li></ul></li><li>固定分区分配：将内存空间划分为若干个固定大小的分区，每个分区中可以装入一道程序<ul><li>分区的大小可以不等，但事先必须确定，在运行时不能改变</li><li>当有空闲分区时，便从后备队列中选择一个适当大小的作业装入运行</li><li>固定分区分配中程序通常采用静态重定位方式装入内存</li><li>固定分区分配的优点是可用于多道程序系统最简单的存储分配，缺点是不能实现多进程共享一个主存区，利用率较低，会产生内部碎片</li></ul></li><li>动态分区分配：作业进入主存时，根据作业的大小动态的建立分区，并使分区的大小正好满足作业的需要，因此系统中分区的大小是可变的，分区数目也是可变的<ul><li>空闲分区表、空闲分区链</li><li>首次适应算法（FF）、下次适应算法（NF）、最佳适应算法（BF）、最差适应算法（WF）</li><li>分区回收</li><li>分区分配的动态管理：拼接技术、动态重定位分区分配技术</li></ul></li><li>动态分区分配的优缺点<ul><li>优点：实现了多道程序共用主存、管理方案相对简单、实现存储保护的手段比较简单</li><li>缺点：主存利用不够充分，存在外部碎片、无法实现多进程共享存储器信息、无法实现主存的扩充，进程地址空间受实际存储空间的限制</li></ul></li></ul><h4 id="非连续分配管理方式"><a href="#非连续分配管理方式" class="headerlink" title="非连续分配管理方式"></a>非连续分配管理方式</h4><ul><li>非连续分配允许一个程序分散地装入到不相邻的内存分区中</li><li>非连续分配管理方式根据分区大小是否固定为分页存储管理方式和分段存储管理方式</li><li>分页存储管理方式根据运行作业时是否需要把作业的所有页都装入内存才能运行而分为基本分页存储管理方式和请求分页存储管理方式</li><li>基本分页存储管理方式（物理单位）<ul><li>分页原理：用户作业的地址空间被划分成若干个大小相等的区域，称为页或页面</li><li>将主存的存储空间分成与页面大小相等的区域，称为块或物理块</li><li>在为作业分配存储空间时，总是以块为单位来分配，可以将作业中的任意一页放到主存的任意一块中</li><li>主存中与页面大小相等的物理块也可称为页框</li><li>为了将逻辑地址上连续的页号映射到物理内存中后成为离散分布的多个物理块，需要将每个页面和每个物理块一一对应，这种映射关系体现在页表中</li><li>每个页表项由页号和块号组成</li><li>基本地址变换机构：页表寄存器（PTR）</li><li>具有快表（TLB）的地址的地址变换机构：具有并行查找功能的高度缓冲存储器</li><li>两级页表和多级页表</li></ul></li><li>基本分页存储管理方式优缺点<ul><li>优点：内存利用率高、实现了离散分配、便于存储访问控制、无外部碎片</li><li>缺点：需要硬件支持（快表）、内存访问效率下降、共享困难、内部碎片</li></ul></li><li>基本分段存储管理方式（逻辑单位）<ul><li>逻辑地址结构由段号 S 和段内位移 W（段内偏移量）组成</li><li>段的长度不定</li><li>作业空间地址是二维的</li><li>段表及地址变换过程</li></ul></li><li>基本分段存储管理方式优缺点<ul><li>优点：便于程序模块化处理和处理变换的数据结构、便于动态链接和共享、无内部碎片</li><li>缺点：与分页类似，需要硬件支持、为满足分段的动态增长和减少外部碎片，要采用拼接手段、分段的最大尺寸受到主存可用空间的限制、有外部碎片</li></ul></li></ul><h4 id="虚拟内存的基本概念"><a href="#虚拟内存的基本概念" class="headerlink" title="虚拟内存的基本概念"></a>虚拟内存的基本概念</h4><ul><li><p>在真实的操作系统中，通常采用段页式存储管理，段面向用户，页面向硬件</p></li><li><p>虚拟内存解决的问题</p><ul><li>一次性：作业必须一次性全部装入内存后才能开始运行。这会造成两个问题：①作业很大时，不能全部装入内存，导致大作业无法运行；②当大量作业要求运行时，由于内存无法容纳所有作业，因此只有少量作业能运行，导致多道程序并发度下降</li><li>驻留性：一旦作业被装入内存，就会一直驻留在内存中，直至作业运行结束。事实上，在一个时间段内，只需要访问作业的一小部分数据即可正常运行，这就导致了内存中会驻留大量的、暂时用不到的数据，浪费了宝贵的内存资源。</li></ul></li><li><p>虚拟内存的实现：</p><ul><li>基于局部性原理，在程序装入时，可以将程序中很快会用到的部分装入内存，暂时用不到的部分留在外存，就可以让程序开始执行</li><li>在程序执行过程中，当所访问的信息不在内存时，由操作系统负责将所需信息从外存调入内存，然后继续执行程序</li><li>若内存空间不够，由操作系统负责将内存中暂时用不到的信息换出到外存。在操作系统的管理下，在用户看来似乎有一个比实际内存大得多的内存，这就是虚拟内存。</li></ul></li></ul><h4 id="请求分页管理"><a href="#请求分页管理" class="headerlink" title="请求分页管理"></a>请求分页管理</h4><ul><li>请求分页管理：在程序执行过程中，当所访问的信息不在内存时，由操作系统负责将所需信息从外存调入内存，然后继续执行程序。若内存空间不够，由操作系统负责将内存中暂时用不到的信息换出到外存</li><li>缺页中断： 在请求分页系统中，每当要访问的页面不在内存时，便产生一个缺页中断，然后由操作系统的缺页中断处理程序处理中断</li><li>缺页的进程阻塞，放入阻塞队列，调页完成后再将其唤醒，放回就绪队列。如果内存中有空闲块，则为进程分配一个空闲块，将所缺页面装入该块，并修改页表中相应的页表项。如果内存中没有空闲块，则由页面置换算法选择一个页面淘汰，同时要注意，若某个页面被换出外存，则快表中的相应表项也要删除，否则可能访问错误的页面</li><li>理解缺页，缺页就像货架上缺少了商品，需要从仓库里调取商品，就先暂停这个货架的销售，等商品调取完毕再重新出售。</li></ul><h4 id="页面置换算法"><a href="#页面置换算法" class="headerlink" title="页面置换算法"></a>页面置换算法</h4><ul><li><p>置换算法的评价指标是：缺页的次数，某种算法让缺页次数最低，调度效率最高，那就是最优的算法</p></li><li><p>最佳置换算法：每次淘汰的页面都是以后永久不用或最长时间不使用的页面，保证最低的缺页率。显然，这种需要预测未来的算法不可能实现。</p></li><li><p>先进先出算法FIFO：缺页时，淘汰最早进入的页面。算法简单，但局限性也明显，例如某些经常使用的页面一直被换进换出，和使用频率低的页面有相同的被换出的机会。</p></li><li><p>最近最久未使用置换算法LRU：每次淘汰的页面都是最近最久未使用的页面。需要在页面中添加一个记录项，记录上次被访问以来经历的时间t，当需要淘汰页面时，选择时间t最大的淘汰，也就是最久未使用的淘汰。算法设计虽好，但开销很大，实现困难。</p></li><li><p>时钟置换算法：时钟置换算法也可以称为最近未使用算法。是一种性能和开销均衡的算法。</p></li><li><p>简单的时钟算法实现方法：为每个页面设置一个访问位，再将内存中的页面都通过链接指针链接成一个循环队列。当某页被访问时，其访问位置为1。当需要淘汰一个页面时，只需检查页的访问位。如果是0，就选择该页换出;如果是1，则将它置为0，暂不换出，继续检查下一个页面，若第一轮扫描中所有页面都是1，则将这些页面的访问位依次置为0后，再进行第二轮扫描（第二轮扫描中一定会有访问位为0的页面，因此简单的CLOCK算法选择一个淘汰页面最多会经过两轮扫描)</p></li></ul><h3 id="I-O原理"><a href="#I-O原理" class="headerlink" title="I/O原理"></a>I/O原理</h3><h4 id="文件的逻辑结构"><a href="#文件的逻辑结构" class="headerlink" title="文件的逻辑结构"></a>文件的逻辑结构</h4><ul><li><p>文件可以分为两类：</p><ul><li><p>无结构文件：文件内部数据就是一系列二进制流或字符流。最典型的就是txt文件。</p></li><li><p>有结构文件：由一组相似的记录组成，又称记录式文件。典型的excel表、数据库表等。</p></li></ul></li><li><p>有结构文件的逻辑结构又分顺序文件、索引文件、索引顺序文件，注意逻辑结构是展示给用户的，是文件的组织形式，例如是一张顺序存储的excel表格，还是一张excel索引表加上excel顺序表，还是多级索引加顺序，而不是在计算机上的存储方式。</p></li><li><p>顺序文件：文件中的记录一个接一个地顺序排列（逻辑上），记录可以是定长的或可变长的。各个记录在物理上可以顺序存储或链式存储。</p></li><li><p>顺序存储即逻辑相邻的文件物理上也相邻，链式存储即在末尾添加新的文件。</p></li><li><p>记录的类型又分为可变长和不可变长记录</p></li></ul><ul><li>索引顺序文件：索引顺序文件是索引文件和顺序文件思想的结合。索引顺序文件中，同样会为文件建立一张索引表，但不同的是：并不是每个记录对应一个索引表项，而是一组记录对应一个索引表项，索引表项的地址直接指向顺序文件所在区域，再顺序查找到所需的文件，从而节省了很大的空间。(例如我们可以通过An Qi找到An Kang、An Jie等，而不用在索引表中存放这么多信息。另外索引项之间不需要有按照逻辑关系排列)</li><li>多级索引顺序文件：在索引顺序文件的基础上再增加层次深度，可以减少查找的次数(顺序查找范围缩小了)</li></ul><h4 id="文件目录"><a href="#文件目录" class="headerlink" title="文件目录"></a>文件目录</h4><ul><li><p>文件目录可以分为：单级目录结构、两级目录结构、多级目录结构(树形目录结构)</p></li><li><p>单极目录结构：顾名思义，所有的文件放在一个目录中，类似于一个仓库把所有文件不加整理的堆放在一起，显然效率会很低下</p></li><li><p>两级目录结构:主要分为主文件目录和用户文件目录。类似于仓库中加了几个员工货架，不同员工的货物放在不同货架，但在一个货架中文件还是采用堆砌式的存储。</p></li><li><p>多级目录结构，又称树形目录结构:我们当前主流操作系统都是多级目录结构，简而言之就是文件目录可以一级一级的延申，从而文件更有条理。</p></li><li><p>FCB(文件控制块)，首先来看一张图，如果文件目录都以这种表的形式进行信息查找，会大大降低运行效率，增加系统负担。</p></li><li><p>提出对策，其实在查找各级目录的过程中，只需要用到文件名这个信息，可以考虑让目录表瘦身来提升效率。</p></li><li><p>索引结点指针指向索引结点(文件名之外的其他信息就存放在结点中，从而按需读取，提升效率)</p></li><li><p>每一个文件都有一个FCB，记录了文件的地址、信息、权限等等属性</p></li></ul><h4 id="文件的物理结构"><a href="#文件的物理结构" class="headerlink" title="文件的物理结构"></a>文件的物理结构</h4><ul><li><p>最重要的三种物理结构：顺序、链接、索引，其中最主要使用的是索引文件，可以随机访问，同时增删效率高</p></li><li><p>文件的物理结构是文件分配在计算机存储上的分配方式。分配的基本单位是 物理块,可以构想一下，一个大文件，如一首音乐23MB，难道直接一整个塞入硬盘吗？显然可能会出现一些问题，硬盘的空间也需要不断调整，就像内存分页一样，硬盘也被分为小的物理块号方便进行调度。</p></li><li><p>连续分配</p><ul><li>优点：支持顺序访问和直接访问（即随机访问）；连续分配的文件在顺序访问时速度最快</li><li>缺点：不方便文件拓展；存储空间利用率低，会产生磁盘碎片</li></ul></li><li><p>链式分配</p><ul><li>隐式：采用链式分配（隐式链接）方式的文件，只支持顺序访问，不支持随机访问，查找效率低。另外，指向下一个盘块的指针也需要耗费少量的存储空间。</li></ul></li></ul><ul><li><p>显式：直观理解就是在隐式的基础上添加了一张表，从表上能看出不同物理块号的下一块的地址</p></li><li><p>结论：采用链式分配（显式链接）方式的文件，支持顺序访问，也支持随机访问（想访问i 号逻辑块时，并不需要依次访问之前的0 ~ i-1号逻辑块），由于块号转换的过程不需要访问磁盘，因此相比于隐式链接来说，访问速度快很多</p></li><li><p>显式链接也不会产生外部碎片，也可以很方便地对文件进行拓展。</p></li><li><p>索引分配</p><ul><li>索引就是文件分成不同的物理块存入磁盘，对每个物理块都有一个索引与之对应，需要读写时就通过索引表查询其物理地址进行相关操作</li></ul></li></ul><h4 id="磁盘结构"><a href="#磁盘结构" class="headerlink" title="磁盘结构"></a>磁盘结构</h4><ul><li><p>磁道：每一圈就是一个磁道，最内侧磁道面积最小，所以数据密度最大</p></li><li><p>扇区：磁道被划分为小的磁盘块</p></li><li><p>一个盘片可能有两个盘面;每个盘面对应一个磁头；所有磁头连在一起，共进退；每个盘面的相对位置的磁道组成柱面</p></li></ul><h4 id="磁盘调度算法"><a href="#磁盘调度算法" class="headerlink" title="磁盘调度算法"></a>磁盘调度算法</h4><ul><li><p>磁盘调度算法要解决的核心问题就是寻道时间，即移动磁头的时间，而其他的启动时间、传输时间都很迅速，不是最主要的时间消耗</p></li><li><p>先来先服务FCFS</p><ul><li>根据进程请求房屋内磁盘的现后顺序进行调度。符合惯性思维，但在很多时候，效果很差。</li></ul></li><li><p>最短寻找时间优先(学过数据结构与算法的话，核心思想就是贪心算法)，该算法会优先处理与当前磁头最近的磁道的需求</p><ul><li>那么很可能磁头就会如图所示的移动，也会存在饥饿问题：磁头只在一个小区域移动，而不能满足需要远距离移动的需求。例如不断有18-&gt;38，38-&gt;18的需求，那磁头就不会执行18-&gt;150的请求，从而产生饥饿</li></ul></li><li><p>扫描算法</p><ul><li>核心思想，只有磁头移动到最外侧磁道的时候才能往内侧移动，移动到最内侧的时候才能向外侧移动。这样就不会产生饥饿问题。</li></ul></li></ul><h4 id="文件共享"><a href="#文件共享" class="headerlink" title="文件共享"></a>文件共享</h4><ul><li>文件共享分两种链接方式，硬链接和软连接<ul><li>硬链接就是在另一个用户的目录中，索引结点指针直接指向了发送分享的用户的索引节点，从而实现了共享，count的数量代表文件正在被几个用户使用。</li><li>软连接，类似于快捷方式，记录了原文件的路径，然后层层查找。</li></ul></li></ul><h4 id="文件保护"><a href="#文件保护" class="headerlink" title="文件保护"></a>文件保护</h4><ul><li><p>文件保护有三种方式口令、加密、访问控制</p><ul><li>口令：为文件设置一串口令，就像打开手机需要先解锁。</li></ul></li></ul><ul><li><p>加密：使用加密方法对文件加密，只有拥有正确的解密方法才能解密，有点像不同军队之间进行通信，要实现进行加密，要是想窥探敌情，就要对密文进行破解。</p></li><li><p>访问控制：每个文件的FCB或者索引结点中设置访问控制表，如windows中，设置了很多的访问权限，例如</p></li></ul><h4 id="I-O设备"><a href="#I-O设备" class="headerlink" title="I/O设备"></a>I/O设备</h4><ul><li><p>I/O就是输入输出，I/O设备就是可以将数据输入到计算机或将计算机数据输出的设备，常见的：鼠标、键盘、音响、显示器、打印机、话筒、摄像头等等。</p></li><li><p>I/O控制器:CPU无法直接控制I/O设备，需要一个电子部件去充当中间人，这个部件就是I/O控制器，CPU控制I/O控制器，I/O控制器控制I/O设备。</p></li><li><p>假如我们的CPU能够控制I/O设备，那不同的厂商、不同型号的设备，都要对应进行编码，显然是不切实际的，所以CPU要采用通用调度方式调度I/O设备从而需要I/O控制器。</p></li></ul><ul><li>Java语言中，调用System.out.Println()，这本身并不能在显示器上打印，而需要通过操作系统调用write方法，接着调用字符设备接口，命令显示器写</li></ul>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt; 操作系统（OS）是管理和控制计算机硬件与软件资源，是计算机上直接运行的最基本的系统软件，任何其他软件都必须在操作系统的支持下才能运行。操作系统是用户和计算机的接口，同时也是计算机硬件和其他软件的接口。操作系统的功能包括管理计算机系统的硬件、软件及数据资源，控制程序运行，提供人机交互界面，为其它应用软件提供支持等。我选择的课程是苏州大学的&lt;a href=&quot;https://www.icourse163.org/course/SUDA-1001752241&quot;&gt;国家精品课&lt;/a&gt;和汤子瀛版教材，以下为所记课堂笔记下半部分，包含内存管理、文件管理和设备管理的知识点，可供参考。上半部分笔记请访问&lt;a href=&quot;/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E4%B8%8A&quot;&gt;操作系统（上）&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="计算机专业" scheme="http://blog.zhuangzhihao.top/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%93%E4%B8%9A/"/>
    
    
    <category term="Linux" scheme="http://blog.zhuangzhihao.top/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>数据结构（下）</title>
    <link href="http://blog.zhuangzhihao.top/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%B8%8B/"/>
    <id>http://blog.zhuangzhihao.top/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%B8%8B/</id>
    <published>2021-09-07T16:00:00.000Z</published>
    <updated>2021-09-25T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>数据结构是指数据的存储结构，是带有结构特性的数据元素的集合。精心选择的数据结构可以带来更好的运行或者存储效率。数据结构是计算机科学与技术专业、软件工程专业甚至于其它电气信息类专业的重要专业基础课程，在408计算机学科专业基础综合考试中占有45分。我选择的课程是浙江大学数据结构<a href="https://www.icourse163.org/course/ZJU-93001">国家精品课</a>，以下为所记课堂笔记第三部分，包含排序、查找算法和平衡二叉树的知识总结以及所需记忆的代码，另外我在开源仓库中还保持了浙大慕课版本的<a href="https://github.com/Bezhuang/LearnCS/tree/main/%E5%90%8D%E6%A0%A1%E5%85%AC%E5%BC%80%E8%AF%BE/%E6%B5%99%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84">代码</a>，可供参考。其他部分笔记详见<a href="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%B8%8A">数据结构（上）</a>和<a href="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%B8%AD">数据结构（中）</a></p></blockquote><a id="more"></a><h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><h4 id="排序的基本概念"><a href="#排序的基本概念" class="headerlink" title="排序的基本概念"></a>排序的基本概念</h4><ul><li>排序：将原本无序的序列重新排列成有序序列的过程，这个序列中的每一项可能是单独的数据元素，也可能是一条记录</li><li>记录由多个数据元素组成的，既可以按照记录的主关键字排序（主关键字唯一标识一条记录），也可以按照记录的次关键字排序</li><li>稳定性：当待排序序列中有两个或两个以上相同的关键字时，排序前和排序后这些关键字的相对位置，如果没有发生变化就是稳定的，否则就是不稳定的</li><li>排序算法的分类<ul><li>插入类的排序：直接插入、折半插入、希尔排序</li><li>交换类的排序：冒泡排序、快速排序</li><li>选择类的排序：简单选择、堆选择</li><li>归并类的排序：二路归并</li><li>基数类的排序：多关键字排序</li></ul></li></ul><h4 id="插入类的排序"><a href="#插入类的排序" class="headerlink" title="插入类的排序"></a>插入类的排序</h4><ul><li><p>插入排序</p><pre><code class="cpp">void InsertSort(int* h, size_t len)&#123;    if(h==NULL) return;    if(len&lt;=1) return;    int i,j;    //i是次数，也即排好的个数;j是继续排    for(i=1;i&lt;len;++i)        for(j=i;j&gt;0;--j)            if(h[j]&lt;h[j-1]) Swap(h[j],h[j-1]);            else break;    return;&#125;</code></pre></li><li><p>希尔排序</p><ul><li>缩小增量排序：把记录按下标的一定增量分组，对每组使用直接插入排序算法排序</li><li>随着增量逐渐减少，每组包含的关键词越来越多，当增量减至1时，整个文件恰被分成一组，算法便终止</li></ul><pre><code class="cpp">void ShellSort(int* h, size_t len)&#123;    if(h==NULL) return;    if(len&lt;=1) return;    for(int div=len/2;div&gt;=1;div/=2)        for(int k=0;k&lt;div;++k)            for(int i=div+k;i&lt;len;i+=div)                for(int j=i;j&gt;k;j-=div)                    if(h[j]&lt;h[j-div]) Swap(h[j],h[j-div]);                    else break;    return;&#125;</code></pre></li></ul><h4 id="交换类的排序"><a href="#交换类的排序" class="headerlink" title="交换类的排序"></a>交换类的排序</h4><ul><li><p>快速排序</p><pre><code class="cpp">void QuickSort(SeqList R，int low，int high) &#123; //对 R[low..high]快速排序     int pivotpos； //划分后的基准记录的位置         if (low &lt; high) &#123; //仅当区间长度大于 1 时才须排序             pivotpos = Partition(R，low，high)； //对 R[low..high]做划分                 QuickSort(R，low，pivo t   pos-1)； //对左区间递归排序                 QuickSort(R，pivotp o s+1，high)； //对右区间递归排序         &#125;&#125; //QuickSort</code></pre></li><li><p>冒泡排序</p><ul><li>通过依次交换相邻两个顺序不合法的元素位置，从而将当前最小（大）元素放到合适的位置</li></ul><pre><code class="cpp">void BubbleSort(int* h, size_t len)&#123;    if(h==NULL) return;    if(len&lt;=1) return;    //i是次数，j是具体下标    for(int i=0;i&lt;len-1;++i)        for(int j=0;j&lt;len-1-i;++j)            if(h[j]&gt;h[j+1])                Swap(h[j],h[j+1]);    return;&#125;</code></pre></li></ul><h4 id="选择类的排序"><a href="#选择类的排序" class="headerlink" title="选择类的排序"></a>选择类的排序</h4><ul><li><p>选择排序</p><ul><li>初始时在序列中找到最小（大）元素，放到序列的起始位置作为已排序序列，然后，再从剩余未排序元素中继续寻找最小（大）元素，放到已排序序列的末尾。以此类推，直到所有元素均排序完毕</li><li>每遍历一次都记住了当前最小（大）元素的位置，最后仅需一次交换操作即可将其放到合适的位置</li></ul><pre><code class="cpp">void SelectionSort(int* h, size_t len)&#123;    if(h==NULL) return;    if(len&lt;=1) return;    int minindex,i,j;    //i是次数，也即排好的个数;j是继续排    for(i=0;i&lt;len-1;++i)    &#123;        minindex=i;        for(j=i+1;j&lt;len;++j)        &#123;            if(h[j]&lt;h[minindex]) minindex=j;        &#125;        Swap(h[i],h[minindex]);    &#125;    return;&#125;</code></pre></li><li><p>堆排序</p><ul><li>堆实际上是一棵完全二叉树，堆的每一个父节点都大于（或小于）其子节点，堆的每个左子树和右子树也是一个堆</li><li>最大堆（大顶堆）：堆的每个父节点都大于其孩子节点；最小堆（小顶堆）：堆的每个父节点都小于其孩子节点</li><li>堆的第一个元素要么是最大值（大顶堆），要么是最小值（小顶堆），这样在排序的时候（假设共 n 个节点），直接将第一个元素和最后一个元素进行交换，然后从第一个元素开始进行向下调整至第 n-1 个元素。所以，如果需要升序，就建一个大堆，需要降序，就建一个小堆</li></ul><pre><code class="cpp">void HeapSort(SeqIAst R)&#123; //对 R[1..n]进行堆排序，不妨用 R[0]做暂存单元     int i；        BuildHeap(R)； //将 R[1-n]建成初始堆         for (i = n;i &gt; 1；  i  -)        &#123; //对当前无序区 R[1..i]进行堆排序，共做 n-1 趟            R[0] = R[1];            R[1] = R[i];            R[i] = R[0];//将堆顶和堆中最后一个记录交换             Heapify(R，1 ，i-1); //将 R[1..i-1]重新调整为堆，仅有 R[1]可能违反堆性质         &#125; //endfor &#125; //HeapSort</code></pre></li></ul><h4 id="二路归并排序"><a href="#二路归并排序" class="headerlink" title="二路归并排序"></a>二路归并排序</h4><ul><li><p>MERGE-SORT：利用归并的思想实现的排序方法，采用经典的分治（divide-and-conquer）策略</p></li><li><p>递归拆分子序列，将两个已经有序的子序列合并成一个有序序列</p><pre><code class="cpp">void MergeSortDC(SeqList R，int low，int high) &#123;//用分治法对 R[low..high]进行二路归并排序  int mid；  if(low&lt;high)&#123; //区间长度大于 1  mid=(low+high)/2； //分解  MergeSortDC(R，low，mid); //递归地对 R[low..mid]排序  MergeSortDC(R，mid+1，high)； //递归地对 R[mid+1..high]排序  Merge(R，low，mid，high)； //组合，将两个有序区归并为一个有序区  &#125; &#125;//MergeSortDC </code></pre></li></ul><h4 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h4><ul><li><p>不需要比较关键字的大小，根据关键字中各位的值，通过对排序的N个元素进行若干趟分配与收集来实现排序的</p></li><li><p>时间复杂度为 $O\left( d\left( n+r_{d}\right) \right)$</p><pre><code class="cpp">int GetMaxDight(int* h, int len)&#123;    if(h==NULL) return 0;    if(len&lt;1) return 0;    int max=h[0];    for(int i=1;i&lt;len;++i)    &#123;        if(h[i]&gt;max) max=h[i];    &#125;    int digit=1;    while(max/10!=0)    &#123;        max/=10;        ++digit;    &#125;    return digit;&#125;int GetReminder(int value,int digit)&#123;    int div=1;    for(int i=1;i&lt;digit;++i)        div*=10;    return value/div%10;&#125;void RadixSort_LSD(int* h, int len)&#123;    if(h==NULL) return;    if(len&lt;=1) return;    int digit=GetMaxDight(h,len);    //printf(&quot;MaxDigit:%d\n&quot;, digit);    int count[10]=&#123;0&#125;;    int *tmp=(int*)calloc(len,sizeof(int));    for(int d=1;d&lt;=digit;++d)    &#123;        memset(count,0,sizeof(count));        for(int i=0;i&lt;len;++i)        &#123;            count[GetReminder(h[i],d)]++;        &#125;        //求右边界        for(int i=1;i&lt;10;++i)        &#123;            count[i]+=count[i-1];        &#125;        for(int i=len-1;i&gt;=0;--i)        &#123;            int r=GetReminder(h[i],d);            int index=count[r];            tmp[index-1]=h[i];            count[r]--;        &#125;        memcpy(h,tmp,len*sizeof(int));    &#125;    free(tmp);&#125;void RadixSort_LSD_Reverse(int* h, int len)&#123;    if(h==NULL) return;    if(len&lt;=1) return;    int digit=GetMaxDight(h,len);    //printf(&quot;MaxDigit:%d\n&quot;, digit);    int count[10]=&#123;0&#125;;    int *tmp=(int*)calloc(len,sizeof(int));    for(int d=1;d&lt;=digit;++d)    &#123;        memset(count,0,sizeof(count));        for(int i=0;i&lt;len;++i)        &#123;            count[GetReminder(h[i],d)]++;        &#125;        //printf(&quot;haha\n&quot;);        //求右边界        for(int i=8;i&gt;=0;--i)        &#123;            count[i]+=count[i+1];        &#125;        for(int i=len-1;i&gt;=0;--i)        &#123;            int r=GetReminder(h[i],d);            int index=count[r];            tmp[index-1]=h[i];            count[r]--;        &#125;        memcpy(h,tmp,len*sizeof(int));    &#125;    free(tmp);&#125;</code></pre></li></ul><h4 id="排序知识点总结"><a href="#排序知识点总结" class="headerlink" title="排序知识点总结"></a>排序知识点总结</h4><ul><li>快速排序、希尔排序、归并排序、堆排序的平均时间复杂度都是 $O\left( n\log _{2}n\right)$，其他都是 $O(n^2)$</li><li>快速排序的空间复杂度为 $O\left( \log <em>{2}n\right)$，归并排序的空间复杂度为 $O\left( n\right)$，基数排序的空间复杂度为 $O\left( r</em>{d}\right)$，其他都是 $O(1)$</li><li>快速排序、希尔排序、简单选择排序、堆排序是不稳定的，其他都是稳定的</li><li>交换类和选择类的排序，经过一趟排序能够保证一个关键字到达最终位置</li><li>简单选择排序和折半插入排序的关键字比较次数和原始序列无关</li><li>交换类的排序趟数和原始序列有关</li><li>直接插入按顺序查找的方式，而折半插入按折半查找的方式排序</li><li>借助于比较进行排序的算法在最坏情况下的时间复杂度至少为 $O\left( n\log _{2}n\right)$</li></ul><h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3><h4 id="查找的基本概念"><a href="#查找的基本概念" class="headerlink" title="查找的基本概念"></a>查找的基本概念</h4><ul><li><p>给定一个值 K，在含有 n 个记录的表中找出关键字等于 K 的记录叫查找，记录即为关键字</p></li><li><p>通常把查找过程中对关键字的平均比较次数（也称平均查找长度）作为衡量一个查找算法优劣的标准</p></li><li><p>平均查找长度 $ASL=\sum ^{n}<em>{i=1}p</em>{i}\times c_{i}$</p><ul><li>$p_{i}$ 为查找第 i 个记录的概率，$c_{i}$ 为找到第 i 个记录所需要进行比较的次数（查找长度）</li></ul></li><li><p>顺序查找</p><ul><li>用待查找的关键字和给定序列中的各元素的关键字从左到右（或从右到左）依次进行比较，直到成功或失败</li><li>存储结构通常是顺序结构，也可是链式结构</li></ul><pre><code class="cpp">//顺序表的查找（不带监视哨）int SeqSearch(SSTable S, DataType x)&#123;    int i = 0;    while (i &gt; s.length &amp; S.list[i].key != x.key)        i++;    if (s.list[i].key == x.key)        return i + 1;    return 0;&#125;//顺序表的查找（带监视哨）int SeqSearch2(SSTable S, DataType x)&#123;    int i = S.length;    //将关键字存放在0位置处,防止越界    /*哨兵的主要作用就是在查找循环中监视下标i是否越界      一旦越界(i=0),因为可以和自己进行比较,循环判定条件      不成立就使得查找循环结束,就可以达到忽略判定边界条件的目的*/    s.list[o].key = x.key;    while (s.list[i].key != x.key)        i--;    return i;    // 实际上,一切为简化边界条件而引入的附加结点(元素)均可称为哨兵&#125;//顺序表的查找（链表实现）Node* Search(Lnode* head, int key)&#123;    LNode* p = head-&gt;next;    while (p != NUll)    &#123;        if (P-&gt;data == key)            return p;        p = p-&gt;next;    &#125;    return NULL;&#125;</code></pre></li><li><p>二分查找</p><ul><li>要求线性表是有序的</li><li>在给定序列是有序表的前提下，将表中间位置处的关键字和查找关键字比较，相 等则查找成功</li><li>否则从中间位置将表分成前后两个子表，如果中间位置处的关键字大于 查找关键字，则进一步查找前子表，否则查找后子表</li><li>重复以上过程，直到找到满足条件的记录，此时查找成功，或直到子表不存在为止，表示查找失败</li></ul><pre><code class="cpp">int BSearch(int arr[], int low, int high, int key) &#123;    while (low &lt;= high) &#123;        int mid = (low + high) / 2;        if (arr[mid == key])            return mid;        else if (arr[mid] &gt; key)            high = mid - 1;        else            low = mid + 1;    &#125;    return -1;&#125;</code></pre></li></ul><h4 id="二叉排序树（BST）"><a href="#二叉排序树（BST）" class="headerlink" title="二叉排序树（BST）"></a>二叉排序树（BST）</h4><ul><li><p>二叉排序树要么是空树,要么是满足下列要求的树</p><ul><li>若它的左子树不空，则左子树上所有的关键字的值均小于根节点关键字值</li><li>若它的右子树不空，则右子树上所有的关键字的值均大于根节点关键字值</li><li>左右子树又各是一棵二叉排序树</li></ul></li><li><p>Binary Search Tree 又被叫做二叉搜索树 or 二叉查找树</p></li><li><p>在对某个关键字进行查找的时候，首先和二叉排序树的根节点进行比较，若相等则査找成功</p></li><li><p>由于二叉排序树本身的性质，若该关键字小于根节点值，则再与其左子树进行比较,否则和其右子树进行比较，直到找到与之相等的节点，则查找成功</p></li><li><p>若待比较的位置来到空指针处，则表示査找失败，返回失败的标记</p><pre><code class="cpp">//非递归算法BTNode* BSTSearch(BTNode* p, int key) &#123;    while (p != NULL) &#123;        if (key == p-&gt;key)            return p;        else if (key &lt; p-&gt;key)            p = p-&gt;lChild;        else            p = p-&gt;rChild;    &#125;    return NULL;&#125;//递归算法BTNode* BSTSearch2(BTNode* p, int key) &#123;    if (p == NULL)        return NULL;    else&#123;        if (key == p-&gt;key)            return p;        else if (key &lt; p-&gt;key)            return BSTSearch2(p-&gt;lChild, key);        else            return BSTSearch2(p-&gt;rChild, key);    &#125;&#125;</code></pre></li></ul><h4 id="平衡二叉树（AVL-树）"><a href="#平衡二叉树（AVL-树）" class="headerlink" title="平衡二叉树（AVL 树）"></a>平衡二叉树（AVL 树）</h4><ul><li>平衡二叉树是一种特殊的二叉排序树，其左右子树都是平衡二叉树且左右子树高度之差的绝对值不超过1</li><li>一个节点的平衡因子为其左子树的高度减去右子树的高度，对于平衡二叉树，树中所有结点的平衡因子取值只可能是-1、0、1</li><li>若向平衡二叉树中插入一个新结点后破坏了平衡二叉树的平衡性，则首先要找出插入新节点后失去平衡的最小子树，然后再调整这颗子树使之成为平衡子树</li><li>当失去平衡的最小子树被调整为平衡子树后，无需调整原有其他所有的不平衡子树</li><li>最小不平衡子树：是以距离插入结点最近且以平衡因子绝对值大于1的结点作为跟的子树，又称为失去平衡的最小子树</li></ul><h4 id="散列表"><a href="#散列表" class="headerlink" title="散列表"></a>散列表</h4><ul><li><p>Hash：根据给定的关键字来计算出关键字在表中的地址</p></li><li><p>Hash table（哈希表）：是根据关键码值（Key value）而直接进行访问的数据结构，=通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度，这个映射函数叫做散列函数，存放记录的数组叫做散列表</p></li><li><p>给定表 M，存在函数 f(key)，对任意给定的关键字值 key，代入函数后若能得到包含该关键字的记录在表中的地址，则称表 M 为哈希表，函数 f(key) 为哈希函数</p></li><li><p>键（key）：又称为关键字。唯一的标示要存储的数据，可以是数据本身或者数据的一部分</p></li><li><p>槽（slot/bucket）：哈希表中用于保存数据的一个单元，也就是数据真正存放的容器</p></li><li><p>哈希函数（hash function）：将 key 映射 map 到数据应该存放的槽 slot 所在位置的函数</p></li><li><p>哈希冲突（hash collision）：哈希函数将两个不同的键映射到同一个索引的情况</p><pre><code class="cpp">int h1(int x)&#123;  return (x%5);&#125;int h2(char* x)&#123;  int i,sum;  for(sum=0, i=0; x[i] != &#39;\0&#39;; i++)    sum += (int)x[i];  return (sum%5);&#125;int ELFhash(char*key)&#123;    unsigned long h=0;    while(*key)    &#123;        h = (h &lt;&lt; 4) + *key++;        unsigned long g = h &amp; 0xF0000000L;        if(g)            h ^= g &gt;&gt; 24;        h &amp;= ~g;    &#125;    return h % MOD;&#125;</code></pre></li><li><p>散列表的性能分析（查找成功时的平均查找长度）：找到表中已有表项的平均次数</p></li><li><p>装填因子是关键字个数和表长度的比值</p></li></ul><h3 id="常用算法补充"><a href="#常用算法补充" class="headerlink" title="常用算法补充"></a>常用算法补充</h3><ul><li><p>动态规划算法</p><ul><li>处理多阶段决策问题，一般由初始状态开始，通过对中间阶段决策的选择，达到结束状态</li><li>这些决策形成了一个决策序列，同时确定了完成整个过程的一条活动路线（通常是求最优的活动路线）</li><li>动态规划往往可以用递归程序来实现，不过因为递推可以充分利用前面保存的子问题的解来减少重复计算，所以对于大规模问题来说，有递归不可比拟的优势，这也是动态规划算法的核心之处</li></ul><pre><code class="cpp">for (j = 1; j &lt;= m; j = j + 1) // 第一个阶段    xn[j] = 初始值;for (i = n - 1; i &gt; = 1; i = i - 1)// 其他n-1个阶段    for (j = 1; j &gt;= f(i); j = j + 1)//f(i)与i有关的表达式        xi[j] = j = max&#123; g(xi - 1[j1:j2]), ...... ,  g(xi - 1[jk:jk + 1]) &#125;;t = g(x1[j1:j2]); // 由子问题的最优解求解整个问题的最优解的方案print(x1[j1]);for (i = 2; i &lt;= n - 1; i = i + 1)&#123;    t = t - xi - 1[ji];    for (j = 1; j &gt;= f(i); j = j + 1)        if (t = xi[ji])            break;&#125;</code></pre></li><li><p>贪心算法</p><ul><li>在对问题求解时，总是做出在当前看来是最好的选择，局部最优解</li><li>整个问题的最优解一定由在贪心策略中存在的子问题的最优解得来的</li><li>贪心算法建立哈夫曼树</li></ul><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;using namespace std;typedef struct BTreeNode&#123;    int  data;    struct BTreeNode* left;    struct BTreeNode* right;&#125;btreenode;//建立哈夫曼树btreenode *CreateHuffman(int a[],int n)&#123;    int i;    btreenode *s[n+1], *ss;    for(int i = 0;i&lt;n;i++)&#123;        s[i] = new btreenode;  //初始化s指针数组，使每个指针元素指向a数组中对应的元素结点        s[i]-&gt;data = a[i];   //将树拆成森林，每棵树都只有一个根节点        s[i]-&gt;left = s[i]-&gt;right = NULL;    &#125;    for(int i  = 1;i&lt;n;i++)&#123;        //进行 n-1次循环建立哈夫曼树           int k = -1,t;           //k表示森林中具有最小权值的树根结点的下标，t为次最小的下标        for(int j = 0;j&lt;n;j++)&#123;   //k初始指向森林中第一棵树，t指向第二棵                if(s[j]&amp;&amp;k==-1)&#123;                   k = j;                   continue;                &#125;                if(s[j])&#123;                    t =  j;                    break;                &#125;        &#125;        for(int i = t;i&lt;n;i++)&#123;   //从当前森林中求出最小权值树和次最小 ；            if(s[i])&#123;                if(s[i]-&gt;data&lt;s[k]-&gt;data)&#123;        //比最小树小                    t = k;                    k = i;                &#125;                else if(s[i]-&gt;data&lt;s[t]-&gt;data)&#123;  //比次小树小                    t = i;                &#125;                else&#123;                    ;                &#125;            &#125;        &#125;           //由最小权值树和次最小权值树建立一棵新树，ss指向树根结点(以后依次建立)           ss  = new btreenode;     //ss = (btreenode *)malloc(sizeof(btreenode))           ss-&gt;data =   s[k]-&gt;data+s[t]-&gt;data;           ss-&gt;left =   s[k];           ss-&gt;right =  s[t];           s[k] =  ss;  //关键点:将ss赋给s[k](k为上述找到的最小树下标,但这是s[k]代表的值已改变，同时把s[t]失效的置空,                       //在这里起向下一个判断的作用if(s[j])&#123;t = j;break;&#125;           s[t] = NULL;    &#125;        free(s);   //释放分配空间        return ss;&#125;//求哈夫曼树的带权路径长度int WeightPathLength(btreenode* FBT, int len)&#123;          //参数len为树的层数    if(!FBT)&#123;        return 0;    &#125;    else&#123;        if(FBT-&gt;left ==NULL&amp;&amp;FBT-&gt;right ==NULL)//访问到叶子结点            return FBT-&gt;data*len;        else&#123;               //访问到非叶子结点，进行递归调用，返回左右子树的带权路径长度之和，len递增            return  WeightPathLength(FBT-&gt;left,len+1)+WeightPathLength(FBT-&gt;right,len+1);//一定要记得加1        &#125;    &#125;&#125;//哈夫曼编码void HuffManCoding(btreenode* FBT, int len)&#123;   //参数len为树的层数    static int a[20];                        //定义静态数组a，保存每个叶子的编码，数组长度至少是树深度减1    if(FBT)&#123;                                 //访问到叶子结点时输出其保存在数组a中的0和1序列编码        if(FBT-&gt;left == NULL&amp;&amp;FBT-&gt;right == NULL)&#123;             printf(&quot;结点权值为%d的编码:&quot;,FBT-&gt;data);             for(int i = 0;i&lt;len;i++)&#123;                 printf(&quot;%d&quot;,a[i]);            &#125;                printf(&quot;\n&quot;) ;        &#125;        else&#123;    //访问到非叶子结点时分别向左右子树递归调用，并把分支上的0、1编码保存到数组                //a的对应元素中，向下深入一层时len值增1               a[len] = 0;               HuffManCoding(FBT-&gt;left,len+1);               a[len] = 1;               HuffManCoding(FBT-&gt;right,len+1);            &#125;    &#125;&#125;int main()&#123;    btreenode *s;    int n;    printf(&quot;从键盘输入待构造的哈夫曼树中带权叶子结点数n：&quot;);    while(true)&#123;        scanf(&quot;%d&quot;,&amp;n);        if(n&gt;0)&#123;            break;        &#125;        else&#123;            printf(&quot;-------输入不合法,请重新输入!!\n&quot;);        &#125;    &#125;    int *a = (int *)malloc(n *sizeof(int));    printf(&quot;从键盘输入%d个整数作为权值:&quot;,n);    for (int i = 0; i &lt; n; i++)        scanf(&quot;%d&quot;, &amp;a[i]);    s = CreateHuffman(a,n);    printf(&quot;哈夫曼树的带权路径长度：&quot;);    printf(&quot;%d\n&quot;, WeightPathLength(s, 0));    printf(&quot;树中每个叶子结点的哈夫曼编码：\n&quot;);    HuffManCoding(s,0);    return 0;&#125;</code></pre></li></ul>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;数据结构是指数据的存储结构，是带有结构特性的数据元素的集合。精心选择的数据结构可以带来更好的运行或者存储效率。数据结构是计算机科学与技术专业、软件工程专业甚至于其它电气信息类专业的重要专业基础课程，在408计算机学科专业基础综合考试中占有45分。我选择的课程是浙江大学数据结构&lt;a href=&quot;https://www.icourse163.org/course/ZJU-93001&quot;&gt;国家精品课&lt;/a&gt;，以下为所记课堂笔记第三部分，包含排序、查找算法和平衡二叉树的知识总结以及所需记忆的代码，另外我在开源仓库中还保持了浙大慕课版本的&lt;a href=&quot;https://github.com/Bezhuang/LearnCS/tree/main/%E5%90%8D%E6%A0%A1%E5%85%AC%E5%BC%80%E8%AF%BE/%E6%B5%99%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84&quot;&gt;代码&lt;/a&gt;，可供参考。其他部分笔记详见&lt;a href=&quot;/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%B8%8A&quot;&gt;数据结构（上）&lt;/a&gt;和&lt;a href=&quot;/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%B8%AD&quot;&gt;数据结构（中）&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="算法与数据结构" scheme="http://blog.zhuangzhihao.top/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
  </entry>
  
  <entry>
    <title>微分学重点</title>
    <link href="http://blog.zhuangzhihao.top/%E5%BE%AE%E5%88%86%E5%AD%A6%E9%87%8D%E7%82%B9/"/>
    <id>http://blog.zhuangzhihao.top/%E5%BE%AE%E5%88%86%E5%AD%A6%E9%87%8D%E7%82%B9/</id>
    <published>2021-09-04T16:00:00.000Z</published>
    <updated>2021-12-10T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>微分学重点的十二章关于导数的课程深入挖掘了微积分的子领域，“微分”。 与微积分重点的课程一样，MIT 数学教授 Gilbert Strang 解释了每个主题如何应用于现实生活中，是对微积分重点的补充，以下为所记课堂笔记，笔记以中文形式记录，方便理解，可供参考。</p></blockquote><a id="more"></a><h3 id="极限和连续"><a href="#极限和连续" class="headerlink" title="极限和连续"></a>极限和连续</h3><ul><li><p> 极限定义：当 $n\rightarrow \infty$ 时，$a_{n}\rightarrow A$</p></li><li><p>洛必达法则：假设 $f(x)$ 和 $g(x)$ 都收敛于 0</p><ul><li> $\dfrac{f\left( x\right) }{g\left( x\right) }=\dfrac{\dfrac{\Delta f}{\Delta x}}{\dfrac{\Delta g}{\Delta x}}\rightarrow \dfrac{s}{t}$</li></ul></li><li><p> 可导必然连续，连续不一定可导</p></li><li><p> 连续定义：对任取 $\varepsilon$，都能找到 $\delta$，满足如果 $\left| x-a\right| &lt;\delta$，则 $\left| f\left( x\right) -f\left( a\right) \right| &lt;\varepsilon$</p></li></ul><h3 id="sinx-和-cosx-的导数"><a href="#sinx-和-cosx-的导数" class="headerlink" title="$sinx$ 和 $cosx$ 的导数"></a>$sinx$ 和 $cosx$ 的导数</h3><ul><li><p>用 $sin$ 和 $cos$ 表示勾股定理</p><ul><li><p>$a^2+b^2=c^2$ $\rightarrow$ $\dfrac{a^{2}}{c^{2}}+\dfrac{b^{2}}{c^{2}}=1$ </p></li><li><p>$\left( \cos \theta \right) ^{2}+\left( \sin \theta \right) ^{2}=1$</p></li></ul></li><li><p>$\dfrac{d}{dx}\sin x=\dfrac{\Delta \left( \sin x\right) }{\Delta x}=\dfrac{\sin \left( x+\Delta x\right) -\sin x}{\Delta x}$</p><ul><li><p>因为 $\sin \left( x+\Delta x\right) =\sin x\cos \Delta x+\cos x\sin \Delta x$</p></li><li><p>所以原式 = $\dfrac{sinx\left( \cos \Delta x-1\right) }{\Delta x}+\dfrac{\cos x\sin \Delta x}{\Delta x}$</p></li><li><p>又因为 $\dfrac{\cos \left( \Delta x-1\right) }{\Delta x}\rightarrow 0$ 且 $\dfrac{\sin \Delta x}{\Delta x}\rightarrow 1$</p></li><li><p>所以 $\dfrac{d}{dx}\sin x=\cos x$</p></li></ul></li><li><p>$\dfrac{d}{dx}\cos x=\dfrac{\Delta \left( \cos x\right) }{\Delta x}=\dfrac{\cos \left( x+\Delta x\right) -\cos x}{\Delta x}$</p><ul><li><p>因为 $\cos \left( x+\Delta x\right) =\cos x\cos \Delta x-\sin x\sin \Delta x$</p></li><li><p>所以原式 = $\dfrac{cos\left( \cos \Delta x-1\right) }{\Delta x}-\dfrac{\sin x\sin \Delta x}{\Delta x}$</p></li><li><p>所以 $\dfrac{d}{dx}\cos x=-\sin x$</p></li></ul></li><li><p>$sinx$ 和 $cosx$ 的导数</p><ul><li><p>$\dfrac{d}{dx}\sin x=\cos x$</p></li><li><p>$\dfrac{d}{dx}\cos x=-\sin x$</p></li></ul></li></ul><h3 id="乘法法则和除法法则"><a href="#乘法法则和除法法则" class="headerlink" title="乘法法则和除法法则"></a>乘法法则和除法法则</h3><ul><li><p>$p(x)=f(x)g(x)$</p><ul><li><p>$\dfrac{\Delta p}{\Delta x}=\dfrac{f\Delta g}{\Delta x}+\dfrac{g\Delta f}{\Delta x}+\dfrac{\Delta f{\Delta }g}{\Delta x}$</p></li><li><p>乘法法则：$\dfrac{dp}{dx}=f\left( x\right) \dfrac{dg}{dx}+g\left( x\right) \dfrac{df}{dx}$</p></li><li><p>$\dfrac{d}{dx}x^{n}=nx^{n-1}$</p></li><li><p>$y=x^2sinx$：$\dfrac{dy}{dx}=x^{2}\cos x+2xsinx$</p></li></ul></li><li><p>$q(x)=\dfrac{f(x)}{g(x)}$</p><ul><li><p>$f(x)=g(x)q(x)$</p></li><li><p>$\dfrac{df}{dx}=g\left( x\right) \dfrac{dq}{dx}+q\left( x\right) \dfrac{dg}{dx}=g\left( x\right) \dfrac{dq}{dx}+\dfrac{f\left( x\right) }{g\left( x\right) }\dfrac{dg}{dx}$</p></li><li><p>$g\left( x\right) \dfrac{df}{dx}-f\left( x\right) \dfrac{dg}{dx}=g(x)^{2}\dfrac{dq}{dx}$</p></li><li><p>除法法则：$\dfrac{dq}{dx}=\dfrac{g\left( x\right) \dfrac{df}{dx}-f\left( x\right) \dfrac{dg}{dx}}{g\left( x\right) ^{2}}$</p></li></ul></li></ul><h3 id="链式法则"><a href="#链式法则" class="headerlink" title="链式法则"></a>链式法则</h3><ul><li><p>函数链（复合函数）：$y=g(x)$，$z=f(y)$</p><ul><li>求导：$\dfrac{dz}{dx}=\dfrac{dz}{dy}\dfrac{dy}{dx}$</li></ul></li><li><p>$sin(3x)$ 的导数：$3cos(3x)$</p></li><li><p>$\dfrac{1}{\sqrt{1-x^{2}}}$ 的导数：$\left( -\dfrac{1}{2}\left( 1-x^{2}\right) ^{-3}\right) -2x=x\left( 1-x^{2}\right) ^{-\dfrac{3}{2}}$</p></li><li><p>$e^{-\dfrac{x^{2}}{2}}$ 的导数：$-x\cdot e^{-\dfrac{x^{2}}{2}}$</p><ul><li>二阶导数：$\left( -x\right) \left( -xe^{-\dfrac{x^{2}}{2}}\right) +\left( e^{-\dfrac{x^{2}}{2}}\right) \left( -1\right)=(x^2-1)\cdot e^{-\dfrac{x^{2}}{2}}$</li></ul></li></ul><h3 id="反函数-f-1-left-y-right-与对数函数-x-lny"><a href="#反函数-f-1-left-y-right-与对数函数-x-lny" class="headerlink" title="反函数 $f^{-1}\left( y\right)$ 与对数函数 $x=lny$"></a>反函数 $f^{-1}\left( y\right)$ 与对数函数 $x=lny$</h3><ul><li><p>$y=f(x)$ 的反函数：$x=f^{-1}(y)$，原函数和反函数关于 $y=x$ 对称</p></li><li><p>$y=e^{x}$ 的反函数：$x=lny$</p></li><li><p>对数函数的性质</p><ul><li><p>$\ln(xy) =\ln x+\ln y$</p></li><li><p>$ln(y^n)=nlny$</p></li></ul></li><li><p>$\dfrac{d}{dy}\left( \ln y\right) =\dfrac{1}{y}$</p></li></ul><h3 id="对数函数-lny-和反三角函数-sin-1-y-的导数"><a href="#对数函数-lny-和反三角函数-sin-1-y-的导数" class="headerlink" title="对数函数 $lny$ 和反三角函数 $sin^{-1}(y)$ 的导数"></a>对数函数 $lny$ 和反三角函数 $sin^{-1}(y)$ 的导数</h3><ul><li><p>令 $y=e^x$</p><ul><li><p>$\ln \left( e^{x}\right) =x$ 两边求导 $\dfrac{d}{dy}\left( \ln y\right) e^{x}=1$</p></li><li><p>$\dfrac{d}{dy}\left( \ln y\right) =\dfrac{1}{e^{x}}=\dfrac{1}{y}$</p></li></ul></li><li><p>$x=\sin ^{-1}y=\arcsin y$</p><ul><li><p>$y=\sin \left( \sin ^{-1}y\right)$ 两边求导 $1=\cos \left( \sin ^{-1}y\right) \dfrac{d\sin ^{-1}y}{dy}$</p></li><li><p>$1=\sqrt{1-y^{2}}\dfrac{d}{dy}\sin ^{-1}y$</p></li><li><p>$\dfrac{d}{dy}\sin ^{-1}y=\dfrac{1}{\sqrt{1-y^{2}}}$</p></li></ul></li><li><p>同理：$\dfrac{d}{dy}\cos ^{-1}y=\dfrac{-1}{\sqrt{1-y^{2}}}$，$\dfrac{d}{dy}\tan ^{-1}\left( y\right) =\dfrac{1}{1+y^{2}}$</p></li></ul><h3 id="增长率和对数图"><a href="#增长率和对数图" class="headerlink" title="增长率和对数图"></a>增长率和对数图</h3><ul><li><p>线性增长：$cx,x^{2},x^{3},\ldots$</p></li><li><p>指数增长：$2^{x},e^{x},10^{x},\ldots$</p></li><li><p>阶乘：$2^{x},e^{x},10^{x},\ldots$</p></li><li><p>对数图</p><ul><li><img src="https://cdn.jsdelivr.net/gh/Bezhuang/Imgbed/blogimg/微积分重点04.png" style="zoom: 50%;"></li></ul></li><li><p>线性拟合</p><ul><li><p>$y=Ax^{n}\rightarrow \log y=\log A+n\log x$</p></li><li><p>$y=B\cdot 10^{cx}\rightarrow \log y=\log B+cx$</p></li></ul></li></ul><h3 id="线性近似和牛顿法"><a href="#线性近似和牛顿法" class="headerlink" title="线性近似和牛顿法"></a>线性近似和牛顿法</h3><ul><li><p>取 $x=a$，已知 $\dfrac{df}{dx}=f’\left( a\right) =\lim _{x\rightarrow a}\dfrac{f\left( x\right) -f\left( a\right) }{x-a}$，求 $f(x)$</p></li><li><p>线性近似：函数在 a 点一阶泰勒展开</p><ul><li><p>$f’\left( a\right) \approx \dfrac{f\left( x\right) -f\left( a\right) }{x-a}$</p></li><li><p>$f\left( x\right) \approx f\left( a\right) +\left( x-a\right) f’\left( a\right)$</p></li></ul></li><li><p>牛顿法</p><ul><li><p>令 $F(x)=0$</p></li><li><p>$x-a\approx \dfrac{-F\left( a\right) }{F’\left( a\right) }$</p></li></ul></li><li><p>近似法求 $\sqrt{9.06}$</p><ul><li><p>$f\left( x\right) =\sqrt{x}=x^{\dfrac{1}{2}}$</p></li><li><p>$f’\left( x\right) =\dfrac{1}{2}x^{-\dfrac{1}{2}}=\dfrac{1}{\sqrt[2] {x}}$</p></li><li><p>取 $a=9$，$f(a)=\sqrt9=3$，$f’(a)=\dfrac{1}{6}$</p></li><li><p>$\sqrt{9.06}\approx 3+\left( 9.06-9\right) \dfrac{1}{6}=3.01$</p></li></ul></li><li><p>近似法求 $e^{0.01}$</p><ul><li><p>$f\left( x\right) =e^{x}$（$x=0.01$）</p></li><li><p>取 $a=0$，$f(a)=e^0=1$，$f’(a)=e^0=1$</p></li><li><p>$e^{x}=e^{0=01}=1+\left( 0.d-0\right) \cdot 1=1.01=1+x$</p></li></ul></li><li><p>牛顿法求 $\sqrt{9.06}$</p><ul><li><p>$F\left( x\right) =x^{2}-9.06=0$</p></li><li><p>取 $a=3$，$F(a)=9-9.06=-0.06$，$F’(a)=2a=6$</p></li><li><p>$x-3\approx \dfrac{0.06}{6}=0.01$</p></li></ul></li></ul><h3 id="幂级数和欧拉公式"><a href="#幂级数和欧拉公式" class="headerlink" title="幂级数和欧拉公式"></a>幂级数和欧拉公式</h3><ul><li><p>泰勒级数：$f\left( x\right) =f\left( 0\right) +f’\left( 0\right) \dfrac{x}{1}+f’’\left( 0\right) \dfrac{x^{2}}{2}+\ldots +f^{\left( n\right) }\left( 0\right) \dfrac{x^{n}}{n!}$</p><ul><li>$x^n$ 的 n 阶导：$n!$</li></ul></li><li><p>使用泰勒级数展开的幂级数</p><ul><li><p>$e^{x}=1+x+\dfrac{1}{2}x^{2}+\dfrac{1}{6}x^{3}+\ldots +\dfrac{1}{n!}x^{n}$</p></li><li><p>$\sin x=x-\dfrac{x^{3}}{3!}+\dfrac{x^{5}}{5!}\ldots$ 奇级数</p></li><li><p>$\cos x=1-\dfrac{x^{2}}{2!}+\dfrac{x^{4}}{4!}\ldots$ 偶级数</p></li></ul></li><li><p>欧拉公式：将 $e^x$ 级数中的 $x$ 考虑为虚数 $i$</p><ul><li><p>$e^{ix}=1+ix+\dfrac{1}{2!}\left( ix\right) ^{2}+\dfrac{1}{3!}\left( ix\right) ^{3}+\ldots$</p></li><li><p>实数、虚数分离：$e^{ix}=\left( 1-\dfrac{1}{2!}x^{2}+\ldots \right) +i\left( x-\dfrac{1}{3!}x^{3}+\ldots \right)$</p></li><li><p>因此：$e^{ix}=\cos x+i\sin x$</p></li><li><p>同理：$e^{-ix}=\cos x-i\sin x$</p></li></ul></li><li><p>几何级数：$\dfrac{1}{1-x}=1+x+x^{2}+x^{3}+\ldots ( \left| x\right| &lt; 1)$</p></li><li><p>将几何级数逐项积分：$-ln \left( 1-x\right) =x+\dfrac{x^{2}}{2}+\dfrac{x^{3}}{3}+\dfrac{x^{4}}{4}+\ldots ( \left| x\right| &lt; 1)$</p></li></ul><h3 id="关于运动的微分方程"><a href="#关于运动的微分方程" class="headerlink" title="关于运动的微分方程"></a>关于运动的微分方程</h3><ul><li><p>微分方程就是函数的导数和函数本身之间存在的关系</p></li><li><p>常系数二阶线性微分方程：$m\dfrac{d^{2}y}{dt^{2}}+2r\dfrac{dy}{dt}+ky=0$</p><ul><li><p>$m=0$ 时，$\dfrac{dy}{dt}=ay\rightarrow y=ce^{at}$</p></li><li><p>$r=0$ 时，$\dfrac{d^{2}y}{dt^{2}}=-\omega ^{2}y$ （$\omega ^{2}= \dfrac{k}{m}$）$\rightarrow y=C\cos \omega t+D\sin \omega t$</p></li><li><img src="https://cdn.jsdelivr.net/gh/Bezhuang/Imgbed/blogimg/%E5%BE%AE%E7%A7%AF%E5%88%86%E9%87%8D%E7%82%B905.png" style="zoom: 50%;"></li></ul></li><li><p>令 $y=e^{\lambda t}$ 满足方程 $m\lambda ^{2}e^{\lambda t}+2r\lambda e^{\lambda t}+ke^{\lambda t}=0$</p><ul><li><p>$m\lambda ^{2}+2r\lambda +k=0$</p></li><li><p>$\lambda =\dfrac{-r\pm \sqrt{r^{2}-km}}{m}$</p></li><li><p>$y=Ce^{\lambda _{1}t}+De^{\lambda _{2}t}$</p></li><li><p>若 $\lambda _{1}=\lambda _{2}$，$y=Ce^{\lambda t}+Dte^{\lambda t}$</p></li></ul></li><li><p>当 $m=1,r=3,k=10$ 时，$1y’’+6y’+10y=0$</p><ul><li><p>$\lambda ^{2}+6\lambda +10=0$</p></li><li><p>$\lambda =-3\pm i$</p></li><li><p>$y\left( t\right) =Ce^{\left( -3+i\right) t}+De^{\left( -3-i\right) t}$</p></li><li><p>由欧拉公式：$y\left( t\right) =Ae^{-3t}\cos t+Be^{-3t}\sin t$</p></li></ul></li></ul><h3 id="关于增长的微分方程"><a href="#关于增长的微分方程" class="headerlink" title="关于增长的微分方程"></a>关于增长的微分方程</h3><ul><li><p>微分方程 $\dfrac{dy}{dt}=cy$，对于任意 A 有解 $y\left( t\right) =Ae^{ct}$</p><ul><li>$y\left( t\right) =y\left( 0\right) e^{ct}$</li></ul></li><li><p>增加初始常数：$\dfrac{dy}{dt}=cy+s$</p><ul><li><p>$\dfrac{d}{dt}\left( y+\dfrac{s}{c}\right) =c\left( y+\dfrac{s}{c}\right)$</p></li><li><p>$y\left( t\right) =-\dfrac{s}{c}+\left( y\left( 0\right) +\dfrac{s}{c}\right) e^{ct}$</p></li></ul></li><li><p>人口增长方程：$\dfrac{dP}{dt}=cP-sP^{2}$，$c$ 为增长率而 $s$ 为竞争因素</p><ul><li><img src="https://cdn.jsdelivr.net/gh/Bezhuang/Imgbed/blogimg/%E5%BE%AE%E7%A7%AF%E5%88%86%E9%87%8D%E7%82%B906.png" style="zoom: 50%;"></li><li><p>令 $y=\dfrac{1}{P}$，$\dfrac{dy}{dt}=-\dfrac{\dfrac{dP}{dt}}{P^{2}}=\dfrac{\left( cP+sP^{2}\right) }{P^{2}}=s-cP=s-cy$</p></li><li><p>$y\left( t\right) =\dfrac{s}{c}+Ae^{-ct}=\dfrac{s}{c}+\left( y\left( 0\right) -\dfrac{s}{c}\right) e^{-ct}$</p></li><li><p>$\dfrac{1}{p\left( t\right) }-\dfrac{s}{c}=\left( \dfrac{1}{p(0)}-\dfrac{s}{c}\right) e^{-ct}$</p></li></ul></li><li><p>人口增长方程二阶导数：$\dfrac{d^{2}P}{dt^{2}}=\dfrac{d}{dt}\left( cP-sP^{2}\right) =\left( c-2sP\right) \dfrac{dP}{dt}$</p><ul><li>$p=\dfrac{c}{2s}$ 时，$\dfrac{d^{2}P}{dt^{2}}=0$（拐点，增长率开始放缓）</li></ul></li></ul><h3 id="微分学总结"><a href="#微分学总结" class="headerlink" title="微分学总结"></a>微分学总结</h3><h4 id="六函数"><a href="#六函数" class="headerlink" title="六函数"></a>六函数</h4><table><thead><tr><th align="center">积分</th><th align="center"></th><th align="center">导数</th></tr></thead><tbody><tr><td align="center">$\dfrac{x^{n+1}}{\left( n+1\right) },n\neq -1$</td><td align="center">$x^n$</td><td align="center">$nx^{n-1}$</td></tr><tr><td align="center">$-cosx$</td><td align="center">$sinx$</td><td align="center">$cosx$</td></tr><tr><td align="center">$sinx$</td><td align="center">$cosx$</td><td align="center">$-sinx$</td></tr><tr><td align="center">$\dfrac{e^{cx}}{c}$</td><td align="center">$e^{cx}$</td><td align="center">$ce^{cx}$</td></tr><tr><td align="center">$x\ln x-x$</td><td align="center">$lnx$</td><td align="center">$\dfrac{1}{x}$</td></tr><tr><td align="center">斜坡函数</td><td align="center">分段函数</td><td align="center">$\delta$ 函数</td></tr></tbody></table><h4 id="六法则"><a href="#六法则" class="headerlink" title="六法则"></a>六法则</h4><ul><li><p>加法法则：和的导数等于导数的和</p><ul><li>$af\left( x\right) +bg\left( x\right) \rightarrow a\dfrac{df}{dx}+b\dfrac{dg}{dx}$</li></ul></li><li><p>乘法法则：上乘下导加下乘上导</p><ul><li>$f\left( x\right) g\left( x\right) \rightarrow f\left( x\right) \dfrac{dg}{dx}+g\left( x\right) \dfrac{df}{dx}$</li></ul></li><li><p>除法法则：下平方分之下乘上导减上乘下导</p><ul><li>$\dfrac{f\left( x\right) }{g\left( x\right) }\rightarrow  \dfrac{g\left( x\right) \dfrac{df}{dx}-f\left( x\right) \dfrac{dg}{dx}}{g\left( x\right) ^{2}}$</li></ul></li><li><p>链式法则</p><ul><li>$f\left( g\left( x\right) \right) \rightarrow \dfrac{df}{dy}\dfrac{dy}{dx}$</li></ul></li><li><p>反函数的导数等于原函数的导数分之一</p><ul><li>$x=f^{-1}\left( y\right) \rightarrow \dfrac{dx}{dy}=\dfrac{1}{\dfrac{dy}{dx}}$</li></ul></li><li><p>洛必达法则：$\dfrac{0}{0}$ 或 $\dfrac{\infty }{\infty }$</p><ul><li>$\dfrac{f\left( x\right) }{g\left( x\right) }\rightarrow \dfrac{\dfrac{dt}{dx}}{\dfrac{dg}{dx}}$</li></ul></li></ul><h4 id="六定理"><a href="#六定理" class="headerlink" title="六定理"></a>六定理</h4><ul><li><p>微积分基本定理</p><ul><li><p>如果函数 $f(x)=\int _{a}^{x}s\left( t\right) dt$，那么函数的导数为 $\dfrac{df}{dx}=s\left( x\right) $</p></li><li><p>如果函数的导数为 $\dfrac{df}{dx}=s\left( x\right) $，那么导数的积分（原函数）为 $\int _{a}^{b}s\left( x\right) dx=f\left( b\right) -f\left( a\right) $</p></li></ul></li><li><p>介值定理（全值定理）</p><ul><li><p>对于 $a\leq x\leq b$ 区间上的连续函数</p></li><li><p>一定能取到最大值 $M$ 和最小值 $m$，使得 $[M,m]$ 中的任意值都存在函数上的点与之对应</p></li><li><p>连续函数的一个区间内的函数值肯定介于最大值 $M$ 和最小值 $m$之间</p></li></ul></li><li><p>中值定理</p><ul><li>如果函数 $f(x)$ 在闭区间 $[a,b]$ 上连续，在开区间 $(a,b)$ 内可导，那么在 $(a,b)$ 内至少有一点 $\varepsilon $，使 $f\left( b\right) -f\left( a\right) =f\left( \varepsilon \right) \left( b-a\right) $ 成立</li></ul></li><li><p>泰勒级数</p><ul><li><p>$f\left( x\right) =f\left( a\right) +f’\left( a\right) \left( x-a\right) +\dfrac{1}{2}f’’\left( a\right) \left( x-a\right) ^{2}+\ldots =\sum ^{\infty }_{n=0}\dfrac{1}{n!}f^{\left( n\right) }\left( a\right) \left( x-a\right) ^{n}$</p></li><li><p>若级数截断于 $\left( x-a\right) ^{n}$ 项，余项为：$\dfrac{1}{\left( n+1\right) !}f^{\left( n+1\right) }\left( c\right) \left( x-a\right) ^{\left( n+1\right) }$</p></li><li><p>当 $a=0$ 时，$f\left( x\right)=\sum ^{\infty }_{n=0}\dfrac{1}{n!}f^{\left( n\right) }\left( 0\right) \left( x\right) ^{n}$</p></li></ul></li><li><p>二项式定理</p><ul><li><p>帕斯卡三角：<img src="https://cdn.jsdelivr.net/gh/Bezhuang/Imgbed/blogimg/%E5%BE%AE%E7%A7%AF%E5%88%86%E9%87%8D%E7%82%B907.png" style="zoom:80%;"></p></li><li><p>$(1+x)^p=1+px+\dfrac{P\left( p-1\right) }{\left( 2\right) \left( 1\right) }x^{2}+\dfrac{p\left( p-1\right) \left( p-2\right) }{\left( 3\right) \left( 2\right) \left( 1\right) }x^{3}+\ldots $</p></li></ul></li></ul>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;微分学重点的十二章关于导数的课程深入挖掘了微积分的子领域，“微分”。 与微积分重点的课程一样，MIT 数学教授 Gilbert Strang 解释了每个主题如何应用于现实生活中，是对微积分重点的补充，以下为所记课堂笔记，笔记以中文形式记录，方便理解，可供参考。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="数学" scheme="http://blog.zhuangzhihao.top/categories/%E6%95%B0%E5%AD%A6/"/>
    
    
  </entry>
  
  <entry>
    <title>微积分重点</title>
    <link href="http://blog.zhuangzhihao.top/%E5%BE%AE%E7%A7%AF%E5%88%86%E9%87%8D%E7%82%B9/"/>
    <id>http://blog.zhuangzhihao.top/%E5%BE%AE%E7%A7%AF%E5%88%86%E9%87%8D%E7%82%B9/</id>
    <published>2021-08-31T16:00:00.000Z</published>
    <updated>2021-12-04T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>微积分重点（Highlights of Calculus）是 MIT 数学教授 Gilbert Strang 对于微积分中的精华和重点出的一个生动、简短的课程，帮助我们重新审视微积分，课程主要涉及单变量微积分的总览，以下为所记课堂笔记，笔记以中文形式记录，方便理解，可供参考。</p></blockquote><a id="more"></a><h3 id="微积分总览"><a href="#微积分总览" class="headerlink" title="微积分总览"></a>微积分总览</h3><ul><li><p>微积分是函数（1）和函数（2）之间的桥梁</p><ul><li><p>距离 $f\left( t\right)$ 、速度 $\dfrac{df}{dt}$</p></li><li><p>高度 $y\left( x\right)$ 、斜率 $\dfrac{dy}{dx}$</p></li></ul></li><li><p>匀速情况下，$速度=\dfrac{距离}{时间}$，即 $斜率=\dfrac{垂直}{水平}$，即 $s=\dfrac{f}{t}$</p><ul><li>若要求中间一段时间或距离的速度，$s=\dfrac{\Delta f}{\Delta t}$</li></ul></li><li><p>匀变速情况下，函数图像均为曲线</p><ul><li><p>微分学就是已知 $距离-时间$ 函数求 $速度-时间$ 函数</p></li><li><p>积分学就是已知 $速度-时间$ 函数求 $距离-时间$ 函数</p></li><li><p> $速度-时间$ 函数 $s=at$ 下面积 $\dfrac{1}{2}t\left( at\right)$ 就是 $距离-时间$ 函数 $\dfrac{1}{2}at^{2}$</p></li><li><p>速度 $s=\dfrac{df}{dt}$ 就是 $f=\int s\left( t\right) dt$ 的导数</p></li></ul></li></ul><h3 id="导数总览"><a href="#导数总览" class="headerlink" title="导数总览"></a>导数总览</h3><ul><li><p>已知距离 $f\left( t\right)$  如何求速度 $\dfrac{df}{dt}$，即已知高度 $y\left( x\right)$  如何求斜率 $\dfrac{dy}{dx}$</p></li><li><p>三个重要函数的斜率</p><ul><li><p>幂函数 $y=x^{n}$ ：$\dfrac{dy}{dx}=nx^{n-1}$</p></li><li><p>三角函数 $y=\sin x$ ：$\dfrac{dy}{dx}=\cos x$</p></li><li><p>指数函数 $y=e^{x}$ ：$\dfrac{dy}{dx}=e^{x}$</p></li></ul></li><li><p>$y=x^2$ 斜率的含义</p><ul><li><p>$平均斜率\dfrac{\left( \Delta x\right) ^{2}}{\Delta x}$，即 $\dfrac{\Delta y}{\Delta x}$ $\rightarrow$ $瞬时斜率\dfrac{dy}{dx}$</p></li><li><p>$\dfrac{\Delta y}{\Delta x}=\dfrac{\left( x+\Delta x\right) ^{2}}{\Delta x}\dfrac{-x^{2}}{}=\dfrac{2xax+\left( \Delta x\right) ^{2}}{\Delta x}=2x+\Delta x$</p></li><li><p>求导：$\dfrac{dy}{dx}=\lim\dfrac{\Delta y}{\Delta x}=2x$</p></li></ul></li><li><p>任意 $x$ 处，$y=\sin x 的斜率\rightarrow \dfrac{dy}{dx}=\cos x$</p></li></ul><h3 id="极值及二阶导数"><a href="#极值及二阶导数" class="headerlink" title="极值及二阶导数"></a>极值及二阶导数</h3><ul><li><p>二阶导数：导数的导数</p><ul><li>一阶导数用于确认极值点，二阶导数表明曲线弯曲方向</li></ul></li><li><p>二阶导数的例子：加速度</p><ul><li><p>距离 $f\left( t\right)$ 、速度 $\dfrac{df}{dt}$、加速度 $\dfrac{d^{2}f}{dt^{2}}$</p></li><li><p>高度 $y=x^2$ 、斜率 $\dfrac{dy}{dx}=2x$、弯曲性 $\dfrac{d^{2}f}{dt^{2}}=2$</p></li><li><p>$sinx$ 的二阶导数为 $-sinx$</p></li></ul></li><li><p>凸函数和凹函数：$f’’ &gt;0$ 为凸，表示向上弯曲，相对的凹为 $f’’ &lt;0$</p></li><li><p>拐点：二阶导数为 0 的点，表示弯曲方向改变</p></li><li><p>对于函数 $y=x^{3}-x^{2}$ $\rightarrow$ $y’=3x^{2}-2x$，$y’’=6x-2$</p><ul><li><p>求极值点：令 $y’=3x^{2}-2x=0$，$x= 0或x=\dfrac{2}{3}$</p></li><li><p>$x=0$ 处，二阶导数为负，取局部最大值（极大值）</p></li><li><p>$x=\dfrac{2}{3}$ 处，二阶导数为正，取局部最小值（极小值）</p></li></ul></li><li><p>应用：上班的最短时间</p><ul><li><p>设高速总长 $b$，家垂直上高速距离为 $a$，没走的高速距离为 $x$</p></li><li><img src="https://cdn.jsdelivr.net/gh/Bezhuang/Imgbed/blogimg/%E5%BE%AE%E7%A7%AF%E5%88%86%E9%87%8D%E7%82%B901.png" style="zoom: 33%;"></li><li><p>$时间t=\dfrac{b-x}{60}+\dfrac{\sqrt{a^{2}+x^{2}}}{30}$</p></li><li><p>取时间方程的导数，然后令导数为 0 来求最小值</p></li><li><p>$f’=-\dfrac{1}{60}+\dfrac{1}{30}\cdot \dfrac{1}{2}\cdot \dfrac{2x}{\sqrt{a^{2}+x^{2}}}=0$ $\rightarrow$ $x=\dfrac{a}{\sqrt{3}}$</p></li></ul></li><li><p>最值的一般求法：比较所有驻点（$f’=0$）处及边界点函数值，得到最大或最小值即函数最值</p></li><li><p>$f’’$ 的符号可通过 $f’$ 的单调性求出：$x&gt;0$ 时，$f’(x)&gt;f’(0)$ ，斜率变化率为正，$f’’&gt;0$</p></li></ul><h3 id="指数函数-e-x"><a href="#指数函数-e-x" class="headerlink" title="指数函数 $e^x$"></a>指数函数 $e^x$</h3><ul><li><p>最简单的微分方程：$y=\dfrac{dy}{dx}$</p></li><li><p>指数函数：通过微积分构造的函数</p><ul><li><p>重要性质一：指数函数的导数就是其自身</p></li><li><p>函数初始点：$y=e^{0}=1$</p></li><li><p>$\dfrac{x^{n}}{n!}$ 斜率的导数为 $\dfrac{x^{n-1}}{\left( n-1\right) !}$</p></li><li><p>指数级数：$e^{x}=1+x+\dfrac{x^{2}}{2!}+\dfrac{x^{3}}{3!}+\ldots +\dfrac{x^{n}}{n!}+\ldots$</p></li><li><p>重要性质二：$e^{x}\cdot e^{X}=e^{x+X}$</p></li><li><p>$e$ 等于 $x=1$ 时指数级数的值：$e=1+1+\dfrac{1}{2}+\dfrac{1}{6}+\ldots \dfrac{1}{n!}+\ldots\approx 2.71828\ldots$</p></li></ul></li><li><p>指数函数的图像</p><ul><li><p>由重要性质二可得：$e^{-x}=\dfrac{1}{e^{x}}$</p></li><li><img src="https://cdn.jsdelivr.net/gh/Bezhuang/Imgbed/blogimg/%E5%BE%AE%E7%A7%AF%E5%88%86%E9%87%8D%E7%82%B902.png" style="zoom:50%;"></li></ul></li><li><p>应用：计算存款复利</p><ul><li><p>假设利率为 100%，1 美元存一年得到 2 美元或更多</p></li><li><p>将一年分为 n 份付利息，得到 $\left( 1+\dfrac{1}{n}\right) ^{n}$，$n\rightarrow \infty$ 时最终趋近于 $e$</p></li><li><p>解常微分方程：$\dfrac{dy}{dx}=cy$ $\rightarrow$ $y\left( x\right) =e^{cx}$</p></li></ul></li></ul><h3 id="积分总览"><a href="#积分总览" class="headerlink" title="积分总览"></a>积分总览</h3><ul><li><p>函数二 $\dfrac{dy}{dx}=nx^{n-1}$ 是函数一 $y=x^{n}$ 的导数</p></li><li><p>函数一 $y=\dfrac{x^{n+1}}{n+1}$ 是函数二 $\dfrac{dy}{dx}=x^{n}$ 的积分</p></li><li><p>求原函数：$y\left( x\right) =\int s\left( x\right) dx$</p></li><li><p>求积分方法A：反过来看什么函数的导数能得到要积分的函数</p></li><li><p>例：通过代数方法求函数一</p><ul><li><img src="https://cdn.jsdelivr.net/gh/Bezhuang/Imgbed/blogimg/%E5%BE%AE%E7%A7%AF%E5%88%86%E9%87%8D%E7%82%B903.png" style="zoom:67%;"></li><li><p>相加求和：$\sum \Delta y=y_{终}-y_{始}$</p></li></ul></li><li><p>例：通过微积分方法求函数一</p><ul><li><p>同时乘除 $\Delta x$：$\sum \left( \dfrac{\Delta y}{\Delta x}\right) \Delta x=y_{终}-y_{始}$</p></li><li><p>在 $\Delta x\rightarrow 0$ 的极限情况下，求和转化为积分：$\int \dfrac{dy}{dx}dx$</p></li></ul></li><li><p>求积分方法B：$积分=函数一=函数二图像下的面积$</p><ul><li>斜率为 $s=2-2x$，对应的高度 $y=2x-x^2$</li></ul></li></ul>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;微积分重点（Highlights of Calculus）是 MIT 数学教授 Gilbert Strang 对于微积分中的精华和重点出的一个生动、简短的课程，帮助我们重新审视微积分，课程主要涉及单变量微积分的总览，以下为所记课堂笔记，笔记以中文形式记录，方便理解，可供参考。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="数学" scheme="http://blog.zhuangzhihao.top/categories/%E6%95%B0%E5%AD%A6/"/>
    
    
  </entry>
  
  <entry>
    <title>计算机网络（下）</title>
    <link href="http://blog.zhuangzhihao.top/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E4%B8%8B/"/>
    <id>http://blog.zhuangzhihao.top/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E4%B8%8B/</id>
    <published>2021-08-29T16:00:00.000Z</published>
    <updated>2021-10-25T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>计算机网络是计算机专业必修的重要课程之一，与现实世界结合得相当紧密，也是考研408计算机学科专业基础综合考试中的一门课程。计算机网络学习的核心内容就是网络协议的学习。网络协议是为计算机网络中进行数据交换而建立的规则、标准或者说是约定的集合。我选择的课程是哈工大的<a href="https://www.icourse163.org/learn/HIT-154005">国家精品课</a>和谢希仁版教材，以下为所记课堂笔记下半部分，包含网络层、传输层和应用层的知识点，可供参考。上半部分笔记请访问<a href="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E4%B8%8A">计算机网络（上）</a></p></blockquote><a id="more"></a><h3 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h3><h4 id="网络层提供的两种服务"><a href="#网络层提供的两种服务" class="headerlink" title="网络层提供的两种服务"></a>网络层提供的两种服务</h4><ul><li>网络层向上只提供简单灵活的、无连接的、尽最大努力交互的数据报服务，并且网络层不提供服务质量的承诺。</li><li>这样的好处在于网络造价大大降低，运行方式灵活。</li></ul><h4 id="网际协议IP"><a href="#网际协议IP" class="headerlink" title="网际协议IP"></a>网际协议IP</h4><ul><li>网际协议IP是TCP/IP体系中两个最主要的协议之一。其中，与IP协议配套使用的有三种协议：<ul><li>地址解析协议ARP</li><li>网际控制报文协议ICMP</li><li>网际组管理协议IGMP</li></ul></li><li>其中，ICMP、IGMP协议是往基层向上提供的两种服务</li></ul><h4 id="互联网络"><a href="#互联网络" class="headerlink" title="互联网络"></a>互联网络</h4><ul><li>因为用户的需求是多种多样的，没有一种单一的网络能够适应所有用户的需求,所以不同的网络之间，将网络互联起来需要使用一些中间设备。<ul><li>物理层使用的中间设备是转发器</li><li>数据链路层使用的中间设备是网桥或者桥接器</li><li>网络层使用的中间设备是路由器</li><li>网络层以上使用的中间设备叫网关</li></ul></li></ul><h5 id="IP地址与硬件地址"><a href="#IP地址与硬件地址" class="headerlink" title="IP地址与硬件地址"></a>IP地址与硬件地址</h5><ul><li><p>物理地址是数据链路层和物理层使用的地址，而IP地址是网络层和网络层以上各层使用的地址</p></li><li><p>在发送数据时，数据从高层下到底层，然后才到通信链路上使用IP的IP数据报一旦交给了数据链路层，就被封装成MAC帧（MAC地址）</p></li></ul><h5 id="地址解析协议ARP"><a href="#地址解析协议ARP" class="headerlink" title="地址解析协议ARP"></a>地址解析协议ARP</h5><ul><li><p>已知一个机器的IP地址，如何找出其所对应的硬件地址呢？这就是ARP的主要任务。</p><ul><li>ARP协议的主要内容在于从网络层使用的IP地址，解析出在数据链路层使用的硬件地址。</li></ul></li></ul><ul><li>工作原理：一个主机都设有一个ARP高速缓存，里面有所在的局域网上的各主机和路由器的 IP 地址到硬件地址的映射表。如果所要找的主机和源主机不在同一个局域网上，那么就要通过 ARP 找到一个位于本局域网上的某个路由器的硬件地址，然后把分组发送给这个路由器，让这个路由器把分组转发给下一个网络。</li></ul><h4 id="IP数据报"><a href="#IP数据报" class="headerlink" title="IP数据报"></a>IP数据报</h4><ul><li>一个IP数据报由首部（20 字节+可选字段）和数据两部分组成</li></ul><h4 id="划分子网和构建超网"><a href="#划分子网和构建超网" class="headerlink" title="划分子网和构建超网"></a>划分子网和构建超网</h4><ul><li><p>两级IP到三级IP</p><ul><li><p>两级IP（&lt;网络号&gt;，&lt;主机号&gt;）的缺陷：</p></li><li><p>IP地址的空间利用率有时很低</p><ul><li>两级IP地址不够灵活</li></ul></li><li><p>给每一个物理网络分配一个网络号会使路由表变得太大而使网络性能变坏。</p></li><li><p>三级IP地址：将其中二级IP的主机号取出并高x位变成子网络，形成网络号+子网号+主机号的地址格式</p></li><li><p>划分子网：划分子网属于一个单位内部的事情，它将二级IP地址变为三级IP地址</p></li></ul></li></ul><h4 id="无分类编制CIDR"><a href="#无分类编制CIDR" class="headerlink" title="无分类编制CIDR"></a>无分类编制CIDR</h4><ul><li><p>CIDR取消了传统的A类、B类和C类地址以及划分子网的概念，并且用网络前缀代替网络号和子网号，后面的部分指明主机。因此，CIDR使IP地址从三级地址(使用子网掩码)，又回到了两级地址（无分类的两级编址）。</p></li><li><p>CIDR把网络前缀相同的连续的IP地址组成一个”CIDR地址块”只要知道CIDR地址块中的任何一个地址，就可以知道这地址块的起始地址(即最小地址)和最大地址，以及地址块中的地址数。具体看如下例子</p></li><li><p>地址掩码：是一连串的1和0组成，而1的个数救赎网络前缀长度。在斜线记法中。斜线后面的数字就是地址掩码中1的个数。</p></li><li><p>构成超网：由于一个CIDR地址块中含有很多地址，所以在路由表中就利用CIDR地址块来查找目标网络，这种地址的聚合常称为路由聚合，也称构成超网。</p></li></ul><h4 id="最长前缀匹配"><a href="#最长前缀匹配" class="headerlink" title="最长前缀匹配"></a>最长前缀匹配</h4><ul><li><p>最长前缀匹配之前，使用CIDR时，每个项目由网络前缀和下一跳地址组成。但是在查找路由表时会得到不止一个匹配结果该怎么办呢？</p></li><li><p>此时应该选择匹配结果中，有最长网络前缀的路由。因为网络前缀越长，可分配的地址数就越少，其地址信息路由就越具体</p></li></ul><h4 id="网际控制报文协议ICMP"><a href="#网际控制报文协议ICMP" class="headerlink" title="网际控制报文协议ICMP"></a>网际控制报文协议ICMP</h4><ul><li><p>为了更有效地转发IP数据报和提高交付成功的机会，在网际层使用了ICMP，ICMP允许主机或路由器报告差错情况和提供有关异常情况的报告。ICMP是互联网的标准协议，但不是高层协议。其种类如下：</p><ul><li>ICMP差错报告报文</li></ul></li></ul><ul><li><p>ICMP询问报文</p></li><li><p>ICMP的应用在于分组网间探测PING，以用来测试两台主机之间的连通性。</p></li></ul><h4 id="互联网的路由选择协议"><a href="#互联网的路由选择协议" class="headerlink" title="互联网的路由选择协议"></a>互联网的路由选择协议</h4><ul><li><p>路由选择协议分为两大类：</p><ul><li>内部网关协议</li></ul></li></ul><ul><li><p>外部网关协议</p></li><li><p>内部网关协议</p><ul><li>RIP是内部网关协议中最先得到广泛应用的协议，也被称为路由信息协议，但是其很少被使用。其主要特点如下：<ul><li>仅和相邻路由器交换信息。</li><li>路由器交换的信息是当前路由器所知道的全部信息，即自己现在的路由</li><li>按固定的时间间隔交换路由信息，例如，每隔30秒。</li><li>因此，RIP有如下的优缺点。</li><li>当网络出现故障时，要经过比较长的时间才能将此信息传送到所有的路由器。</li><li>RIP 协议最大的优点就是实现简单，开销较小。</li><li>RIP 限制了网络的规模，它能使用的最大距离为 15（16 表示不可达）。</li><li>路由器之间交换的路由信息是路由器中的完整路由表，因而随着网络规模的扩大，开销也就增加。</li></ul></li></ul></li><li><p>OSPF最主要的特征就是使用分布式的链路状态协议，其主要特点：</p><ul><li>使用洪泛法向本自治系统中所有路由器发送信息。</li></ul></li></ul><ul><li><p>发送的信息是与本路由器相邻的所有路由器的链路状态。</p></li><li><p>只有当链路状态发生变化时，路由器才用洪泛法向所有路由器发送此信息。</p></li></ul><h4 id="IPv6"><a href="#IPv6" class="headerlink" title="IPv6"></a>IPv6</h4><ul><li>解决IP地址耗尽的根本措施在于采用具有更大地址空间的新版本IP，即IPv6。它有两大部分组成：基本首部，有效载荷</li><li>IPv6采用的是点分十六进制的记法，把每个十六位的值用十六进制表示，并且各个值之间用冒号分割</li><li>冒号十六进制允许零压缩，但只能使用一次零压缩</li><li>冒号十六进制可以结合使用点分十进制记法的后缀。</li></ul><h3 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h3><h4 id="运输层协议概述"><a href="#运输层协议概述" class="headerlink" title="运输层协议概述"></a>运输层协议概述</h4><ul><li>运输层功能<ul><li>运输层应用进程之间提供端到端的逻辑通信。这与网络层的区别在于网络层是为主机之间提供逻辑通信的</li><li>运输层需要对收到的报文进行差错检验</li><li>运输层有两种不同的运输协议，即面向连接的TCP和无连接的UDP</li></ul></li><li>TCP/IP的运输层有两个不同的协议：<ul><li>用户数据报协议UDP</li><li>传输控制协议TCP</li></ul></li><li>UDP协议特点<ul><li>提供无连接服务</li><li>尽最大努力交付</li><li>面向报文，UDP 一次交付一个完整的报文</li><li>没有拥塞控制，网络拥塞不会使源主机的发送速率降低</li><li>支持一对一、一对多、多对一和多对多的交互通信</li><li>首部开销小，只有 8 个字节</li><li>应用：对可靠性要求不高，需要传送的数据不多，使用频率不高。并且可以实时应用。</li></ul></li><li>TCP协议特点<ul><li>提供面向连接的服务</li><li>可靠传输：主要以字节为单位的滑动窗口和超时重传时间的选择</li><li>面向字节流</li><li>拥塞控制：避免由于对网络中某资源的需求超过可用资源，令网络的性能变坏</li><li>TCP 的流量控制：让发送方的发送速率不要太快</li><li>总结：TCP和UDP协议的区别</li></ul></li><li>TCP的特点<ul><li>面向连接协议</li><li>提供交互保证</li><li>较UDP实时性低</li><li>TCP首部开销20个字节</li><li>TCP速度较慢</li><li>拥塞机制</li><li>TCP将数据看成一连串的字节</li><li>重量级协议，资源占用多</li><li>只有点对点连接</li></ul></li><li>UDP的特点<ul><li>无连接协议</li><li>尽最大努力交付，不提供有序、序列保证</li><li>较好的实时性</li><li>首部开销8字节</li><li>运行速度较快</li><li>无拥塞机制</li><li>面向报文</li><li>轻量级</li><li>一对一，一对多，多对多</li></ul></li><li>运输层的端口<ul><li>运行在计算机中的进程是用进程标识符来标志的。但运行在应用层的各种应用进程却不应当让计算机操作系统指派它的进程标识符。这是因为在互联网上使用的计算机的操作系统种类很多，而不同的操作系统又使用不同格式的进程标识符。<br>为了使运行不同操作系统的计算机的应用进程能够互相通信，就必须用统一的方法对 TCP/IP 体系的应用进程进行标志。</li><li>由于进程的创建和撤销都是动态的，发送方几乎无法识别其他机器上的进程。有时我们会改换接收报文的进程，但并不需要通知所有发送方。所以我们往往需要利用目的主机提供的功能来识别终点，而不需要知道实现这个功能的进程。</li><li>解决这个问题的方法就是在运输层使用协议端口号 (protocol port number)，或通常简称为端口(port)。虽然通信的终点是应用进程，但我们可以把端口想象是通信的终点，因为我们只要把要传送的报文交到目的主机的某一个合适的目的端口，剩下的工作（即最后交付目的进程）就由 TCP来完成。</li></ul></li></ul><h4 id="TCP可靠传输的实现"><a href="#TCP可靠传输的实现" class="headerlink" title="TCP可靠传输的实现"></a>TCP可靠传输的实现</h4><ul><li><p>以字节单位的滑动窗口</p><ul><li><p>TCP使用流水线传输和滑动窗口协议实现高效、可靠的传输。TCP 的滑动窗口是以字节为单位的。</p></li><li><p>发送方 A 和接收方 B 分别维持一个发送窗口和一个接收窗口。</p></li></ul></li></ul><ul><li>发送窗口表示：在没有收到确认的情况下，可以连续把窗口内的数据全部发送出去。</li></ul><ul><li>接收窗口表示：只允许接收落入窗口内的数据。</li></ul><ul><li><p>超时重传时间的选择</p><ul><li>重传机制是 TCP 中最重要和最复杂的问题之一。</li><li>TCP 每发送一个报文段，就对这个报文段设置一次计时器。</li><li>只要计时器设置的重传时间到但还没有收到确认，就要重传这一报文段。</li><li>重传时间的选择是 TCP 最复杂的问题之一。</li></ul></li><li><p>利用滑动窗口实现流量控制</p><ul><li>一般说来，我们总是希望数据传输得更快一些。但如果发送方把数据发送得过快，接收方就可能来不及接收，这就会造成数据的丢失。</li><li>流量控制 (flow control) 就是让发送方的发送速率不要太快，既要让接收方来得及接收，也不要使网络发生拥塞。</li><li>利用滑动窗口机制可以很方便地在 TCP 连接上实现流量控制。</li></ul></li><li><p>拥塞机制</p><ul><li>在某段时间，若对网络中某资源的需求超过了该资源所能提供的可用部分，网络的性能就要变坏。这种现象称为拥塞 (congestion)。</li><li>最坏结果：系统崩溃。</li></ul></li><li><p>网络拥塞往往是由许多因素引起的。例如：</p><ul><li>点缓存的容量太小；</li><li>链路的容量不足；</li><li>处理机处理的速率太慢；</li><li>拥塞本身会进一步加剧拥塞；</li><li>总的来说，出现拥塞的原因在于对资源的需求大于可用资源</li></ul></li><li><p>TCP的拥塞控制方法</p><ul><li><p>慢开始与拥塞窗口</p><ul><li><p>TCP 采用基于窗口的方法进行拥塞控制。该方法属于闭环控制方法。</p></li><li><p>TCP发送方维持一个拥塞窗口 cwnd</p></li><li><p>发送端利用拥塞窗口根据网络的拥塞情况调整发送的数据量。</p></li><li><p>发送窗口大小不仅取决于接收方窗口，还取决于网络的拥塞状况</p></li><li><p>只要网络没有出现拥塞，拥塞窗口就可以再增大一些，以便把更多的分组发送出去，这样就可以提高网络的利用率。</p></li><li><p>但只要网络出现拥塞或有可能出现拥塞，就必须把拥塞窗口减小一些，以减少注入到网络中的分组数，以便缓解网络出现的拥塞。</p></li><li><p>其中，对于拥塞的判断，有以下两个指标：1.重传定时器超时。2.收到三个重复的ACK。</p></li></ul></li></ul></li></ul><h3 id="应用层协议"><a href="#应用层协议" class="headerlink" title="应用层协议"></a>应用层协议</h3><ul><li><p>应用层协议主要定义运行在不同端系统上的应用程序进程之间如何相互传递信息</p></li><li><p>常用的几种协议：DNS、FTP、HTTP、DHCP 的作用</p><ul><li>DNS：域名系统DNS是互联网使用的命名系统，用来把便于人们使用的机器名字转换为IP地址。DNS同时占用TCP协议与UDP协议的53号端口。</li><li>FTP：文件传送协议FTP是互联网上使用的最广泛的文件传送协议。FTP使用的传输层协议是</li><li>TCP，FTP 传数据流占用20号端口，FTP传控制流占用21号端口。</li><li>HTTP：HTTP协议定义了浏览器怎样向万维网服务器请求万维网文档，以及服务器怎样把文档传送给浏览器。HTTP使用传输层协议为TCP，端口号为80。</li><li>DHCP：互联网目前广泛使用的动态主机配置协议DHCP，它提供一种机制，成为即插即用联网。DHCP使用UDP，端口号为67和68。</li></ul></li><li><p>在应用层，用到DNS协议，作用是域名解析，HTTP协议浏览器和服务器之间的交互访问协议。</p></li><li><p>在传输层，运用UDP域名解析协议使用的运输层协议，TCP浏览器和WWW服务器之间建立连接，提供可靠的数据传输。</p></li><li><p>在网际层IP，IP数据报传输和路由选择，ICMP提供网络传输中的差错检测，ARP将本机缺省的网关IP地址映射成物理地址（MAC地址）。</p></li></ul>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;计算机网络是计算机专业必修的重要课程之一，与现实世界结合得相当紧密，也是考研408计算机学科专业基础综合考试中的一门课程。计算机网络学习的核心内容就是网络协议的学习。网络协议是为计算机网络中进行数据交换而建立的规则、标准或者说是约定的集合。我选择的课程是哈工大的&lt;a href=&quot;https://www.icourse163.org/learn/HIT-154005&quot;&gt;国家精品课&lt;/a&gt;和谢希仁版教材，以下为所记课堂笔记下半部分，包含网络层、传输层和应用层的知识点，可供参考。上半部分笔记请访问&lt;a href=&quot;/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E4%B8%8A&quot;&gt;计算机网络（上）&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="计算机专业" scheme="http://blog.zhuangzhihao.top/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%93%E4%B8%9A/"/>
    
    
  </entry>
  
  <entry>
    <title>数据结构（中）</title>
    <link href="http://blog.zhuangzhihao.top/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%B8%AD/"/>
    <id>http://blog.zhuangzhihao.top/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%B8%AD/</id>
    <published>2021-08-16T16:00:00.000Z</published>
    <updated>2021-09-25T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>数据结构是指数据的存储结构，是带有结构特性的数据元素的集合。精心选择的数据结构可以带来更好的运行或者存储效率。数据结构是计算机科学与技术专业、软件工程专业甚至于其它电气信息类专业的重要专业基础课程，在408计算机学科专业基础综合考试中占有45分。我选择的课程是浙江大学数据结构<a href="https://www.icourse163.org/course/ZJU-93001">国家精品课</a>，以下为所记课堂笔记第二部分，包含树和图的知识总结以及所需记忆的代码，另外我在开源仓库中还保持了浙大慕课版本的<a href="https://github.com/Bezhuang/LearnCS/tree/main/%E5%90%8D%E6%A0%A1%E5%85%AC%E5%BC%80%E8%AF%BE/%E6%B5%99%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84">代码</a>，可供参考。其他部分笔记详见<a href="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%B8%8A">数据结构（上）</a>和<a href="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%B8%8B">数据结构（下）</a></p></blockquote><a id="more"></a><h3 id="矩阵与广义表"><a href="#矩阵与广义表" class="headerlink" title="矩阵与广义表"></a>矩阵与广义表</h3><h4 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵"></a>矩阵</h4><ul><li><p>矩阵的转置</p><pre><code class="cpp">void trsmat(int A[][maxSize],int B[][maxSize],int m, int n)&#123;    for (int i = 0;i &lt; m;++i)        for (int j = 0;j &lt; n;++j)            B[j][i] = A[i][j];&#125;</code></pre></li><li><p>矩阵相加</p><pre><code class="cpp">void addmat(int C[][maxSize],int A[][maxSize],int B[][maxSize],int m, int n)&#123;    for (int i = 0;i &lt; m;++i)        for (int j = 0;j &lt; n;++j)            C[i][j] = A[i][j] + B[i][j];&#125;</code></pre></li><li><p>矩阵相乘</p><pre><code class="cpp">void amutmat(int C[][maxSize],int A[][maxSize],int B[][maxSize],int m, int n,int k)&#123;    for (int i = 0;i &lt; m;++i)        for (int j = 0;j &lt; k;++j)        &#123;            C[i][j] = 0;            for int(h = 0;h &lt; n;++h)                C[i][j] += A[i][j] * B[i][j];        &#125;&#125;</code></pre></li><li><p>相同的元素或者零元素在矩阵中分布存在一定规律的矩阵称为特殊矩阵，反之称为稀疏矩阵</p><ul><li>对称矩阵、三角阵、对角矩阵</li></ul></li></ul><h4 id="广义表"><a href="#广义表" class="headerlink" title="广义表"></a>广义表</h4><ul><li>表元素可以是原子或者广义表的一种线性表的扩展结构</li><li>广义表可以是递归定义的，长度为表最上层元素的个数，深度为表中括号的最大的层数</li><li>当广义表非空时，第一个元素为广义表的表头，其余元素组成的表是广义表的表尾</li><li>原子结点有两个域：标志域和数据域</li><li>广义表结点有三个域：标志域，头指针域与尾指针域</li></ul><h3 id="树"><a href="#树" class="headerlink" title="树"></a>树</h3><h4 id="树的基本概念"><a href="#树的基本概念" class="headerlink" title="树的基本概念"></a>树的基本概念</h4><ul><li>树是一种非线性的数据结构，是若干个结点的集合，由唯一的根和若干个互不相交的子树组成<ul><li>结点不仅包含数据元素，并且包含指向子树的分支</li><li>结点的度是结点拥有的子树个数或者分支个数，树的度是树中各结点度的最大值</li><li>树的高度是树中结点的最大层次，根结点的高度为树的高度</li></ul></li><li>树的双亲存储结构：<code>int tree[maxSize]</code></li><li>树的链式存储结构<ul><li>邻接表：孩子存储结构</li><li>孩子兄弟存储结构</li></ul></li></ul><h4 id="二叉树的概念和性质"><a href="#二叉树的概念和性质" class="headerlink" title="二叉树的概念和性质"></a>二叉树的概念和性质</h4><ul><li><p>二叉树的定义</p><ul><li>每个结点最多只有两颗子树，即二叉树中的结点的度只能为0、1、2</li><li>子树有左右顺序之分，不能颠倒</li></ul></li><li><p>满二叉树：在一颗二叉树中，如果所有的分支节点都有左、右孩子节点，并且叶子节点都集中在二叉树的最下一层</p></li><li><p>完全二叉树由满二叉树从右至左、从上之下挨个删除结点得到的</p></li><li><p>二叉树的主要性质</p><ol><li><p>非空二叉树上叶子结点数等于双分支结点数加1，$n_0=n_2+1$</p></li><li><p>在二叉树的第 $i$ 层上最多有 $2^{i-1}$个节点，$(i&gt;=1)$</p></li><li><p>二叉树中如果深度为 $k$，那么最多有 $2^{k-1}$ 个节点，$(k&gt;=1)$</p></li><li><p>若对含 n 个结点的完全二叉树从上到下且从左至右进行 1 至 n 的编号，则对完全二叉树中任意一个编号为 i 的结点：</p><ul><li>若 i=1，则该结点是二叉树的根，无双亲，否则编号为 $\lfloor i/2\rfloor$ 的结点为其双亲结点（向下取整）</li><li>若 2i&gt;n，则该结点无左孩子，否则，编号为 2i 的结点为其左孩子结点</li><li>若 2i+1&gt;n，则该结点无右孩子，否则，编号为2i+1 的结点为其右孩子结点</li></ul></li><li><p>Catalan()：给定 n 个结点，能够成 $h\left( n\right) =\dfrac{C_{2n}^{n}}{n+1}$  棵不同的二叉树</p></li><li><p>在完全二叉树中，具有n个节点的完全二叉树的深度为 $\lfloor log2n\rfloor+1$</p></li></ol></li><li><p>二叉树的顺序存储结构最适用于完全二叉树</p></li><li><p>二叉树的链式存储结构</p><pre><code class="cpp">typedef struct BTNode&#123;    char  data;    //数据域    struct BTNoode* lchild;    struct BTNode* rchild;&#125; BTNode;</code></pre></li></ul><h4 id="二叉树的遍历算法"><a href="#二叉树的遍历算法" class="headerlink" title="二叉树的遍历算法"></a>二叉树的遍历算法</h4><ul><li><p>先序遍历</p><pre><code class="cpp">/*二叉树的非递归先序遍历*/void PreTraverseTree2(BitNode * root)&#123;    StackNode* S;   //定义一个栈指针    BitNode* p;   //工作指针    S = NULL;    p = root;    S = InitStack(S);   //初始化栈    if (NULL == p)    &#123;        printf(&quot;树为空！\n&quot;);        return;    &#125;     //end if    while (p || !StackEmpty(S))    &#123;     //如果树不空或者栈不空        if (p)        &#123;            StackPush(S, p);    //p 所指节点入栈            printf(&quot;%c &quot;, p-&gt;data);     //相当于 visit（p）            p = p-&gt;lchild ;     //指向 p 的左孩子         &#125;//end if        else        &#123;     //p 所指节点为空，则出栈赋给 p，遍历右子树            StackPop(S, p);            p = p-&gt;rchild;     //若右孩子有左子树则继续 while 将左孩子入栈        &#125;    //end else    &#125;    //end while    free(S);&#125;    //end PreTraverseTree2/*二叉树的递归先序遍历*/void preOrder(BiTNode *root)&#123;    if (root)    &#123;        printf(&quot;%d &quot;, root-&gt;data);        preOrder(root-&gt;lchild);        preOrder(root-&gt;rchild);    &#125;&#125;</code></pre></li><li><p>中序遍历</p><pre><code class="cpp">/*二叉树的非递归中序遍历*/void InOrderTraverseTree2(BitNode* root)&#123;    StackNode* S; //定义一个栈指针    BitNode* p; //工作指针    S = NULL;    p = root;    S = InitStack(S); //初始化栈    if (NULL == p) &#123; //如果是空树        printf(&quot;树为空！\n&quot;) ;        return;    &#125;//end if    while (p || !StackEmpty(S)) &#123; //如果树不空或者栈不空        if (p)        &#123;            StackPush(S, p); //将节点入栈            p = p-&gt;lchild; //指针一直向左孩子移动直到无左孩子        &#125;//end if        else        &#123;            StackPop(S, p); //p 左子树为空则出栈            printf(&quot;%c &quot;, p-&gt;data); //访问 p 节点            p = p-&gt;rchild; //向右子树移动        &#125;//end else    &#125;//end while    free(S);&#125;//end InOrderTraverseTree2/*二叉树的递归中序遍历*/void inOrder(BiTNode* root)&#123;    if (root)    &#123;        inOrder(root-&gt;lchild);        printf(&quot;%d &quot;, root-&gt;data);        inOrder(root-&gt;rchild);    &#125;&#125;</code></pre></li><li><p>后序遍历</p><pre><code class="CPP">/*二叉树非递归后序遍历*/void LastTraverseTree2(BiTNode* root)&#123;    StackNode* S; BiTNode* cur, * pre;//定义一个栈指针    S = NULL; S = InitStack(S); //cur 为当前节点指针，pre 保存上一节点    if (NULL == root)    &#123;        printf(&quot;树为空！\n&quot;);        return;    &#125;//end if    pre = NULL; cur = NULL;    StackPush(S, T); //根节点入栈    while (!StackEmpty(S))    &#123; //若栈非空        cur = NULL;        StackGetTop(S, cur); //将栈顶节点赋给 cur/*要保证根节点在左孩子和右孩子访问之后才能访问，因此对于任一节点 P，先将其入 栈。如果 P 不存在左孩子和右孩子，则可以直接访问它；或者 P 存在左孩子或者右孩子，但是其左孩子和右孩子都已被访问过了，则同样可以直接访问该节点。*/        if ((cur-&gt;lchild == NULL &amp;&amp; cur-&gt;rchild == NULL) ||            (pre != NULL &amp;&amp; (pre == cur-&gt;lchild || pre == cur-&gt;rchild)))        &#123;            printf(&quot;%c &quot;, cur-&gt;data);            pre = cur;            StackPop(S, cur);        &#125;//end if//若非上述两种情况，则将 P 的右孩子和左孩子依次入栈，这样就保证了每次取栈顶元素//的时候，左孩子在右孩子前面被访问，左孩子和右孩子都在根节点前面被访问。        else        &#123;            if (cur-&gt;rchild != NULL)                StackPush(S, cur-&gt;rchild);            if (cur-&gt;lchild != NULL)                StackPush(S, cur-&gt;lchild);        &#125;//end else    &#125;//end while    free(S);&#125;//end LastTraverseTree2/*二叉树递归后序遍历*/void postOrder(BiTNode* root)&#123;    if (root)    &#123;        postOrder(root-&gt;lchild);        postOrder(root-&gt;rchild);        printf(&quot;%d &quot;, root-&gt;data);    &#125; &#125;</code></pre></li><li><p>层次遍历：自上而下，自左向右</p><ul><li>首先，将二叉树的祖先节点入队列</li><li>然后循环执行以下步骤，直到队列为空：节点出队列进行相应操作，该节点如果有左孩子节点，左孩子节点入队列，该节点如果有右孩子节点，右孩子节点入队</li></ul><pre><code class="cpp">void LayerOrder(BiTreeNode* head)&#123;    LQueue Q;    Initiate_Queue(&amp;Q);    BiTreeNode* p;    if (head != NULL) AppendQueue(&amp;Q, head);    while (QueueNotEmpty(&amp;Q)) &#123;        p = QueueDelete(&amp;Q);        cout &lt;&lt; p-&gt;data &lt;&lt; &quot; &quot;;        if (p-&gt;LChild != NULL) AppendQueue(&amp;Q, p-&gt;LChild);        if (p-&gt;RChild != NULL) AppendQueue(&amp;Q, p-&gt;RChild);    &#125;&#125; </code></pre></li></ul><h4 id="哈夫曼树和哈夫曼编码"><a href="#哈夫曼树和哈夫曼编码" class="headerlink" title="哈夫曼树和哈夫曼编码"></a>哈夫曼树和哈夫曼编码</h4><ul><li><p>哈夫曼树又叫做最优二叉树，它的特点是带权路径最短</p><ul><li>树的路径长度是指从根到每个节点的路径长度之和</li><li>带权路径长度是从该节点到根节之间的路径长度乘以结点的权值</li><li>树的带权路径长度（WPL）是指树中所有叶子节点的带权路径长度之和</li></ul></li><li><p>求哈夫曼树的带权路径长度：WPL = 第 i 个节点的权值+ 第i个节点的长度</p><pre><code class="cpp">ElemType WeightPathLength(struct BTreeNode* FBT, int len)//len初始为0  &#123;      if (FBT == NULL) //空树返回0          return 0;      else      &#123;          if (FBT-&gt;left == NULL &amp;&amp; FBT-&gt;right == NULL)//访问到叶子结点              return FBT-&gt;data * len;          else //访问到非叶子结点，进行递归调用，返回左右子树的带权路径长度之和，len递增              return WeightPathLength(FBT-&gt;left,len+1)+WeightPathLength(FBT-&gt;right,len+1);      &#125;  &#125;  </code></pre></li><li><p>哈夫曼树的构造方法：根据数组 a 中 n 个权值建立一棵哈夫曼树，返回树根指针  </p><pre><code class="cpp">struct BTreeNode* CreateHuffman(ElemType a[], int n)  &#123;      int i, j;      struct BTreeNode **b, *q;      b = malloc(n*sizeof(struct BTreeNode));      for (i = 0; i &lt; n; i++) //初始化b指针数组，使每个指针元素指向a数组中对应的元素结点      &#123;          b[i] = malloc(sizeof(struct BTreeNode));          b[i]-&gt;data = a[i];          b[i]-&gt;left = b[i]-&gt;right = NULL;      &#125;      for (i = 1; i &lt; n; i++)//进行 n-1 次循环建立哈夫曼树      &#123;          //k1表示森林中具有最小权值的树根结点的下标，k2为次最小的下标          int k1 = -1, k2;          for (j = 0; j &lt; n; j++)//让k1初始指向森林中第一棵树，k2指向第二棵          &#123;              if (b[j] != NULL &amp;&amp; k1 == -1)              &#123;                  k1 = j;                  continue;              &#125;              if (b[j] != NULL)              &#123;                  k2 = j;                  break;              &#125;          &#125;          for (j = k2; j &lt; n; j++)//从当前森林中求出最小权值树和次最小          &#123;              if (b[j] != NULL)              &#123;                  if (b[j]-&gt;data &lt; b[k1]-&gt;data)                  &#123;                      k2 = k1;                      k1 = j;                  &#125;                  else if (b[j]-&gt;data &lt; b[k2]-&gt;data)                      k2 = j;              &#125;          &#125;          //由最小权值树和次最小权值树建立一棵新树，q指向树根结点          q = malloc(sizeof(struct BTreeNode));          q-&gt;data = b[k1]-&gt;data + b[k2]-&gt;data;          q-&gt;left = b[k1];          q-&gt;right = b[k2];          b[k1] = q;//将指向新树的指针赋给b指针数组中k1位置          b[k2] = NULL;//k2位置为空      &#125;      free(b); //删除动态建立的数组b      return q; //返回整个哈夫曼树的树根指针  &#125;  </code></pre></li><li><p>哈夫曼编码</p><ul><li>每个字符对应一个二进制编码，采用不等长编码方式，构造哈夫曼树</li><li>将每个字符的出现频率作为字符结点的权值赋予叶子结点，每个分支结点的左右分支分别用0和1编码</li><li>从树根结点到每个叶子结点的路径上所经分支的0、1编码序列等于该叶子结点的二进制编码</li><li>哈夫曼编码产生的是最短前缀码</li></ul><pre><code class="cpp">void HuffManCoding(struct BTreeNode* FBT, int len)//len初始值为0  &#123;      static int a[10];  //定义静态数组a，保存每个叶子的编码，数组长度至少是树深度减一      if (FBT != NULL)  //访问到叶子结点时输出其保存在数组a中的0和1序列编码      &#123;          if (FBT-&gt;left == NULL &amp;&amp; FBT-&gt;right == NULL)          &#123;              int i;              printf(&quot;结点权值为%d的编码：&quot;, FBT-&gt;data);              for (i = 0; i &lt; len; i++)                  printf(&quot;%d&quot;, a[i]);              printf(&quot;\n&quot;);          &#125;          else    //访问到非叶子结点时分别向左右子树递归调用，并把分支上的0、1编码保存到数组a          &#123;   //的对应元素中，向下深入一层时len值增1              a[len] = 0;              HuffManCoding(FBT-&gt;left, len + 1);              a[len] = 1;              HuffManCoding(FBT-&gt;right, len + 1);          &#125;      &#125;  &#125;  </code></pre></li></ul><h3 id="图"><a href="#图" class="headerlink" title="图"></a>图</h3><h4 id="图的基本概念"><a href="#图的基本概念" class="headerlink" title="图的基本概念"></a>图的基本概念</h4><ul><li>图由结点的有穷集合的 V 和边的集合  E 组成（<code>G(V,E)</code>）</li><li>图是按照无方向和有方向分为无向图和有向图，无向边用 $(v_i,v_j)$ 表示，有向边用 $&lt;v_i,v_j&gt;$ 表示</li><li>路径长度：路径上边或者弧的数目</li><li>顶点的度：顶点关联边的数目<ul><li>有向图中：方向指向顶点的边为入度；方向背向顶点的边为出度</li><li>在有向图中，顶点的度就是两者之和</li><li>在无向图中，任意两个顶点是相通的就是连通图，它的极大连通子图为连通分量</li><li>在向图中，任意两个顶点间互相都存在路径的就是强连通图，它的极大强连通子图为强连通分量</li></ul></li></ul><h4 id="图的存储结构"><a href="#图的存储结构" class="headerlink" title="图的存储结构"></a>图的存储结构</h4><ul><li><p>邻接矩阵</p><ul><li>图的顺序存储结构</li><li>用两个数组保存数据：一个一维数组存储图中顶点信息，一个二维数组存储图中边或弧的信息</li><li>无向图中邻接矩阵是个对称矩阵</li><li>0表示无边，1表示有边</li><li>顶点的度是行内数组之和，有向图中各行之和是出度，各列之和是入度 </li><li>邻接矩阵对于边数相对顶点较少的图，就是对存储空间极大的浪费</li></ul><pre><code class="cpp">typedef struct&#123;  int no;  char info;&#125; VertexType;typedef struct&#123;  int edges[maxSize][maxSize];    //有权图中int改为float  int n,e;    //顶点数和边数  VertexType vex[maxSize];    //存放结点信息&#125; MGragh;</code></pre></li><li><p>邻接表</p><ul><li>数组和链表相结合的存储方法，图的链式存储结构</li><li>图中顶点用一个一维数组存储</li><li>图中每个顶点 $V_i$ 的所有邻接点构成一个线性表</li><li>顶点表的各个结点由 data 和 Firstedge 两个域表示<ul><li>data 是数据域，存储顶点信息</li><li>firstedge 是指针域，指向边表的第一个结点，即顶点的第一个邻接点</li></ul></li><li>边表结点由 adjvex 和 next 两个域组成<ul><li>adjvex 是邻接点域，存储某顶点的邻接点在顶点表中坐标</li><li>next 存储边表中下一个结点指针</li></ul></li><li>有向图也可以用邻接表，出度表叫邻接表，入度表尾逆邻接表</li></ul><pre><code class="cpp">typedef struct ArcNode&#123;    int adnex;    //该边所指向的结点的位置    struct ArcNode * nextarc;    //指向下一条边的指针    int info;    //该边的相关信息(如权值)&#125; ArcNode;typedef struct&#123;    char data;    //顶点信息    ArcNode* firstarc;    //指向第一条边的指针&#125;VNode;typedef struct&#123;    VNode adjlist[maxSize];    //邻接表    int n, e;    //顶点数和边数&#125; AGraph;    //图的邻接表类型</code></pre></li><li><p>十字链表</p><ul><li>在邻接表中针对有向图，分为邻接表和逆邻接表，导致无法从一个表中获取图的入读和出度的情况，有人提出了十字链表</li><li>定点表<ul><li>firstin：入边表头指针，指向顶点入边表的第一个结点</li><li>firstout：出边表头指针，指向顶点出边表第一个结点</li></ul></li><li>边表<ul><li>tailvex 是指弧起点在顶点表的下标，headvex 弧终点在顶点表的下标</li><li>headlink 入边表指针域，指向终点相同的下一条边</li><li>taillink 是指边表指针域，指向起点相同的下一条边</li></ul></li></ul></li><li><p>邻接多重表</p><ul><li>ivex 和 jvex 是与某条边依附的两个顶点在顶点表中的下标</li><li>ilink 指向依附项点 ivex 的下一条边</li><li>jlink 指向依附顶点 jvex 的下一条边</li></ul></li></ul><h4 id="图的遍历算法"><a href="#图的遍历算法" class="headerlink" title="图的遍历算法"></a>图的遍历算法</h4><ul><li><p>深度优先遍历（DFS，Depth First Search） </p><ul><li>首先从图中某个顶点 $v_0$ 出发，访问此顶点，然后依次从 $v_0$ 相邻的顶点出发 深度优先遍历，直至图中所有与 $v_0$ 路径相通的顶点都被访问了</li><li>若此时尚有顶点未被访问， 则从中选一个顶点作为起始点，重复上述过程，直到所有的顶点都被访问</li><li>深度优先遍历是一个递归的过程，这种遍历过程类似树的先序遍历，均是先访问节点，再从该节点出发继续向下遍历</li></ul><pre><code class="cpp">bool visited[Max_Vex];    //定义访问标记数组，为了防止重复访问void DFSTraverse(Graph G)&#123;    for (v = 0;v &lt; G.vexnum;++v)        visited[v] = false;    //初始化标记数组    for (v = 0;v &lt; G.vexnum;++v)        if (!visited[v])    //如果 v 未被访问，那么从 v 起，开始做深度优先遍历            DFS(G, v);&#125;void DFS(Graph G, int v)&#123;    visit(v);    visited[v] = true; //定义为已访问    for (w = FirstNeighbor(G, v);w &gt;= 0;w = NextNeighbor(G, v, w))        if (!visited[w])            DFS(G, w);&#125;</code></pre></li><li><p>广度优先遍历（BFS，Breadth First Search）</p><ul><li>首先从图的某个顶点 $v_0$ 出发，访问了 $v_0$ 之后，依次访问与 $v_0$ 相邻的未被访 问的顶点</li><li>然后分别从这些顶点出发，广度优先遍历，直至所有的顶点都被访问完</li><li>BFS 遍历的方式类似于树的层次遍历</li></ul><pre><code class="cpp">bool visited[Max_Vex];    //定义访问标记数组void BFSTraverse(Graph G)&#123;    for (i = 0;i &lt; G.vexnum;++i)        visited[v] = false;    //初始化标记数组    InitQueue(Q);    for (v = 0;v &lt; G.vexnum;++v)        if (!visited[v])    //如果 v 未被访问，那么从 v 起，开始做广度优先遍历            BFS(G, v);&#125;void BFS(Graph G, int v)&#123;    visit(v);    visited[v] = true;    //定义为已访问    while (!isEmpty(Q))    &#123;        DeQueue(Q, v);        for (w = FirstNeighbor(G, v);w &gt;= 0;w = NextNeighbor(G, v, w))            if (!visited[w])            &#123;                visit(w);                visited[w] = true;                EnQueue(Q, w)            &#125;    //if    &#125;    //while&#125;</code></pre></li></ul><h4 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h4><ul><li><p>Prim 算法</p><ul><li>从图中仼意取出一个顶点，把它当成一棵树，然后从与这棵树相接的边中选取一条最短（权值最小）的边，并将这条边及其所连接的顶点也并入这棵树中，此时得到了一棵有两个顶点的树</li><li>然后从与这棵树相接的边中选取一条最短的边，并将这条边及其所连顶点并入当前树中，得到一棵有3个顶点的树</li><li>以此类推，直到图中所有顶点都被并入树中为止，此时得到的生成树就是最小生成树</li></ul><pre><code class="cpp">void prim (G,T)&#123;    T = ∅;    U = &#123;w&#125;;    while ((V - U) != ∅  )    &#123; //若图中不含全部顶点        设  (u，v) 是使 u∈U 与 v∈ (V-U)，且权值最小的边;        T = T∪ (u，v); //边归入树        U = U∪ &#123;v&#125;;     //顶点归入树    &#125;&#125;</code></pre></li><li><p>Kruskal 算法</p><ul><li>将图中边按照权值从小到大排序，然后从最小边开始扫描各边，并检测当前边是否为候选边，即是否该边的并入会构成回路，如不构成回路，则将该边并入当前生成树中，直到所有边都被检测完为止</li><li>Kruskal 算法的时间复杂度主要由选取的排序算法决定，排序算法所处理数据的规模由图的边数e 决定，与顶点数无关，因此克鲁斯卡尔算法适用于稀疏图</li><li>普里姆算法和克鲁斯卡尔算法都是针对于无向图的</li><li>判断是否产生回路要用到并查集，并查集中保存了一棵或者几棵树<ul><li>通过树中一个结点，可以找到其双亲结点，进而找到根结点（可以快速地将两个含有很多元素的集合并为一个，两个集合就是并査集中的两棵树，只需找到其中一棵树的根，然后将其作为另一棵树中任何个结点的孩子结点即可，可以方便地判断两个元素是否属于同一个集合</li><li>通过这两个元素所在的结点找到它们的根结点，如果它们有相同的根，则说明它们属于同一个集合，否则属于不同集合</li></ul></li></ul><pre><code class="cpp">void kruskal（V，T）&#123;    T = V;    //初始化树，仅含顶点    numS = n;    //不连分量的数目    while (numS &gt; 1)    &#123;        从 E 中取出权值最小的边（v,u）;        if（v 和 u 属于 T 中不同的连通分量）        &#123;            T = T∪（u，v）;//将此边加入到生成树中；            numS--; //不连通的分量减少 1        &#125;    &#125;&#125;</code></pre></li></ul><h4 id="最短路径"><a href="#最短路径" class="headerlink" title="最短路径"></a>最短路径</h4><ul><li><p>Dijkstra 算法</p><ul><li>通常用于求图中某一顶点到其余各顶点的最短路径</li><li>设  G=(V,E) 是一个带权有向图，把图中顶点集合 V 分成两组</li><li>第一组为已求出最短路径的顶点集合（用 S 表示，初始时 S 中只有一个源点，,以后每求得一条最短路径就将求得的顶点加入到集合 S 中，直到全部顶点都加入到 S 中）</li><li>第二组为其余未确定最短路径的顶点集合（用 U 表示），按最短路径长度的递增次序依次把第二组的顶点加入 S 中，在加入的过程中，总保持从源点 V 到 S 中各顶点的最短路径长度不大于从源点 V 到 U 中任何顶点的最短路径长度</li></ul></li><li><p>Dijkstra 算法步骤</p><ol><li>初始时，S 只包含源点，即 S＝{v}，v 的距离为 0，U 包含除 v 外的其他顶点，即:U={其 余顶点}，若 v 与 U 中顶点 u 有边，则正常有权值，若 u 不是 v 的出边邻接点，则 权值为 $∞$</li><li>从 U 中选取一个距离 v 最小的顶点 k，把 k 加入 S 中（该选定的距离就是 v 到 k 的最短路 径长度）</li><li>以 k 为新考虑的中间点，修改 U 中各顶点的距离值：若从源点 v 到顶点 u 的距离（经过顶点 k）比原来距离（不经过顶点 k）短，则修改顶点 u 的距离值，修改后的距离值为 v 到 k 的距离加上 k 到 u 的距离</li><li>重复步骤 b 和 c 直到所有顶点都包含在 S 中</li></ol><pre><code class="cpp">void Dijkstra(int v0)&#123;  　　bool S[MAXNUM];                                  // 判断是否已存入该点到S集合中      int n=MAXNUM;  　　for(int i=1; i&lt;=n; ++i) 　　 &#123;      　　dist[i] = A[v0][i];      　　S[i] = false;                                // 初始都未用过该点      　　if(dist[i] == MAXINT)                　　prev[i] = -1; 　　     else             　　prev[i] = v0;   　　&#125;   　 dist[v0] = 0;   　 S[v0] = true; 　　 　　 for(int i=2; i&lt;=n; i++) 　　 &#123;       　　int mindist = MAXINT;       　　int u = v0; 　　                            // 找出当前未使用的点j的dist[j]最小值      　　 for(int j=1; j&lt;=n; ++j)      　　    if((!S[j]) &amp;&amp; dist[j]&lt;mindist)      　　    &#123;         　　       u = j;                             // u保存当前邻接点中距离最小的点的号码          　 　      mindist = dist[j];       　　   &#125;       　　S[u] = true;        　　for(int j=1; j&lt;=n; j++)       　　    if((!S[j]) &amp;&amp; A[u][j]&lt;MAXINT)       　　    &#123;           　    　if(dist[u] + A[u][j] &lt; dist[j])     //在通过新加入的u点路径找到离v0点更短的路径             　    　&#123;                   　　dist[j] = dist[u] + A[u][j];    //更新dist                    　　prev[j] = u;                    //记录前驱顶点             　　    &#125;        　    　&#125;   　　&#125;&#125;</code></pre></li><li><p>Floyd 算法</p><ul><li>Floyd-Warshall算法（Floyd-Warshall algorithm）是解决任意两点间的最短路径的一种算法，可以正确处理有向图或负权的最短路径问题，同时也被用于计算有向图的传递闭包</li><li>Floyd-Warshall 算法的时间复杂度为  $O(N^3)$，空间复杂度为  $O(N^2)$</li><li>Floyd 算法是一个经典的动态规划算法，目标是寻找从点 i 到点 j 的最短路径，假设 Dis(i,j) 为节点 u 到节点 v 的最短路径的距离</li><li>对于每一个节点 k，检查 Dis(i,k) + Dis(k,j) &lt; Dis(i,j) 是否成立，如果成立，证明从 i 到 k 再到 j 的路径比 i 直接到j的路径短，便设置 Dis(i,j) = Dis(i,k) + Dis(k,j)，这样当遍历完所有节点 k，Dis(i,j) 中记录的便是 i 到 j 的最短路径的距离</li></ul></li><li><p>Floyd 算法步骤</p><ul><li>从任意一条单边路径开始，所有两点之间的距离是边的权，如果两点之间没有边相连，则权为无穷大　　</li><li>对于每一对顶点 u 和 v，看看是否存在一个顶点 w 使得从 u 到 w 再到 v 比己知的路径更短，如果是更新它</li></ul><pre><code class="cpp">for (k = 1;k &lt;= n;k++)    for (i = 1;i &lt;= n;i++)        for (j = 1;j &lt;= n;j++)            if (a[i][j] &gt; a[i][k] + a[k][j])                a[i][j] = a[i][k] + a[k][j];</code></pre></li></ul><h4 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h4><ul><li><p>对一个有向无环图 G 进行拓扑排序，是将 G 中所有顶点排成一个线性序列，使得图中任意一对顶点 u 和 v，若存在由 u 到 v 的路径，则在拓扑排序序列中一定是 u 出现在 v 的前边</p><ol><li>从 DAG 图中选择一个没有前驱的节点并输出</li><li>从图中删除该节点和所有以它为起点的有向边</li><li>重复上两步直到当前的 DAG 图为空或不存在无前驱的顶点为止</li></ol><pre><code class="cpp">bool topologicalSort(Graph GL)&#123;    EdgeNode* e;    int top = 0; //用于栈指针下标     int count = 0; // 用于统计输出顶点的个数     int* stack; // 建栈将入度为 0 的顶点入栈     stack = (int*)malloc(GL-&gt;numVertexes * sizeof(int));    for (i = 0; i &lt; GL-&gt;numVertexes; i++)        if (0 == GL-&gt;adjList[i].in) //将入度为 0 的顶点入栈             stack[++top] = i;    while (top != 0)    &#123;        gettop = stack[top--];        printf(&quot;%d -&gt; &quot;, GL-&gt;adjList[gettop].data);        count++; //输出 i 号顶点，并计数         for (e = GL-&gt;adjList[gettop].firstedge; e; e = e-&gt;next) &#123;            k = e-&gt;adjvex;            if (!(--GL-&gt;adjList[k].in))                //将 i 顶点的邻接点入度减 1，如果减 1 后为 0，则入栈                 stack[++top] = k;        &#125;    &#125;    if (count &lt; GL-&gt;numVertexes) return false;    else return true;&#125;</code></pre></li></ul>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;数据结构是指数据的存储结构，是带有结构特性的数据元素的集合。精心选择的数据结构可以带来更好的运行或者存储效率。数据结构是计算机科学与技术专业、软件工程专业甚至于其它电气信息类专业的重要专业基础课程，在408计算机学科专业基础综合考试中占有45分。我选择的课程是浙江大学数据结构&lt;a href=&quot;https://www.icourse163.org/course/ZJU-93001&quot;&gt;国家精品课&lt;/a&gt;，以下为所记课堂笔记第二部分，包含树和图的知识总结以及所需记忆的代码，另外我在开源仓库中还保持了浙大慕课版本的&lt;a href=&quot;https://github.com/Bezhuang/LearnCS/tree/main/%E5%90%8D%E6%A0%A1%E5%85%AC%E5%BC%80%E8%AF%BE/%E6%B5%99%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84&quot;&gt;代码&lt;/a&gt;，可供参考。其他部分笔记详见&lt;a href=&quot;/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%B8%8A&quot;&gt;数据结构（上）&lt;/a&gt;和&lt;a href=&quot;/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%B8%8B&quot;&gt;数据结构（下）&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="算法与数据结构" scheme="http://blog.zhuangzhihao.top/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
  </entry>
  
  <entry>
    <title>基于Python和OpenCV实现人脸识别</title>
    <link href="http://blog.zhuangzhihao.top/Python-OpenCV%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%AB/"/>
    <id>http://blog.zhuangzhihao.top/Python-OpenCV%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%AB/</id>
    <published>2021-08-02T16:00:00.000Z</published>
    <updated>2021-09-14T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Open Source Computer Vision Library（OpenCV）是一个跨平台的计算机视觉库，可用于开发实时的图像处理、计算机视觉以及模式识别程序。OpenCV 用 C++ 语言编写，但本次实战项目使用的是 <code>python-opencv</code> 库实现的，主要是为了初步了解人脸识别的步骤和算法后面的原理。以下为项目笔记，源代码保存在 <a href="https://github.com/Bezhuang/PracticeMakesPerfect/tree/main/Python-OpenCV">Github 仓库</a>中，可供参考。</p></blockquote><a id="more"></a><h3 id="项目背景"><a href="#项目背景" class="headerlink" title="项目背景"></a>项目背景</h3><h4 id="人脸识别介绍"><a href="#人脸识别介绍" class="headerlink" title="人脸识别介绍"></a>人脸识别介绍</h4><ul><li>对人类来说，人脸识别很容易：我们的大脑有专门的神经细胞针对不同的场景或运动特征作出反应，视觉皮层再以某种方式把不同的信息来源转化成可用的模型</li><li>自动人脸识别就是研究如何从一幅图像中提取有意义的特征，形成可用的模型，然后对他们进行一些分类，因此基于几何特征的人脸的人脸识别可能是最直观的识别人脸的方法</li><li>但即使是使用最先进的算法，标记点的确定也是很复杂的，单靠几何特征不能提供足够的信息用于人脸识别</li><li>特征脸方法：把面部图像看作是一个点，从高维图像空间找到它在低维空间的表示，使用主元分析（Principal Component Analysis，PCA）可以找拥有最大方差的轴，但轴的最大方差不一定包含任何有鉴别性的信息</li><li>使用线性鉴别（Linear Discriminant Analysis，LDA）的特定类投影方法：使类内方差最小的同时，使类外方差最大</li><li>仅仅使用的局部特征描述图像的方法避免输入的图像的高维数据：提取的特征对于局部遮挡、光照变化、小样本等情况更强健<ul><li>盖伯小波：Gabor Waelets</li><li>离散傅立叶变换：Discrete Cosinus Transform（DCT）</li><li>局部二值模式：Local Binary Patterns（LBP）</li></ul></li></ul><h4 id="OpenCV-介绍"><a href="#OpenCV-介绍" class="headerlink" title="OpenCV 介绍"></a>OpenCV 介绍</h4><ul><li>从 OpenCV 2.4 开始，加入了新的类 FaceRecognizer，可以使用它便捷地进行人脸识别实验</li><li>FaceRecognizer 类目前包含三种人脸识别方法<ul><li>基于 PCA 变换的人脸识别：EigenFaceRecognizer</li><li>基于 Fisher 变换的人脸识别：FisherFaceRecognizer</li><li>基于局部二值模式的人脸识别：LBPHFaceRecognizer</li></ul></li><li>特征脸（Eigenfaces）：图像表示的问题是他的高维问题，如果数据有任何差异，可以通过寻找主元来知道主要信息，把一些可能相关的变量转换成一个更小的不相关的子集<ul><li>一个高维数据集经常被相关变量表示，因此只有一些的维上数据才是有意义的（包含最多的信息）</li><li>PCA 方法寻找数据中拥有最大方差的方向（主成分）</li><li>计算特征值和对应的特征向量，对特征值进行递减排序，特征向量和它顺序一致</li><li>k 个主成分也就是 k 个最大的特征值对应的特征向量</li><li>把所有的训练数据投影到 PCA 子空间 -&gt; 把待识别图像投影到 PCA 子空间 -&gt; 找到训练数据投影后的向量和待识别图像投影后的向量最近的那个</li></ul></li><li>FisherFaces：基于线性判别分析（Linear Discriminant Analysis，LDA）理论，在降维的同时考虑类别信息，基于特征脸的方法，找到使数据中最大方差的特征线性组合<ul><li>在低维表示下，相同的类应该紧紧的聚在一起，而不同的类别尽量距离越远</li></ul></li><li>局部二值模式直方图（Local Binary Patterns Histograms）：不把整个图像看成一个高维向量，仅用局部特征来描述一个物体，通过这种方式提取特征，获得一个低维隐式<ul><li>对图像的像素和它局部周围像素进行对比后的结果进行求和，把这个像素作为中心，对相邻像素进行阈值比较</li><li>如果中心像素的亮度大于等于他的相邻像素，标记为 1，否则标记为 0（用二进制数字来表示每个像素）</li></ul></li></ul><h3 id="OpenCV-的基本使用"><a href="#OpenCV-的基本使用" class="headerlink" title="OpenCV 的基本使用"></a>OpenCV 的基本使用</h3><h4 id="读取图片"><a href="#读取图片" class="headerlink" title="读取图片"></a>读取图片</h4><pre><code class="python">#导入模块import cv2 as cv#读取图片img=cv.imread(&#39;lena.jpg&#39;)    #加载图片路径中不能有中文#显示图片cv.imshow(&#39;read_img&#39;,img)#等待键盘输入 单位毫秒  传入0 则就是无限等待cv.waitKey(3000)#释放内存  由于OpenCV底层是C++编写的cv.destroyAllWindows()</code></pre><h4 id="图片灰度转换"><a href="#图片灰度转换" class="headerlink" title="图片灰度转换"></a>图片灰度转换</h4><pre><code class="python">import cv2 as cvimg=cv.imread(&#39;lena.jpg&#39;)cv.imshow(&#39;BGR_img&#39;,img)#将图片灰度转换gray_img=cv.cvtColor(img,cv.COLOR_BGR2GRAY)cv.imshow(&#39;gray_img&#39;,gray_img)#保存图片cv.imwrite(&#39;gray_lena.jpg&#39;,gray_img)cv.waitKey(0)cv.destroyAllWindows()</code></pre><h4 id="修改图片尺寸"><a href="#修改图片尺寸" class="headerlink" title="修改图片尺寸"></a>修改图片尺寸</h4><pre><code class="python">import cv2 as cvimg=cv.imread(&#39;lena.jpg&#39;)cv.imshow(&#39;img&#39;,img)print(&#39;原来图片的形状&#39;,img.shape)# 修改图片尺寸resize_img=cv.resize(img,dsize=(600,560))print(&#39;修改后图片的形状：&#39;,resize_img.shape)cv.imshow(&#39;resize_img&#39;,resize_img) #输入q时退出while True:    if ord(&#39;q&#39;)==cv.waitKey(0):        breakcv.destroyAllWindows()</code></pre><h4 id="画图"><a href="#画图" class="headerlink" title="画图"></a>画图</h4><pre><code class="python">import cv2 as cvimg=cv.imread(&#39;lena.jpg&#39;)#绘制矩形，左上角坐标(x,y) 矩形的宽度和高度(w,h)x,y,w,h=100,100,100,100cv.rectangle(img,(x,y,x+w,y+h),color=(0,255,255),thickness=3) #BGR#绘制圆形，圆点的坐标center，半径radiusx,y,r=200,200,100cv.circle(img,center=(x,y),radius=r,color=(0,0,255),thickness=2)#显示图片cv.imshow(&#39;rectangle_img&#39;,img)cv.waitKey(0)cv.destroyAllWindows()</code></pre><h3 id="人脸检测"><a href="#人脸检测" class="headerlink" title="人脸检测"></a>人脸检测</h3><h4 id="Haarcascades"><a href="#Haarcascades" class="headerlink" title="Haarcascades"></a>Haarcascades</h4><ul><li>提取出图像的细节对产生稳定分类结果和跟踪结果很有用，这些提取的结果被称为特征</li><li>虽然任意像素都可以能影响多个特征，但特征应该比像素少得多，两个图像的相似程度可以通过它们对应特征的欧氏距离来度量</li><li>Haar 特征是一种用于实现实时人脸跟踪的特征，每一个 Haar 特征都描述了相邻图像区域的对比模式，如边、顶点和细线都能生成具有判别性的特征</li></ul><h4 id="官方-demo"><a href="#官方-demo" class="headerlink" title="官方 demo"></a>官方 demo</h4><ul><li><p>下载：<a href="https://sourceforge.net/projects/opencvlibrary/files/4.5.3/opencv-4.5.3-vc14_vc15.exe/download">https://sourceforge.net/projects/opencvlibrary/files/4.5.3/opencv-4.5.3-vc14_vc15.exe/download</a></p></li><li><p>build 中是 OpenCV 使用时要用到的一些库文件</p></li><li><p>sources 中是 OpenCV 官方提供的 demo 示例源码</p></li><li><p>sources/data/haarcascades 文件夹包含了所有 OpenCV 的人脸检测的 XML 文件，可用于检测静止图像、视频和摄像头所得到图像中的人脸</p></li></ul><h4 id="静态人脸检测"><a href="#静态人脸检测" class="headerlink" title="静态人脸检测"></a>静态人脸检测</h4><pre><code class="python">import cv2 as cvdef face_detect_demo():    #将图片转换为灰度图片    gray=cv.cvtColor(img,cv.COLOR_BGR2GRAY)    #加载特征数据    face_detector=cv.CascadeClassifier(&#39;opencv/sources/data/haarcascades/haarcascade_frontalface_default.xml&#39;)    faces=face_detector.detectMultiScale(gray)    for x,y,w,h in faces:        cv.rectangle(img,(x,y),(x+w,y+h),color=(0,255,0),thickness=2)    cv.imshow(&#39;result&#39;,img)#加载图片img=cv.imread(&#39;lena.jpg&#39;)face_detect_demo()cv.waitKey(0)cv.destroyAllWindows()</code></pre><h4 id="检测多张人脸"><a href="#检测多张人脸" class="headerlink" title="检测多张人脸"></a>检测多张人脸</h4><pre><code class="python">import cv2 as cvdef face_detect_demo():    #将图片灰度    gray=cv.cvtColor(img,cv.COLOR_BGR2GRAY)    #加载特征数据    face_detector = cv.CascadeClassifier(        &#39;opencv/sources/data/haarcascades/haarcascade_frontalface_default.xml&#39;)    faces = face_detector.detectMultiScale(gray)    for x,y,w,h in faces:        print(x,y,w,h)        cv.rectangle(img,(x,y),(x+w,y+h),color=(0,0,255),thickness=2)        cv.circle(img,center=(x+w//2,y+h//2),radius=w//2,color=(0,255,0),thickness=2)    #显示图片    cv.imshow(&#39;result&#39;,img)#加载图片img=cv.imread(&#39;face3.jpg&#39;)#调用人脸检测方法face_detect_demo()cv.waitKey(0)cv.destroyAllWindows()</code></pre><h4 id="检测视频中的人脸"><a href="#检测视频中的人脸" class="headerlink" title="检测视频中的人脸"></a>检测视频中的人脸</h4><pre><code class="python">import cv2 as cvdef face_detect_demo(img):    #将图片灰度    gray=cv.cvtColor(img,cv.COLOR_BGR2GRAY)    #加载特征数据    face_detector = cv.CascadeClassifier(&#39;opencv/sources/data/haarcascades/haarcascade_frontalface_default.xml&#39;)    faces = face_detector.detectMultiScale(gray)    for x,y,w,h in faces:        cv.rectangle(img,(x,y),(x+w,y+h),color=(0,0,255),thickness=2)        cv.circle(img,center=(x+w//2,y+h//2),radius=(w//2),color=(0,255,0),thickness=2)    cv.imshow(&#39;result&#39;,img)#读取视频cap=cv.VideoCapture(&#39;video.mp4&#39;)while True:    flag,frame=cap.read()    print(&#39;flag:&#39;,flag,&#39;frame.shape:&#39;,frame.shape)    if not flag:        break    face_detect_demo(frame)    if ord(&#39;q&#39;) == cv.waitKey(10):        breakcv.destroyAllWindows()cap.release()</code></pre><h3 id="人脸识别"><a href="#人脸识别" class="headerlink" title="人脸识别"></a>人脸识别</h3><ul><li>用一系列分好类的图像来训练程序，并基于这些图像来进行识别</li><li>每个识别都具有转置信（confidence）评分，因此可在实际应用中通过对其设置阈值来进行筛选</li></ul><h4 id="训练数据"><a href="#训练数据" class="headerlink" title="训练数据"></a>训练数据</h4><ul><li><code>train()</code> 函数中有两个参数：图像数组和标签数组，这些标签表示进行识别时候某人人脸的ID</li><li>需要安装 <code>opencv-contrib-python</code> 模块</li></ul><pre><code class="python">import osimport cv2 as cvimport sysfrom PIL import Imageimport numpy as npdef getImageAndLabels(path):    facesSamples=[]    ids=[]    imagePaths=[os.path.join(path,f) for f in os.listdir(path)]    #检测人脸    face_detector = cv.CascadeClassifier(        &#39;opencv/sources/data/haarcascades/haarcascade_frontalface_default.xml&#39;)    #遍历列表中的图片    for imagePath in imagePaths:        #打开图片        PIL_img=Image.open(imagePath).convert(&#39;L&#39;)        #将图像转换为数组        img_numpy=np.array(PIL_img,&#39;uint8&#39;)        faces = face_detector.detectMultiScale(img_numpy)        #获取每张图片的id        id=int(os.path.split(imagePath)[1].split(&#39;.&#39;)[0])        for x,y,w,h in faces:            facesSamples.append(img_numpy[y:y+h,x:x+w])            ids.append(id)    return facesSamples,idsif __name__ == &#39;__main__&#39;:    #图片路径    path=&#39;./data/jm/&#39;    #获取图像数组和id标签数组    faces,ids = getImageAndLabels(path)    #获取训练对象    recognizer = cv.face.LBPHFaceRecognizer_create()    recognizer.train(faces,np.array(ids))    #保存文件    recognizer.write(&#39;trainer/trainer.yml&#39;)</code></pre><h4 id="基于-LBPH-的人脸识别"><a href="#基于-LBPH-的人脸识别" class="headerlink" title="基于 LBPH 的人脸识别"></a>基于 LBPH 的人脸识别</h4><ul><li>LBPH（Local Binary Pattern Histogram）将检测到的人脸分为小单元，并将其与模型中的对应单元进行比较，对每个区域的匹配值产生一个直方图</li><li>由于这种方法的灵活性，LBPH 是唯一允许模型样本人脸和检测到的人脸在形状、大小上可以不同的人脸识别算法</li><li>调整后的区域中调用 <code>predict()</code>函数，该函数返回两个元素的数组：第一个元素是所识别<br>个体的标签，第二个是置信度评分</li><li>所有的算法都有一个置信度评分阈值，置信度评分用来衡量所识别人脸与原模型的差距，0 表示完全匹配</li><li>可能有时不想保留所有的识别结果，则需要进一步处理，因此可用自己的算法来估算识别的置信度评分</li><li>一个好的 LBPH 识别参考值要低于50，任何高于80的参考值都会被认为是低的置信度评分</li></ul><pre><code class="python">import cv2 as cvimport numpy as npimport os# 加载训练数据集文件recognizer = cv.face.LBPHFaceRecognizer_create()recognizer.read(&#39;trainer/trainer.yml&#39;)# 准备识别的图片faceCascade = cv.CascadeClassifier(    &#39;opencv/sources/data/haarcascades/haarcascade_frontalface_default.xml&#39;)font = cv.FONT_HERSHEY_SIMPLEXid = 0img = cv.imread(&#39;19.pgm&#39;)gray_img=cv.cvtColor(img,cv.COLOR_BGR2GRAY)faces = faceCascade.detectMultiScale(gray_img)for x, y, w, h in faces:    cv.rectangle(img, (x, y), (x + w, y + h), (0, 255, 0), 2)    # 人脸识别    id, confidence = recognizer.predict(gray_img[y:y + h, x:x + w])    print(&#39;标签id:&#39;, id, &#39;置信评分：&#39;, confidence)cv.imshow(&#39;result&#39;, img)cv.waitKey(0)cv.destroyAllWindows()</code></pre><h3 id="摄像头人脸识别"><a href="#摄像头人脸识别" class="headerlink" title="摄像头人脸识别"></a>摄像头人脸识别</h3><h4 id="摄像头调试"><a href="#摄像头调试" class="headerlink" title="摄像头调试"></a>摄像头调试</h4><pre><code class="python">#导入opencv模块import cv2#捕捉帧，笔记本摄像头设置为0即可capture = cv2.VideoCapture(0)#循环显示帧while(True):    ret, frame = capture.read()    #显示窗口第一个参数是窗口名，第二个参数是内容    cv2.imshow(&#39;frame&#39;, frame)    if cv2.waitKey(1) == ord(&#39;q&#39;):      #按q退出        break</code></pre><h4 id="摄像头人脸识别-1"><a href="#摄像头人脸识别-1" class="headerlink" title="摄像头人脸识别"></a>摄像头人脸识别</h4><pre><code class="python">import cv2import numpy as npface_cascade = cv2.CascadeClassifier(    &quot;opencv\sources\data\haarcascades\haarcascade_frontalface_default.xml&quot;)eye_cascade = cv2.CascadeClassifier(&quot;opencv\sources\data\haarcascades\haarcascade_eye.xml&quot;)cap = cv2.VideoCapture(0)while True:    ret, img = cap.read()    gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)    faces = face_cascade.detectMultiScale(gray, 1.1, 5)    if len(faces) &gt; 0:        for faceRect in faces:            x, y, w, h = faceRect            cv2.rectangle(img, (x, y), (x + w, y + h), (255, 0, 0), 2)            roi_gray = gray[y:y + h // 2, x:x + w]            roi_color = img[y:y + h // 2, x:x + w]            eyes = eye_cascade.detectMultiScale(roi_gray, 1.1, 1, cv2.CASCADE_SCALE_IMAGE, (2, 2))            for (ex, ey, ew, eh) in eyes:                cv2.rectangle(roi_color, (ex, ey), (ex + ew, ey + eh), (0, 255, 0), 2)    cv2.imshow(&quot;img&quot;, img)    if cv2.waitKey(1) &amp; 0xFF == ord(&#39;q&#39;):        break</code></pre>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;Open Source Computer Vision Library（OpenCV）是一个跨平台的计算机视觉库，可用于开发实时的图像处理、计算机视觉以及模式识别程序。OpenCV 用 C++ 语言编写，但本次实战项目使用的是 &lt;code&gt;python-opencv&lt;/code&gt; 库实现的，主要是为了初步了解人脸识别的步骤和算法后面的原理。以下为项目笔记，源代码保存在 &lt;a href=&quot;https://github.com/Bezhuang/PracticeMakesPerfect/tree/main/Python-OpenCV&quot;&gt;Github 仓库&lt;/a&gt;中，可供参考。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="编程与开发" scheme="http://blog.zhuangzhihao.top/categories/%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="Python" scheme="http://blog.zhuangzhihao.top/tags/Python/"/>
    
    <category term="OpenCV" scheme="http://blog.zhuangzhihao.top/tags/OpenCV/"/>
    
  </entry>
  
  <entry>
    <title>考研政治小抄</title>
    <link href="http://blog.zhuangzhihao.top/%E8%80%83%E7%A0%94%E6%94%BF%E6%B2%BB%E5%B0%8F%E6%8A%84/"/>
    <id>http://blog.zhuangzhihao.top/%E8%80%83%E7%A0%94%E6%94%BF%E6%B2%BB%E5%B0%8F%E6%8A%84/</id>
    <published>2021-07-31T16:00:00.000Z</published>
    <updated>2021-09-20T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>“思想政治理论”是研究生招生考试必考科目之一（为什么！┗|｀O′|┛），分为马原、毛中特、史纲、思修和时政5个大类。政治内容众多且杂，如果对基础概念和知识进行具体总结，篇幅非常长，本篇笔记只是以一个“Cheat-sheet”的形式尽可能包含所有考试重点，至于系统的归纳梳理则以肖精讲精练为准。</p></blockquote><a id="more"></a><h3 id="马克思主义基本原理概论"><a href="#马克思主义基本原理概论" class="headerlink" title="马克思主义基本原理概论"></a>马克思主义基本原理概论</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><ul><li>马克思主义哲学（科学方法）<ul><li>哲学的基本问题哲学的基本问题，不同的哲学流派</li><li>马哲</li><li>唯物论——世界的本源是什么</li><li>辩证法——世界是怎样的</li><li>认识论——如何认知世界</li><li>唯物史观——人类历史发展规律</li></ul></li><li>马克思主义政治经济学（主体）<ul><li>简单商品经济时期（资本主义以前的商品经济就叫简单经济时期）</li><li>发达商品经济时期</li><li>自由竞争资本主义（考试重点）</li><li>垄断竞争资本主义</li></ul></li><li>科学社会主义理论（目的和归宿）<ul><li>社会主义：从空想到实</li><li>共产主义：社会的终极形态</li></ul></li><li>恩格斯的《反杜林论》把马原分为哲学、政经、科社</li></ul><h4 id="唯物论"><a href="#唯物论" class="headerlink" title="唯物论"></a>唯物论</h4><ul><li>世界的本原<ul><li>主观唯心：世界的本原在我心里（王阳明心学）</li><li>客观唯心：世界的本原是脱离物质世界、不依赖于个人意识而独立存在的精神（佛教中的“缘”、道教中的“道”）</li><li>马克思主义哲学认为世界的本原是一切客观实在</li><li>客观实在：不以人的意志为转移</li></ul></li><li>物质决定意识，物质派生出意识</li></ul><h4 id="辩证法"><a href="#辩证法" class="headerlink" title="辩证法"></a>辩证法</h4><ul><li>物质世界是联系和发展的</li><li>辩证法的两大总特征：联系、发展<ul><li>联系：世界上的万事万物都与其他事物发生某种关联、产生某种联系，这个世界是联系的统一体，不存在完全孤立的事物</li><li>发展：任何事物都有它的过去、现在与将来，要立足于过去，展望将来</li></ul></li><li>事物是一对一对联系的<ul><li>一个事物与另一个事物发生联系，而另一个事物又与另一个事物发生联系，如此循环往复</li><li>世界就是靠一对一对相互交织的联系，构建出一张普遍交织的大网，这就是联系的普遍性</li></ul></li><li>辩证法的三大规律：对立统一、量变质变、否定之否定<ul><li>对立统一：是世间万事万物发展的原因和动力</li><li>量变质变：不断地进行星的积累，最终实现质的突破，不断地积累与突破</li><li>否定之否定：波浪式地上升、螺旋式的前进，是事物发展的方向与归宿</li></ul></li></ul><h4 id="认识论"><a href="#认识论" class="headerlink" title="认识论"></a>认识论</h4><ul><li>认识的本质是人类头脑对外部世界的能动反映</li><li>实践是认识的来源</li><li>没有人类的实践，就不会有人类的认识<ul><li>感性认识（浅显）：外部世界直接作用于感官而形成的认识</li><li>理性认识（深刻）：基于感性素材，对其概括、抽象、提炼、加工、思考，获得理性认识</li></ul></li><li>真理：脑子里面的东西与外部世界相致</li><li>谬误：脑子里面的东西与外部世界不一致</li><li>真理的绝对性与相对性：任何一个真理既是绝对的,又是相对的（从不同角度来看）<ul><li>真理的绝对性（通俗）：我既然是真理，我肯定是对的</li><li>真理的相对性（通俗）：我虽然是对的，但我未来有可能不对</li></ul></li></ul><h4 id="唯物史观"><a href="#唯物史观" class="headerlink" title="唯物史观"></a>唯物史观</h4><ul><li>历史进程中的决定性力量<ul><li>唯心史观:由精神力量所决定</li><li>唯物史观:由物质力量所决定（社会生产劳动及其生产力水平的提高决定历史发展）</li></ul></li><li>历史是什么人创造的<ul><li>唯心史观：历史是由英雄人物创造</li><li>唯物史观：历史是由人民群众创造</li></ul></li><li>历史向前发展是统一性和多样性的统一<ul><li>自然界：不以人的意志为转移的客观规律</li><li>人类社会：历史发展规律（取决定性作用）+ 人的主观能动性（对其选择）</li><li>规律使得人类社会的发展具有统一性，能动使得人类社会的发展具有多样性</li></ul></li></ul><h4 id="马克思主义政治经济学"><a href="#马克思主义政治经济学" class="headerlink" title="马克思主义政治经济学"></a>马克思主义政治经济学</h4><ul><li>商品价值的本质是劳动者通过劳动创造的价值</li><li>商品的价值：隐藏在商品里面、用作交换的、人的劳动</li><li>资本主社会以前：劳动的过程以及劳动的成果都归劳动者本人所有</li><li>资本主义社会以后：劳动的过程以及劳动的成果都归资本家所有</li><li>为什么资本主义社会存在剥削<ul><li>劳动创造价值，其中一部分价值通过工资的形式给了劳动者，多出来的部分（剩余价值）被资本家无偿占有</li></ul></li></ul><h4 id="科学社会主义发展进程"><a href="#科学社会主义发展进程" class="headerlink" title="科学社会主义发展进程"></a>科学社会主义发展进程</h4><ul><li>社会主义的发展进程<ul><li>空想 -&gt; 科学</li><li>理论 -&gt; 实践</li></ul></li><li>共产主义的基本特征<ul><li>物质财富极大丰富（产品）</li><li>精神境界极大提高</li><li>每个人自由而全面的发展</li></ul></li></ul><h3 id="思想道德修养与法律基础"><a href="#思想道德修养与法律基础" class="headerlink" title="思想道德修养与法律基础"></a>思想道德修养与法律基础</h3><h4 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h4><ul><li>思想修养<ul><li>人生观：如何树立正确的人生观</li><li>理想信念：如何树立远大的理想，理想和现实是怎样的关系</li><li>中国精神：什么是中国精神，如何去弘扬中国精神</li><li>社会主义核心价值观：当代中国人的思想标准</li></ul></li><li>道德修养<ul><li>道德的基本问题：概念、本质、特征、功能、历史发展脉络</li><li>两个维度<ul><li>不同时期的道德：古代的道德、近代的道德、今天的道德</li><li>不同领域的道德：社会工作中的道德提倡、职场工作中的道德提倡、自身修养的道德报倡、家庭生活中的道德提倡</li></ul></li></ul></li><li>法律基础：基础常识</li></ul><h4 id="思想修养"><a href="#思想修养" class="headerlink" title="思想修养"></a>思想修养</h4><ul><li>人生价值<ul><li>人生观：指我们对自己的人生的整体看法和整体观点</li><li>人生观属于世界观，世界观包含人生观</li><li>人生目的：在人生观中居于核心地位</li><li>人生目的是人生观的核心，可以决定人生态度和人生价值</li></ul></li><li>理想信念<ul><li>理想通过实践实现现实</li><li>实践是理想变成现实的根本途径</li><li>理想 -&gt; 信念 -&gt; 信仰 -&gt; 科学/非科学的信仰</li><li>信仰一般不会改变,但是不是不能改变</li><li>个人理想服从于社会理想，社会理想为个人理想提供保障</li></ul></li><li>中国精神<ul><li>以爱国主义为核心的民族精神</li><li>以改革创新为核心的时代精神</li></ul></li><li>社会主义核心价值观</li></ul><h4 id="道德修养"><a href="#道德修养" class="headerlink" title="道德修养"></a>道德修养</h4><ul><li>道德是上层建筑，由经济基础决定<ul><li>社会主义国家的经济基础：公有制（集体利益大于个人利益）</li><li>资本主义国家的经济基础：私有制（个人利益至上）</li></ul></li><li>道德的功能<ul><li>行为前：认识功能</li><li>行为中：规范功能</li><li>行为后：调节功能</li></ul></li><li>不同时期的道德<ul><li>古代的道德：传统美德</li><li>近代的道德：革命道德</li><li>现代的的道德：社会主义道德</li></ul></li><li>不同领域的道德<ul><li>社会公德</li><li>职业道德</li><li>家庭美德</li><li>个人品德</li></ul></li></ul><h4 id="法律基础"><a href="#法律基础" class="headerlink" title="法律基础"></a>法律基础</h4><ul><li>法律的基本问题<ul><li>法律的概念、功能、历史发展的脉络</li><li>法律是统治阶级的整体意志的体现，是统治阶级进行阶级统治的工具</li></ul></li><li>法律的运行：立法 -&gt; 执法 -&gt; 司法 -&gt; 守法</li><li>法律体系<ul><li>实体法律部门：宪法、民法等</li><li>程序法律部门：诉讼法、非诉讼法等</li></ul></li><li>法治体系：法律体系、法律实施体系、法律监督体系</li><li>法治思维：坚持法治思维，就要批判人治思维</li><li>法律权威：外在（强制性）和内在（合理性）</li><li>法律权利和义务</li></ul><h3 id="中国近代史纲要"><a href="#中国近代史纲要" class="headerlink" title="中国近代史纲要"></a>中国近代史纲要</h3><h4 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h4><ul><li>不考历史的细节，而考历史背后的政治逻辑</li><li>1840年鸦片战争：中国近代史开端</li><li>1911年辛亥革命：清朝政府结束，北洋政府开始</li><li>1919年五四运动：新旧民主主义革命分界线</li><li>1928年东北易帜：北洋政府结束，国民政府开始</li><li>1949年新中国成立：中国现代史开端</li></ul><h4 id="国情（从实际出发）"><a href="#国情（从实际出发）" class="headerlink" title="国情（从实际出发）"></a>国情（从实际出发）</h4><ul><li>国情是一切历史理论研究的起点</li><li>近代中国的国情：半殖民地半封建社会（1840年—1949年）</li></ul><h4 id="二、矛盾"><a href="#二、矛盾" class="headerlink" title="二、矛盾"></a>二、矛盾</h4><ul><li>近代中国主要矛盾<ul><li>半殖民：帝国主义与中华民族之间的矛盾</li><li>半封建：封建主义与人民大众之间的矛盾</li></ul></li></ul><h4 id="任务和对象"><a href="#任务和对象" class="headerlink" title="任务和对象"></a>任务和对象</h4><ul><li>近中国的任务<ul><li>帝国主义与中华民族之间的矛盾的任务：反帝</li><li>封建主义与人民大众之间的矛盾的任务：反封建</li></ul></li></ul><h4 id="中国革命的性质"><a href="#中国革命的性质" class="headerlink" title="中国革命的性质"></a>中国革命的性质</h4><ul><li>中国的革命是一场以反帝反封建为任务为对象的革命</li><li>革命的性质：资产阶级民族革命</li><li>新民主义革命是由无产阶级领导，但性质却是资产阶级革命<ul><li>决定革命性肤的不是革命的领导者，而是革命的任务和对象</li></ul></li><li>革命：推翻旧制度、确立新制度、确立新的生产关系的行为</li><li>奴隶社会：封建地主推翻奴隶主，奴隶主居于统治地位，奴隶处于被统治地位</li><li>封建社会：资产阶级推翻封建地主，封建地主居于统治地位，农民处于被统治地位</li><li>资本主义社会：无产阶级推翻资产阶级，资本主义居于统治地位，无产阶级处于被统治地位</li><li>因为中国革命的任务是反帝反封建，所以中国革命的性质就是资产阶级革命，无论谁来<br>做</li></ul><h4 id="史纲总结"><a href="#史纲总结" class="headerlink" title="史纲总结"></a>史纲总结</h4><ul><li>近代中国我们要做反帝反封建的任务，这件事情理应由资产阶级去做，是资产阶级的历<br>史使命</li><li>但是因为资产阶级的软弱本身没有实力去完成反帝反封建的历史使命，于是就由中国的无产阶级替资产阶级去完成本该由资产阶级完成的反帝反封建的历史使命</li><li>中国的革命也因此变成了由无产阶级领导的、资产阶级性质的、反帝反封建的、新式的<br>民主主义革命</li></ul><h3 id="毛泽东思想和中国特色社会主义理论体系概论"><a href="#毛泽东思想和中国特色社会主义理论体系概论" class="headerlink" title="毛泽东思想和中国特色社会主义理论体系概论"></a>毛泽东思想和中国特色社会主义理论体系概论</h3><h4 id="毛泽东思想"><a href="#毛泽东思想" class="headerlink" title="毛泽东思想"></a>毛泽东思想</h4><ul><li>理论的形成</li><li>理论内容<ul><li>新民主主义革命理论：1949年之前</li><li>社会主义改造理论：1949—1956年</li><li>社会主义建设道路的初步探索：1956—1976年</li></ul></li></ul><h4 id="中国特色主义理论体系"><a href="#中国特色主义理论体系" class="headerlink" title="中国特色主义理论体系"></a>中国特色主义理论体系</h4><ul><li>社会主义应该具有先进的、发达的生产力</li><li>怎样建设社会主义<ul><li>解放生产力，发展生产力</li><li>消灭剥削，消灭两极分化</li><li>最终达到共同富裕</li></ul></li><li>邓小平理论</li><li>“三个代表”重要思想<ul><li>建设什么样的党？怎样建设党？</li><li>要始终代表先进生产力的发展方向</li><li>要始终代表先进文化的发展方向</li><li>要始终代表广大人民的根本利益</li></ul></li><li>科学发展观<ul><li>实现什么样的发展？怎样发展？</li></ul></li><li>习近平新时代中国特色社会主义思想<ul><li>新时代、新思想</li><li>全面小康社会</li><li>建党一百年全面脱贫</li><li>2035年基本实现社会主义现代化</li><li>21世界中叶，建成社会主义现代化强国，实现中华民族伟大复兴</li><li>总任务：实现社会主义现代化，中华民族伟大复兴</li><li>布局理论：五位一体总体布局、四个全面战略布局</li><li>内外条件：国防军队建设、中国的外交问题、党的建设</li></ul></li></ul><h4 id="马克思主义中国化"><a href="#马克思主义中国化" class="headerlink" title="马克思主义中国化"></a>马克思主义中国化</h4><ul><li>新文化运动：学习西方资产阶级民族思想，来改造中国人的思想文化</li><li>十月革命：给中国送来了马克思列宁主义</li><li>五四运动：马克思列宁主义得到广泛传播</li><li>中共一大：以无产阶级革命推翻资产阶级，应联合资产阶级一起反帝反封建</li><li>六届六中全会：首次提出“马克思主义中国话”的命题</li><li>中共七大：实现了第一次飞跃，成果即为毛泽东思想</li><li>1956年《论十大关系》：第二次马克思主义中国化开始</li><li>改革开放：实现了马克思主义中国化的第二次飞跃，成果即为中国特色社会主义理论体系</li></ul><h4 id="新民主主义理论"><a href="#新民主主义理论" class="headerlink" title="新民主主义理论"></a>新民主主义理论</h4><ul><li>革命路线：无产阶级领导的人民大众的反帝反封建反官资的革命</li><li>革命纲领<ul><li>政治上：各革命阶级联合专政</li><li>经济上：没收地主、官资，保护民资</li><li>文化上：民族的、科学的、大众的</li></ul></li><li>革命道路：农村包围城市，武装夺取政权</li><li>革命经验（三大法宝）：统战线、武装斗争、党的建设</li></ul><h4 id="社会主义建设初步探索理论"><a href="#社会主义建设初步探索理论" class="headerlink" title="社会主义建设初步探索理论"></a>社会主义建设初步探索理论</h4><ul><li>《论十大关系》<ul><li>第二次马克思主义中国化开始</li><li>方针：调动一切积极因素为社会主义建设服务</li><li>指导思想：独立自主的符合中国特点的社会主义建设道路</li></ul></li><li>《关于正确处理人民内部矛盾的问题》<ul><li>基本矛盾：生产力和生产关系、经济基础和上层建筑</li><li>主要矛盾：作为一个落后的农业国与先进的工业国需求之间存在的矛盾、人民日益增长的物质文化需要同当前的发展不满足人民需要状况之间的矛盾</li><li>两类矛盾：敌我矛盾、人民内部矛盾</li></ul></li><li>中国工业化道路：农轻重</li></ul><h3 id="当代世界经济与政治"><a href="#当代世界经济与政治" class="headerlink" title="当代世界经济与政治"></a>当代世界经济与政治</h3><h4 id="当代世界政治与经济"><a href="#当代世界政治与经济" class="headerlink" title="当代世界政治与经济"></a>当代世界政治与经济</h4><ul><li>当今世界形势：百年未有之大变局，机遇与挑战并存</li><li>国际行为体：大国、欧盟</li><li>地区热点问题：朝韩问题，伊朗问题，叙利亚问题等</li><li>中国对外战略：和平发展道路、合作共赢的新型国际关系、人类命运共同体、一带一路</li></ul><h4 id="时事政治"><a href="#时事政治" class="headerlink" title="时事政治"></a>时事政治</h4><ul><li>重大会议：国际、国内（两会）</li><li>重大改革举措：雄安新区、深圳、粤港澳大湾区</li><li>科技创新：神舟、天宫、嫦娥</li><li>中国对外战略：事件、人物、政策</li></ul>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;“思想政治理论”是研究生招生考试必考科目之一（为什么！┗|｀O′|┛），分为马原、毛中特、史纲、思修和时政5个大类。政治内容众多且杂，如果对基础概念和知识进行具体总结，篇幅非常长，本篇笔记只是以一个“Cheat-sheet”的形式尽可能包含所有考试重点，至于系统的归纳梳理则以肖精讲精练为准。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="学习生活" scheme="http://blog.zhuangzhihao.top/categories/%E5%AD%A6%E4%B9%A0%E7%94%9F%E6%B4%BB/"/>
    
    
    <category term="考研" scheme="http://blog.zhuangzhihao.top/tags/%E8%80%83%E7%A0%94/"/>
    
  </entry>
  
  <entry>
    <title>操作系统（上）</title>
    <link href="http://blog.zhuangzhihao.top/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E4%B8%8A/"/>
    <id>http://blog.zhuangzhihao.top/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E4%B8%8A/</id>
    <published>2021-07-27T16:00:00.000Z</published>
    <updated>2021-09-19T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p> 操作系统（OS）是管理和控制计算机硬件与软件资源，是计算机上直接运行的最基本的系统软件，任何其他软件都必须在操作系统的支持下才能运行。操作系统是用户和计算机的接口，同时也是计算机硬件和其他软件的接口。操作系统的功能包括管理计算机系统的硬件、软件及数据资源，控制程序运行，提供人机交互界面，为其它应用软件提供支持等。我选择的课程是苏州大学的<a href="https://www.icourse163.org/course/SUDA-1001752241">国家精品课</a>和汤子瀛版教材，以下为所记课堂笔记上半部分，包含计算机操作系统概述、处理器管理的知识点，可供参考。下半部分笔记请访问<a href="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E4%B8%8B">操作系统（下）</a></p></blockquote><a id="more"></a><h3 id="操作系统概述"><a href="#操作系统概述" class="headerlink" title="操作系统概述"></a>操作系统概述</h3><h4 id="操作系统基本概念"><a href="#操作系统基本概念" class="headerlink" title="操作系统基本概念"></a>操作系统基本概念</h4><ul><li>冯诺依曼模型：运算器、存储器、控制器、输入设备和输出设备</li><li>引入操作系统的目的：提供一个计算机用户与计算机硬件系统之间的接口、有效的控制和管理计算机系统中的各种硬件和软件资源、合理地组织计算机系统的工作流程</li><li>操作系统是计算机系统的资源管理程序</li><li>操作系统的核心是控制和协调进程的运行，解决进程之间的通信</li><li>操作系统的发展：无操作系统阶段 -&gt; 单道批处理系统 -&gt; 多道批处理系统</li></ul><h4 id="操作系统的特征"><a href="#操作系统的特征" class="headerlink" title="操作系统的特征"></a>操作系统的特征</h4><ul><li>并行性：2个或多个事件在同一时刻发生</li><li>并发性：2个或多个事件在同一时间间隔内发生</li><li>并发和共享是操作系统的2个最基本的特征，二者之间互为存在条件</li><li>资源共享方式：互斥共享、同时访问</li><li>虚拟是指把一个物理上的实体变为若干个逻辑上的对应物</li><li>异步性</li></ul><h4 id="操作系统的功能和服务"><a href="#操作系统的功能和服务" class="headerlink" title="操作系统的功能和服务"></a>操作系统的功能和服务</h4><ul><li>处理器管理：进程控制、进程同步、进程通信、进程调度</li><li>存储器管理：内存分配、内存保护、内存扩充</li><li>设备管理：设备分配、设备传输控制、设备独立性</li><li>文件管理：文件存储空间的管理、目录管理、文件操作管理、文件保护</li><li>用户接口：命令接口、程序接口、图形接口<ul><li>联机命令接口又称交互式命令结构</li><li>脱机命令接口又称批处理命令接口</li></ul></li><li>操作系统3种基本类型：批处理操作系统、分时操作系统、实时操作系统</li><li>其他操作系统：嵌入式操作系统、集群系统、网络操作系统、分布式操作系统</li></ul><h4 id="操作系统的运行环境"><a href="#操作系统的运行环境" class="headerlink" title="操作系统的运行环境"></a>操作系统的运行环境</h4><ul><li>处理器的执行状态分为核心态与用户态<ul><li>核心态是操作系统管理程序执行时机器所处的状态</li><li>用户态是用户程序执行时机器所处的状态</li></ul></li><li>特权指令是只能由操作系统内核部分使用，不允许用户直接使用的指令，如I/O指令、设置中断屏蔽指令、清内存指令、存储保护指令和设置时钟指令</li><li>内核的指令操作工作在核心态<ul><li>时钟管理</li><li>中断机制</li><li>原语</li><li>系统控制的数据结构及处理</li></ul></li><li>异常，也称内中断，是由错误引起的</li><li>通常异常会引起中断，而中断未必是由异常引起的</li><li>系统调用（API）：进程控制、文件系统控制、系统控制、内存管理、网络管理、socket 管控、制用户管理以及进程间通信</li></ul><h4 id="操作系统的体系结构"><a href="#操作系统的体系结构" class="headerlink" title="操作系统的体系结构"></a>操作系统的体系结构</h4><ul><li>操作系统的体系结构主要包括模块组合结构、层次结构和微内核结构</li><li>模块组合结构<ul><li>接口简单直接，系统的效率相对较高</li><li>系统结构不清晰、可扩展性差、可适应性差</li></ul></li><li>层次结构<ul><li>按功能的调用次序排列成若干层</li><li>组织和依赖关系清晰明了，可读性、可适应性及可靠性都得到了增强</li><li>通常要将为进程提供服务的系统调用模块放在系统的内层。</li></ul></li><li>微内核结构<ul><li>客户服务器模式（C/S 模式）</li><li>每个服务进程运行在独立的用户进程中，可靠性好，灵活性好，便于维护</li><li>适合分布式处理的计算环境</li><li>效率不高，尤其是通信频繁的系统</li></ul></li></ul><h3 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h3><h4 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h4><ul><li><p>在计算机操作系统中，进程是资源分配的基本单位，也是独立运行的基本单位</p><ul><li>程序顺序执行时的特征：顺序性，封闭性，可再现性</li><li>程序的并发执行的特征：间断性，失去封闭性，不可再现性</li></ul></li><li><p>程序并发执行且其结果具有可再现性的条件（Bernstein 条件）</p><ul><li>R(p1) ∩ W(p2) = ∅</li><li>R(p2) ∩ W(p1) = ∅</li><li>W(p1) ∩ W(p2) = ∅</li></ul></li><li><p>进程的特征：动态性、并发性、独立性、异步性、结构特征（程序段、数据段和进程控制块）</p></li><li><p>进程和程序的关系</p><ul><li>进程和程序的关系程序是静止的</li><li>进程是暂时的，程序是永久的</li><li>进程的组成包括程序段、数据块和进程控制块（Process Control Block）</li><li>通过多次执行，一个程序可以产生多个不同的进程，通过调用关系，一个进程可以执行多个程序</li><li>进程可创建其他进程，而程序不能形成新的程序</li></ul></li><li><p>由程序段、相关数据段和PCB三部分构成的是进程映像，也叫进程实体</p><ul><li>映像是静态的，进程是动态的，进程是进程实体的运行过程</li></ul></li><li><p>进程和作业的区别</p><ul><li>作业是用户需要计算机完成某项任务而要求计算机所做的工作的集合</li><li>作业提交、作业收容、作业执行、作业完成</li><li>进程是已提交完毕的作业的执行过程，是资源分配的基本单位</li><li>作业是用户向计算机提交任务的任务实体，而进程是完成用户任务的执行实体</li><li>这个作业可由多个进程组成，而必须至少由一个进程组成，但一个进程不能构成多个作业</li></ul></li><li><p>进程的组成</p><ul><li>进程控制块（PCB）：标识进程的存在，刻画执行瞬间特征的数据机构</li><li>其他组成部分：程序段、数据段、进程标识符（PID）、进程当前状态、进程队列指针、程序和数据地址，进程优先级、CPU 现场保护区、通信信息、家族联系、占有资源清单</li></ul></li><li><p>PCB 是进程存在的唯一标志</p><ul><li>PCB 存在是为了保证程序的并发执行</li><li>创建进程实质上是创建进程的 PCB，而撤销进程实质上是撤销进程的 PCB</li><li>系统总是通过 PCB 对进程进行控制的</li></ul></li><li><p>进程的5种基本状态：就续状态、执行状态、阻塞状态、创建状态、结束状态</p><ul><li>执行状态只能由就绪状态转换，而无法由阻塞状态直接转换</li><li>不能从就绪状态变为阻塞状态</li><li>进程状态是唯一的</li></ul></li><li><p>进程的创建</p><ul><li>进程创建是通过创建原语实现的</li><li>申请一个空闲 PCB，并指定唯一的 PID -&gt; 分配必要的资源 -&gt; 将新进程的PCB初始化 -&gt; 插入到就绪队列</li><li>导致进程创建的事件：用户登录、作业调度和请求服务</li></ul></li><li><p>撤销一个进程：撤销原语</p><ul><li>找到被撤销进程的PCB -&gt; 停止该进程的执行 -&gt; 回收被撤销进程所占用的资源 -&gt; 回收PCB</li></ul></li><li><p>进程的阻塞与唤醒：两条低级进程通讯原语</p><ul><li>阻塞原语（P 原语）的功能是将进行进程由执行状态转为阻塞状态</li><li>唤醒原语（V 原语）的功能是将进程由阻塞状态变为就绪状态</li><li>一个进程由执行状态变为阻塞状态，是由这个进程自己调用阻塞原语去完成的</li><li>进程由阻塞状态变为就绪状态，是由另一个发现者进程调用唤醒原语去实现的。一般这个发现者进程与被唤醒进程是合作的并发进程</li></ul></li><li><p>调度是决定将系统资源分配给哪个进程，进程切换是实际分配系统资源</p><ul><li>进程切换一定会产生中断，但处理器模式切换不一定产生进程切换</li></ul></li><li><p>进程的互斥与同步就是一种进程间的通信方式</p><ul><li>高级进程通信方式：共享存储器系、消息传递系统、管道（共享文件）通信系统</li></ul></li></ul><h4 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h4><ul><li>线程是进程内一个相对独立的可调度的执行单元<ul><li>内核级线程依赖于内核，一个内核级线程由于 I/O 操作而阻塞时不会影响其他线程的运行</li><li>用户级线程不依赖于操作系统核心，由于操作系统内核不了解用户线程的存在，当一个线程阻塞时，整个进程必须等待</li></ul></li><li>进程与线程<ul><li>线程谁独立调度的基本单位，进程是拥有资源的基本单位</li><li>线程不拥有资源，但线程可以访问其隶属进程的系统资源</li><li>进程之间可以并发执行，同一进程内的多个线程之间也可以并发执行</li><li>多线程之间的同步与通信非常容易实现</li></ul></li><li>多线程模型：多对一模型，一对一模型，多对多模型（将多个用户级线程映射到多个内核级线程）</li></ul><h4 id="处理器的三级调度"><a href="#处理器的三级调度" class="headerlink" title="处理器的三级调度"></a>处理器的三级调度</h4><ul><li>高级调度（作业调度）：从外存上处于后备状态的作业中选择一个或多个，给他们分配内存等必要资源并建立相应的进程，以便该作业具有获得竞争处理器的权利<ul><li>作业调度每次要接纳多少个作业进入内存取决于多道程序的并发程度</li><li>多道程序的并发程度应根据系统的规模和运算速度来决定</li><li>应将哪些作业从外存调入内存取决于所采取的调度算法</li></ul></li><li>中级调度（交换调度）：按照给定的原则和策略，将处于外存对换区中具备运行条件的进程调入内存，并将其状态修改为就绪状态，挂在就绪队列上等待</li><li>低级调度（进程调度）：按照某种策略和方法，从就绪队列中选取一个进程，将处理器先分配给他<ul><li>进程调度的运行频率很高</li><li>作业调度的结果是为作业创造进程，而进程调度的结果是进程被执行</li></ul></li><li>衡量调度算法的性能： CPU利用率、系统吞吐量、响应时间、周转时间<ul><li>作业的周转时间 = 作业的完成时间 - 作业的提交时间</li><li>平均周转时间：多个作业周转时间的平均值</li><li>带权周转时间是作业周转时间与运行时间的比</li></ul></li></ul><h4 id="进程调度"><a href="#进程调度" class="headerlink" title="进程调度"></a>进程调度</h4><ul><li>处理器分配的任务由进程调度程序完成</li><li>进程调度的功能：记录系统中所有进程的有关情况以及状态特征，选择获得处理器的进程和处理器分配</li><li>引起进程调度的原因<ul><li>当前运行进程运行结束</li><li>当前运行进程因某种原因从运行状态进入阻塞状态</li><li>执行完系统调用等系统程序后返回用户进程</li><li>在采用抢占调度方式的系统中，一个更高优先级的进程要求使用处理器</li><li>在分时系统中分配给该进程的时间片已用完</li></ul></li><li>不能进行进程调度的情况<ul><li>处理中断的过程中</li><li>在操作系统内核程序临界区中</li><li>其他需要完全屏蔽中断的原子操作过程中</li></ul></li><li>进程调度的方式：抢占方式、非抢占方式</li></ul><h4 id="常见调度算法"><a href="#常见调度算法" class="headerlink" title="常见调度算法"></a>常见调度算法</h4><ul><li>先来先服务调度算法（作业调度、进程调度）<ul><li>FCFS：按照进程进入就绪队列的先后次序来分配处理器</li></ul></li><li>短作业优先调度算法（作业调度、进程调度）<ul><li>SJF：把处理器分配给最快完成的作业或进程</li></ul></li><li>优先级调度算法（作业调度、进程调度）<ul><li>静态优先级是在创建进程时确定的，确定之后整个进程运行期间不再改变</li><li>按进程类、作业的资源要求、用户类型和要求确定静态优先级</li><li>动态优先级是指在创建进程时根据进程的特点及相关情况确定一个优先级</li><li>根据进程占有CPU时间的长短和就绪进程等待CPU时间的长短确定动态优先级</li><li>基于优先级的调度算法还可按调度方式的不同，分为非抢占优先级调度算法和抢占优先级调度算法</li><li>在优先级相同的情况下，通常按照先来先服务或者短作业优先的顺序执行</li></ul></li><li>时间片轮转调度算法（进程调度）<ul><li>分时系统必须满足系统对响应时间的要求</li><li>就绪队列中的进程数与时间片的大小成反比</li><li>系统的处理能力决定时间片的大小</li></ul></li><li>高响应比优先调度算法（作业调度）<ul><li>响应比 = 作业响应时间 / 估计运行时间</li><li>作业响应时间 = 作业等待时间 + 估计运行时间</li></ul></li><li>多级反馈队列调度算法（作业调度）<ul><li>时间片轮转调度算法和优先级调度算法的综合与发展</li></ul></li></ul><h4 id="同步与互斥"><a href="#同步与互斥" class="headerlink" title="同步与互斥"></a>同步与互斥</h4><ul><li><p>互斥是间接相互制约关系，而同步是直接相互制约关系</p></li><li><p>只要是同类进程即为互斥关系，不同类进程即为同步关系</p></li><li><p>临界资源：同时仅允许一个进程使用的资源</p><ul><li>进入区、临界区、退出区、剩余区</li><li>临界区：进程中用于访问临界资源的代码，又称临界段</li><li>临界资源是必须互斥访问的资源，这种资源同时只能被一个进程所使用，但需要这种资源的进程不止一个，因此需要对使用临界资源的进程进行管理</li><li>每个进程的临界区代码可以不相同</li></ul></li><li><p>互斥的要求：空闲让进，忙则等待，有限等待，让权等待</p></li><li><p>互斥实现方法</p><ul><li>软件实现方法</li><li>互斥实现的硬件方法：中断屏蔽、硬件指令</li><li>硬件方法适用范围广，支持多个临界区，但不能实现让权等待</li></ul></li></ul><h4 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h4><ul><li>信号量 <code>(s,q)</code> 及同步原语<ul><li>整型变量 s 表示系统中某类资源的数目，q 是一个初始状态为空的队列</li><li>信号量的值仅能由 P 操作（wait）操作和 V 操作（signal）操作改变，操作系统利用它的状态对进程和资源进行管理</li><li> P 操作相当于申请资源，V 操作相当于释放资源</li></ul></li><li>信号量分为整型信号量和记录型信号量（资源信号量）<ul><li>记录型信号量添加了链表结构用于链接所有等待该资源的进程，解决忙等的问题</li></ul></li><li>信号量可以用来实现进程互斥和描述前趋关系</li></ul><h4 id="经典同步问题"><a href="#经典同步问题" class="headerlink" title="经典同步问题"></a>经典同步问题</h4><ul><li>生产者-消费者问题<ul><li>P(full) / P(empty) 与 P(mutex) 的顺序不可倒，必须先对资源信号量进行 P 操作，再对互斥信号量进行 P 操作。否则会导致死锁</li><li>互斥信号量就是给同类进程准备的</li></ul></li><li>读者写者问题（许多进程共享数据区）<ul><li>读者不互斥，写者必须互斥</li><li>读者优先，公平情况和写者优先三种不同算法</li></ul></li><li>哲学家进餐问题<ul><li>最多允许4个哲学家同时进餐</li><li>仅当一个哲学家左右两边的筷子同时可用时，他才可以拿起筷子</li><li>将哲学家编号要求奇数号的哲学家先拿左边筷子，偶数号的哲学家先拿右边筷子</li></ul></li><li>理发师问题</li><li>信号量机制问题的解题步骤分析<ul><li>关系分析</li><li>确定临界资源</li><li>整理思路</li></ul></li><li>实现同步互斥的 P、V 操作必须成对出现，先进行 P 操作进入临界区，后进行 V 操作退出临界区</li><li> P、V操作要分别紧靠临界区的头尾部</li><li>通常用于互斥的信号量初值设为 1</li></ul><h4 id="管程"><a href="#管程" class="headerlink" title="管程"></a>管程</h4><ul><li>管程定义了一个数据结构和能为并发进程所执行的一组操作<ul><li>局部于管程的数据只能被局部于管程内的过程所访问</li><li>一个进程只有通过调用管程内的过程才能进入管程访问共享数据</li><li>每次仅允许一个进程在管程内执行某个内部过程，即进程互斥地通过调用内部过程进入管程</li></ul></li><li>管程的互斥访问完全由编译程序在编译时自动添加</li><li>为实现进程间的同步，管程还必须包含若干用于同步的设施<ul><li>局限于管程并仅能从管程内进行访问的若干变量，用于区别各种不同的等待原因</li><li>在条件变量上进行操作的两个函数过程，wait 和 signal</li></ul></li></ul><h4 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h4><ul><li>死锁的概念<ul><li>参死锁的进程至少有两个</li><li>每个参与死锁的进程均等待资源</li><li>参与死锁的进程中至少有两个进程占有资源</li><li>死锁进程是系统中当前进程集合的一个子集</li></ul></li><li>死锁产生的原因是竞争资源<ul><li>一个资源是否属于可剥夺资源，完全取决于资源本身的性质</li></ul></li><li>死锁产生的必要条件<ul><li>互斥条件</li><li>不剥夺条件</li><li>请求于保持条件：可采用预先静态分配方法</li><li>环路等待条件：可采用有序资源分配法</li></ul></li><li>处理死锁的方法：鸵鸟算法、预防死锁、避免死锁、检测及解除死锁（被动）<ul><li>死锁预防对系统加的限制条件通常很严格，对系统的并发性会产生很大的副作用</li><li>死锁避免往往在资源被分配出去之前，要计算分配之后系统是否安全</li></ul></li><li>死锁的避免<ul><li>系统在进行资源分配之前，先计算资源分配的安全性（安全序列）</li><li>并非所有不安全状态都是死锁状态，死锁是不安全状态的真子集</li><li>银行家算法</li></ul></li><li>死锁的检测和解除<ul><li>系统资源分配图（system resource allocation graph）可定义为一个二元组</li><li><code>SRAG = (V,E)</code></li><li>死锁定理：不同简化顺序将得到相同的不可简化图。系统状态 S 为死锁状态的条件是当且仅当 S 状态的资源分配图是不可完全简化的</li><li>死锁检测算法：available、allocation、request、临时变量（work与finish）</li><li>死锁解除：剥夺资源，撤销进程，进程回退</li></ul></li><li>进程与饿死<ul><li>当等待时间给进程推进和响应带来明显影响时，发生进程饥饿</li><li>当饥饿到一定程度，进程所赋予的任务即使完成也不再具有实际意义时，进程被饿死</li><li>活锁：在忙时等待条件下发生的饥饿</li><li>饥饿和饿死与资源分配策略有关，因而可从公平性方面考虑防止饥饿与饿死</li></ul></li></ul>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt; 操作系统（OS）是管理和控制计算机硬件与软件资源，是计算机上直接运行的最基本的系统软件，任何其他软件都必须在操作系统的支持下才能运行。操作系统是用户和计算机的接口，同时也是计算机硬件和其他软件的接口。操作系统的功能包括管理计算机系统的硬件、软件及数据资源，控制程序运行，提供人机交互界面，为其它应用软件提供支持等。我选择的课程是苏州大学的&lt;a href=&quot;https://www.icourse163.org/course/SUDA-1001752241&quot;&gt;国家精品课&lt;/a&gt;和汤子瀛版教材，以下为所记课堂笔记上半部分，包含计算机操作系统概述、处理器管理的知识点，可供参考。下半部分笔记请访问&lt;a href=&quot;/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E4%B8%8B&quot;&gt;操作系统（下）&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="计算机专业" scheme="http://blog.zhuangzhihao.top/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%93%E4%B8%9A/"/>
    
    
    <category term="Linux" scheme="http://blog.zhuangzhihao.top/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>计算机组成原理（上）</title>
    <link href="http://blog.zhuangzhihao.top/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E4%B8%8A/"/>
    <id>http://blog.zhuangzhihao.top/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E4%B8%8A/</id>
    <published>2021-07-13T16:00:00.000Z</published>
    <updated>2021-08-14T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>计算机组成原理是计算机专业本科教学中的重要课程，它可以帮助我们系统地理解计算机硬件系统的组织结构和工作原理、掌握计算机硬件系统的基本分析与设计方法以及建立计算机系统的整体概念，为进一步学习计算机设计实践课程、培养系统开发、调试以及设计创新能力奠定良好的基础。计组是考研的最重最难点，在408计算机学科专业基础综合考试中占有45分。我选择的课程是哈工大的<a href="https://www.icourse163.org/course/hit-309001">国家精品课</a>，配合天勤高分笔记，以下为所记课堂笔记上半部分，包含计算机系统概论、数据的表示和运算、存储器和指令系统的知识点，可供参考。下半部分笔记请访问<a href="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E4%B8%8B">计算机组成原理（下）</a></p></blockquote><a id="more"></a><h3 id="计算机系统概述"><a href="#计算机系统概述" class="headerlink" title="计算机系统概述"></a>计算机系统概述</h3><h4 id="计算机系统的多层次结构"><a href="#计算机系统的多层次结构" class="headerlink" title="计算机系统的多层次结构"></a>计算机系统的多层次结构</h4><ul><li>硬件：<ol><li>微程序机器层M0（微指令系统），由硬件直接执行微指令</li><li>传统机器M1（机器语言机器），用微程序解释机器指令</li></ol></li><li>软件：<ol><li>虚拟机器M2（操作系统机器），用机器语言解释操作系统</li><li>汇编语言M3（汇编语言机器），用汇编程序翻译成机器语言程序</li><li>虚拟机器M4（高级语言机器），用编译程序翻译成汇编语言程序</li></ol></li></ul><h4 id="冯·诺依曼机"><a href="#冯·诺依曼机" class="headerlink" title="冯·诺依曼机"></a>冯·诺依曼机</h4><ul><li><p>基本工作方式：控制流驱动方式</p></li><li><p>最根本的特征：采用存储程序原理，即按地址访问并顺序执行指令</p></li><li><p>指令和数据均以二进制形式存放在存储器中</p></li><li><p>CPU区分依据是：指令周期的不同阶段</p></li><li><p>冯·诺依曼计算机：以运算器为中心</p></li><li><p>现代的计算器：以存储器为中心</p></li><li><p>5大部件：存储器、运算器、控制器、输入设备、输出设备（适配器）</p></li><li><p>三大部分：CPU（运算器、控制器）、I/O设备（输入设备、输出设备）、主存储器</p></li><li><p>哈佛结构：将指令和数据放在两个独立的存储器，允许在一个机器周期内同时获得指令和操作数，提高了执行速度</p></li></ul><h4 id="计算机性能指标"><a href="#计算机性能指标" class="headerlink" title="计算机性能指标"></a>计算机性能指标</h4><ul><li><p>机器字长：</p><ul><li>CPU一次能处理数据的位数，通常与CPU的寄存器位数有关，字长越长，精度越高</li><li>机器的字长也会影响机器的运算速度：字长较短，运算位数多，可能需要多次运算才能完成</li><li>对硬件造价有影响：直接影响ALU、数据总线以及存储字长的位数</li></ul></li><li><p>存储容量：主存容量、辅存容量</p></li></ul><ul><li><p>运算速度：</p><ul><li>吞吐量和响应时间</li><li>主频和CPU时钟周期</li><li>CPI：执行一条指令所需的时钟周期数</li><li>CPU执行时间：指运行一个程序所花费的时间。取决于：主频、CPI、指令条数</li><li>MIPS：每秒执行多少百万条指令</li><li>MFLOPS：每秒执行多少百万次浮点运算（标志系统性能最有用参数）</li><li>GFLOPS：每秒执行多少十亿次浮点运算</li><li>TFLOPS：每秒执行多少万亿次浮点运算</li></ul></li></ul><h3 id="数据的表示和运算"><a href="#数据的表示和运算" class="headerlink" title="数据的表示和运算"></a>数据的表示和运算</h3><h4 id="汉字的编码"><a href="#汉字的编码" class="headerlink" title="汉字的编码"></a>汉字的编码</h4><ul><li>输入码（外码）：区位码、国际码、拼音码、电报码、表形码等</li><li>内码：0、1（机器码）</li><li>输出码：汉字字形码</li><li>汉字编码包括汉字的输入编码、汉字内码、汉字字形。用两个字节表示一个汉字，每个字节用七位码。区位码是4位十进制数，前2位是区码，后2位是位码</li><li>国标码是将十进制的区位码转换为十六进制后，再在每个字节上加上20H。为了方便计算机区分中文字符和英文字符，将国标码两个字节的最高位都改为“1”，这就是汉字内码（十六进制）</li></ul><h4 id="字符串的存放"><a href="#字符串的存放" class="headerlink" title="字符串的存放"></a>字符串的存放</h4><ul><li>小端模式：按先存储低位字节、后存储高位字节的顺序存放字符串的内容</li><li>大端模式：按先存储高位字节、后存储低位字节的顺序存放字符串的内容</li></ul><h4 id="校验码"><a href="#校验码" class="headerlink" title="校验码"></a>校验码</h4><ul><li>奇偶校验码：只能检出一位错误，不能确定出错的位置；只能检验处奇数位错误，不能检测出偶数位错误。<ul><li>奇校验码：整个校验码中“1”的个数为奇数。</li><li>偶校验码：整个校验码中“1”的个数为偶数。</li></ul></li><li>海明（汉明）检验码：可检出错位位置</li><li>循环冗余校验（CRC）码：可检出错误位置（通过除法运算）</li></ul><h4 id="原码、反码、补码、移码"><a href="#原码、反码、补码、移码" class="headerlink" title="原码、反码、补码、移码"></a>原码、反码、补码、移码</h4><ul><li>原码、补码、反码三种机器数的最高位均是符号位</li><li>当真值为正时，原码、补码、反码的表示形式均相同，即符号位用“0”表示，数值部分与真值相同</li><li>当真值为负时，原码、补码、反码的表示形式不同，但其符号位都用“1”表示，而数值部分补码是原码的“求反加1”，反码是原码的“每位求反”。</li><li>同一个真值的移码和补码仅差一个符号位。</li><li>4、不同机器数表示±0时，其形式不同。</li><li>[+0]原≠[-0]原， [+0]反≠[-0]反，[+0]补=[-0]补，[+0]移=[-0]移</li><li>当机器字长确定后，补码比原码、反码能多表示一个负数</li><li>移码只能表示整数，用它表示浮点数的阶码时，能方便地判断阶码的大小</li></ul><h4 id="补码定点数的加-减运算"><a href="#补码定点数的加-减运算" class="headerlink" title="补码定点数的加/减运算"></a>补码定点数的加/减运算</h4><ul><li>基本公式：（将符号位和数值部分一起参加运算，并且将符号位产生的进位自然丢掉即可）</li><li>加法：[A]补+[B]补=[A+B]补</li><li>减法：[A-B]补=[A]补+[-B]补（[-B]补由[B]补连同符号位在内，每位取反，末尾加1）</li></ul><h4 id="溢出判断"><a href="#溢出判断" class="headerlink" title="溢出判断"></a>溢出判断</h4><ul><li>用一位符号判断溢出：实际参加操作的两个数符号相同，结果又与原操作数的符号不同，即为溢出</li><li>用两位符号位判断溢出：当2位符号位不同时，表示溢出，否则，无溢出。不论是否发生溢出，高位（第1位）符号永远代表真正的符号。（变形补码，运算时多一位）</li><li>01正溢出（上溢）；10负溢出（下溢）</li><li>采用一位符号位根据数据位的进位情况判断溢出。如果符号位的进位与最高数位的进位不同，则表示结果溢出</li></ul><h4 id="浮点数的加-减运算"><a href="#浮点数的加-减运算" class="headerlink" title="浮点数的加/减运算"></a>浮点数的加/减运算</h4><ul><li>对阶：两个数的小数点位置对齐（使阶码相等），两个数的阶码相减求阶差，使小阶的尾数向右移位，每右移一位，阶码加1</li><li>尾数求和：将对阶后的两个尾数按定点加（减）运算规则进行运算</li><li>规格化：补码规格化形式为[S]补 00.1××××；[S]补 11.0××××<ul><li>左规：尾数出现00.0××××或11.1××××时，需左规。尾数左移一位，阶码减1</li><li>右规：尾数出现01.××××或10.××××时，表示尾数溢出，但在浮点运算中不算溢出，可通过右规处理。尾数右移一位，阶码加1</li></ul></li><li>舍入：在对阶和右规的过程中，可能会将尾数的低位丢失，引起误差，影响精度，用舍入法来提高尾数的精度<ul><li>“0舍1入”法：被移去的最高位数值位为0，则舍去；被移去的最高数值位为1，则在尾数的末位加1。又溢出时，再右规……</li><li>“恒置1”法：不论丢掉的最高数位是“1”还是“0”，都使尾数末位恒置“1”。</li><li>两种方法同样都有使尾数变大和变小两种可能</li></ul></li><li>溢出判断（是否溢出由阶码的符号决定）<ul><li>上溢：阶码[j]补=01，×××，作溢出处理</li><li>下溢：阶码[j]补=10，×××，按机器零处理</li></ul></li></ul><h4 id="浮点数的表示范围"><a href="#浮点数的表示范围" class="headerlink" title="浮点数的表示范围"></a>浮点数的表示范围</h4><ul><li><p>上溢：当浮点数阶码大于最大阶码时，上溢，机器停止运算，进行中断溢出处理。</p></li><li><p>下溢：当浮点数阶码小于最小阶码时，下溢，溢出的数绝对值很小，通常将位数各位强制为0，按机器零处理，机器可以继续运行。</p></li></ul><h4 id="8位二进制整数范围"><a href="#8位二进制整数范围" class="headerlink" title="8位二进制整数范围"></a>8位二进制整数范围</h4><ul><li>原码、反码：-127—+127</li><li>补码、移码：-128—+127</li></ul><h4 id="标准IEEE-754标准"><a href="#标准IEEE-754标准" class="headerlink" title="标准IEEE 754标准"></a>标准IEEE 754标准</h4><ul><li><p>现代计算机中，浮点数一般采用IEEE制定的国际标准：</p></li><li><p>常用的浮点数有三种：阶码用移码表示</p></li><li><p>短实数、长实数、临时实数的偏移量用十六进制数表示分别为7FH（127）、3FFH、3FFFH</p></li><li><p>尾数部分通常是用原码、规格化表示，即非“0”的有效位最高位总是“1”，但在IEEE标准中，有效位呈如下形式：1▲ff…ffff</p></li><li><p>其中▲表示假想的二进制小数点。在实际表示中，对短实数和长实数，这个整数位的1省略，称隐藏位；对于临时实数不采用隐藏位方案</p></li></ul><h3 id="存储器层次结构"><a href="#存储器层次结构" class="headerlink" title="存储器层次结构"></a>存储器层次结构</h3><h4 id="存储器的层次化结构"><a href="#存储器的层次化结构" class="headerlink" title="存储器的层次化结构"></a>存储器的层次化结构</h4><ul><li><p>存储器主要性能指标：速度、容量、每位价格（位价）</p></li><li><p>一般来说，速度越高，位价越高；容量越大，位价越低；容量越大，速度越低。</p></li><li><p>层次结构主要体现在缓存-主存和主存-辅存这两个层次上。</p><ul><li>缓存-主存：主要解决CPU和主存速度不匹配问题（由硬件自动完成）数据调动对任何程序员透明。</li><li>主存-辅存：主要解决存储系统的容量问题（由硬件和操作系统共同完成）数据调动对应用程序员透明</li></ul></li></ul><h4 id="动态RAM的刷新"><a href="#动态RAM的刷新" class="headerlink" title="动态RAM的刷新"></a>动态RAM的刷新</h4><ul><li>一般取2ms，对动态RAM的全部基本单元电路必作一次刷新，称为刷新周期，又称再生周期。刷新的单位是行，仅需要行地址。</li><li>集中刷新：在规定的一个刷新周期内，对全部存储单元集中一段时间逐行进行刷新，此刻必须停止读/写操作，称“死时间”或“死区”。（全部一起刷）</li><li>分散刷新：对每行存储单元的刷新分到每个存取周期内完成。优点：没有死区。缺点：存取周期加长，整个系统速度降低。（一个个刷）</li><li>异步刷新：是前两种方式的结合，既缩短“死时间”，又充分利用最大刷新时间间隔为2ms的特点。（一行行刷）</li><li>一行行刷的平均刷新时间<ul><li>行数 = 芯片容量 / 每行存储单元个数</li><li>平均刷新时间 = 间隔最长 / 行数</li></ul></li></ul><h5 id="存储容量的扩展"><a href="#存储容量的扩展" class="headerlink" title="存储容量的扩展"></a>存储容量的扩展</h5><ul><li>位扩展<ul><li>增加存储字长</li><li>例如：2片1K4位的存储芯片可组成1K8位的存储器。</li><li>注意：其中一片的数据线作为高4位D7-D4，另一片的数据线作为低4位D3-D0。</li></ul></li><li>字扩展<ul><li>增加存储器字的数量</li><li>例如：2片1K8位的存储芯片可组成一个2K8位的存储器。</li><li>注意：两片都连地址线A0-A9。（从低位连起）</li></ul></li><li>字、位扩展<ul><li>既增加存储字的数量又增加存储字长。</li></ul></li></ul><h4 id="双口RAM和多模块存储器"><a href="#双口RAM和多模块存储器" class="headerlink" title="双口RAM和多模块存储器"></a>双口RAM和多模块存储器</h4><ul><li>为了提高CPU访问存储器的速度，可以采用双端口存储器（空间并行）、多模块存储器（时间并行）等技术，都属于并行技术。</li></ul><h4 id="多模块存储器"><a href="#多模块存储器" class="headerlink" title="多模块存储器"></a>多模块存储器</h4><ul><li>为了提高访存速度（CPU速度比存储器快，同时从存储器中取出n条指令，可以充分利用CPU资源，提高运行速度）</li><li>单体多字系统<ul><li>在一个存取周期内，从同一地址取出n条指令，然后逐条将指令送至CPU执行，即每隔1/n存取周期，主存向CPU送一条指令，增大了存储器的带宽，提高了存储器的工作速度。</li><li>例如：从同一地址取出4条指令，为单体四字结构，每字W位。按地址在一个存取周期内可读出4*W位的指令或数据，使主存带宽提高到4倍。</li><li>缺点：指令和数据在主存内必须是连续存放的，一旦遇到转移指令，或者操作数不能连续存放，这种方法的效果就不明显。</li></ul></li><li>多体并行系统</li><li>采用多提模块组成的存储器。每个模块可以并行工作，也可以交叉工作。<ul><li>低位交叉编址<ul><li>程序连续存放在相邻体中（交叉存储）。低位地址表示体号，高位地址表示体内地址。<br>地址的低n为片选。</li><li>优点：相邻地址单元的数据放在不同组，各组可以并行工作，能较好提高存储器的带宽。</li><li>缺点：某一组出现故障，会影响整个存储器的正常工作。</li></ul></li><li>高位交叉编址<ul><li>按体内地址顺序存放（顺序存储）。高位地址表示体号，低位地址表示体内地址。</li><li>地址的高n位片选。</li><li>优点： 某一组的故障不影响其他组，且容易通过添加模块来扩充容量。</li><li>缺点：相邻地址单元的数据放在同一组存储单元，各组间串行工作，不利于提升存储器的带宽。</li></ul></li></ul></li></ul><h4 id="Cache中主存块之间的映射方式"><a href="#Cache中主存块之间的映射方式" class="headerlink" title="Cache中主存块之间的映射方式"></a>Cache中主存块之间的映射方式</h4><ul><li>由主存地址映射到Cache地址称为地址映射</li><li>直接映射<ul><li>主存数据只能装入Cache中的唯一位置。若这个位置已有内容，则产生块冲突，原来的块将无条件地被替换出去（无需使用替换算法）。</li><li>优点：实现简单，只需利用主存地址的某些位直接判断，即可确定所需字块是否在缓存中。</li><li>缺点：不够灵活，降低命中率。</li></ul></li><li>全相联映射<ul><li>允许主存中每一字块映射到Cache中的任何一块位置上。可以从已被占满的Cache中替换出任一旧字块。</li><li>通常采用昂贵的“按内容寻址”的相联存储器来完成。</li><li>优点：灵活，命中率高，缩小了块冲突率，空间利用率高。</li><li>缺点：地址变换速度慢，实现成本高</li></ul></li><li>组相联映射（上述两种映射的折中）<ul><li>将Cache空间分成大小相同的组，主存的一个数据块可以装入到一组内的任何一个位置（组间采取直接映射，组内采取全相联映射）。</li></ul></li></ul><h4 id="Cache中主存块的替换算法"><a href="#Cache中主存块的替换算法" class="headerlink" title="Cache中主存块的替换算法"></a>Cache中主存块的替换算法</h4><ul><li>先进先出（First-In-First-Out，FIFO）算法</li><li>近期最少使用（Least Recently Used，LRU）算法</li><li>随机法</li></ul><h4 id="磁盘存储器"><a href="#磁盘存储器" class="headerlink" title="磁盘存储器"></a>磁盘存储器</h4><ul><li>磁盘寻址的最小单位是扇区。</li><li>道密度：沿磁盘半径方向单位长度的磁道数。</li><li>位密度：单位长度磁道上记录二进制的位数。</li><li>平均寻道时间：从一个磁道转移到另一个磁道的平均时间。（全部寻道时间的一半）</li><li>平均等待时间：旋转等待的平均时间。（转一周时间的一半）</li><li>一扇区的传送时间：T=1 / (转速×扇区数)</li><li>存取一个扇区的时间：T=每个扇区位数 / (转速×扇区数)</li><li>平均存取时间=平均寻道时间 + 平均等待时间 + 传输时间</li><li>每个记录面的磁道数：K=[(外直径-内直径)/2]*磁道密度</li><li>盘组格式化容量：C = 记录面数 * K * 每个扇区字节数 * 扇区数</li><li>盘组非格式化容量：CN = 记录面数 * K * 最内圈磁道周长 * 内层位密度</li><li>WE 为写允许信号：低电平0为写，高电平1为读</li><li>CS为片选信号：低电平0有效</li><li>借位/进位C：1=结果的最高位发生了进位，0=结果的最高位未发生进位</li><li>溢出标志位V：1=溢出，0=没有溢出</li></ul><h3 id="指令系统"><a href="#指令系统" class="headerlink" title="指令系统"></a>指令系统</h3><h4 id="指令的寻址方式"><a href="#指令的寻址方式" class="headerlink" title="指令的寻址方式"></a>指令的寻址方式</h4><ul><li>寻址模式是大多数中央处理器 （CPU）设计中的指令集架构的一个方面</li><li>在给定指令集架构中定义的各种寻址模式决定了该架构中的机器语言指令如何识别每个指令的操作数</li><li>寻址模式指定如何通过使用寄存器中保存的信息和/或机器指令中包含的常量或其他地方包含的常量来计算操作数的有效存储器地址。</li></ul><h4 id="CISC和RISE"><a href="#CISC和RISE" class="headerlink" title="CISC和RISE"></a>CISC和RISE</h4><ul><li>从硬件角度来看CISC处理的是不等长指令集，它必须对不等长指令进行分割，因此在执行单一指令的时候需要进行较多的处理工作。而RISC执行的是等长精简指令集，CPU在执行指令的时候速度较快且性能稳定。因此在并行处理方面RISC明显优于CISC，RISC可同时执行多条指令，它可将一条指令分割成若干个进程或线程，交由多个处理器同时执行。由于RISC执行的是精简指令集，所以它的制造工艺简单且成本低廉。</li><li>从软件角度来看，CISC运行的则是我们所熟识的DOS、Windows操作系统。而且它拥有大量的应用程序。因为全世界有65%以上的软件厂商都理为基于CISC体系结构的PC及其兼容机服务的，象赫赫有名的Microsoft就是其中的一家。而RISC在此方面却显得有些势单力薄。虽然在RISC上也可运行DOS、Windows，但是需要一个翻译过程，所以运行速度要慢许多。</li></ul><h4 id="地址指令操作数物理位置的三种形式"><a href="#地址指令操作数物理位置的三种形式" class="headerlink" title="地址指令操作数物理位置的三种形式"></a>地址指令操作数物理位置的三种形式</h4><ul><li>寄存器——寄存器型（RR型）；</li><li>寄存器——存储器型指令（RS型）；</li><li>存储器——存储器型（SS型）。</li></ul>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;计算机组成原理是计算机专业本科教学中的重要课程，它可以帮助我们系统地理解计算机硬件系统的组织结构和工作原理、掌握计算机硬件系统的基本分析与设计方法以及建立计算机系统的整体概念，为进一步学习计算机设计实践课程、培养系统开发、调试以及设计创新能力奠定良好的基础。计组是考研的最重最难点，在408计算机学科专业基础综合考试中占有45分。我选择的课程是哈工大的&lt;a href=&quot;https://www.icourse163.org/course/hit-309001&quot;&gt;国家精品课&lt;/a&gt;，配合天勤高分笔记，以下为所记课堂笔记上半部分，包含计算机系统概论、数据的表示和运算、存储器和指令系统的知识点，可供参考。下半部分笔记请访问&lt;a href=&quot;/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E4%B8%8B&quot;&gt;计算机组成原理（下）&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="计算机专业" scheme="http://blog.zhuangzhihao.top/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%93%E4%B8%9A/"/>
    
    
  </entry>
  
</feed>
