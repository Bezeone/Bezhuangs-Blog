---
title: 数据结构
date: 2020-10-28
updated: 2021-05-29
tags: []
categories: 计算机专业
mathjax: true
references:
  - title: 浙江大学数据结构
    url: https://www.icourse163.org/course/ZJU-93001
  - title: 2021版天勤计算机考研高分笔记系列
    url: https://book.douban.com/series/54664
---

> 数据结构是指数据的存储结构，是带有结构特性的数据元素的集合。精心选择的数据结构可以带来更好的运行或者存储效率。数据结构是计算机科学与技术专业、软件工程专业甚至于其它电气信息类专业的重要专业基础课程，在408计算机学科专业基础综合考试中占有45分。我选择的课程是浙江大学数据结构国家精品课，教材是严奶奶的版本，以下为所记课堂笔记以及[代码](https://github.com/Bezhuang/LearnCS101/tree/main/%E6%B5%99%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84)，可供参考。

<!--more-->

### 基本概念

#### 什么是数据结构

- 数据结构是计算机中存储、组织数据的方式，精心选择的数据结构可以带来最优效率的算法
- 数据结构和数据的组织形式有关，和空间的利用效率有关，和算法的巧妙程度有关
- 数据对象在计算机中的组织方式：逻辑结构和物理存储结构
- 抽象数据类型（Abstract Data Type）
  - 数据类型：数据对象集、数据集合相关联的操作集
  - 抽象：描述数据类型的方法不依赖于具体实现，与存放数据的机器、数据存储的物理结构、实现操作的算法和编程语言均无关

#### 什么是算法

- 算法（Algorithm）：一个有限的指令集，接受一些输入产生输出，一定在有限步骤后终止
- 算法的每一条指令必须有充分明确的目标（不可以有歧义），在计算机能处理范围内，描述应不依赖于任何一种计算机语言以及具体的实现手段
- 空间复杂度 $S(n)$：根据算法写成的程序在执行时占用存储空间的长度
- 时间复杂度 $T(n)$：根据算法写成的程序在执行时耗费的时间的长度
- 分析一般算法的效率时，常常关注最坏情况复杂度 $T_{worst}(n)$ 和平均情况复杂度 $T_{avg}(n)$
  
  - $T_{avg}(n) ≤ T_{worst}(n)$
  - 一般情况下更多关注的是最坏情况复杂度 $T_{worst}(n)$
- 复杂度的渐进表示法
  - $T(n)=O(f(n))$ 表示存在常数 $C>0$，$n_0>0$，使得当 $n≥n_0$ 时有 $T(n)≤C⋅f(n)$，即 $O(f(n))$ 表示 $f(n)$ 是 $T(n)$ 的某种上界
  - $T(n)=Ω(g(n))$ 表示存在常数 $C>0$，$n_0>0$，使得当 $n≥n_0$ 时有 $T(n)≥C⋅g(n)$，即 $Ω(g(n))$ 表示 $g(n)$ 是 $T(n)$ 的某种下界
  - $T(n)=θ(h(n))$ 表示同时有 $T(n)=O⋅h(n)$ 和 $T(n)=Ω(h(n))$，即 $θ(h(n))$ 表既是上界也是下界
- 复杂度分析
  - 若两段算法分别有复杂度 $T_1(n)=O(f_1(n))$ 和 $T_2(n)=O(f_2(n))$，则 $T_1(n)+T_2(n)=max(O(f_1(n)),O(f_2(n)))$ 且 $T_1(n)\times T_2(n)=O(f_1(n)\times f_2(n))$
  - 若 $T(n)$ 是关于 $n$ 的 $k$ 阶多项式，那么 $T(n)=θ(n^k)$
  - 一个 `for` 循环的时间复杂度等于循环次数乘以循环体代码的复杂度
  - `if-else` 结构的复杂度取决于 `if` 的条件判断复杂度和两个分枝部分的复杂度，总体复杂度取三者中最大

### 线性结构
- 顺序储存结构
- 链式储存结构
- 线性表（Linear List）：由同类型数据元素构成有序序列的线性结构
- 广义表
- 多重链表：链表中的节点可能同时隶属于多个链；（节点）多个指针域
  - 双向链表不是多重链表
- 矩阵的表示：十字链表
- 堆栈（stack）：只在栈顶做插入和删除，具有一定操作约束的线性表。
- 入栈（Push）、出栈（Pop）
- LIFO：后入先出
- 后缀表达式
- 堆栈的链式存储实现：链栈
- 堆栈应用：调用函数及递归、深度优先搜索、回溯算法
- 队列：一端插入另一端删除的具有一定操作约束的线性表
- FIFO：先进先出
- front变量、rear变量

### 树
- 静态查找与动态查找（可插入删除）
- 二分查找（Binary Search）：适用有序且连续排列的数组 - O(logN)
- 二分查找判断树
- ASL：平均成功查找次数
- 树（Tree）：n （n >= 0）个结点构成的有限集合
- 根（root），子树（互不相交）
- 除根结点外，每个结点有且仅有一个父结点
- 结点的度：结点的子树的个数
- 树的度：树的所有结点中最大度数
- 叶结点：度为0的结点
- 根结点在1层，树的深度是所有结点中的最大层次
- 儿子-兄弟表示法
- 二叉树T：一个又穷的结点集合
- 左子树和右子树
- 斜二叉树、完美二叉树、完全二叉树
- 二叉树的遍历
  - 先序遍历
  - 中序遍历
  - 后序遍历
  - 层序遍历
- 树的同构
- 二叉搜索树BST（Binary Search Tree）：左子树键值 < 根结点键值 < 右子树键值，且左右子树都是BST
  - 查找效率决定于树的高度，最大值在最右，最小值在最左
- 平衡因子BF（Balance Factor）= 左子树高度 - 右子树高度
- 平衡二叉树（AVL树）（Balanced Binary Tree）：任意结点左右子树高度差的绝对值不超过1，即 |BF(T)| <= 1
- 给定结点数n的AVL树最大高度为 O(log2(n))!
- 平衡二叉树的调整（发现者、麻烦结点）

### 堆（Heap）
- 优先队列（Priority Queue）
- 优先队列的完全二叉树表示
- 堆的结构性：用数组表示的完全二叉树
- 对的有序性：任一结点的关键字是其子树所有结点的最大或最小值，从根结点到任意结点路径上的结点序列有序
- 最大堆（MaxHeap）和最小堆（MinHeap）
- 哈夫曼树（Huffman Tree）：最优二叉树，WPL最小的二叉树
- 带权路径长度（WPL）
- 构造哈夫曼树：每次吧权值最小的两颗二叉树合并
- 哈夫曼树的特点：
  - 没有度为1的结点
  - n个叶子结点的哈夫曼树共有2n-1个结点
  - 任意非叶节点的左右子树交换后仍是哈夫曼树
  - 对同一权值存在不同构成的两棵哈夫曼树
- 哈夫曼编码
  - 前缀码（Prefix Code）：任何字符编码都不是另一字符的前缀
- 并查集：树结构表示，每个结点代表一个集合元素
- 堆中的路径

### 图（Graph）
- 图表示的是多对多的关系
- 顶点V（Vertex）集合，边（Edge）集合，顶点对 (v,w)
- 有向边 `<v,w>`表示从V指向W的边（单行线）
- 图不考虑重边和自回路
- 无向图和有向图
- 邻接矩阵`G[N][M]`：直观简单好理解，但浪费时间空间
- 邻接表：`G[N]`为指针数组，对应矩阵每行一个链表，只存非0元素，N个头指针+2E个结点
- 图的度：从该点发出的边数为“度”，指向该点的边数为“入度”
- 图的遍历
  - DFS深度优先搜索（Depth First Search）：类似于树的先序遍历（栈）
  - BFS广度优先搜索（Breadth First Search）：类似于树的层序遍历（队列）
- 连通、路径、回路、连通图、连通分量、极大顶点数、极大边数、强连通、强连通分量
- 图不连通则每调用一次DFS/BFS，就把V所有连通分量遍历一遍（List Components）
- 建立图
- 最短路径问题
  - 无权图的最短路径算法：BFS
  - 有权图的单源最短路径算法：Dijkstra算法
  - 负值圈（Negative-cost Cycle）
  - 多源最短路算法：稀疏图和稠密图
- 最小生成树问题（Minimum Spanning Tree）
- 贪心算法
  - Prim算法（小树长大）
  - Kruskal算法（森林合并成树）

### 排序
- 拓扑排序：获得一个拓扑序的过程
- AOV（Activity On Vertex）网络
- DAG有向无环图（Directed Acyclic Graph）：有合理的拓扑序的AOV
- 关键路径问题
  - AOE（Activity On Edge）网络：由绝对不允许延误的活动组成的路径
- 冒泡排序
- 插入排序
- 时间复杂度下界
- 逆序对（Inversion）
- 希尔排序：缩小增量排序
  - Hibbard增量序列：相邻元素互质
  - Sedgewick增量序列
- 堆排序（Heap Sort）
  - 选择排序
- 归并排序：有序子列的归并
  - 递归算法（分而治之）、非递归算法
- 快速排序：选主元、子集划分、小规模数据处理不递归（Cutoff阈值）
- 表排序
  - 间接排序：定义一个指针数组作为表（table）
  - 物理排序：N个数字的排列有若干个独立的环组成
- 桶排序
- 基数排序
  - 次位优先（Least Significant Digit）优于主位优先（Most Significant Digit）

### 串的模式匹配
- 串：线性存储的一组数据
- C库函数：strstr
- KMP算法（Knuth、Morris、Pratt）
- BuildMatch实现

### 散列查找
- 哈希表（散列表）
- 散列（Hashing）、关键字（Key）、装填因子（Loading Factor）
- 散列查找法：构造散列函数计算位置、解决冲突（collision）
- 散列函数：计算简单，以便提高转换速度；关键词对应的地址空间分布均匀，以尽量减少冲突
  - 直接定址法
  - 除留余数法
  - 数字分析法
  - 折叠法
  - 平方取中法
- 字符关键词的散列函数构造
  - ASCII码加和法
  - 移位法
- 冲突处理办法之开放定址法（Open Addressing）：一旦产生了冲突（该地址已有其它元素），就按某种规则去寻找另一空地址
  - 线性探测法（Linear Probing）
  - 平方探测法（Quadratic Probing）：二次探测
  - 双散列探测法（Double Hashing）
  - 再散列（Rehashing）
- 冲突处理办法之分离链接法（Separate Chaining）：将相应位置上冲突的所有关键词存储在同一个单链表中
- 散列表的性能分析
  - 平均查找长度（ASL）用来度量散列表查找效率：成功、不成功
  - 影响产生冲突多少有三个因素：散列函数是否均匀；处理冲突的方法；散列表的装填因子α
  - 线性探测法的查找性能
  - 平方探测法和双散列探测法的查找性能
  - 分离链接法的查找性能
- 开放定址法：散列表是一个数组，存储效率高，但是随机查找散列表有“聚集”现象
- 分离链接法：散列表是顺序存储和链式存储的结合，链表部分的存储效率和查找效率都比较低，关键字删除不需要“懒惰删除”法，从而没有存储“垃圾”，但是太小的α可能导致空间浪费，大的α又将付出更多的时间代价。不均匀的链表长度导致时间效率的严重下降
- 应用：文件中单词词频统计