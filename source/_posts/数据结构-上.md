---
title: 数据结构（上）
date: 2021-06-28
updated: 2021-08-26
tags: []
categories: 算法与数据结构
mathjax: true
---

> 数据结构是指数据的存储结构，是带有结构特性的数据元素的集合。精心选择的数据结构可以带来更好的运行或者存储效率。数据结构是计算机科学与技术专业、软件工程专业甚至于其它电气信息类专业的重要专业基础课程，在408计算机学科专业基础综合考试中占有45分。我选择的课程是浙江大学数据结构[国家精品课](https://www.icourse163.org/course/ZJU-93001)，以下为所记课堂笔记第一部分，包含C/C++语言基础、线性表、栈和队列的知识总结以及所需记忆的代码，另外我在开源仓库中还保持了浙大慕课版本的[代码](https://github.com/Bezhuang/LearnCS/tree/main/%E5%90%8D%E6%A0%A1%E5%85%AC%E5%BC%80%E8%AF%BE/%E6%B5%99%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84)，可供参考。其他部分笔记详见[数据结构（中）](/数据结构-中)和[数据结构（下）](/数据结构-下)

<!--more-->

### 基本概念

#### C/C++语言基础

- 数据类型
  - 结构型 `int a[maxSize];`
  - 指针型 `int *a;`
  - 链表结点
    ```C
    typedef struct Node
    {
      int data;
      struct Node *next;
    }Node;
    ```
  - 二叉树结点
    ```C
    typedef struct BTNode
    {
      int data;
      struct BTNode *lchild;
      struct BTNode *rchild;
    }BTNode;
    ```
  - 动态申请数组空间
    ```C
    int *p;
    p=(int *)malloc(n * sizeof(int));
    ```
- 函数
  - 函数参数的引用型定义
    ```cpp
    int a=0;
    void f(int &x)
    {
      ++x;
    }
    f(a);
    ```
  - 数组作参数的引用型定义
    ```cpp
    void f(int x[][maxSize], int n){···;}
    ```

#### 算法的时间复杂度和空间复杂度

- 时间复杂度 
  - $T(n)=O(f(n)中增长最快的项的系数)$
  - 将最坏的情况作为算法时间复杂度的度量
  - $O(1)≤O(\log_{2}\left(n\right)≤O(n)≤O(n\log_{2}\left(n\right)≤O(n^2)≤O(2^n)$（常对幂指阶）
  - 取最深层循环内的语句所描述的操作为基本操作，由循环基本执行的次数为规模n，计算函数 $f(n)$
- 空间复杂度：算法在运行时所需存储空间的度量，主要考虑在算法运行过程中临时占用的存储空间大小
  - 空间复杂度 = 函数递归调用的深度

#### 数据结构基本概念

- 数据是对客观事物的符号表示
- 数据元素是数据的基本单位
- 数据对象是性质相同的数据元素的集合
- 数据结构是相互之间存在一种或多种特定关系的数据元素的集合
  - 数据的逻辑结构是对数据之间关系的描述，分为线性结构（一个数据元素的次序集合）和非线性结构（树、图）
  - 数据的存储（物理）结构是数据的逻辑结构在计算机中的表示（映像），包括数据元素的表示和关系的表示
- 数据元素之间的关系：顺序映像和非顺序映像
- 数据结构中常用储存方法：顺序存储（数组）、链式存储（指针）、索引存储 `<关键字, 地址>`、散列存储（根据结点的关键字通过散列函数直接计算出该结点的存储地址）

#### 算法的基本概念

- 算法的特性：有穷性、确定性、输入、输出、可行性
- 算法的设计目标：正确性、可读性、健壮性、高效率和低存储量需求

### 线性表

#### 线性表的基本概念

- 线性表是具有相同特性数据元素的一个有限序列，长度 $n≥0$
- 线性表只有一个表头元素，一个表尾元素，除表头表尾元素外其他元素只有一个直接前驱和一个直接后继（有序性）
- 顺序表：随机访问特性、要求占用连续的存储空间、做插入操作要移动多个元素
- 链表：不支持随机访问、结点的存储空间利用率稍低、支持存储空间的动态分配
- 头指针指向链表的第一个结点、头结点指向带头结点链表的第一个结点
- 单链表、双链表、循环单链表、循环双链表、静态链表（数据元素分量+指针分量）

#### 线性表的结构体定义

- 顺序表
  ```cpp
  typedef struct
  {
    int data[maxSize];   //考试写这两行
    int length;         //
  }Sqlist;
  ```
- 单链表
  ```cpp
  typedef struct LNode
  {
    int data;
    struct LNode *next;
  }LNode
  //构造LNode型结点
  LNode *A = (LNode*)malloc(sizeof(LNode));
  ```
- 双链表
  ```cpp
  typedef struct DLNode
  {
    int data;
    struct DLNode *prior;
    struct DLNode *next;
  }DLNode;
  ```

#### 顺序表的操作

- 插入元素
  
  - 1 ≤ i ≤ ListLength(L）
  
  ```cpp
  int ListInsert(SeqList *L,int i,ElemType *e){
    int k；
    if(L->length==MAXSIZE)/*顺序线性表已经满*/
      return ERROR;
    if（i<1 || i>L->length+1)/*当 i 不在范围内时*/
      return ERROR;
    if(i<=L->length)
    {            /*若插入数据位置不在表尾*/
      for(k=L->length-1；k>=i-1；k--)    /*将要插入位置后的数据元素向后移动一位*/
        L->data[k+1]=L->data[k];
    }
    L->data[i-1]=e;/*将新元素插入*/
    L->length++;
    return OK;
  }
  ```
  
- 删除元素
  ```cpp
  int ListDelete(SqList *L,int i,ElemType *e){
    int k;
    if (L->length==0)/*线性表为空*/
      return ERROR;
    if(i<1|| i>L->length)/*删除位置不正确*/
      return ERROR;
    *e=L->data[i-1];
    if(i<L->1ength)
    {    /*如果删除不是最后位置*/
      for（k=i；k<L->length;k++)/*将删除位置后继元素前移*/
      L->data[k-1]=L->data[k];
    }
    L->length--；
    return OK;
  }
  ```
  
- 查找元素
  ```cpp
  int findElem (Sqlist L, int e)
  {
    int i;
    for (i=0; i<L.length; ++i)
      if (e==L.data[i])
        return i;
    return -1;
  }
  ```
  
- 求指定位置元素

  ```cpp
  int getElem(Sqlist L, int p, int &e)
    if(p<0||p>L.length-1)
      return 0;
    e=L.data[p];
    return 1;
  ```

#### 单链表的操作

- 尾插法建立链表C
  ```cpp
  void createlistR(LNode *&C, int a[], int n)
  {
    LNode *s, *r;  //s指向新申请结点，r指向C的终端结点
    int i;
    C=(LNode *)malloc(sizeof(LNode));  //申请C的头结点空间
    C->next=NULL;
    r=C;
    for (i=0; i<n; ++i)
    {
      s=(LNode *)malloc(sizeof(LNode));
      s->data=a[i];
      r->next=s;
      r=r->next;
    }
    r->next=NULL;
  }
  ```

- 归并成递减的单链表

  ```cpp
  void merge (LNode *A, LNode *B, LNode *C)
  {
    LNode *p=A->next;
    LNode *q=B->next;
    LNode *s;
    C=A;
    C->next=NULL;
    free(B);
    while(p!=NULL&&q!=NULL)
    {    /*下面的if else体现了头插法*/
      if(p->data<=q->data)
      {
        s=p;p->next;
        s->next=C->next;
        C-next=s;
      }
      else
      {
        s=q;q=q->next;
        s->next=C->next;
        C->next=s;
      }
    }
    while(p!=NULL)
    {
      s=p;
      p=p->next;
      s->next=C->next;
      C->next=s;
    }
    while(q!=NULL)
    {
      s=q;
      q=q->next;
      s->next=C->next;
      C->next=s;
    }
  }
  ```

- 单链表获取元素

  - 用 e 返回表中第 i 个数据元素的值

  ```cpp
  int GetElem(LinkList L,int i,ElemType *e){
    int j=1;    /*j 为计数器*/
    LinkList p;    /*声明一节点 p*/
    p=L->next;    /*p 指向链表 L 的第一个节点*/
    while(p && j<i) 
    {     /*当 p 不为空并且计数器不等于 i 时，循环继续*/
      p=p->next； /*p 指向下一个节点*/
      ++j;
    }
    if(!p || j > i)
      return ERROR;
    *e = p->data;
    return OK;
  }
  ```

- 单链表插入元素

  ```cpp
  int ListInsert(LinkList *L,int i,ElemType e)
  {
    int j=1；
  	LinkList p,s;
  	p=*L；
  	while (p && j<i)     /*寻找第 i 个节点*/
  	{
  		p=p->next;
  		++j；
  	}
    if (!p || j>i)
    return ERROR;     /*第 i 个元素不存在*/
    s=(LinkList *) malloc (sizeof(Node));    /*生成新节点（C 标准函数）*/
    s->data=e;
    s->next=p->next;    //将 p 的后继节点赋值给 s 的后继*）
    p->next=s;       //将 s 赋值给 p 的后继
    return OK;
  }
  ```

#### 双链表的操作

- 尾插法建立双链表

  ```cpp
  void createDlistR(DLNode *&L, int a[], int n)
  {
    DLNode *s, *r;  //s指向新申请结点，r指向C的终端结点
    int i;
    L=(DLNode *)malloc(sizeof(DLNode));
    L->prior=NULL;
    L->next=NULL;
    r=L;    //和单链表一样，r始终指向终端节点，开始头节点也是尾节点
    for (i=0; i<n; ++i)
    {
      s=(DLNode *)malloc(sizeof(DLNode));
      s->data=a[i];
      r->next=s;
      s->prior=r;
      r=s;
    }
    r->next=NULL;
  }
  ```

- 双链表寻找结点

  ```cpp
  DLNoded* findNode(DLNode *C, int x)
  {
    DLNode *p=C->next;
    while(p!=NULL)
    {
      if(p->data==x)
      	break;
      p=p->next;
    }
    return p;  //如果找到，则P中内容是结点地址，如果没找到，则P中内容是NULL
  }
  ```

- 双链表插入结点

  ```cpp
  s->prior = p; 
  s->next = p->next; 
  p->next->prior = s; 
  p->next = s; 
  ```

- 双链表删除结点

  ```cpp
  p->prior->next = p->next; 
  p->next->prior = p->prior; 
  free(p)     //释放空间，不要漏掉
  ```

- 链表的逆置

  ```cpp
  ListNode* reverseList(ListNode head)
  {
    if(head == NULL || head->next == NULL)
    	return head;
    	ListNode* newhead = reverseList(head->next);   //递归到链尾
    	head->next->next = head;    //反转链表
    	head->next = NULL;    //将指针置NULL
    	return newhead;    //newhead始终指向新链表的头
  }
  ```

#### 循环链表的操作

- 逆置循环链表

  - 只交换节点中的数据成员 data，其他的前后指针不变

  ```cpp
  void Reverse () 
  { 
    LinkList * begin = _head; 
    LinkList * end = _tail; 
    while (begin != end && begin->_prev != end) 
    { 
       swap(begin->_data, end->_data); 
       begin = begin->_next; 
       end = end->_prev; 
    } 
  } 
  ```

- 删除顺序表中值在 min 和 max 之间的数

  - 对顺序表进行遍历查找介于 min 与 max 之间的数然后进行删除

  ```cpp
  void Delete(Seqlist *L,int min,int max)
  {
    int i=0,n=0;
    while(i<L->length) 
    {
  		if(L->elem[i]>=min && L->elem[i]<=max)
  			n++; 
  		else
  			L->elem[i-n]=L->elem[i];
  		i++;
  	}
    L->length -= n; 
    if(L->length==0)
    printf("the sqlist ie empty/n"); 
  } 
  ```

### 栈和队列

#### 栈和队列的基本概念

- 栈是一种只能在一端进行插入或删除操作的线性表（FILO）
  - 栈顶（Top）动态变化，栈底固定不变
- 队列为仅允许在表的一端进行插入，在表的另一端进行删除的线性表（FIFO）
  - 队头（Front）可进行删除，队尾（Rear）可进行插入

#### 栈和队列的结构体定义

- 顺序栈的定义

  ```cpp
  typedef struct
  {
    int data[maxSize];
    int top;
  } SqStack;
  ```

- 链栈结点的定义

  ```cpp
  typedef struct LNode
  {
    int data;
    struct LNode *next;
  }  LNode;
  ```

- 顺序队列的定义

  ```cpp
  typedef struct
  {
    int data[maxSize];
    int front;
    int rear;
  } SqQueue;
  ```

- 链队结点的定义

  ```cpp
  typedef struct QNode
  {
    int data;
    struct QNode *next;
  } QNode;
  ```

- 链队类型的定义

  ```cpp
  typedef struct
  {
    QNode *front;
    QNode *rear;
  } LiQueue;
  ```

#### 顺序栈

- 栈空状态：`st.top==-1`

- 栈满状态：`st.top==maxSize-1`

- 非法状态：栈满后继续入站上溢，栈空继续出栈下溢

- 定义一个栈并初始化：`int stack[maxSize]; int top==-1`

- 进栈：先移动指针再进栈

  - `stack[++top]=x`;

  ```cpp
  int push(SqStack &st,int x)
  {
    if(st.top==maxSize-1)
      return 0;
    ++(st.top);
    st.data[st.top]=x;
    return 1;
  }
  ```

- 出栈：先取出元素，再移动指针

  - `x=stack[top--];`

  ```cpp
  int pop(SqStack &st,int &x)
  {
    if(st.stop==-1)
      return 0;    //栈空不能出栈
    x = st.data[st.top];
    --(st.top);
    return 1;
  }
  ```

#### 链栈

- 栈空状态：`lst->next==NULL`
- 不存在栈满状态
- 进栈：头插法建立链表中的插入操作
  - `p->next=lst->next; lst->next=p;`
- 出栈：单链表的删除操作，出栈元素保存在 x 中
  - `p-lst->next; x=p->data; lst->next=p->next; free(p);`

#### 循环队列

- 解决假溢出：`front=(front+1)%maxSize`

- 队空状态：`qu.rear==qu.front`

- 队满状态：`(qu.rear+1)%maxSize==qu.front`

- 初始化队列：队首和队尾指针重合，并且指向0

  - `qu.front=qu.rear=0;`

- 进队算法

  ```cpp
  int enQueue(SqQueue qu)
  {
    if((qu.rear+1)%maxSize==qu.front)
      return 0
    qu.rear=(qu.rear+1)%maxSize;    //先移动指针
    qu.data[qu.rear]=x;    //再存入元素
    return 1;
  }
  ```

- 出队算法

  ```cpp
  int denQueue(SqQueue &qu, int &x)
  {
    if(qu.rear==qu.front)
      return 0;
    qu.front=((qu.front+1)%maxSize)    //先移动指针
    x=qu.data[qu.front];
    return 1;
  }
  ```

#### 链队（尽量避免使用）

- 队空状态：`lqu->rear==NULL` 或者 `lqu->front==NULL`

- 不存在队满状态

- 初始化链队

  ```cpp
  void initQueue(LiQueue *&lqu)
  {
    lqu=(LiQueue*)malloc(sizeof(LiQueue));
    lqu->front=lqu->rear=NULL;
  }
  ```

- 进队操作：`lqu->rear->next=p;  lqu->rear=p;`

- 出队操作：`p=lqu->front; lqu->front=p->next; x=p->data; free(p);`

#### 用队列实现栈

- 入栈：push(x)，除栈顶元素：pop() -- 移，获取栈顶元素：top() ，返回栈是否为空：empty()

  ```cpp
  // Push element x onto stack.
  void push(int x)
  {
    q1.push(x);
  }
  // Removes the element on top of the stack and returns that
  int pop()
  {
    int length1 =  q1size();
    for(int i-0; i< length1- 1; i++)
    {
      q2.push(q1.front());
      q1. pop();
    }
    data= q1.front()
  	int length2= q2size():
    for(int j=0;j< length2; j++)
    {
      q1.push(q2.front());
      q2.pop();
    }
    return data;
  }
  // Get the top element. *
  int top()
  	int length1 = q1.size();
  	int data;
  	for (int i=0; i< length1- 1; i++)
    {
      q2.push(q1.front());
      q1.pop();
    }
  	data= q1.front();
  	return data;
  }
  // Returns whether the stack isempty
  bool empty()
  {
    if(q1.empty()&&q2.empty())
      return true;
    else
  		return false;
  }
  ```

### 串

#### 串数据类型的定义

- 串是限定了元素为字符的线性表，`char str[]="abcdef";`

- 空格串不是空串

- 串赋值：对数组中的每个元素进行逐一赋值操作

  - `strassign(str,"cur input");`

- 取串长度

  - `return str.length;`

- 串比较操作

  ```cpp
  int strcompare(Str s1, Str s2)
  {
    for(int i=0;i<s1.length&&i<s2.length;++i)
    	if(s1.ch[i]!=s2.ch[i])
        return s1.ch[i]-s2.ch[i];
    return s1.length - s2.length;
  }
  ```

#### 串的模式匹配算法

- KMP 算法

  ```cpp
  void getnext(str substr, int next[])
  {
    int i=1, j=0;
  	next[1]=0;
  	while (i<substr.length)
    {
      if (j==0||substr.ch[i]==substr.ch[j])
      {
        ++i, ++j;
        next[i]=j;
      }
      else
        j=next[j];
    }
  }
  int KMP (Str str, Str substr, int next[])
  { 
    int i=j=1;
    while(i<=str.length&&j<=substr.length)
    { 
      if (j==0||str.ch[i]==substr.ch[j])
        ++i, ++j;
      else
        j=next[ j];
      if (j>substr.length) 
        return i-substr.length;
      else
        return 0;
    }
  }
  ```

  
