---
title: 线性表的顺序存储原理及实现
date: 2022-06-24
tags: []
categories: 算法与数据结构
mathjax: true
references:
  - title: 2023 王道数据结构
    url: https://www.jd.com/chanpin/148068.html
---

> 线性表是由 n（n $\geq$ 0）个相同类型的元素组成的有序集合。$L =\left( a_{1},a_{2},\ldots ,a_{i-1},a_{i},a_{i+1},\ldots ,a_{n}\right)$。线性表中元素个数 n 称为线性表的长度，当 $n = 0$ 时，为空表。$a_{1}$ 是唯一的“第一个”数据元素，$a_{n}$ 是唯一的“最后一个”数据元素，$a_{i-1}$ 是 $a_{i}$ 的直接前驱，$a_{i+1}$ 是 $a_{i}$ 的直接后驱。

<!--more-->

### 一、线性表的特点

1.  表中元素的个数是有限的。
2.  表中元素的数据类型都相同，意味着每一个元素占用相同大小的空间。
3.  表中元素具有逻辑上的顺序性，在序列中各元素排序有其先后顺序。

### 二、线性表的顺序表示

逻辑上相邻的两个元素在物理位置上也相邻。

```cpp
#define MaxSize 50;    //定义线性表的长度
typedef struct {
  	ElemType data[MaxSize];  //顺序表的元素
  	int len;      //顺序表的当前长度
}SqList;      //顺序表的类型定义
```

#### 优点

1.  可以随机存取（根据表头元素地址和元素序号）表中任意一个元素。
2.  存储密度高，每个结点只存储数据元素。

#### 缺点

1.  插入和删除操作需要移动大量元素。
2.  线性表变化较大时，难以确定存储空间的容量。
3.  存储分配需要一整段连续的存储空间，不够灵活。

### 三、插入操作

1.   最好情况：在表尾插入元素，不需要移动元素，时间复杂度为 $O(1)$。
2.   最坏情况：在表头插入元素，所有元素依次后移，时间复杂度为 $O(n$)。
3.   平均情况：在插入位置概率均等的情况下，平均移动元素的次数为 $n/2$，复杂度为 $O(n)$。

```cpp
//判断插入位置 i 是否合法（满足 1 <= i <= len+1）
//判断存储空间是否已满（插入 x 后是否会超出数组长度）
for (int j = L.len; j >= i; j--)  //将最后一个元素到第 i 个元素依次后移一位
  	L.data[j] = L.data[j - 1];
L.data[i - 1] = x;    //空出位置 i 放入元素 x
L.len++;    //线性表长度 + 1
```

### 四、删除操作

1.   最好情况：删除表尾元素，不需要移动元素，时间复杂度为 $O(1)$。
2.   最坏情况：删除表头元素，之后的所有元素依次前移，时间复杂度为 $O(n)$。
3.   平均情况：在删除位置概率均等的情况下，平均移动元素的次数为 $(n-1)/2$，时间复杂度为 $O(n)$。

```cpp
//判断删除位置 i 是否合法（满足 1 <= i <= len）
//插入和删除时，i 的合法范围是不一样的
e = L.data[i - 1];    //将被删除的元素赋值给 e
for (int j = i; j < L.len; j++)
  	L.data[j - 1] = L.data[j];  //将删除后的元素依次前移
L.len--;    //线性表长度 - 1
```

### 五、动态分配

C 语言的初始动态分配语句：

```c
L.data = (ElemType *)malloc(sizeof(ElemType) * InitSize);
```

C++ 的初始动态分配语句：

```cpp
L.data = new ElemType[InitSize];
```

动态分配数组的类型定义：

```cpp
#define MaxSize 100;    //定义线性表的长度
typedef struct {
  	ElemType *data;  //指示动态分配数组的指针
  	int MaxSize, length;      //数组的当前容量和最大个数
}SeqList;     
```

