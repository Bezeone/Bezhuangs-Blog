---
title: 计算机组成原理（上）
date: 2021-07-14
updated: 2021-08-15
tags: []
categories: 计算机专业
references:
  - title: 计算机组成原理重点总结
    url: https://blog.csdn.net/weixin_47135547/article/details/107566603
---

> 计算机组成原理是计算机专业本科教学中的重要课程，它可以帮助我们系统地理解计算机硬件系统的组织结构和工作原理、掌握计算机硬件系统的基本分析与设计方法以及建立计算机系统的整体概念，为进一步学习计算机设计实践课程、培养系统开发、调试以及设计创新能力奠定良好的基础。计组是考研的最重最难点，在408计算机学科专业基础综合考试中占有45分。我选择的课程是哈工大的[国家精品课](https://www.icourse163.org/course/hit-309001)，配合天勤高分笔记，以下为所记课堂笔记上半部分，包含计算机系统概论、数据的表示和运算、存储器和指令系统的知识点，可供参考。下半部分笔记请访问[计算机组成原理（下）](/计算机组成原理-下)

<!--more-->

### 计算机系统概述

#### 计算机系统的多层次结构

- 硬件：
  1. 微程序机器层M0（微指令系统），由硬件直接执行微指令
  2. 传统机器M1（机器语言机器），用微程序解释机器指令
- 软件：
  1. 虚拟机器M2（操作系统机器），用机器语言解释操作系统
  2. 汇编语言M3（汇编语言机器），用汇编程序翻译成机器语言程序
  3. 虚拟机器M4（高级语言机器），用编译程序翻译成汇编语言程序

#### 冯·诺依曼机

- 基本工作方式：控制流驱动方式
- 最根本的特征：采用存储程序原理，即按地址访问并顺序执行指令
- 指令和数据均以二进制形式存放在存储器中
- CPU区分依据是：指令周期的不同阶段
- 冯·诺依曼计算机：以运算器为中心
- 现代的计算器：以存储器为中心
- 5大部件：存储器、运算器、控制器、输入设备、输出设备（适配器）
- 三大部分：CPU（运算器、控制器）、I/O设备（输入设备、输出设备）、主存储器

- 哈佛结构：将指令和数据放在两个独立的存储器，允许在一个机器周期内同时获得指令和操作数，提高了执行速度

#### 计算机性能指标

- 机器字长：
  - CPU一次能处理数据的位数，通常与CPU的寄存器位数有关，字长越长，精度越高
  - 机器的字长也会影响机器的运算速度：字长较短，运算位数多，可能需要多次运算才能完成
  - 对硬件造价有影响：直接影响ALU、数据总线以及存储字长的位数

- 存储容量：主存容量、辅存容量


- 运算速度：

  - 吞吐量和响应时间
  - 主频和CPU时钟周期
  - CPI：执行一条指令所需的时钟周期数
  - CPU执行时间：指运行一个程序所花费的时间。取决于：主频、CPI、指令条数
  - MIPS：每秒执行多少百万条指令
  - MFLOPS：每秒执行多少百万次浮点运算（标志系统性能最有用参数）
  - GFLOPS：每秒执行多少十亿次浮点运算
  - TFLOPS：每秒执行多少万亿次浮点运算

### 数据的表示和运算

#### 汉字的编码

- 输入码（外码）：区位码、国际码、拼音码、电报码、表形码等
- 内码：0、1（机器码）
- 输出码：汉字字形码
- 汉字编码包括汉字的输入编码、汉字内码、汉字字形。用两个字节表示一个汉字，每个字节用七位码。区位码是4位十进制数，前2位是区码，后2位是位码
- 国标码是将十进制的区位码转换为十六进制后，再在每个字节上加上20H。为了方便计算机区分中文字符和英文字符，将国标码两个字节的最高位都改为“1”，这就是汉字内码（十六进制）

#### 字符串的存放

- 小端模式：按先存储低位字节、后存储高位字节的顺序存放字符串的内容
- 大端模式：按先存储高位字节、后存储低位字节的顺序存放字符串的内容

#### 校验码

- 奇偶校验码：只能检出一位错误，不能确定出错的位置；只能检验处奇数位错误，不能检测出偶数位错误。
  - 奇校验码：整个校验码中“1”的个数为奇数。
  - 偶校验码：整个校验码中“1”的个数为偶数。
- 海明（汉明）检验码：可检出错位位置
- 循环冗余校验（CRC）码：可检出错误位置（通过除法运算）

#### 原码、反码、补码、移码

- 原码、补码、反码三种机器数的最高位均是符号位
- 当真值为正时，原码、补码、反码的表示形式均相同，即符号位用“0”表示，数值部分与真值相同
- 当真值为负时，原码、补码、反码的表示形式不同，但其符号位都用“1”表示，而数值部分补码是原码的“求反加1”，反码是原码的“每位求反”。
- 同一个真值的移码和补码仅差一个符号位。
- 4、不同机器数表示±0时，其形式不同。
- [+0]原≠[-0]原， [+0]反≠[-0]反，[+0]补=[-0]补，[+0]移=[-0]移
- 当机器字长确定后，补码比原码、反码能多表示一个负数
- 移码只能表示整数，用它表示浮点数的阶码时，能方便地判断阶码的大小

#### 补码定点数的加/减运算

- 基本公式：（将符号位和数值部分一起参加运算，并且将符号位产生的进位自然丢掉即可）
- 加法：[A]补+[B]补=[A+B]补
- 减法：[A-B]补=[A]补+[-B]补（[-B]补由[B]补连同符号位在内，每位取反，末尾加1）

#### 溢出判断

- 用一位符号判断溢出：实际参加操作的两个数符号相同，结果又与原操作数的符号不同，即为溢出
- 用两位符号位判断溢出：当2位符号位不同时，表示溢出，否则，无溢出。不论是否发生溢出，高位（第1位）符号永远代表真正的符号。（变形补码，运算时多一位）
- 01正溢出（上溢）；10负溢出（下溢）
- 采用一位符号位根据数据位的进位情况判断溢出。如果符号位的进位与最高数位的进位不同，则表示结果溢出

#### 浮点数的加/减运算

- 对阶：两个数的小数点位置对齐（使阶码相等），两个数的阶码相减求阶差，使小阶的尾数向右移位，每右移一位，阶码加1
- 尾数求和：将对阶后的两个尾数按定点加（减）运算规则进行运算
- 规格化：补码规格化形式为[S]补 00.1××××；[S]补 11.0××××
  - 左规：尾数出现00.0××××或11.1××××时，需左规。尾数左移一位，阶码减1
  - 右规：尾数出现01.××××或10.××××时，表示尾数溢出，但在浮点运算中不算溢出，可通过右规处理。尾数右移一位，阶码加1
- 舍入：在对阶和右规的过程中，可能会将尾数的低位丢失，引起误差，影响精度，用舍入法来提高尾数的精度
  - “0舍1入”法：被移去的最高位数值位为0，则舍去；被移去的最高数值位为1，则在尾数的末位加1。又溢出时，再右规……
  - “恒置1”法：不论丢掉的最高数位是“1”还是“0”，都使尾数末位恒置“1”。
  - 两种方法同样都有使尾数变大和变小两种可能
- 溢出判断（是否溢出由阶码的符号决定）
  - 上溢：阶码[j]补=01，×××，作溢出处理
  - 下溢：阶码[j]补=10，×××，按机器零处理

#### 浮点数的表示范围

- 上溢：当浮点数阶码大于最大阶码时，上溢，机器停止运算，进行中断溢出处理。

- 下溢：当浮点数阶码小于最小阶码时，下溢，溢出的数绝对值很小，通常将位数各位强制为0，按机器零处理，机器可以继续运行。

#### 8位二进制整数范围

- 原码、反码：-127—+127
- 补码、移码：-128—+127

#### 标准IEEE 754标准

- 现代计算机中，浮点数一般采用IEEE制定的国际标准：
- 常用的浮点数有三种：阶码用移码表示
- 短实数、长实数、临时实数的偏移量用十六进制数表示分别为7FH（127）、3FFH、3FFFH

- 尾数部分通常是用原码、规格化表示，即非“0”的有效位最高位总是“1”，但在IEEE标准中，有效位呈如下形式：1▲ff…ffff
- 其中▲表示假想的二进制小数点。在实际表示中，对短实数和长实数，这个整数位的1省略，称隐藏位；对于临时实数不采用隐藏位方案

### 存储器层次结构

#### 存储器的层次化结构

- 存储器主要性能指标：速度、容量、每位价格（位价）
- 一般来说，速度越高，位价越高；容量越大，位价越低；容量越大，速度越低。

- 
  层次结构主要体现在缓存-主存和主存-辅存这两个层次上。

  - 缓存-主存：主要解决CPU和主存速度不匹配问题（由硬件自动完成）数据调动对任何程序员透明。
  - 主存-辅存：主要解决存储系统的容量问题（由硬件和操作系统共同完成）数据调动对应用程序员透明

#### 动态RAM的刷新

- 一般取2ms，对动态RAM的全部基本单元电路必作一次刷新，称为刷新周期，又称再生周期。刷新的单位是行，仅需要行地址。
- 集中刷新：在规定的一个刷新周期内，对全部存储单元集中一段时间逐行进行刷新，此刻必须停止读/写操作，称“死时间”或“死区”。（全部一起刷）
- 分散刷新：对每行存储单元的刷新分到每个存取周期内完成。优点：没有死区。缺点：存取周期加长，整个系统速度降低。（一个个刷）
- 异步刷新：是前两种方式的结合，既缩短“死时间”，又充分利用最大刷新时间间隔为2ms的特点。（一行行刷）
- 一行行刷的平均刷新时间
  - 行数 = 芯片容量 / 每行存储单元个数
  - 平均刷新时间 = 间隔最长 / 行数

##### 存储容量的扩展

- 位扩展
  - 增加存储字长
  - 例如：2片1K4位的存储芯片可组成1K8位的存储器。
  - 注意：其中一片的数据线作为高4位D7-D4，另一片的数据线作为低4位D3-D0。
- 字扩展
  - 增加存储器字的数量
  - 例如：2片1K8位的存储芯片可组成一个2K8位的存储器。
  - 注意：两片都连地址线A0-A9。（从低位连起）
- 字、位扩展
  - 既增加存储字的数量又增加存储字长。

#### 双口RAM和多模块存储器

- 为了提高CPU访问存储器的速度，可以采用双端口存储器（空间并行）、多模块存储器（时间并行）等技术，都属于并行技术。

#### 多模块存储器

- 为了提高访存速度（CPU速度比存储器快，同时从存储器中取出n条指令，可以充分利用CPU资源，提高运行速度）
- 单体多字系统
  - 在一个存取周期内，从同一地址取出n条指令，然后逐条将指令送至CPU执行，即每隔1/n存取周期，主存向CPU送一条指令，增大了存储器的带宽，提高了存储器的工作速度。
  - 例如：从同一地址取出4条指令，为单体四字结构，每字W位。按地址在一个存取周期内可读出4*W位的指令或数据，使主存带宽提高到4倍。
  - 缺点：指令和数据在主存内必须是连续存放的，一旦遇到转移指令，或者操作数不能连续存放，这种方法的效果就不明显。
- 多体并行系统
- 采用多提模块组成的存储器。每个模块可以并行工作，也可以交叉工作。
  - 低位交叉编址
    - 程序连续存放在相邻体中（交叉存储）。低位地址表示体号，高位地址表示体内地址。
      地址的低n为片选。
    - 优点：相邻地址单元的数据放在不同组，各组可以并行工作，能较好提高存储器的带宽。
    - 缺点：某一组出现故障，会影响整个存储器的正常工作。
  - 高位交叉编址
    - 按体内地址顺序存放（顺序存储）。高位地址表示体号，低位地址表示体内地址。
    - 地址的高n位片选。
    - 优点： 某一组的故障不影响其他组，且容易通过添加模块来扩充容量。
    - 缺点：相邻地址单元的数据放在同一组存储单元，各组间串行工作，不利于提升存储器的带宽。

#### Cache中主存块之间的映射方式

- 由主存地址映射到Cache地址称为地址映射
- 直接映射
  - 主存数据只能装入Cache中的唯一位置。若这个位置已有内容，则产生块冲突，原来的块将无条件地被替换出去（无需使用替换算法）。
  - 优点：实现简单，只需利用主存地址的某些位直接判断，即可确定所需字块是否在缓存中。
  - 缺点：不够灵活，降低命中率。
- 全相联映射
  - 允许主存中每一字块映射到Cache中的任何一块位置上。可以从已被占满的Cache中替换出任一旧字块。
  - 通常采用昂贵的“按内容寻址”的相联存储器来完成。
  - 优点：灵活，命中率高，缩小了块冲突率，空间利用率高。
  - 缺点：地址变换速度慢，实现成本高
- 组相联映射（上述两种映射的折中）
  - 将Cache空间分成大小相同的组，主存的一个数据块可以装入到一组内的任何一个位置（组间采取直接映射，组内采取全相联映射）。

#### Cache中主存块的替换算法

- 先进先出（First-In-First-Out，FIFO）算法
- 近期最少使用（Least Recently Used，LRU）算法
- 随机法

#### 磁盘存储器

- 磁盘寻址的最小单位是扇区。
- 道密度：沿磁盘半径方向单位长度的磁道数。
- 位密度：单位长度磁道上记录二进制的位数。
- 平均寻道时间：从一个磁道转移到另一个磁道的平均时间。（全部寻道时间的一半）
- 平均等待时间：旋转等待的平均时间。（转一周时间的一半）
- 一扇区的传送时间：T=1 / (转速×扇区数)
- 存取一个扇区的时间：T=每个扇区位数 / (转速×扇区数)
- 平均存取时间=平均寻道时间 + 平均等待时间 + 传输时间
- 每个记录面的磁道数：K=[(外直径-内直径)/2]*磁道密度
- 盘组格式化容量：C = 记录面数 * K * 每个扇区字节数 * 扇区数
- 盘组非格式化容量：CN = 记录面数 * K * 最内圈磁道周长 * 内层位密度
- WE 为写允许信号：低电平0为写，高电平1为读
- CS为片选信号：低电平0有效
- 借位/进位C：1=结果的最高位发生了进位，0=结果的最高位未发生进位
- 溢出标志位V：1=溢出，0=没有溢出

### 指令系统

#### 指令的寻址方式

- 寻址模式是大多数中央处理器 （CPU）设计中的指令集架构的一个方面
- 在给定指令集架构中定义的各种寻址模式决定了该架构中的机器语言指令如何识别每个指令的操作数
- 寻址模式指定如何通过使用寄存器中保存的信息和/或机器指令中包含的常量或其他地方包含的常量来计算操作数的有效存储器地址。

#### CISC和RISE

- 从硬件角度来看CISC处理的是不等长指令集，它必须对不等长指令进行分割，因此在执行单一指令的时候需要进行较多的处理工作。而RISC执行的是等长精简指令集，CPU在执行指令的时候速度较快且性能稳定。因此在并行处理方面RISC明显优于CISC，RISC可同时执行多条指令，它可将一条指令分割成若干个进程或线程，交由多个处理器同时执行。由于RISC执行的是精简指令集，所以它的制造工艺简单且成本低廉。
- 从软件角度来看，CISC运行的则是我们所熟识的DOS、Windows操作系统。而且它拥有大量的应用程序。因为全世界有65%以上的软件厂商都理为基于CISC体系结构的PC及其兼容机服务的，象赫赫有名的Microsoft就是其中的一家。而RISC在此方面却显得有些势单力薄。虽然在RISC上也可运行DOS、Windows，但是需要一个翻译过程，所以运行速度要慢许多。

#### 地址指令操作数物理位置的三种形式

- 寄存器——寄存器型（RR型）；
- 寄存器——存储器型指令（RS型）；
- 存储器——存储器型（SS型）。