---
title: 操作系统（上）
date: 2021-06-12
updated: 2021-09-20
tags: [Operating System]
categories: 计算机专业
---

>  操作系统（OS）是管理和控制计算机硬件与软件资源，是计算机上直接运行的最基本的系统软件，任何其他软件都必须在操作系统的支持下才能运行。操作系统是用户和计算机的接口，同时也是计算机硬件和其他软件的接口。操作系统的功能包括管理计算机系统的硬件、软件及数据资源，控制程序运行，提供人机交互界面，为其它应用软件提供支持等。我选择的课程是苏州大学的[国家精品课](https://www.icourse163.org/course/SUDA-1001752241)和汤子瀛版教材，以下为所记课堂笔记上半部分，包含计算机操作系统概述、处理器管理的知识点，可供参考。下半部分笔记请访问[操作系统（下）](/操作系统-下)

<!--more-->

###  操作系统概述

#### 操作系统基本概念

- 冯诺依曼模型：运算器、存储器、控制器、输入设备和输出设备
- 引入操作系统的目的：提供一个计算机用户与计算机硬件系统之间的接口、有效的控制和管理计算机系统中的各种硬件和软件资源、合理地组织计算机系统的工作流程
- 操作系统是计算机系统的资源管理程序
- 操作系统的核心是控制和协调进程的运行，解决进程之间的通信
- 操作系统的发展：无操作系统阶段 -> 单道批处理系统 -> 多道批处理系统

#### 操作系统的特征

- 并行性：2个或多个事件在同一时刻发生
- 并发性：2个或多个事件在同一时间间隔内发生
- 并发和共享是操作系统的2个最基本的特征，二者之间互为存在条件
- 资源共享方式：互斥共享、同时访问
- 虚拟是指把一个物理上的实体变为若干个逻辑上的对应物
- 异步性

#### 操作系统的功能和服务

- 处理器管理：进程控制、进程同步、进程通信、进程调度
- 存储器管理：内存分配、内存保护、内存扩充
- 设备管理：设备分配、设备传输控制、设备独立性
- 文件管理：文件存储空间的管理、目录管理、文件操作管理、文件保护
- 用户接口：命令接口、程序接口、图形接口
  - 联机命令接口又称交互式命令结构
  - 脱机命令接口又称批处理命令接口
- 操作系统3种基本类型：批处理操作系统、分时操作系统、实时操作系统
- 其他操作系统：嵌入式操作系统、集群系统、网络操作系统、分布式操作系统

#### 操作系统的运行环境

- 处理器的执行状态分为核心态与用户态
  - 核心态是操作系统管理程序执行时机器所处的状态
  - 用户态是用户程序执行时机器所处的状态
- 特权指令是只能由操作系统内核部分使用，不允许用户直接使用的指令，如I/O指令、设置中断屏蔽指令、清内存指令、存储保护指令和设置时钟指令
- 内核的指令操作工作在核心态
  - 时钟管理
  - 中断机制
  - 原语
  - 系统控制的数据结构及处理
- 异常，也称内中断，是由错误引起的
- 通常异常会引起中断，而中断未必是由异常引起的
- 系统调用（API）：进程控制、文件系统控制、系统控制、内存管理、网络管理、socket 管控、制用户管理以及进程间通信

#### 操作系统的体系结构

- 操作系统的体系结构主要包括模块组合结构、层次结构和微内核结构
- 模块组合结构
  - 接口简单直接，系统的效率相对较高
  - 系统结构不清晰、可扩展性差、可适应性差
- 层次结构
  - 按功能的调用次序排列成若干层
  - 组织和依赖关系清晰明了，可读性、可适应性及可靠性都得到了增强
  - 通常要将为进程提供服务的系统调用模块放在系统的内层。
- 微内核结构
  - 客户服务器模式（C/S 模式）
  - 每个服务进程运行在独立的用户进程中，可靠性好，灵活性好，便于维护
  - 适合分布式处理的计算环境
  - 效率不高，尤其是通信频繁的系统

### 进程管理

#### 进程

- 在计算机操作系统中，进程是资源分配的基本单位，也是独立运行的基本单位
  - 程序顺序执行时的特征：顺序性，封闭性，可再现性
  - 程序的并发执行的特征：间断性，失去封闭性，不可再现性
- 程序并发执行且其结果具有可再现性的条件（Bernstein 条件）
  - R(p1) ∩ W(p2) = ∅
  - R(p2) ∩ W(p1) = ∅
  - W(p1) ∩ W(p2) = ∅
- 进程的特征：动态性、并发性、独立性、异步性、结构特征（程序段、数据段和进程控制块）
- 进程和程序的关系
  - 进程和程序的关系程序是静止的
  - 进程是暂时的，程序是永久的
  - 进程的组成包括程序段、数据块和进程控制块（Process Control Block）
  - 通过多次执行，一个程序可以产生多个不同的进程，通过调用关系，一个进程可以执行多个程序
  - 进程可创建其他进程，而程序不能形成新的程序
- 由程序段、相关数据段和PCB三部分构成的是进程映像，也叫进程实体
  - 映像是静态的，进程是动态的，进程是进程实体的运行过程
- 进程和作业的区别
  - 作业是用户需要计算机完成某项任务而要求计算机所做的工作的集合
  - 作业提交、作业收容、作业执行、作业完成
  - 进程是已提交完毕的作业的执行过程，是资源分配的基本单位
  - 作业是用户向计算机提交任务的任务实体，而进程是完成用户任务的执行实体
  - 这个作业可由多个进程组成，而必须至少由一个进程组成，但一个进程不能构成多个作业
- 进程的组成
  - 进程控制块（PCB）：标识进程的存在，刻画执行瞬间特征的数据机构
  - 其他组成部分：程序段、数据段、进程标识符（PID）、进程当前状态、进程队列指针、程序和数据地址，进程优先级、CPU 现场保护区、通信信息、家族联系、占有资源清单
-  PCB 是进程存在的唯一标志
  - PCB 存在是为了保证程序的并发执行
  - 创建进程实质上是创建进程的 PCB，而撤销进程实质上是撤销进程的 PCB
  - 系统总是通过 PCB 对进程进行控制的

- 进程的5种基本状态：就续状态、执行状态、阻塞状态、创建状态、结束状态
  - 执行状态只能由就绪状态转换，而无法由阻塞状态直接转换
  - 不能从就绪状态变为阻塞状态
  - 进程状态是唯一的
- 进程的创建
  - 进程创建是通过创建原语实现的
  - 申请一个空闲 PCB，并指定唯一的 PID -> 分配必要的资源 -> 将新进程的PCB初始化 -> 插入到就绪队列
  - 导致进程创建的事件：用户登录、作业调度和请求服务
- 撤销一个进程：撤销原语
  - 找到被撤销进程的PCB -> 停止该进程的执行 -> 回收被撤销进程所占用的资源 -> 回收PCB
- 进程的阻塞与唤醒：两条低级进程通讯原语
  - 阻塞原语（P 原语）的功能是将进行进程由执行状态转为阻塞状态
  - 唤醒原语（V 原语）的功能是将进程由阻塞状态变为就绪状态
  - 一个进程由执行状态变为阻塞状态，是由这个进程自己调用阻塞原语去完成的
  - 进程由阻塞状态变为就绪状态，是由另一个发现者进程调用唤醒原语去实现的。一般这个发现者进程与被唤醒进程是合作的并发进程
- 调度是决定将系统资源分配给哪个进程，进程切换是实际分配系统资源
  - 进程切换一定会产生中断，但处理器模式切换不一定产生进程切换
- 进程的互斥与同步就是一种进程间的通信方式
  - 高级进程通信方式：共享存储器系、消息传递系统、管道（共享文件）通信系统

#### 线程

- 线程是进程内一个相对独立的可调度的执行单元
  - 内核级线程依赖于内核，一个内核级线程由于 I/O 操作而阻塞时不会影响其他线程的运行
  - 用户级线程不依赖于操作系统核心，由于操作系统内核不了解用户线程的存在，当一个线程阻塞时，整个进程必须等待
- 进程与线程
  - 线程谁独立调度的基本单位，进程是拥有资源的基本单位
  - 线程不拥有资源，但线程可以访问其隶属进程的系统资源
  - 进程之间可以并发执行，同一进程内的多个线程之间也可以并发执行
  - 多线程之间的同步与通信非常容易实现
- 多线程模型：多对一模型，一对一模型，多对多模型（将多个用户级线程映射到多个内核级线程）

#### 处理器的三级调度

- 高级调度（作业调度）：从外存上处于后备状态的作业中选择一个或多个，给他们分配内存等必要资源并建立相应的进程，以便该作业具有获得竞争处理器的权利
  - 作业调度每次要接纳多少个作业进入内存取决于多道程序的并发程度
  - 多道程序的并发程度应根据系统的规模和运算速度来决定
  - 应将哪些作业从外存调入内存取决于所采取的调度算法
- 中级调度（交换调度）：按照给定的原则和策略，将处于外存对换区中具备运行条件的进程调入内存，并将其状态修改为就绪状态，挂在就绪队列上等待
- 低级调度（进程调度）：按照某种策略和方法，从就绪队列中选取一个进程，将处理器先分配给他
  - 进程调度的运行频率很高
  - 作业调度的结果是为作业创造进程，而进程调度的结果是进程被执行
- 衡量调度算法的性能： CPU利用率、系统吞吐量、响应时间、周转时间
  - 作业的周转时间 = 作业的完成时间 - 作业的提交时间
  - 平均周转时间：多个作业周转时间的平均值
  - 带权周转时间是作业周转时间与运行时间的比

#### 进程调度

- 处理器分配的任务由进程调度程序完成
- 进程调度的功能：记录系统中所有进程的有关情况以及状态特征，选择获得处理器的进程和处理器分配
- 引起进程调度的原因
  - 当前运行进程运行结束
  - 当前运行进程因某种原因从运行状态进入阻塞状态
  - 执行完系统调用等系统程序后返回用户进程
  - 在采用抢占调度方式的系统中，一个更高优先级的进程要求使用处理器
  - 在分时系统中分配给该进程的时间片已用完
- 不能进行进程调度的情况
  - 处理中断的过程中
  - 在操作系统内核程序临界区中
  - 其他需要完全屏蔽中断的原子操作过程中
- 进程调度的方式：抢占方式、非抢占方式

#### 常见调度算法

- 先来先服务调度算法（作业调度、进程调度）
  - FCFS：按照进程进入就绪队列的先后次序来分配处理器
- 短作业优先调度算法（作业调度、进程调度）
  - SJF：把处理器分配给最快完成的作业或进程
- 优先级调度算法（作业调度、进程调度）
  - 静态优先级是在创建进程时确定的，确定之后整个进程运行期间不再改变
  - 按进程类、作业的资源要求、用户类型和要求确定静态优先级
  - 动态优先级是指在创建进程时根据进程的特点及相关情况确定一个优先级
  - 根据进程占有CPU时间的长短和就绪进程等待CPU时间的长短确定动态优先级
  - 基于优先级的调度算法还可按调度方式的不同，分为非抢占优先级调度算法和抢占优先级调度算法
  - 在优先级相同的情况下，通常按照先来先服务或者短作业优先的顺序执行
- 时间片轮转调度算法（进程调度）
  - 分时系统必须满足系统对响应时间的要求
  - 就绪队列中的进程数与时间片的大小成反比
  - 系统的处理能力决定时间片的大小
- 高响应比优先调度算法（作业调度）
  - 响应比 = 作业响应时间 / 估计运行时间
  - 作业响应时间 = 作业等待时间 + 估计运行时间
- 多级反馈队列调度算法（作业调度）
  - 时间片轮转调度算法和优先级调度算法的综合与发展

#### 同步与互斥

- 互斥是间接相互制约关系，而同步是直接相互制约关系
- 只要是同类进程即为互斥关系，不同类进程即为同步关系
- 临界资源：同时仅允许一个进程使用的资源
  - 进入区、临界区、退出区、剩余区
  - 临界区：进程中用于访问临界资源的代码，又称临界段
  - 临界资源是必须互斥访问的资源，这种资源同时只能被一个进程所使用，但需要这种资源的进程不止一个，因此需要对使用临界资源的进程进行管理
  - 每个进程的临界区代码可以不相同

- 互斥的要求：空闲让进，忙则等待，有限等待，让权等待
- 互斥实现方法
  - 软件实现方法
  - 互斥实现的硬件方法：中断屏蔽、硬件指令
  - 硬件方法适用范围广，支持多个临界区，但不能实现让权等待

#### 信号量

- 信号量 `(s,q)` 及同步原语
  - 整型变量 s 表示系统中某类资源的数目，q 是一个初始状态为空的队列
  - 信号量的值仅能由 P 操作（wait）操作和 V 操作（signal）操作改变，操作系统利用它的状态对进程和资源进行管理
  -  P 操作相当于申请资源，V 操作相当于释放资源
- 信号量分为整型信号量和记录型信号量（资源信号量）
  - 记录型信号量添加了链表结构用于链接所有等待该资源的进程，解决忙等的问题
- 信号量可以用来实现进程互斥和描述前趋关系

#### 经典同步问题

- 生产者-消费者问题
  - P(full) / P(empty) 与 P(mutex) 的顺序不可倒，必须先对资源信号量进行 P 操作，再对互斥信号量进行 P 操作。否则会导致死锁
  - 互斥信号量就是给同类进程准备的
- 读者写者问题（许多进程共享数据区）
  - 读者不互斥，写者必须互斥
  - 读者优先，公平情况和写者优先三种不同算法
- 哲学家进餐问题
  - 最多允许4个哲学家同时进餐
  - 仅当一个哲学家左右两边的筷子同时可用时，他才可以拿起筷子
  - 将哲学家编号要求奇数号的哲学家先拿左边筷子，偶数号的哲学家先拿右边筷子
- 理发师问题
- 信号量机制问题的解题步骤分析
  - 关系分析
  - 确定临界资源
  - 整理思路
- 实现同步互斥的 P、V 操作必须成对出现，先进行 P 操作进入临界区，后进行 V 操作退出临界区
-  P、V操作要分别紧靠临界区的头尾部
- 通常用于互斥的信号量初值设为 1

#### 管程

- 管程定义了一个数据结构和能为并发进程所执行的一组操作
  - 局部于管程的数据只能被局部于管程内的过程所访问
  - 一个进程只有通过调用管程内的过程才能进入管程访问共享数据
  - 每次仅允许一个进程在管程内执行某个内部过程，即进程互斥地通过调用内部过程进入管程
- 管程的互斥访问完全由编译程序在编译时自动添加
- 为实现进程间的同步，管程还必须包含若干用于同步的设施
  - 局限于管程并仅能从管程内进行访问的若干变量，用于区别各种不同的等待原因
  - 在条件变量上进行操作的两个函数过程，wait 和 signal

#### 死锁

- 死锁的概念
  - 参死锁的进程至少有两个
  - 每个参与死锁的进程均等待资源
  - 参与死锁的进程中至少有两个进程占有资源
  - 死锁进程是系统中当前进程集合的一个子集
- 死锁产生的原因是竞争资源
  - 一个资源是否属于可剥夺资源，完全取决于资源本身的性质
- 死锁产生的必要条件
  - 互斥条件
  - 不剥夺条件
  - 请求于保持条件：可采用预先静态分配方法
  - 环路等待条件：可采用有序资源分配法
- 处理死锁的方法：鸵鸟算法、预防死锁、避免死锁、检测及解除死锁（被动）
  - 死锁预防对系统加的限制条件通常很严格，对系统的并发性会产生很大的副作用
  - 死锁避免往往在资源被分配出去之前，要计算分配之后系统是否安全
- 死锁的避免
  - 系统在进行资源分配之前，先计算资源分配的安全性（安全序列）
  - 并非所有不安全状态都是死锁状态，死锁是不安全状态的真子集
  - 银行家算法
- 死锁的检测和解除
  - 系统资源分配图（system resource allocation graph）可定义为一个二元组
  - `SRAG = (V,E)`
  - 死锁定理：不同简化顺序将得到相同的不可简化图。系统状态 S 为死锁状态的条件是当且仅当 S 状态的资源分配图是不可完全简化的
  - 死锁检测算法：available、allocation、request、临时变量（work与finish）
  - 死锁解除：剥夺资源，撤销进程，进程回退
- 进程与饿死
  - 当等待时间给进程推进和响应带来明显影响时，发生进程饥饿
  - 当饥饿到一定程度，进程所赋予的任务即使完成也不再具有实际意义时，进程被饿死
  - 活锁：在忙时等待条件下发生的饥饿
  - 饥饿和饿死与资源分配策略有关，因而可从公平性方面考虑防止饥饿与饿死

