---
title: LintCode 必会新手 50 题阶段一
date: 2020-10-28
tags: [LintCode]
categories: 算法与数据结构
---

> 在线评测平台 LintCode 整合了当前各大IT企业技术求职的热门题库，拥有2000多道常见面试题，可有效提升算法与数据结构水平，助力通过知名IT企业面试，拿到满意的Offer。新手必刷编程50题为初到Lintcode所接触到的最基础的阶梯练习，必知必会。在新手50题阶段一中考验的是对基本数据类型的掌握，以下是刷题过程中的思路和方法的记录，也包含成功通过的代码。

<!--more-->

### 37.反转一个3位整数

#### 描述

- 反转一个只有3位数的整数

#### 问题分析

- 获得个位数并将它变成百位数，获得十位数并将它变成十位数，获得百位数并将它变成个数位

#### 题解

```cpp
class Solution {
public:
    int reverseInteger(int number) {
        return number % 10 * 100 + number / 10 % 10 * 10 + number / 100;
    }
};
```

### 1.A+B问题

#### 描述

- 给出两个整数a和b，求他们的和并以整数（int）的形式返回

#### 问题分析

- 不需要从标准输入流读入数据，只需要根据`aplusb`传入的两个参数a和b，计算他们的和并返回就行

#### 题解

```cpp
class Solution {
public:
    int aplusb(int a, int b) {
        return a + b;
    }
};
```

### 1300.巴什博弈

#### 描述

- 你正在和朋友玩一个游戏：桌子上有一堆石头，每一次你们都会从中拿出1到3个石头。拿走最后一个石头的人赢得游戏
- 游戏开始时，你是先手。假设两个人都绝对理性，都会做出最优决策。给定石头的数量，判断你是否会赢得比赛
- 举例：有四个石头，那么你永远不会赢得游戏。不管拿几个，最后一个石头一定会被你的朋友拿走

#### 问题分析

- 巴什博弈：n个物品，两个人轮流从这堆物品中取物，规定每次至少取一个，最多取m个，最后取光者得胜
- 如果物品数量 n 不能被 m+1 整除，则 n=k(m+1)+x（k为自然数，0<x<m+1），那么只要先手者第一次拿走 x 个物品，剩余物品数量变为 k(m+1)，接下来无论后手者怎么拿，先手者都可以让物品数量变 k(m+1) ，k逐渐变小直到最后变为 1，此时剩余物品为 m+1，接下来无论后手者拿多少都拿不完 ，并且会使剩余物品数量小于 m+1 ，而先手者则可以直接把剩下的拿完，先手者必胜
- 如果物品数量为 k(m+1)，即 n 可被 (m+1) 整除，此时先手者就会面临上面的后手者的问题，先手者必输
- 由题可知，m=3，所以物品数量不能被4整除，即n若是4的倍数则输出False，否则输出True

#### 题解

```cpp
class Solution {
public:
    bool canWinBash(int n) {
        if(n%4 == 0)
        {
            return false;
        }
        else return true;
    }
};
```

### 764.计算圆周长和面积

#### 描述

- 给定一个整数`r`代表一个圆的半径，返回一个数组，其中数组的第一个元素代表圆的周长，数组的第二个元素代表圆的面积

#### 问题分析

- PI = 3.14
- 向量（Vector）是一个封装了动态大小数组的顺序容器（Sequence Container），是一个能够存放任意类型的动态数组
- `#include<vector>;`

#### 题解

```cpp
class Solution {
public:
    vector<double> calculate(int r) {
        vector<double>ans;
        ans.push_back(2 * 3.14 * r);
        ans.push_back(3.14 * r * r);
        return ans;
    }
};
```

