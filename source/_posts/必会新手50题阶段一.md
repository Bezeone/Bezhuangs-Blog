---
title: 必会新手 50 题之阶段一
date: 2020-10-28
tags: [LintCode]
categories: 算法与数据结构
---

> 在线评测平台 LintCode 整合了当前各大IT企业技术求职的热门题库，拥有2000多道常见面试题，可有效提升算法与数据结构水平，助力通过知名IT企业面试，拿到满意的Offer。新手必刷编程50题为初到Lintcode所接触到的最基础的阶梯练习，必知必会。在新手50题阶段一中考验的是对基本数据类型的掌握。

<!--more-->

### 37、反转一个3位整数

#### 描述

反转一个只有3位数的整数。

#### 问题分析

获得个位数并将它变成百位数，获得十位数并将它变成十位数，获得百位数并将它变成个数位。

#### 题解

```cpp
class Solution {
public:
    int reverseInteger(int number) {
        return number % 10 * 100 + number / 10 % 10 * 10 + number / 100;
    }
};
```

### 1、A+B问题

#### 描述

给出两个整数a和b，求他们的和并以整数（int）的形式返回。

#### 问题分析

不需要从标准输入流读入数据，只需要根据`aplusb`传入的两个参数a和b，计算他们的和并返回就行。

#### 题解

```cpp
class Solution {
public:
    int aplusb(int a, int b) {
        return a + b;
    }
};
```

### 1300、巴什博弈

#### 描述

你正在和朋友玩一个游戏：桌子上有一堆石头，每一次你们都会从中拿出1到3个石头。拿走最后一个石头的人赢得游戏。

游戏开始时，你是先手。假设两个人都绝对理性，都会做出最优决策。给定石头的数量，判断你是否会赢得比赛。

举例：有四个石头，那么你永远不会赢得游戏。不管拿几个，最后一个石头一定会被你的朋友拿走。

#### 问题分析

巴什博弈：n个物品，两个人轮流从这堆物品中取物，规定每次至少取一个，最多取m个，最后取光者得胜。

如果物品数量 n 不能被 m+1 整除，则 n=k(m+1)+x（k为自然数，0<x<m+1），那么只要先手者第一次拿走 x 个物品，剩余物品数量变为 k(m+1)，接下来无论后手者怎么拿，先手者都可以让物品数量变 k(m+1) ，k逐渐变小直到最后变为 1，此时剩余物品为 m+1，接下来无论后手者拿多少都拿不完 ，并且会使剩余物品数量小于 m+1 ，而先手者则可以直接把剩下的拿完，先手者必胜。

如果物品数量为 k(m+1)，即 n 可被 (m+1) 整除，此时先手者就会面临上面的后手者的问题，先手者必输。

由题可知，m=3，所以物品数量不能被4整除，即n若是4的倍数则输出False，否则输出True。

#### 题解

```cpp
class Solution {
public:
    bool canWinBash(int n) {
        if(n%4 == 0)
        {
            return false;
        }
        else return true;
    }
};
```

### 764、计算圆周长和面积

#### 描述

给定一个整数`r`代表一个圆的半径，返回一个数组，其中数组的第一个元素代表圆的周长，数组的第二个元素代表圆的面积。

#### 问题分析

PI = 3.14。

向量（Vector）是一个封装了动态大小数组的顺序容器（Sequence Container），是一个能够存放任意类型的动态数组。

`#include<vector>;`

#### 题解

```cpp
class Solution {
public:
    vector<double> calculate(int r) {
        vector<double>ans;
        ans.push_back(2 * 3.14 * r);
        ans.push_back(3.14 * r * r);
        return ans;
    }
};
```

