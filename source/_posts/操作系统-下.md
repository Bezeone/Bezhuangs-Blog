---
title: 操作系统（下）
date: 2021-09-11
updated: 2021-11-31
tags: [Linux]
references:
  - title: 操作系统笔记整理
    url: https://blog.csdn.net/SakuraA6/article/details/108810916
categories: 计算机专业
---

>  操作系统（OS）是管理和控制计算机硬件与软件资源，是计算机上直接运行的最基本的系统软件，任何其他软件都必须在操作系统的支持下才能运行。操作系统是用户和计算机的接口，同时也是计算机硬件和其他软件的接口。操作系统的功能包括管理计算机系统的硬件、软件及数据资源，控制程序运行，提供人机交互界面，为其它应用软件提供支持等。我选择的课程是苏州大学的[国家精品课](https://www.icourse163.org/course/SUDA-1001752241)和汤子瀛版教材，以下为所记课堂笔记下半部分，包含内存管理、文件管理和设备管理的知识点，可供参考。上半部分笔记请访问[操作系统（上）](/操作系统-上)

<!--more-->

### 内存管理

#### 内存管理概述

- 内存管理的功能是为多道程序的运行提供良好的环境
  - 内存的分配和回收：记住内存空间的使用情况、实施内存的分配、回收系统或用户释放的内存空间
  - 地址变换：将逻辑地址转换为物理地址
  - 扩充内存：虚拟存储技术或其他自动覆盖技术
  - 存储保护：由硬件和软件配合完成
- 应用程序的编译、链接与装入
  1. 经过编译程序将源代码编译为若干个目标模块
  2. 通过链接程序将编译好的目标模块以及所需的库函数链接在一起，形成完整的装入模块
  3. 通过装入程序将这些装入模块装入内存并执行
- 源程序（名地址）-> 目标程序（逻辑地址）-> 可执行程序（物理地址）
  - 对程序设计者来说，数据的存放地址由数据名称决定，称为名地址或符号名地址，即为源程序的地址空间
  - 当链接程序将多个模块链接为装入模块时，链接程序会按照各个模块的相对地址，将其地址构成统一的从0号单元开始编址的相对地址
  - 当装入程序将可执行代码装入内存时，程序的逻辑地址与程序存在内存的实际地址，通常不同这就需要通过地址转换将逻辑地址转为物理地址，这个过程叫重定位
- 程序链接的 3 种方式
  - 静态链接：在程序运行之前，先将各目标模块及所需的库函数连接成一个完整的可执行程序（装入模块），之后不再拆开
  - 装入时动态链接：将各目标模块装入内存时，边装入边链接的链接方式
  - 运行时动态链接：在程序执行中需要该目标模块时，才对它进行链接。其优点是物理地址便于修改和更新，便于实现对目标模块的共享
- 程序装入的 3 种方式
  - 绝对装入：在编译时就知道程序将要驻留在内存的物理地址，编译程序产生含有物理地址的目标代码
  - 可重定位装入：根据内存当前情况将装入模块装入到内存的适当位置，地址变换通常在装入时一次完成，容易实现，无需增加硬件地址变换机构
  - 动态运行装入：允许程序运行时在内存中移动位置，在程序执行过程中，每当访问到相应指令或数据时，才将要访问的程序或数据的相对地址转换为物理地址，可以将程序分配到不连续的存储区中
- 在重定位中通常会设一个重定位寄存器，用来存放进程分配的内存空间的地址（基址寄存器）
  - 当 CPU 需要访问内存时，将逻辑地址转换为物理地址
  - 物理地址 = 基址计算器内容 + 逻辑地址
- 逻辑地址和物理地址
  - 逻辑地址是指由程序产生的与段相关的偏移部分地址（与页无关，因为只有段对用户可见）
  - 物理地址是指出现在 CPU 外部地址总线上的寻址物理内存的地址信号，是逻辑地址变换后的最终结果地址，物理地址空间是指内存中物理地址单元的集合
  - 从逻辑地址到物理地址的转换过程由硬件自动完成，这个转换过程叫做地址重定位
- 内存保护
  1. 界限寄存器方法
     - 上、下界寄存器方法：分别存放作业的结束地址和开始地址
     - 基址和限长寄存器方法
  2. 存储保护键方法：给每个存储块分配一个单独的保护键

#### 交换与覆盖

- 覆盖技术，就是把一个大的程序划分为一系列覆盖，每个覆盖是一个相对独立的程序单位
  - 把程序执行时并不要求同时装入内存的复盖组成一组，称为覆盖段
  - 将这个覆盖段分配到同一存储区域，这个存储区域称为覆盖区
  - 覆盖区与覆盖段一一对应
  - 覆盖技术只能覆盖与覆盖程序段无关的程序段
  - 为了使一个覆盖区能被相应覆盖段中每个覆盖在不同时刻共享，其大小应由覆盖段中最大覆盖来确定
  - 覆盖技术的特点是打破了必须将一个进程的全部信息装入主存后才能运行的限制，但当同时执行程序的代码量超过主存时，程序仍然不能运行
- 交换技术就是把暂时不用的某个程序及数据部分从内存移到外存中，以便腾出必要的内存空间，或把指定的程序或数据从外存读到相应的内存中，并将控制权转让给他，让其在系统上运行的一种内存扩充技术
  - 处理器三级调度中的中级调度就是采用了交换技术
  - 与覆盖技术相比，交换技术不要求程序员给出程序段之间的覆盖结构，且交换主要是在进程或作业之间进行，而覆盖主要在同一个作业或进程中进行
  - 交换进程由换出和换入两个过程组成
  - 交换技术的特点是打破了一个程序一旦进入主存便一直运行到结束的限制，但运行的进程大小仍然受实际主存的限制
  - 交换需要备份存储
  - 影响交换时间的因素主要是转移时间
  - 如果换出进程，必须确保该进程完全空闲
  - 交换空间通常作为磁盘的一整块，且独立于文件系统
  - 交换通常在有许多进程运行，且内存空间紧张时开始启动，而在系统负荷减轻时暂停

#### 连续分配管理方式

- 内部碎片和外部碎片
  - 内部碎片是指已经分配给作业，但不能被利用的内部空间
  - 外部碎片是指系统中还没有分配给作业，但由于碎片太小而无法分配给申请内存空间的新进程的存储块
- 单一连续分配：将内存分为两个连续存储区域，其中一个存储区域固定的分配给操作系统使用，通常放在内存低地址部分，另一个存储区域给用户作业使用
  - 通常用户作业只占用所有分配空间的一部分，剩下一部分实际上浪费掉了
  - 单一连续分配方式采用静态分配，适合单道程序，可采用覆盖技术
  - 作业一旦进入内存，就要等到其结束后才能释放内存，因此这种分配方式不支持虚拟存储器的实现，无法实现多道程序共享主存
  - 单一连续分配会产生内部碎片
- 固定分区分配：将内存空间划分为若干个固定大小的分区，每个分区中可以装入一道程序
  - 分区的大小可以不等，但事先必须确定，在运行时不能改变
  - 当有空闲分区时，便从后备队列中选择一个适当大小的作业装入运行
  - 固定分区分配中程序通常采用静态重定位方式装入内存
  - 固定分区分配的优点是可用于多道程序系统最简单的存储分配，缺点是不能实现多进程共享一个主存区，利用率较低，会产生内部碎片
- 动态分区分配：作业进入主存时，根据作业的大小动态的建立分区，并使分区的大小正好满足作业的需要，因此系统中分区的大小是可变的，分区数目也是可变的
  - 空闲分区表、空闲分区链
  - 首次适应算法（FF）、下次适应算法（NF）、最佳适应算法（BF）、最差适应算法（WF）
  - 分区回收
  - 分区分配的动态管理：拼接技术、动态重定位分区分配技术
- 动态分区分配的优缺点
  - 优点：实现了多道程序共用主存、管理方案相对简单、实现存储保护的手段比较简单
  - 缺点：主存利用不够充分，存在外部碎片、无法实现多进程共享存储器信息、无法实现主存的扩充，进程地址空间受实际存储空间的限制

#### 非连续分配管理方式

- 非连续分配允许一个程序分散地装入到不相邻的内存分区中
- 非连续分配管理方式根据分区大小是否固定为分页存储管理方式和分段存储管理方式
- 分页存储管理方式根据运行作业时是否需要把作业的所有页都装入内存才能运行而分为基本分页存储管理方式和请求分页存储管理方式
- 基本分页存储管理方式（物理单位）
  - 分页原理：用户作业的地址空间被划分成若干个大小相等的区域，称为页或页面
  - 将主存的存储空间分成与页面大小相等的区域，称为块或物理块
  - 在为作业分配存储空间时，总是以块为单位来分配，可以将作业中的任意一页放到主存的任意一块中
  - 主存中与页面大小相等的物理块也可称为页框
  - 为了将逻辑地址上连续的页号映射到物理内存中后成为离散分布的多个物理块，需要将每个页面和每个物理块一一对应，这种映射关系体现在页表中
  - 每个页表项由页号和块号组成
  - 基本地址变换机构：页表寄存器（PTR）
  - 具有快表（TLB）的地址的地址变换机构：具有并行查找功能的高度缓冲存储器
  - 两级页表和多级页表
- 基本分页存储管理方式优缺点
  - 优点：内存利用率高、实现了离散分配、便于存储访问控制、无外部碎片
  - 缺点：需要硬件支持（快表）、内存访问效率下降、共享困难、内部碎片
- 基本分段存储管理方式（逻辑单位）
  - 逻辑地址结构由段号 S 和段内位移 W（段内偏移量）组成
  - 段的长度不定
  - 作业空间地址是二维的
  - 段表及地址变换过程
- 基本分段存储管理方式优缺点
  - 优点：便于程序模块化处理和处理变换的数据结构、便于动态链接和共享、无内部碎片
  - 缺点：与分页类似，需要硬件支持、为满足分段的动态增长和减少外部碎片，要采用拼接手段、分段的最大尺寸受到主存可用空间的限制、有外部碎片

#### 虚拟内存的基本概念

- 在真实的操作系统中，通常采用段页式存储管理，段面向用户，页面向硬件
- 虚拟内存解决的问题
  - 一次性：作业必须一次性全部装入内存后才能开始运行。这会造成两个问题：①作业很大时，不能全部装入内存，导致大作业无法运行；②当大量作业要求运行时，由于内存无法容纳所有作业，因此只有少量作业能运行，导致多道程序并发度下降
  - 驻留性：一旦作业被装入内存，就会一直驻留在内存中，直至作业运行结束。事实上，在一个时间段内，只需要访问作业的一小部分数据即可正常运行，这就导致了内存中会驻留大量的、暂时用不到的数据，浪费了宝贵的内存资源。

- 虚拟内存的实现：
  - 基于局部性原理，在程序装入时，可以将程序中很快会用到的部分装入内存，暂时用不到的部分留在外存，就可以让程序开始执行
  - 在程序执行过程中，当所访问的信息不在内存时，由操作系统负责将所需信息从外存调入内存，然后继续执行程序
  - 若内存空间不够，由操作系统负责将内存中暂时用不到的信息换出到外存。在操作系统的管理下，在用户看来似乎有一个比实际内存大得多的内存，这就是虚拟内存。


#### 请求分页管理

- 请求分页管理：在程序执行过程中，当所访问的信息不在内存时，由操作系统负责将所需信息从外存调入内存，然后继续执行程序。若内存空间不够，由操作系统负责将内存中暂时用不到的信息换出到外存
- 缺页中断： 在请求分页系统中，每当要访问的页面不在内存时，便产生一个缺页中断，然后由操作系统的缺页中断处理程序处理中断
- 缺页的进程阻塞，放入阻塞队列，调页完成后再将其唤醒，放回就绪队列。如果内存中有空闲块，则为进程分配一个空闲块，将所缺页面装入该块，并修改页表中相应的页表项。如果内存中没有空闲块，则由页面置换算法选择一个页面淘汰，同时要注意，若某个页面被换出外存，则快表中的相应表项也要删除，否则可能访问错误的页面
- 理解缺页，缺页就像货架上缺少了商品，需要从仓库里调取商品，就先暂停这个货架的销售，等商品调取完毕再重新出售。

#### 页面置换算法

- 置换算法的评价指标是：缺页的次数，某种算法让缺页次数最低，调度效率最高，那就是最优的算法
- 最佳置换算法：每次淘汰的页面都是以后永久不用或最长时间不使用的页面，保证最低的缺页率。显然，这种需要预测未来的算法不可能实现。

- 先进先出算法FIFO：缺页时，淘汰最早进入的页面。算法简单，但局限性也明显，例如某些经常使用的页面一直被换进换出，和使用频率低的页面有相同的被换出的机会。

- 最近最久未使用置换算法LRU：每次淘汰的页面都是最近最久未使用的页面。需要在页面中添加一个记录项，记录上次被访问以来经历的时间t，当需要淘汰页面时，选择时间t最大的淘汰，也就是最久未使用的淘汰。算法设计虽好，但开销很大，实现困难。

- 时钟置换算法：时钟置换算法也可以称为最近未使用算法。是一种性能和开销均衡的算法。

- 简单的时钟算法实现方法：为每个页面设置一个访问位，再将内存中的页面都通过链接指针链接成一个循环队列。当某页被访问时，其访问位置为1。当需要淘汰一个页面时，只需检查页的访问位。如果是0，就选择该页换出;如果是1，则将它置为0，暂不换出，继续检查下一个页面，若第一轮扫描中所有页面都是1，则将这些页面的访问位依次置为0后，再进行第二轮扫描（第二轮扫描中一定会有访问位为0的页面，因此简单的CLOCK算法选择一个淘汰页面最多会经过两轮扫描)


### I/O原理

#### 文件的逻辑结构

- 文件可以分为两类：
  - 无结构文件：文件内部数据就是一系列二进制流或字符流。最典型的就是txt文件。

  - 有结构文件：由一组相似的记录组成，又称记录式文件。典型的excel表、数据库表等。
- 有结构文件的逻辑结构又分顺序文件、索引文件、索引顺序文件，注意逻辑结构是展示给用户的，是文件的组织形式，例如是一张顺序存储的excel表格，还是一张excel索引表加上excel顺序表，还是多级索引加顺序，而不是在计算机上的存储方式。

- 顺序文件：文件中的记录一个接一个地顺序排列（逻辑上），记录可以是定长的或可变长的。各个记录在物理上可以顺序存储或链式存储。

- 顺序存储即逻辑相邻的文件物理上也相邻，链式存储即在末尾添加新的文件。

- 记录的类型又分为可变长和不可变长记录


- 索引顺序文件：索引顺序文件是索引文件和顺序文件思想的结合。索引顺序文件中，同样会为文件建立一张索引表，但不同的是：并不是每个记录对应一个索引表项，而是一组记录对应一个索引表项，索引表项的地址直接指向顺序文件所在区域，再顺序查找到所需的文件，从而节省了很大的空间。(例如我们可以通过An Qi找到An Kang、An Jie等，而不用在索引表中存放这么多信息。另外索引项之间不需要有按照逻辑关系排列)
- 多级索引顺序文件：在索引顺序文件的基础上再增加层次深度，可以减少查找的次数(顺序查找范围缩小了)

#### 文件目录

- 文件目录可以分为：单级目录结构、两级目录结构、多级目录结构(树形目录结构)
- 单极目录结构：顾名思义，所有的文件放在一个目录中，类似于一个仓库把所有文件不加整理的堆放在一起，显然效率会很低下

- 两级目录结构:主要分为主文件目录和用户文件目录。类似于仓库中加了几个员工货架，不同员工的货物放在不同货架，但在一个货架中文件还是采用堆砌式的存储。

- 多级目录结构，又称树形目录结构:我们当前主流操作系统都是多级目录结构，简而言之就是文件目录可以一级一级的延申，从而文件更有条理。

- FCB(文件控制块)，首先来看一张图，如果文件目录都以这种表的形式进行信息查找，会大大降低运行效率，增加系统负担。

- 提出对策，其实在查找各级目录的过程中，只需要用到文件名这个信息，可以考虑让目录表瘦身来提升效率。

- 索引结点指针指向索引结点(文件名之外的其他信息就存放在结点中，从而按需读取，提升效率)

- 每一个文件都有一个FCB，记录了文件的地址、信息、权限等等属性


#### 文件的物理结构

- 最重要的三种物理结构：顺序、链接、索引，其中最主要使用的是索引文件，可以随机访问，同时增删效率高

- 文件的物理结构是文件分配在计算机存储上的分配方式。分配的基本单位是 物理块,可以构想一下，一个大文件，如一首音乐23MB，难道直接一整个塞入硬盘吗？显然可能会出现一些问题，硬盘的空间也需要不断调整，就像内存分页一样，硬盘也被分为小的物理块号方便进行调度。

- 连续分配

  - 优点：支持顺序访问和直接访问（即随机访问）；连续分配的文件在顺序访问时速度最快
  - 缺点：不方便文件拓展；存储空间利用率低，会产生磁盘碎片

- 链式分配

  - 隐式：采用链式分配（隐式链接）方式的文件，只支持顺序访问，不支持随机访问，查找效率低。另外，指向下一个盘块的指针也需要耗费少量的存储空间。


  - 显式：直观理解就是在隐式的基础上添加了一张表，从表上能看出不同物理块号的下一块的地址
  - 结论：采用链式分配（显式链接）方式的文件，支持顺序访问，也支持随机访问（想访问i 号逻辑块时，并不需要依次访问之前的0 ~ i-1号逻辑块），由于块号转换的过程不需要访问磁盘，因此相比于隐式链接来说，访问速度快很多
  - 显式链接也不会产生外部碎片，也可以很方便地对文件进行拓展。

- 索引分配

  - 索引就是文件分成不同的物理块存入磁盘，对每个物理块都有一个索引与之对应，需要读写时就通过索引表查询其物理地址进行相关操作

#### 磁盘结构

- 
  磁道：每一圈就是一个磁道，最内侧磁道面积最小，所以数据密度最大

- 扇区：磁道被划分为小的磁盘块

- 一个盘片可能有两个盘面;每个盘面对应一个磁头；所有磁头连在一起，共进退；每个盘面的相对位置的磁道组成柱面

#### 磁盘调度算法

- 磁盘调度算法要解决的核心问题就是寻道时间，即移动磁头的时间，而其他的启动时间、传输时间都很迅速，不是最主要的时间消耗

- 先来先服务FCFS

  - 根据进程请求房屋内磁盘的现后顺序进行调度。符合惯性思维，但在很多时候，效果很差。

- 最短寻找时间优先(学过数据结构与算法的话，核心思想就是贪心算法)，该算法会优先处理与当前磁头最近的磁道的需求

  - 那么很可能磁头就会如图所示的移动，也会存在饥饿问题：磁头只在一个小区域移动，而不能满足需要远距离移动的需求。例如不断有18->38，38->18的需求，那磁头就不会执行18->150的请求，从而产生饥饿
- 扫描算法
  - 核心思想，只有磁头移动到最外侧磁道的时候才能往内侧移动，移动到最内侧的时候才能向外侧移动。这样就不会产生饥饿问题。

#### 文件共享

- 文件共享分两种链接方式，硬链接和软连接
  - 硬链接就是在另一个用户的目录中，索引结点指针直接指向了发送分享的用户的索引节点，从而实现了共享，count的数量代表文件正在被几个用户使用。
  - 软连接，类似于快捷方式，记录了原文件的路径，然后层层查找。

#### 文件保护

- 文件保护有三种方式口令、加密、访问控制

  - 口令：为文件设置一串口令，就像打开手机需要先解锁。


  - 加密：使用加密方法对文件加密，只有拥有正确的解密方法才能解密，有点像不同军队之间进行通信，要实现进行加密，要是想窥探敌情，就要对密文进行破解。

  - 访问控制：每个文件的FCB或者索引结点中设置访问控制表，如windows中，设置了很多的访问权限，例如

#### I/O设备

- I/O就是输入输出，I/O设备就是可以将数据输入到计算机或将计算机数据输出的设备，常见的：鼠标、键盘、音响、显示器、打印机、话筒、摄像头等等。
- I/O控制器:CPU无法直接控制I/O设备，需要一个电子部件去充当中间人，这个部件就是I/O控制器，CPU控制I/O控制器，I/O控制器控制I/O设备。

- 假如我们的CPU能够控制I/O设备，那不同的厂商、不同型号的设备，都要对应进行编码，显然是不切实际的，所以CPU要采用通用调度方式调度I/O设备从而需要I/O控制器。


- Java语言中，调用System.out.Println()，这本身并不能在显示器上打印，而需要通过操作系统调用write方法，接着调用字符设备接口，命令显示器写
