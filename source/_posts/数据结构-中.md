---
title: 数据结构（中）
date: 2021-08-17
updated: 2021-09-26
tags: [Data Structure]
categories: 计算机专业
mathjax: true
---

> 数据结构是指数据的存储结构，是带有结构特性的数据元素的集合。精心选择的数据结构可以带来更好的运行或者存储效率。数据结构是计算机科学与技术专业、软件工程专业甚至于其它电气信息类专业的重要专业基础课程，在408计算机学科专业基础综合考试中占有45分。我选择的课程是浙江大学数据结构[国家精品课](https://www.icourse163.org/course/ZJU-93001)，以下为所记课堂笔记第二部分，包含树和图的知识总结以及所需记忆的代码，另外我在开源仓库中还保持了浙大慕课版本的[代码](https://github.com/Bezhuang/LearnCS/tree/main/%E5%90%8D%E6%A0%A1%E5%85%AC%E5%BC%80%E8%AF%BE/%E6%B5%99%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84)，可供参考。其他部分笔记详见[数据结构（上）](/数据结构-上)和[数据结构（下）](/数据结构-下)

<!--more-->

### 矩阵与广义表

#### 矩阵

- 矩阵的转置

  ```cpp
  void trsmat(int A[][maxSize],int B[][maxSize],int m, int n)
  {
      for (int i = 0;i < m;++i)
          for (int j = 0;j < n;++j)
              B[j][i] = A[i][j];
  }
  ```

- 矩阵相加

  ```cpp
  void addmat(int C[][maxSize],int A[][maxSize],int B[][maxSize],int m, int n)
  {
      for (int i = 0;i < m;++i)
          for (int j = 0;j < n;++j)
              C[i][j] = A[i][j] + B[i][j];
  }
  ```

- 矩阵相乘

  ```cpp
  void amutmat(int C[][maxSize],int A[][maxSize],int B[][maxSize],int m, int n,int k)
  {
      for (int i = 0;i < m;++i)
          for (int j = 0;j < k;++j)
          {
              C[i][j] = 0;
              for int(h = 0;h < n;++h)
                  C[i][j] += A[i][j] * B[i][j];
          }
  }
  ```

- 相同的元素或者零元素在矩阵中分布存在一定规律的矩阵称为特殊矩阵，反之称为稀疏矩阵

  - 对称矩阵、三角阵、对角矩阵

#### 广义表

- 表元素可以是原子或者广义表的一种线性表的扩展结构
- 广义表可以是递归定义的，长度为表最上层元素的个数，深度为表中括号的最大的层数
- 当广义表非空时，第一个元素为广义表的表头，其余元素组成的表是广义表的表尾
- 原子结点有两个域：标志域和数据域
- 广义表结点有三个域：标志域，头指针域与尾指针域

### 树

#### 树的基本概念

- 树是一种非线性的数据结构，是若干个结点的集合，由唯一的根和若干个互不相交的子树组成
  - 结点不仅包含数据元素，并且包含指向子树的分支
  - 结点的度是结点拥有的子树个数或者分支个数，树的度是树中各结点度的最大值
  - 树的高度是树中结点的最大层次，根结点的高度为树的高度
- 树的双亲存储结构：`int tree[maxSize]`
- 树的链式存储结构
  - 邻接表：孩子存储结构
  - 孩子兄弟存储结构

#### 二叉树的概念和性质

- 二叉树的定义

  - 每个结点最多只有两颗子树，即二叉树中的结点的度只能为0、1、2
  - 子树有左右顺序之分，不能颠倒

- 满二叉树：在一颗二叉树中，如果所有的分支节点都有左、右孩子节点，并且叶子节点都集中在二叉树的最下一层

- 完全二叉树由满二叉树从右至左、从上之下挨个删除结点得到的

- 二叉树的主要性质

  1. 非空二叉树上叶子结点数等于双分支结点数加1，$n_0=n_2+1$
  2. 在二叉树的第 $i$ 层上最多有 $2^{i-1}$个节点，$(i>=1)$
  3. 二叉树中如果深度为 $k$，那么最多有 $2^{k-1}$ 个节点，$(k>=1)$
  4. 若对含 n 个结点的完全二叉树从上到下且从左至右进行 1 至 n 的编号，则对完全二叉树中任意一个编号为 i 的结点：

     - 若 i=1，则该结点是二叉树的根，无双亲，否则编号为 $\lfloor i/2\rfloor$ 的结点为其双亲结点（向下取整）
     - 若 2i>n，则该结点无左孩子，否则，编号为 2i 的结点为其左孩子结点
     - 若 2i+1>n，则该结点无右孩子，否则，编号为2i+1 的结点为其右孩子结点
  5. Catalan()：给定 n 个结点，能够成 $h\left( n\right) =\dfrac{C_{2n}^{n}}{n+1}$  棵不同的二叉树
  6. 在完全二叉树中，具有n个节点的完全二叉树的深度为 $\lfloor log2n\rfloor+1$

- 二叉树的顺序存储结构最适用于完全二叉树

- 二叉树的链式存储结构

  ```cpp
  typedef struct BTNode
  {
      char  data;    //数据域
      struct BTNoode* lchild;
      struct BTNode* rchild;
  } BTNode;
  ```

#### 二叉树的遍历算法

- 先序遍历

  ```cpp
  /*二叉树的非递归先序遍历*/
  void PreTraverseTree2(BitNode * root)
  {
      StackNode* S;   //定义一个栈指针
      BitNode* p;   //工作指针
      S = NULL;
      p = root;
      S = InitStack(S);   //初始化栈
      if (NULL == p)
      {
          printf("树为空！\n");
          return;
      }     //end if
      while (p || !StackEmpty(S))
      {     //如果树不空或者栈不空
          if (p)
          {
              StackPush(S, p);    //p 所指节点入栈
              printf("%c ", p->data);     //相当于 visit（p）
  			p = p->lchild ;     //指向 p 的左孩子
   		}//end if
          else
          {     //p 所指节点为空，则出栈赋给 p，遍历右子树
              StackPop(S, p);
              p = p->rchild;     //若右孩子有左子树则继续 while 将左孩子入栈
          }    //end else
      }    //end while
      free(S);
  }    //end PreTraverseTree2
  
  /*二叉树的递归先序遍历*/
  void preOrder(BiTNode *root)
  {
      if (root)
      {
          printf("%d ", root->data);
          preOrder(root->lchild);
          preOrder(root->rchild);
      }
  }
  ```

- 中序遍历

  ```cpp
  /*二叉树的非递归中序遍历*/
  void InOrderTraverseTree2(BitNode* root)
  {
      StackNode* S; //定义一个栈指针
      BitNode* p; //工作指针
      S = NULL;
      p = root;
      S = InitStack(S); //初始化栈
      if (NULL == p) { //如果是空树
          printf("树为空！\n") ;
          return;
      }//end if
      while (p || !StackEmpty(S)) { //如果树不空或者栈不空
          if (p)
          {
              StackPush(S, p); //将节点入栈
              p = p->lchild; //指针一直向左孩子移动直到无左孩子
          }//end if
          else
          {
              StackPop(S, p); //p 左子树为空则出栈
              printf("%c ", p->data); //访问 p 节点
              p = p->rchild; //向右子树移动
          }//end else
      }//end while
      free(S);
  }//end InOrderTraverseTree2
  
  /*二叉树的递归中序遍历*/
  void inOrder(BiTNode* root)
  {
      if (root)
      {
          inOrder(root->lchild);
          printf("%d ", root->data);
          inOrder(root->rchild);
      }
  }
  ```

- 后序遍历

  ```CPP
  /*二叉树非递归后序遍历*/
  void LastTraverseTree2(BiTNode* root)
  {
      StackNode* S; BiTNode* cur, * pre;//定义一个栈指针
      S = NULL; S = InitStack(S); //cur 为当前节点指针，pre 保存上一节点
      if (NULL == root)
      {
          printf("树为空！\n");
          return;
      }//end if
      pre = NULL; cur = NULL;
      StackPush(S, T); //根节点入栈
      while (!StackEmpty(S))
      { //若栈非空
          cur = NULL;
          StackGetTop(S, cur); //将栈顶节点赋给 cur
  /*要保证根节点在左孩子和右孩子访问之后才能访问，因此对于任一节点 P，先将其入 栈。
  如果 P 不存在左孩子和右孩子，则可以直接访问它；或者 P 存在左孩子或者右孩子，但是
  其左孩子和右孩子都已被访问过了，则同样可以直接访问该节点。*/
          if ((cur->lchild == NULL && cur->rchild == NULL) ||
              (pre != NULL && (pre == cur->lchild || pre == cur->rchild)))
          {
              printf("%c ", cur->data);
              pre = cur;
              StackPop(S, cur);
          }//end if
  //若非上述两种情况，则将 P 的右孩子和左孩子依次入栈，这样就保证了每次取栈顶元素
  //的时候，左孩子在右孩子前面被访问，左孩子和右孩子都在根节点前面被访问。
          else
          {
              if (cur->rchild != NULL)
                  StackPush(S, cur->rchild);
              if (cur->lchild != NULL)
                  StackPush(S, cur->lchild);
          }//end else
      }//end while
      free(S);
  }//end LastTraverseTree2
  
  /*二叉树递归后序遍历*/
  void postOrder(BiTNode* root)
  {
      if (root)
      {
          postOrder(root->lchild);
          postOrder(root->rchild);
          printf("%d ", root->data);
      } 
  }
  ```

- 层次遍历：自上而下，自左向右

  - 首先，将二叉树的祖先节点入队列
  - 然后循环执行以下步骤，直到队列为空：节点出队列进行相应操作，该节点如果有左孩子节点，左孩子节点入队列，该节点如果有右孩子节点，右孩子节点入队

  ```cpp
  void LayerOrder(BiTreeNode* head)
  {
      LQueue Q;
      Initiate_Queue(&Q);
      BiTreeNode* p;
      if (head != NULL) AppendQueue(&Q, head);
      while (QueueNotEmpty(&Q)) {
          p = QueueDelete(&Q);
          cout << p->data << " ";
          if (p->LChild != NULL) AppendQueue(&Q, p->LChild);
          if (p->RChild != NULL) AppendQueue(&Q, p->RChild);
      }
  } 
  ```

#### 哈夫曼树和哈夫曼编码

- 哈夫曼树又叫做最优二叉树，它的特点是带权路径最短

  - 树的路径长度是指从根到每个节点的路径长度之和
  - 带权路径长度是从该节点到根节之间的路径长度乘以结点的权值
  - 树的带权路径长度（WPL）是指树中所有叶子节点的带权路径长度之和

- 求哈夫曼树的带权路径长度：WPL = 第 i 个节点的权值+ 第i个节点的长度

  ```cpp
  ElemType WeightPathLength(struct BTreeNode* FBT, int len)//len初始为0  
  {  
      if (FBT == NULL) //空树返回0  
          return 0;  
      else  
      {  
          if (FBT->left == NULL && FBT->right == NULL)//访问到叶子结点  
              return FBT->data * len;  
          else //访问到非叶子结点，进行递归调用，返回左右子树的带权路径长度之和，len递增  
              return WeightPathLength(FBT->left,len+1)+WeightPathLength(FBT->right,len+1);  
      }  
  }  
  ```

- 哈夫曼树的构造方法：根据数组 a 中 n 个权值建立一棵哈夫曼树，返回树根指针  

  ```cpp
  struct BTreeNode* CreateHuffman(ElemType a[], int n)  
  {  
      int i, j;  
      struct BTreeNode **b, *q;  
      b = malloc(n*sizeof(struct BTreeNode));  
      for (i = 0; i < n; i++) //初始化b指针数组，使每个指针元素指向a数组中对应的元素结点  
      {  
          b[i] = malloc(sizeof(struct BTreeNode));  
          b[i]->data = a[i];  
          b[i]->left = b[i]->right = NULL;  
      }  
      for (i = 1; i < n; i++)//进行 n-1 次循环建立哈夫曼树  
      {  
          //k1表示森林中具有最小权值的树根结点的下标，k2为次最小的下标  
          int k1 = -1, k2;  
          for (j = 0; j < n; j++)//让k1初始指向森林中第一棵树，k2指向第二棵  
          {  
              if (b[j] != NULL && k1 == -1)  
              {  
                  k1 = j;  
                  continue;  
              }  
              if (b[j] != NULL)  
              {  
                  k2 = j;  
                  break;  
              }  
          }  
          for (j = k2; j < n; j++)//从当前森林中求出最小权值树和次最小  
          {  
              if (b[j] != NULL)  
              {  
                  if (b[j]->data < b[k1]->data)  
                  {  
                      k2 = k1;  
                      k1 = j;  
                  }  
                  else if (b[j]->data < b[k2]->data)  
                      k2 = j;  
              }  
          }  
          //由最小权值树和次最小权值树建立一棵新树，q指向树根结点  
          q = malloc(sizeof(struct BTreeNode));  
          q->data = b[k1]->data + b[k2]->data;  
          q->left = b[k1];  
          q->right = b[k2];  
    
          b[k1] = q;//将指向新树的指针赋给b指针数组中k1位置  
          b[k2] = NULL;//k2位置为空  
      }  
      free(b); //删除动态建立的数组b  
      return q; //返回整个哈夫曼树的树根指针  
  }  
  ```

- 哈夫曼编码

  - 每个字符对应一个二进制编码，采用不等长编码方式，构造哈夫曼树
  - 将每个字符的出现频率作为字符结点的权值赋予叶子结点，每个分支结点的左右分支分别用0和1编码
  - 从树根结点到每个叶子结点的路径上所经分支的0、1编码序列等于该叶子结点的二进制编码
  - 哈夫曼编码产生的是最短前缀码

  ```cpp
  void HuffManCoding(struct BTreeNode* FBT, int len)//len初始值为0  
  {  
      static int a[10];  //定义静态数组a，保存每个叶子的编码，数组长度至少是树深度减一  
      if (FBT != NULL)  //访问到叶子结点时输出其保存在数组a中的0和1序列编码  
      {  
          if (FBT->left == NULL && FBT->right == NULL)  
          {  
              int i;  
              printf("结点权值为%d的编码：", FBT->data);  
              for (i = 0; i < len; i++)  
                  printf("%d", a[i]);  
              printf("\n");  
          }  
          else    //访问到非叶子结点时分别向左右子树递归调用，并把分支上的0、1编码保存到数组a  
          {   //的对应元素中，向下深入一层时len值增1  
              a[len] = 0;  
              HuffManCoding(FBT->left, len + 1);  
              a[len] = 1;  
              HuffManCoding(FBT->right, len + 1);  
          }  
      }  
  }  
  ```

### 图

#### 图的基本概念

- 图由结点的有穷集合的 V 和边的集合  E 组成（`G(V,E)`）
- 图是按照无方向和有方向分为无向图和有向图，无向边用 $(v_i,v_j)$ 表示，有向边用 $<v_i,v_j>$ 表示
- 路径长度：路径上边或者弧的数目
- 顶点的度：顶点关联边的数目
  - 有向图中：方向指向顶点的边为入度；方向背向顶点的边为出度
  - 在有向图中，顶点的度就是两者之和
  - 在无向图中，任意两个顶点是相通的就是连通图，它的极大连通子图为连通分量
  - 在向图中，任意两个顶点间互相都存在路径的就是强连通图，它的极大强连通子图为强连通分量

#### 图的存储结构

- 邻接矩阵

  - 图的顺序存储结构
  - 用两个数组保存数据：一个一维数组存储图中顶点信息，一个二维数组存储图中边或弧的信息
  - 无向图中邻接矩阵是个对称矩阵
  - 0表示无边，1表示有边
  - 顶点的度是行内数组之和，有向图中各行之和是出度，各列之和是入度 
  - 邻接矩阵对于边数相对顶点较少的图，就是对存储空间极大的浪费

  ```cpp
  typedef struct
  {
    int no;
    char info;
  } VertexType;
  typedef struct
  {
    int edges[maxSize][maxSize];    //有权图中int改为float
    int n,e;    //顶点数和边数
    VertexType vex[maxSize];    //存放结点信息
  } MGragh;
  ```

- 邻接表

  - 数组和链表相结合的存储方法，图的链式存储结构
  - 图中顶点用一个一维数组存储
  - 图中每个顶点 $V_i$ 的所有邻接点构成一个线性表
  - 顶点表的各个结点由 data 和 Firstedge 两个域表示
    - data 是数据域，存储顶点信息
    - firstedge 是指针域，指向边表的第一个结点，即顶点的第一个邻接点
  - 边表结点由 adjvex 和 next 两个域组成
    - adjvex 是邻接点域，存储某顶点的邻接点在顶点表中坐标
    - next 存储边表中下一个结点指针
  - 有向图也可以用邻接表，出度表叫邻接表，入度表尾逆邻接表

  ```cpp
  typedef struct ArcNode
  {
      int adnex;    //该边所指向的结点的位置
      struct ArcNode * nextarc;    //指向下一条边的指针
      int info;    //该边的相关信息(如权值)
  } ArcNode;
  typedef struct
  {
      char data;    //顶点信息
      ArcNode* firstarc;    //指向第一条边的指针
  }VNode;
  typedef struct
  {
      VNode adjlist[maxSize];    //邻接表
      int n, e;    //顶点数和边数
  } AGraph;    //图的邻接表类型
  ```

- 十字链表

  - 在邻接表中针对有向图，分为邻接表和逆邻接表，导致无法从一个表中获取图的入读和出度的情况，有人提出了十字链表
  - 定点表
    - firstin：入边表头指针，指向顶点入边表的第一个结点
    - firstout：出边表头指针，指向顶点出边表第一个结点
  - 边表
    - tailvex 是指弧起点在顶点表的下标，headvex 弧终点在顶点表的下标
    - headlink 入边表指针域，指向终点相同的下一条边
    - taillink 是指边表指针域，指向起点相同的下一条边

- 邻接多重表

  - ivex 和 jvex 是与某条边依附的两个顶点在顶点表中的下标
  - ilink 指向依附项点 ivex 的下一条边
  - jlink 指向依附顶点 jvex 的下一条边


#### 图的遍历算法

- 深度优先遍历（DFS，Depth First Search） 

  - 首先从图中某个顶点 $v_0$ 出发，访问此顶点，然后依次从 $v_0$ 相邻的顶点出发 深度优先遍历，直至图中所有与 $v_0$ 路径相通的顶点都被访问了
  - 若此时尚有顶点未被访问， 则从中选一个顶点作为起始点，重复上述过程，直到所有的顶点都被访问
  - 深度优先遍历是一个递归的过程，这种遍历过程类似树的先序遍历，均是先访问节点，再从该节点出发继续向下遍历

  ```cpp
  bool visited[Max_Vex];    //定义访问标记数组，为了防止重复访问
  void DFSTraverse(Graph G)
  {
      for (v = 0;v < G.vexnum;++v)
          visited[v] = false;    //初始化标记数组
      for (v = 0;v < G.vexnum;++v)
          if (!visited[v])    //如果 v 未被访问，那么从 v 起，开始做深度优先遍历
              DFS(G, v);
  }
  void DFS(Graph G, int v)
  {
      visit(v);
      visited[v] = true; //定义为已访问
      for (w = FirstNeighbor(G, v);w >= 0;w = NextNeighbor(G, v, w))
          if (!visited[w])
              DFS(G, w);
  }
  ```

- 广度优先遍历（BFS，Breadth First Search）

  - 首先从图的某个顶点 $v_0$ 出发，访问了 $v_0$ 之后，依次访问与 $v_0$ 相邻的未被访 问的顶点
  - 然后分别从这些顶点出发，广度优先遍历，直至所有的顶点都被访问完
  - BFS 遍历的方式类似于树的层次遍历

  ```cpp
  bool visited[Max_Vex];    //定义访问标记数组
  void BFSTraverse(Graph G)
  {
      for (i = 0;i < G.vexnum;++i)
          visited[v] = false;    //初始化标记数组
      InitQueue(Q);
      for (v = 0;v < G.vexnum;++v)
          if (!visited[v])    //如果 v 未被访问，那么从 v 起，开始做广度优先遍历
              BFS(G, v);
  }
  void BFS(Graph G, int v)
  {
      visit(v);
      visited[v] = true;    //定义为已访问
      while (!isEmpty(Q))
      {
          DeQueue(Q, v);
          for (w = FirstNeighbor(G, v);w >= 0;w = NextNeighbor(G, v, w))
              if (!visited[w])
              {
                  visit(w);
                  visited[w] = true;
                  EnQueue(Q, w)
              }    //if
      }    //while
  }
  ```

#### 最小生成树

- Prim 算法

  - 从图中仼意取出一个顶点，把它当成一棵树，然后从与这棵树相接的边中选取一条最短（权值最小）的边，并将这条边及其所连接的顶点也并入这棵树中，此时得到了一棵有两个顶点的树
  - 然后从与这棵树相接的边中选取一条最短的边，并将这条边及其所连顶点并入当前树中，得到一棵有3个顶点的树
  - 以此类推，直到图中所有顶点都被并入树中为止，此时得到的生成树就是最小生成树

  ```cpp
  void prim (G,T)
  {
      T = ∅;
      U = {w};
      while ((V - U) != ∅  )
      { //若图中不含全部顶点
          设  (u，v) 是使 u∈U 与 v∈ (V-U)，且权值最小的边;
          T = T∪ (u，v); //边归入树
          U = U∪ {v};     //顶点归入树
      }
  }
  ```

- Kruskal 算法

  - 将图中边按照权值从小到大排序，然后从最小边开始扫描各边，并检测当前边是否为候选边，即是否该边的并入会构成回路，如不构成回路，则将该边并入当前生成树中，直到所有边都被检测完为止
  - Kruskal 算法的时间复杂度主要由选取的排序算法决定，排序算法所处理数据的规模由图的边数e 决定，与顶点数无关，因此克鲁斯卡尔算法适用于稀疏图
  - 普里姆算法和克鲁斯卡尔算法都是针对于无向图的
  - 判断是否产生回路要用到并查集，并查集中保存了一棵或者几棵树
    - 通过树中一个结点，可以找到其双亲结点，进而找到根结点（可以快速地将两个含有很多元素的集合并为一个，两个集合就是并査集中的两棵树，只需找到其中一棵树的根，然后将其作为另一棵树中任何个结点的孩子结点即可，可以方便地判断两个元素是否属于同一个集合
    - 通过这两个元素所在的结点找到它们的根结点，如果它们有相同的根，则说明它们属于同一个集合，否则属于不同集合

  ```cpp
  void kruskal（V，T）
  {
      T = V;    //初始化树，仅含顶点
      numS = n;    //不连分量的数目
      while (numS > 1)
      {
          从 E 中取出权值最小的边（v,u）;
          if（v 和 u 属于 T 中不同的连通分量）
          {
              T = T∪（u，v）;//将此边加入到生成树中；
              numS--; //不连通的分量减少 1
          }
      }
  }
  ```

#### 最短路径

- Dijkstra 算法

  - 通常用于求图中某一顶点到其余各顶点的最短路径
  - 设  G=(V,E) 是一个带权有向图，把图中顶点集合 V 分成两组
  - 第一组为已求出最短路径的顶点集合（用 S 表示，初始时 S 中只有一个源点，,以后每求得一条最短路径就将求得的顶点加入到集合 S 中，直到全部顶点都加入到 S 中）
  - 第二组为其余未确定最短路径的顶点集合（用 U 表示），按最短路径长度的递增次序依次把第二组的顶点加入 S 中，在加入的过程中，总保持从源点 V 到 S 中各顶点的最短路径长度不大于从源点 V 到 U 中任何顶点的最短路径长度

- Dijkstra 算法步骤

  1. 初始时，S 只包含源点，即 S＝{v}，v 的距离为 0，U 包含除 v 外的其他顶点，即:U={其 余顶点}，若 v 与 U 中顶点 u 有边，则正常有权值，若 u 不是 v 的出边邻接点，则 权值为 $∞$
  2. 从 U 中选取一个距离 v 最小的顶点 k，把 k 加入 S 中（该选定的距离就是 v 到 k 的最短路 径长度）
  3. 以 k 为新考虑的中间点，修改 U 中各顶点的距离值：若从源点 v 到顶点 u 的距离（经过顶点 k）比原来距离（不经过顶点 k）短，则修改顶点 u 的距离值，修改后的距离值为 v 到 k 的距离加上 k 到 u 的距离
  4. 重复步骤 b 和 c 直到所有顶点都包含在 S 中

  ```cpp
  void Dijkstra(int v0)
  {
    　　bool S[MAXNUM];                                  // 判断是否已存入该点到S集合中
        int n=MAXNUM;
    　　for(int i=1; i<=n; ++i)
   　　 {
        　　dist[i] = A[v0][i];
        　　S[i] = false;                                // 初始都未用过该点
        　　if(dist[i] == MAXINT)    
              　　prev[i] = -1;
   　　     else 
              　　prev[i] = v0;
     　　}
     　 dist[v0] = 0;
     　 S[v0] = true; 　　
   　　 for(int i=2; i<=n; i++)
   　　 {
         　　int mindist = MAXINT;
         　　int u = v0; 　　                            // 找出当前未使用的点j的dist[j]最小值
        　　 for(int j=1; j<=n; ++j)
        　　    if((!S[j]) && dist[j]<mindist)
        　　    {
           　　       u = j;                             // u保存当前邻接点中距离最小的点的号码 
           　 　      mindist = dist[j];
         　　   }
         　　S[u] = true; 
         　　for(int j=1; j<=n; j++)
         　　    if((!S[j]) && A[u][j]<MAXINT)
         　　    {
             　    　if(dist[u] + A[u][j] < dist[j])     //在通过新加入的u点路径找到离v0点更短的路径  
             　    　{
                     　　dist[j] = dist[u] + A[u][j];    //更新dist 
                     　　prev[j] = u;                    //记录前驱顶点 
              　　    }
          　    　}
     　　}
  }
  ```

- Floyd 算法

  - Floyd-Warshall算法（Floyd-Warshall algorithm）是解决任意两点间的最短路径的一种算法，可以正确处理有向图或负权的最短路径问题，同时也被用于计算有向图的传递闭包
  - Floyd-Warshall 算法的时间复杂度为  $O(N^3)$，空间复杂度为  $O(N^2)$
  - Floyd 算法是一个经典的动态规划算法，目标是寻找从点 i 到点 j 的最短路径，假设 Dis(i,j) 为节点 u 到节点 v 的最短路径的距离
  - 对于每一个节点 k，检查 Dis(i,k) + Dis(k,j) < Dis(i,j) 是否成立，如果成立，证明从 i 到 k 再到 j 的路径比 i 直接到j的路径短，便设置 Dis(i,j) = Dis(i,k) + Dis(k,j)，这样当遍历完所有节点 k，Dis(i,j) 中记录的便是 i 到 j 的最短路径的距离

- Floyd 算法步骤

  - 从任意一条单边路径开始，所有两点之间的距离是边的权，如果两点之间没有边相连，则权为无穷大　　
  - 对于每一对顶点 u 和 v，看看是否存在一个顶点 w 使得从 u 到 w 再到 v 比己知的路径更短，如果是更新它

  ```cpp
  for (k = 1;k <= n;k++)
      for (i = 1;i <= n;i++)
          for (j = 1;j <= n;j++)
              if (a[i][j] > a[i][k] + a[k][j])
                  a[i][j] = a[i][k] + a[k][j];
  ```

#### 拓扑排序

- 对一个有向无环图 G 进行拓扑排序，是将 G 中所有顶点排成一个线性序列，使得图中任意一对顶点 u 和 v，若存在由 u 到 v 的路径，则在拓扑排序序列中一定是 u 出现在 v 的前边

  1. 从 DAG 图中选择一个没有前驱的节点并输出
  2. 从图中删除该节点和所有以它为起点的有向边
  3. 重复上两步直到当前的 DAG 图为空或不存在无前驱的顶点为止

  ```cpp
  bool topologicalSort(Graph GL)
  {
      EdgeNode* e;
      int top = 0; //用于栈指针下标 
      int count = 0; // 用于统计输出顶点的个数 
      int* stack; // 建栈将入度为 0 的顶点入栈 
      stack = (int*)malloc(GL->numVertexes * sizeof(int));
      for (i = 0; i < GL->numVertexes; i++)
          if (0 == GL->adjList[i].in) //将入度为 0 的顶点入栈 
              stack[++top] = i;
      while (top != 0)
      {
          gettop = stack[top--];
          printf("%d -> ", GL->adjList[gettop].data);
          count++; //输出 i 号顶点，并计数 
          for (e = GL->adjList[gettop].firstedge; e; e = e->next) {
              k = e->adjvex;
              if (!(--GL->adjList[k].in))
                  //将 i 顶点的邻接点入度减 1，如果减 1 后为 0，则入栈 
                  stack[++top] = k;
          }
      }
      if (count < GL->numVertexes) return false;
      else return true;
  }
  ```

  

