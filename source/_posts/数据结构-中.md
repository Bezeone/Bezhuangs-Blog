---
title: 数据结构（中）
date: 2021-8-10
updated: 2021-08-26
tags: []
categories: 计算机专业
mathjax: true
---

> 数据结构是指数据的存储结构，是带有结构特性的数据元素的集合。精心选择的数据结构可以带来更好的运行或者存储效率。数据结构是计算机科学与技术专业、软件工程专业甚至于其它电气信息类专业的重要专业基础课程，在408计算机学科专业基础综合考试中占有45分。我选择的课程是浙江大学数据结构[国家精品课](https://www.icourse163.org/course/ZJU-93001)，以下为所记课堂笔记第一部分，包含树和图的知识总结以及所需记忆的代码，另外我在开源仓库中还保持了浙大慕课版本的[伪代码](https://github.com/Bezhuang/LearnCS/tree/main/%E5%90%8D%E6%A0%A1%E5%85%AC%E5%BC%80%E8%AF%BE/%E6%B5%99%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84)，可供参考。其他部分笔记详见[数据结构（上）](/数据结构-上)和[数据结构（下）](/数据结构-下)

<!--more-->

### 基本概念

#### C/C++语言基础

- 数据类型
  - 结构型 `int a[maxSize];`
  - 指针型 `int *a;`
  - 链表结点
    ```C
    typedef struct Node
    {
      int data;
      struct Node *next;
    }Node;
    ```
  - 二叉树结点
    ```C
    typedef struct BTNode
    {
      int data;
      struct BTNode *lchild;
      struct BTNode *rchild;
    }BTNode;
    ```
  - 动态申请数组空间
    ```C
    int *p;
    p=(int *)malloc(n * sizeof(int));
    ```
- 函数
  - 函数参数的引用型定义
    ```cpp
    int a=0;
    void f(int &x)
    {
      ++x;
    }
    f(a);
    ```
  - 数组作参数的引用型定义
    ```cpp
    void f(int x[][maxSize], int n){···;}
    ```

#### 算法的时间复杂度和空间复杂度

- 时间复杂度 
  - $T(n)=O(f(n)中增长最快的项的系数)$
  - 将最坏的情况作为算法时间复杂度的度量
  - $O(1)≤O(\log_{2}\left(n\right)≤O(n)≤O(n\log_{2}\left(n\right)≤O(n^2)≤O(2^n)$
  - 取最深层循环内的语句所描述的操作为基本操作，由循环基本执行的次数为规模n，计算函数 $f(n)$
- 空间复杂度：算法在运行时所需存储空间的度量，主要考虑在算法运行过程中临时占用的存储空间大小

#### 数据结构基本概念

- 数据是对客观事物的符号表示
- 数据元素是数据的基本单位
- 数据对象是性质相同的数据元素的集合
- 数据结构是相互之间存在一种或多种特定关系的数据元素的集合
- 数据的逻辑结构是对数据之间关系的描述，分为线性结构（一个数据元素的次序集合）和非线性结构（树、图）
- 数据的存储（物理）结构是数据的逻辑结构在计算机中的表示（映像），包括数据元素的表示和关系的表示
- 数据元素之间的关系：顺序映像和非顺序映像
- 数据结构中常用储存方法：顺序存储（数组）、链式存储（指针）、索引存储 `<关键字, 地址>`、散列存储（根据结点的关键字通过散列函数直接计算出该结点的存储地址）

#### 算法的基本概念

- 算法的特性：有穷性、确定性、输入、输出、可行性
- 算法的设计目标：正确性、可读性、健壮性、高效率和低存储量需求

### 线性表

#### 线性表的基本概念

- 线性表是具有相同特性数据元素的一个有限序列，长度 $n≥0$
- 线性表只有一个表头元素，一个表尾元素，除表头表尾元素外其他元素只有一个直接前驱和一个直接后继（有序性）
- 顺序表：随机访问特性、要求占用连续的存储空间、做插入操作要移动多个元素
- 链表：不支持随机访问、结点的存储空间利用率稍低、支持存储空间的动态分配
- 头指针指向链表的第一个结点、头结点指向带头结点链表的第一个结点
- 单链表、双链表、循环单链表、循环双链表、静态链表（数据元素分量+指针分量）

#### 线性表的结构体定义

- 顺序表
  ```c
  typedef struct
  {
    int data[maxSize];   //考试写这两行
    int length;         //
  }Sqlist;
- 单链表
  ```c
  typedef struct LNode
  {
    int data;
    struct LNode *next;
  }LNode
  //构造LNode型结点
  LNode *A = (LNode*)malloc(sizeof(LNode));
  ```
- 双链表
  ```c
  typedef struct DLNode
  {
    int data;
    struct DLNode *prior;
    struct DLNode *next;
  }DLNode;
  ```

#### 顺序表的操作

- 查找元素
  ```cpp
  int findElem (Sqlist L, int e)
  {
    int i;
    for (i=0; i<L.length; ++i)
      if (e==L.data[i])
        return i;
    return -1;
  }
  ```
- 插入元素
  ```cpp
  int insertElem (Sqlist &L, int p, int e)  //需要改变的变量用引用型&
  {
    int i;
    if (p<0||p>L.length||L.length==maxSize)
      return 0;
    for (i=L.length-1; i>=p; --i)  //从后往前
      L.data[i+1]=L.data[i];
    L.data[p]=e;
    ++(L.length);  //表中多加一元素，表长加一
    return 1;
  }
  ```
- 删除元素
  ```cpp
  int deleteElem(Sqlist &L, int p, int &e)
  {
    int i;
    if (p<0||p>L.length-1)
      return 0;
    e=L.data[p];
    for (i=p; i<L.length; ++i)
      L.data[i]=L.data[i+1];
    --(L.length); 
    return 1;
  }
  ```
- 初始化顺序表
  ```cpp
  void initList(Sqlist &L)
  {
    L.length=0;
  }
  ```
- 求指定位置元素
  ```cpp
  int getElem(Sqlist L, int p, int &e)
    if(p<0||p>L.length-1)
      return 0;
    e=L.data[p];
    return 1;
  ```

#### 单链表的操作

- 尾插法建立链表C
  ```cpp
  void createlistR(LNode *&C, int a[], int n)
  {
    LNode *s, *r;  //s指向新申请结点，r指向C的终端结点
    int i;
    C=(LNode *)malloc(sizeof(LNode));  //申请C的头结点空间
    C->next=NULL;
    r=C;
    for (i=0; i<n; ++i)
    {
      s=(LNode *)malloc(sizeof(LNode));
      s->data=a[i];
      r->next=s;
      r=r->next;
    }
    r->next=NULL;
  }
  ```


### 未完待续






