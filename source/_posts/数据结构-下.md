---
title: 数据结构（下）
date: 2021-09-08
updated: 2021-09-26
tags: [Data Structure]
categories: 计算机专业
mathjax: true
---

> 数据结构是指数据的存储结构，是带有结构特性的数据元素的集合。精心选择的数据结构可以带来更好的运行或者存储效率。数据结构是计算机科学与技术专业、软件工程专业甚至于其它电气信息类专业的重要专业基础课程，在408计算机学科专业基础综合考试中占有45分。我选择的课程是浙江大学数据结构[国家精品课](https://www.icourse163.org/course/ZJU-93001)，以下为所记课堂笔记第三部分，包含排序、查找算法和平衡二叉树的知识总结以及所需记忆的代码，另外我在开源仓库中还保持了浙大慕课版本的[代码](https://github.com/Bezhuang/LearnCS/tree/main/%E5%90%8D%E6%A0%A1%E5%85%AC%E5%BC%80%E8%AF%BE/%E6%B5%99%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84)，可供参考。其他部分笔记详见[数据结构（上）](/数据结构-上)和[数据结构（中）](/数据结构-中)

<!--more-->

### 排序

#### 排序的基本概念

- 排序：将原本无序的序列重新排列成有序序列的过程，这个序列中的每一项可能是单独的数据元素，也可能是一条记录
- 记录由多个数据元素组成的，既可以按照记录的主关键字排序（主关键字唯一标识一条记录），也可以按照记录的次关键字排序
- 稳定性：当待排序序列中有两个或两个以上相同的关键字时，排序前和排序后这些关键字的相对位置，如果没有发生变化就是稳定的，否则就是不稳定的
- 排序算法的分类
  - 插入类的排序：直接插入、折半插入、希尔排序
  - 交换类的排序：冒泡排序、快速排序
  - 选择类的排序：简单选择、堆选择
  - 归并类的排序：二路归并
  - 基数类的排序：多关键字排序

#### 插入类的排序

- 插入排序

  ```cpp
  void InsertSort(int* h, size_t len)
  {
      if(h==NULL) return;
      if(len<=1) return;
      int i,j;
      //i是次数，也即排好的个数;j是继续排
      for(i=1;i<len;++i)
          for(j=i;j>0;--j)
              if(h[j]<h[j-1]) Swap(h[j],h[j-1]);
              else break;
      return;
  }
  ```

- 希尔排序

  - 缩小增量排序：把记录按下标的一定增量分组，对每组使用直接插入排序算法排序
  - 随着增量逐渐减少，每组包含的关键词越来越多，当增量减至1时，整个文件恰被分成一组，算法便终止

  ```cpp
  void ShellSort(int* h, size_t len)
  {
      if(h==NULL) return;
      if(len<=1) return;
      for(int div=len/2;div>=1;div/=2)
          for(int k=0;k<div;++k)
              for(int i=div+k;i<len;i+=div)
                  for(int j=i;j>k;j-=div)
                      if(h[j]<h[j-div]) Swap(h[j],h[j-div]);
                      else break;
      return;
  }
  ```

#### 交换类的排序

- 快速排序

  ```cpp
  void QuickSort(SeqList R，int low，int high) 
  { //对 R[low..high]快速排序 
      int pivotpos； //划分后的基准记录的位置 
          if (low < high) { //仅当区间长度大于 1 时才须排序 
              pivotpos = Partition(R，low，high)； //对 R[low..high]做划分 
                  QuickSort(R，low，pivo t   pos-1)； //对左区间递归排序 
                  QuickSort(R，pivotp o s+1，high)； //对右区间递归排序 
          }
  } //QuickSort
  ```

- 冒泡排序

  - 通过依次交换相邻两个顺序不合法的元素位置，从而将当前最小（大）元素放到合适的位置

  ```cpp
  void BubbleSort(int* h, size_t len)
  {
      if(h==NULL) return;
      if(len<=1) return;
      //i是次数，j是具体下标
      for(int i=0;i<len-1;++i)
          for(int j=0;j<len-1-i;++j)
              if(h[j]>h[j+1])
                  Swap(h[j],h[j+1]);
      return;
  }
  ```

#### 选择类的排序

- 选择排序

  - 初始时在序列中找到最小（大）元素，放到序列的起始位置作为已排序序列，然后，再从剩余未排序元素中继续寻找最小（大）元素，放到已排序序列的末尾。以此类推，直到所有元素均排序完毕
  - 每遍历一次都记住了当前最小（大）元素的位置，最后仅需一次交换操作即可将其放到合适的位置

  ```cpp
  void SelectionSort(int* h, size_t len)
  {
      if(h==NULL) return;
      if(len<=1) return;
      int minindex,i,j;
      //i是次数，也即排好的个数;j是继续排
      for(i=0;i<len-1;++i)
      {
          minindex=i;
          for(j=i+1;j<len;++j)
          {
              if(h[j]<h[minindex]) minindex=j;
          }
          Swap(h[i],h[minindex]);
      }
      return;
  }
  ```

- 堆排序

  - 堆实际上是一棵完全二叉树，堆的每一个父节点都大于（或小于）其子节点，堆的每个左子树和右子树也是一个堆
  - 最大堆（大顶堆）：堆的每个父节点都大于其孩子节点；最小堆（小顶堆）：堆的每个父节点都小于其孩子节点
  - 堆的第一个元素要么是最大值（大顶堆），要么是最小值（小顶堆），这样在排序的时候（假设共 n 个节点），直接将第一个元素和最后一个元素进行交换，然后从第一个元素开始进行向下调整至第 n-1 个元素。所以，如果需要升序，就建一个大堆，需要降序，就建一个小堆

  ```cpp
  void HeapSort(SeqIAst R)
  { //对 R[1..n]进行堆排序，不妨用 R[0]做暂存单元 
      int i；
          BuildHeap(R)； //将 R[1-n]建成初始堆 
          for (i = n;i > 1；  i  -)
          { //对当前无序区 R[1..i]进行堆排序，共做 n-1 趟
              R[0] = R[1];
              R[1] = R[i];
              R[i] = R[0];//将堆顶和堆中最后一个记录交换 
              Heapify(R，1 ，i-1); //将 R[1..i-1]重新调整为堆，仅有 R[1]可能违反堆性质 
          } //endfor 
  } //HeapSort
  ```

#### 二路归并排序

- MERGE-SORT：利用归并的思想实现的排序方法，采用经典的分治（divide-and-conquer）策略

- 递归拆分子序列，将两个已经有序的子序列合并成一个有序序列

  ```cpp
  void MergeSortDC(SeqList R，int low，int high) 
  {//用分治法对 R[low..high]进行二路归并排序 
   int mid； 
   if(low<high){ //区间长度大于 1 
   mid=(low+high)/2； //分解 
   MergeSortDC(R，low，mid); //递归地对 R[low..mid]排序 
   MergeSortDC(R，mid+1，high)； //递归地对 R[mid+1..high]排序 
   Merge(R，low，mid，high)； //组合，将两个有序区归并为一个有序区 
   } 
  }//MergeSortDC 
  ```

#### 基数排序

- 不需要比较关键字的大小，根据关键字中各位的值，通过对排序的N个元素进行若干趟分配与收集来实现排序的

- 时间复杂度为 $O\left( d\left( n+r_{d}\right) \right)$

  ```cpp
  int GetMaxDight(int* h, int len)
  {
      if(h==NULL) return 0;
      if(len<1) return 0;
      int max=h[0];
      for(int i=1;i<len;++i)
      {
          if(h[i]>max) max=h[i];
      }
      int digit=1;
      while(max/10!=0)
      {
          max/=10;
          ++digit;
      }
      return digit;
  }
  int GetReminder(int value,int digit)
  {
      int div=1;
      for(int i=1;i<digit;++i)
          div*=10;
      return value/div%10;
  }
  void RadixSort_LSD(int* h, int len)
  {
      if(h==NULL) return;
      if(len<=1) return;
      int digit=GetMaxDight(h,len);
      //printf("MaxDigit:%d\n", digit);
      int count[10]={0};
      int *tmp=(int*)calloc(len,sizeof(int));
      for(int d=1;d<=digit;++d)
      {
          memset(count,0,sizeof(count));
          for(int i=0;i<len;++i)
          {
              count[GetReminder(h[i],d)]++;
          }
          //求右边界
          for(int i=1;i<10;++i)
          {
              count[i]+=count[i-1];
          }
          for(int i=len-1;i>=0;--i)
          {
              int r=GetReminder(h[i],d);
              int index=count[r];
              tmp[index-1]=h[i];
              count[r]--;
          }
          memcpy(h,tmp,len*sizeof(int));
      }
      free(tmp);
  }
  void RadixSort_LSD_Reverse(int* h, int len)
  {
      if(h==NULL) return;
      if(len<=1) return;
      int digit=GetMaxDight(h,len);
      //printf("MaxDigit:%d\n", digit);
      int count[10]={0};
      int *tmp=(int*)calloc(len,sizeof(int));
      for(int d=1;d<=digit;++d)
      {
          memset(count,0,sizeof(count));
          for(int i=0;i<len;++i)
          {
              count[GetReminder(h[i],d)]++;
          }
          //printf("haha\n");
          //求右边界
          for(int i=8;i>=0;--i)
          {
              count[i]+=count[i+1];
          }
          for(int i=len-1;i>=0;--i)
          {
              int r=GetReminder(h[i],d);
              int index=count[r];
              tmp[index-1]=h[i];
              count[r]--;
          }
          memcpy(h,tmp,len*sizeof(int));
      }
      free(tmp);
  }
  ```

#### 排序知识点总结

- 快速排序、希尔排序、归并排序、堆排序的平均时间复杂度都是 $O\left( n\log _{2}n\right)$，其他都是 $O(n^2)$
- 快速排序的空间复杂度为 $O\left( \log _{2}n\right)$，归并排序的空间复杂度为 $O\left( n\right)$，基数排序的空间复杂度为 $O\left( r_{d}\right)$，其他都是 $O(1)$
- 快速排序、希尔排序、简单选择排序、堆排序是不稳定的，其他都是稳定的
- 交换类和选择类的排序，经过一趟排序能够保证一个关键字到达最终位置
- 简单选择排序和折半插入排序的关键字比较次数和原始序列无关
- 交换类的排序趟数和原始序列有关
- 直接插入按顺序查找的方式，而折半插入按折半查找的方式排序
- 借助于比较进行排序的算法在最坏情况下的时间复杂度至少为 $O\left( n\log _{2}n\right)$

### 查找

#### 查找的基本概念

- 给定一个值 K，在含有 n 个记录的表中找出关键字等于 K 的记录叫查找，记录即为关键字

- 通常把查找过程中对关键字的平均比较次数（也称平均查找长度）作为衡量一个查找算法优劣的标准

- 平均查找长度 $ASL=\sum ^{n}_{i=1}p_{i}\times c_{i}$

  - $p_{i}$ 为查找第 i 个记录的概率，$c_{i}$ 为找到第 i 个记录所需要进行比较的次数（查找长度）

- 顺序查找

  - 用待查找的关键字和给定序列中的各元素的关键字从左到右（或从右到左）依次进行比较，直到成功或失败
  - 存储结构通常是顺序结构，也可是链式结构

  ```cpp
  //顺序表的查找（不带监视哨）
  int SeqSearch(SSTable S, DataType x)
  {
      int i = 0;
      while (i > s.length & S.list[i].key != x.key)
          i++;
      if (s.list[i].key == x.key)
          return i + 1;
      return 0;
  }
  //顺序表的查找（带监视哨）
  int SeqSearch2(SSTable S, DataType x)
  {
      int i = S.length;
      //将关键字存放在0位置处,防止越界
      /*哨兵的主要作用就是在查找循环中监视下标i是否越界
        一旦越界(i=0),因为可以和自己进行比较,循环判定条件
        不成立就使得查找循环结束,就可以达到忽略判定边界条件的目的*/
      s.list[o].key = x.key;
      while (s.list[i].key != x.key)
          i--;
      return i;
      // 实际上,一切为简化边界条件而引入的附加结点(元素)均可称为哨兵
  }
  //顺序表的查找（链表实现）
  Node* Search(Lnode* head, int key)
  {
      LNode* p = head->next;
      while (p != NUll)
      {
          if (P->data == key)
              return p;
          p = p->next;
      }
      return NULL;
  }
  ```

- 二分查找

  - 要求线性表是有序的
  - 在给定序列是有序表的前提下，将表中间位置处的关键字和查找关键字比较，相 等则查找成功
  - 否则从中间位置将表分成前后两个子表，如果中间位置处的关键字大于 查找关键字，则进一步查找前子表，否则查找后子表
  - 重复以上过程，直到找到满足条件的记录，此时查找成功，或直到子表不存在为止，表示查找失败

  ```cpp
  int BSearch(int arr[], int low, int high, int key) {
      while (low <= high) {
          int mid = (low + high) / 2;
          if (arr[mid == key])
              return mid;
          else if (arr[mid] > key)
              high = mid - 1;
          else
              low = mid + 1;
      }
      return -1;
  }
  ```

#### 二叉排序树（BST）

- 二叉排序树要么是空树,要么是满足下列要求的树

  - 若它的左子树不空，则左子树上所有的关键字的值均小于根节点关键字值
  - 若它的右子树不空，则右子树上所有的关键字的值均大于根节点关键字值
  - 左右子树又各是一棵二叉排序树

- Binary Search Tree 又被叫做二叉搜索树 or 二叉查找树

- 在对某个关键字进行查找的时候，首先和二叉排序树的根节点进行比较，若相等则査找成功

- 由于二叉排序树本身的性质，若该关键字小于根节点值，则再与其左子树进行比较,否则和其右子树进行比较，直到找到与之相等的节点，则查找成功

- 若待比较的位置来到空指针处，则表示査找失败，返回失败的标记

  ```cpp
  //非递归算法
  BTNode* BSTSearch(BTNode* p, int key) {
      while (p != NULL) {
          if (key == p->key)
              return p;
          else if (key < p->key)
              p = p->lChild;
          else
              p = p->rChild;
      }
      return NULL;
  }
  //递归算法
  BTNode* BSTSearch2(BTNode* p, int key) {
      if (p == NULL)
          return NULL;
      else{
          if (key == p->key)
              return p;
          else if (key < p->key)
              return BSTSearch2(p->lChild, key);
          else
              return BSTSearch2(p->rChild, key);
      }
  }
  ```

#### 平衡二叉树（AVL 树）

- 平衡二叉树是一种特殊的二叉排序树，其左右子树都是平衡二叉树且左右子树高度之差的绝对值不超过1
- 一个节点的平衡因子为其左子树的高度减去右子树的高度，对于平衡二叉树，树中所有结点的平衡因子取值只可能是-1、0、1
- 若向平衡二叉树中插入一个新结点后破坏了平衡二叉树的平衡性，则首先要找出插入新节点后失去平衡的最小子树，然后再调整这颗子树使之成为平衡子树
- 当失去平衡的最小子树被调整为平衡子树后，无需调整原有其他所有的不平衡子树
- 最小不平衡子树：是以距离插入结点最近且以平衡因子绝对值大于1的结点作为跟的子树，又称为失去平衡的最小子树

#### 散列表

- Hash：根据给定的关键字来计算出关键字在表中的地址

- Hash table（哈希表）：是根据关键码值（Key value）而直接进行访问的数据结构，=通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度，这个映射函数叫做散列函数，存放记录的数组叫做散列表

- 给定表 M，存在函数 f(key)，对任意给定的关键字值 key，代入函数后若能得到包含该关键字的记录在表中的地址，则称表 M 为哈希表，函数 f(key) 为哈希函数

- 键（key）：又称为关键字。唯一的标示要存储的数据，可以是数据本身或者数据的一部分

- 槽（slot/bucket）：哈希表中用于保存数据的一个单元，也就是数据真正存放的容器

- 哈希函数（hash function）：将 key 映射 map 到数据应该存放的槽 slot 所在位置的函数

- 哈希冲突（hash collision）：哈希函数将两个不同的键映射到同一个索引的情况

  ```cpp
  int h1(int x){
    return (x%5);
  }
  int h2(char* x){
    int i,sum;
    for(sum=0, i=0; x[i] != '\0'; i++)
      sum += (int)x[i];
    return (sum%5);
  }
  int ELFhash(char*key)
  {
      unsigned long h=0;
      while(*key)
      {
          h = (h << 4) + *key++;
          unsigned long g = h & 0xF0000000L;
          if(g)
              h ^= g >> 24;
          h &= ~g;
      }
      return h % MOD;
  }
  ```

- 散列表的性能分析（查找成功时的平均查找长度）：找到表中已有表项的平均次数

- 装填因子是关键字个数和表长度的比值

### 常用算法补充

- 动态规划算法

  - 处理多阶段决策问题，一般由初始状态开始，通过对中间阶段决策的选择，达到结束状态
  - 这些决策形成了一个决策序列，同时确定了完成整个过程的一条活动路线（通常是求最优的活动路线）
  - 动态规划往往可以用递归程序来实现，不过因为递推可以充分利用前面保存的子问题的解来减少重复计算，所以对于大规模问题来说，有递归不可比拟的优势，这也是动态规划算法的核心之处

  ```cpp
  for (j = 1; j <= m; j = j + 1) // 第一个阶段
      xn[j] = 初始值;
  for (i = n - 1; i > = 1; i = i - 1)// 其他n-1个阶段
      for (j = 1; j >= f(i); j = j + 1)//f(i)与i有关的表达式
          xi[j] = j = max{ g(xi - 1[j1:j2]), ...... ,  g(xi - 1[jk:jk + 1]) };
  t = g(x1[j1:j2]); // 由子问题的最优解求解整个问题的最优解的方案
  print(x1[j1]);
  for (i = 2; i <= n - 1; i = i + 1)
  {
      t = t - xi - 1[ji];
      for (j = 1; j >= f(i); j = j + 1)
          if (t = xi[ji])
              break;
  }
  ```

- 贪心算法

  - 在对问题求解时，总是做出在当前看来是最好的选择，局部最优解
  - 整个问题的最优解一定由在贪心策略中存在的子问题的最优解得来的
  - 贪心算法建立哈夫曼树

  ```cpp
  #include <bits/stdc++.h>
  using namespace std;
  typedef struct BTreeNode
  {
      int  data;
      struct BTreeNode* left;
      struct BTreeNode* right;
  }btreenode;
  //建立哈夫曼树
  btreenode *CreateHuffman(int a[],int n)
  {
  	int i;
  	btreenode *s[n+1], *ss;
  	for(int i = 0;i<n;i++){
  	    s[i] = new btreenode;  //初始化s指针数组，使每个指针元素指向a数组中对应的元素结点
  	    s[i]->data = a[i];   //将树拆成森林，每棵树都只有一个根节点
  	    s[i]->left = s[i]->right = NULL;
  	}
  	for(int i  = 1;i<n;i++){        //进行 n-1次循环建立哈夫曼树
  	       int k = -1,t;           //k表示森林中具有最小权值的树根结点的下标，t为次最小的下标
  	    for(int j = 0;j<n;j++){   //k初始指向森林中第一棵树，t指向第二棵
  	            if(s[j]&&k==-1){
                     k = j;
                     continue;
  	            }
  		        if(s[j]){
  		            t =  j;
  		            break;
  		        }
  	    }
          for(int i = t;i<n;i++){   //从当前森林中求出最小权值树和次最小 ；
  	        if(s[i]){
  	            if(s[i]->data<s[k]->data){        //比最小树小
  	                t = k;
  	                k = i;
  	            }
  	            else if(s[i]->data<s[t]->data){  //比次小树小
  	                t = i;
  	            }
  	            else{
  	                ;
  	            }
  	        }
  	    }
  	       //由最小权值树和次最小权值树建立一棵新树，ss指向树根结点(以后依次建立)
  	       ss  = new btreenode;     //ss = (btreenode *)malloc(sizeof(btreenode))
  	       ss->data =   s[k]->data+s[t]->data;
  	       ss->left =   s[k];
  	       ss->right =  s[t];
  	       s[k] =  ss;  //关键点:将ss赋给s[k](k为上述找到的最小树下标,但这是s[k]代表的值已改变，同时把s[t]失效的置空,
  	                   //在这里起向下一个判断的作用if(s[j]){t = j;break;}
  	       s[t] = NULL;
  	}
  	    free(s);   //释放分配空间
  		return ss;
  }
  //求哈夫曼树的带权路径长度
  int WeightPathLength(btreenode* FBT, int len){          //参数len为树的层数
  	if(!FBT){
          return 0;
  	}
  	else{
  	    if(FBT->left ==NULL&&FBT->right ==NULL)//访问到叶子结点
  	        return FBT->data*len;
  	    else{               //访问到非叶子结点，进行递归调用，返回左右子树的带权路径长度之和，len递增
  	        return  WeightPathLength(FBT->left,len+1)+WeightPathLength(FBT->right,len+1);//一定要记得加1
  	    }
  	}
  }
  //哈夫曼编码
  void HuffManCoding(btreenode* FBT, int len){   //参数len为树的层数
  	static int a[20];   					 //定义静态数组a，保存每个叶子的编码，数组长度至少是树深度减1
  	if(FBT){ 								//访问到叶子结点时输出其保存在数组a中的0和1序列编码
  	    if(FBT->left == NULL&&FBT->right == NULL){
  	         printf("结点权值为%d的编码:",FBT->data);
  	         for(int i = 0;i<len;i++){
  	             printf("%d",a[i]);
  	        }
  	            printf("\n") ;
  	    }
  	    else{    //访问到非叶子结点时分别向左右子树递归调用，并把分支上的0、1编码保存到数组
  	            //a的对应元素中，向下深入一层时len值增1
  	           a[len] = 0;
  	           HuffManCoding(FBT->left,len+1);
  	           a[len] = 1;
  	           HuffManCoding(FBT->right,len+1);
  	        }
  	}
  }
  int main(){
  	btreenode *s;
  	int n;
  	printf("从键盘输入待构造的哈夫曼树中带权叶子结点数n：");
  	while(true){
  	    scanf("%d",&n);
  	    if(n>0){
  	        break;
  	    }
  	    else{
  	        printf("-------输入不合法,请重新输入!!\n");
  	    }
  	}
  	int *a = (int *)malloc(n *sizeof(int));
  	printf("从键盘输入%d个整数作为权值:",n);
  	for (int i = 0; i < n; i++)
  	    scanf("%d", &a[i]);
  	s = CreateHuffman(a,n);
  	printf("哈夫曼树的带权路径长度：");
  	printf("%d\n", WeightPathLength(s, 0));
  	printf("树中每个叶子结点的哈夫曼编码：\n");
  	HuffManCoding(s,0);
  	return 0;
  }
  ```

  

